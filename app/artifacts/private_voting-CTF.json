{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_join",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5752904658887916296": {
            "error_kind": "string",
            "string": "Game has already started"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEguCIBIAAElAAAARSUAAABpKAIAAQSASScCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAm4eAgACAR4CAAMACioCAwQkAgAEAAAAiiUAAAKXHgIAAgUcCgIEBBwKBAMAHAoDAgQnAgMAAS8KAAMABBwKBAUEHAoFAwAcCgMEBAwqAgQDJAIAAwAAAMolAAACqScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAA8nAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAArstAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAK7LQIAAC0LBgELIgABgEQAByQCAAcAAAIBJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA+QtAgAALQsDAQEiAAGARwAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAACUiUAAAT3JwIBAAsvCgABAAIcCgIEBhwKBAEAMAoAAQADJigAgAQEeAANAAAAgASAAyQAgAMAAAKWKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXau1X/7FdmOTwEAgEmKgEAAQVP1mxOm7Q7CDwEAgEmJQAAAm4tCwQGCyIABoBEAAckAgAHAAAC3ScCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAANwIwAAAvYtCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAADGyUAAAUJLgIAB4ADKACABAQABCUAAAUbLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEcABQ4qBgUHJAIABwAAA1slAAAFqS0OCgEtDggCLQ4FAy0OCQQjAAAD4ycCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAPkLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAFGy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBHAAMtDggEIwAAA+MmJQAAAm4uCIBFAAUjAAAD9A0iAAWAQwAGJAIABgAABGQjAAAECS0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEeiMAAATmLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAFGy4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAATmASIABYBHAAYtCgYFIwAAA/QqAQABBQLcbieAdhKdPAQCASYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAAU2IwAABUEuAIADgAUjAAAFqC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWULgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAVjKAGABQQAAQMAgAYAAoAGIwAABagmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZndTiM7DMffpddc5MOJY15lhVCBsqpUFdSFIx0h3v3YiZ2ZIiXaHc7eML96kn/txLGnw8fu6fDw/vP+eH5++bW7/fGxe7gcT6fjz/vTy+P+7fhyZuvHzskf7/kSb/iadreZr4E/o1xTu8ao17K79Y4B2OC9QFFIZklikcE5GhADMSAYmKWwJYhgIQXCBsEFBhRABe8NskIwSzBLNEtMBqQAYFAUxOcG8hWFAYtCCQZ2i8xCaokuGGQFWccGyYAUAhjoV0RZ1AYiyMsewRtkheQMwIAUZHkb2HQMBkWhmKXYGJJZJFAagIsGqFDXuUIyIIVgg4MNjsHALGDTaxQCNYoKYGDfnm16tsFog9G+vZhFsiV6AZ4eAwPlBsmBASl4djVGgaIQgkFWiM4ADGww2HQwS7LpSaYDQwYDGcOJlDAqFG9ACsSDQaYTNciOA4TEIGnTgC2Jkx8lnOQFWDlxOCg5X0ESqQEpSCI14C1IrIyyvIkdQ1neBllBlrcBKBQbQ3aLxA32pzhvUBRkVRuQQvWnglmqP5xsRTKhQVaQBGhACtkGSxpXQJsl+55QIBmQgqRxA2xA1dUKOpi8M+gWnU4hGth0qRupCKCClIsGpJCSQnYGRQF1DQl1nak4A7V452WQVD0nK5RdJTSSxVLKRnJwJA2YUicyytCp27DbsNtKt5Vuo65HZvNSCZTQSGqBUurUZ9S9p0q8ErnaqveVxPsahxfvG+VuE++VZG4QkuOj1G2Snrk2Jylijch3MuXgfKdi5GMnMgrQqdv6foS+H6HvR4D+HanO/fy82VkTvX+7HA7SQ1ddlXvt6/5yOL/tbs/vp9PN7p/96b0O+vW6P9fr2/7Cd1nzcH7iKws+H08Hoc+bZbYbT5XYik5nTrlLULrS8GON5Ip5wFi6Qr72IowVSvJJFQoX05HCPA7ZZoujhFEcMNYAcqgSQD6PvEiTOABsMblWwbY41vtRYBTHRCMnaQtVIqccu0K69qJMFKK0x6YQIY3ioMlKYDEFrr9hw0pcRYFhFMVUAVNXoOE6+ElixhxMIuZVavND6bVGnG0pUt9RokWDvmhMUhNLtCOGfFhGy+knuck93NzgLj48pT5PIvFAtidcjMPwiMxDCUsoeSxRZn5QWs7Ishox5k3ZRWlLdmV5ZGsKOQ2zK0wKp4/ZJDz45ahzn7vWmGSol0ecKhFWxyz6cq0wyU9+guuJgbRsSChfIplsakxWfGFVOIP7ojBJT+6sVjBCcDTWmORn6hm+biJ/pEDWAfgZelscoZgTIa525I800PdNxUkk0f1dDZ+zHVWfsWzTQOwlAyls0yDXKyiFyZrOzhr0ffEJ8vCsxcm+ZHSWoxhWjZWuD1vMsyrcFXDdTuD3y04uveyMm1os329qkb7f1MB9u6mB/3ZTg/A/NLV5KL/V1ABmh81jP2wRNjW1dUvKOMoNmLV46Cnu+eXMMEMBJ89+/NbLnv2iGz4FwyRF+UVB/0HAXXIoMctQ/o3YfxGw+3HL07gLXcLlcUOYSfie5JxpZZvE8tPGl21exN7YGLd5kXqKcwHFbRJ5qcGFtgWytAJ+BbpNAvpTV0ybAkGwDUHIWwQILL0pbQpi+alKYZsHPacI0zdD+Cpwxx/3j8fL1b8IPkXqctw/nA768fn9/Li6+/bvq92xfzG8Xl4eD0/vl4MoLf9n4D8/Ar8iDJjv5NUTf+S3MDfck+Sjl7uIfJfuPsWZ/wA=",
      "brillig_names": [
        "_join"
      ]
    },
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBUJwAABAMnAgMEAicCBAQAHwoAAwAEgFIdAIBTgFMELgiAUgABLgiAUwACJQAAAFIlAAAAyigCAAEEgFQnAgIEADsOAAIAASgAgEMEAAMoAIBEAQAAKACARQQAACgAgEYAAAAoAIBHAQABKACASAQAASgAgEkEAAIoAIBKAAACKACASwQABCgAgEwAACAoAIBNAABAKACATgAASCgAgE8AAGgoAIBQAABwKwCAUQAAAAAAAAAAAwAAAAAAAAAAJiUAAAiDLQgBAwAAAQIBLgyARAADLQgBBAAAAQIBLgyARgAELQgBBQAAAQIBLgyASgAFHgIABgEeAgAHAAoqBgcIJAIACAAAARglAAAIrB4CAAYFHAoGCAQcCggHABwKBwYEJwIHAAMvCgAHAAgtCAEHJwIJBAIACAEJAScDBwQBACIHAgktCgkKLQ4ICicCCQQKLQgACi0KBwsACAAJACUAAAi+LQIAAC0KCwgMKggGByQCAAcAAAGIJQAACOMtCAEGJwIHBAQACAEHAScDBgQBACIGAgctCgcILgyARgAIACIIAgguDIBGAAgAIggCCC4MgEYACCsCAAcAAAAAAAAAAAIAAAAAAAAAAC0IAQgnAgkEBQAIAQkBJwMIBAEAIggCCS0KCQouDIBGAAoAIgoCCi4MgEYACgAiCgIKLgyARgAKACIKAgotDgcKLQgBBwAAAQIBLQ4GBy0IAQYAAAECAS0OCAYtCAEIAAABAgEuDIBFAAgtCAEJAAABAgEuDIBEAAknAgoAEicCCwQMLQgADC0KBw0tCgYOLQoIDy0KCRAtCgoRAAgACwAlAAAI9S0CAAAnAgoECy0IAAstCgcMLQoGDS0KCA4tCgkPLQoBEAAIAAoAJQAACPUtAgAAJwILBAwtCAAMLQoHDS0KBg4tCggPLQoJEAAIAAsAJQAACh4tAgAALQoNCgsiAAqARgAGCyIABoBEAAckAgAHAAAC8SUAAAqSJwIJBAstCAALLQoDDC0KBA0tCgUOLQoKDy0KAhAACAAJACUAAAqkLQIAAC0KDAYtCg0HLQoOCCcCCQAXJwINBA4tCAAOLQoDDy0KBBAtCgURLQoJEgAIAA0AJQAADvQtAgAALQoPCi0KEAstChEMDCoLAg0kAgANAAADciMAAAgmJwILBAwtCAAMLQoDDS0KBA4tCgUPLQoJEC0KAhEACAALACUAAAqkLQIAAC0KDQctCg4ILQoPCi0LAwItCwQJLQsFCycCDAATJwIOBA8tCAAPLQoCEC0KCREtCgsSLQoMEwAIAA4AJQAAD/otAgAALQoQDS0LDQIAIgICAi0OAg0nAgkEDi0IAA4tCg0PLgiASAAQAAgACQAlAAARDi0CAAAtCg8CLQsNCQAiCQIJLQ4JDScCCwQOLQgADi0KDQ8uCIBJABAACAALACUAABEOLQIAAC0KDwkBIgACgEgADi0LDgsBIgAJgEgADi0LDgIBIgANgEgADi0LDgkcCgkOBBwKDg0AHAoNCQQvCgAMAA0nAhMEFC0IABQtCg0VAAgAEwAlAAARji0CAAAtChUOLQoWDy0KFxAtChgRLQoZEh4CAA0FHAoNFAQcChQTABwKEw0EDCoNEhMkAgATAAAE+CMAAATXFgoQBxwKEAgEHAoHCgQEKggRBwAqBwoILQoIBiMAAAUZFgoOBxwKDggEHAoHCgQEKggPBwAqBwoILQoIBiMAAAUZACoNBggOKg0ICiQCAAoAAAUwJQAAEpEMKg0JBhYKBgkcCgYKABwKCQYABCoKCwkEKgYCCgAqCQoCHAoIBgAcChIIACcCCgQSLQgAEi4IgEoAEy4IgEwAFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoGCggcChAGACcCCgQSLQgAEi4IgEoAEy4IgE0AFAAIAAoAJQAAEqMtAgAALQoTCQQqBgkKACoICgYcChEIACcCCgQQLQgAEC4IgEoAES4IgE4AEgAIAAoAJQAAEqMtAgAALQoRCQQqCAkKACoGCggcCg4GACcCCgQQLQgAEC4IgEoAES4IgE8AEgAIAAoAJQAAEqMtAgAALQoRCQQqBgkKACoICgYcCg8IACcCCgQNLQgADS4IgEoADi4IgFAADwAIAAoAJQAAEqMtAgAALQoOCQQqCAkKACoGCggtCAEGJwIJBAQACAEJAScDBgQBACIGAgktCgkKLQ4ICgAiCgIKLQ4CCgAiCgIKLQ4BCi0LBgkAIgkCCS0OCQYtCAEJJwIKBAQACAEKAScDCQQBACIJAgotCgoLLgyARgALACILAgsuDIBGAAsAIgsCCy4MgEYACy0IAQonAgsEBQAIAQsBJwMKBAEAIgoCCy0KCw0uDIBGAA0AIg0CDS4MgEYADQAiDQINLgyARgANACINAg0uDIBRAA0tCAELAAABAgEtDgkLLQgBCQAAAQIBLQ4KCS0IAQoAAAECAS4MgEUACi0IAQ0AAAECAS4MgEQADS0LBg4AIg4CDi0ODgYuCIBFAAcjAAAHbw0iAAeAQwAOJAIADgAACCcjAAAHhCcCBwQOLQgADi0KCw8tCgkQLQoKES0KDRIACAAHACUAAAoeLQIAAC0KDwYtCwMHLQsEAy0LBQQtCAEFJwIJBAUACAEJAScDBQQBACIFAgktCgkKLQ4ICgAiCgIKLQ4CCgAiCgIKLQ4BCgAiCgIKLQ4GCicCAQQNLQgADS0KBw4tCgMPLQoEEC0KDBEtCgUSAAgAAQAlAAAToy0CAAAjAAAIJiYkAgAOAAAINCMAAAhyACIGAg8AKg8HEC0LEA4nAg8EEC0IABAtCgsRLQoJEi0KChMtCg0ULQoOFQAIAA8AJQAACPUtAgAAIwAACHIBIgAHgEgADi0KDgcjAAAHbygAgAQEeAANAAAAgASAAyQAgAMAAAirKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW8GSwLkcVeAzwEAgEmJQAACIMBIgABgEgAAy0LAwIcCgIDBBwKAwEAHAoBAgQtCgIBJioBAAEFz5TqbdQBMuo8BAIBJiUAAAiDLQsEBgsiAAaARAAHJAIABwAACRcnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAAJqiMAAAkwLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJAIACgAACVUlAAAT+C4CAAeAAygAgAQEAAQlAAAUCi4IgAUACgAiCgILACoLBgwtDgUMASIABoBIAAUOKgYFByQCAAcAAAmVJQAAEpEtDgoBLQ4IAi0OBQMtDgkEIwAACh0nAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAUmC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAAFAouCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyASAADLQ4IBCMAAAodJiUAAAiDLQsEBQsiAAWARAAGJAIABgAACkAnAgcEADwGBwEnAgUEBi0IAAYtCgEHLQoCCC0KAwktCgQKAAgABQAlAAAUmC0CAAAtCwEFLQsCBi0LAwctDgUBLQ4GAi0OBwMuDIBHAAQBIgAGgEgAAi0LAgEmKgEAAQUC3G4ngHYSnTwEAgEmJQAACIMnAgoECy0IAAstCgEMLQoCDS0KAw4tCgQPAAgACgAlAAAO9C0CAAAtCgwHLQoNCC0KDgkvCgAEAAonAhAEES0IABEtCgoSAAgAEAAlAAARji0CAAAtChILLQoTDC0KFA0tChUOLQoWDx4CAAoFHAoKEQQcChEQABwKEAoEDCoKDxAkAgAQAAALWCMAAAs3FgoNEBwKDREEHAoQEgQEKhEOEAAqEBIRLQoRBiMAAAt5FgoLEBwKCxEEHAoQEgQEKhEMEAAqEBIRLQoRBiMAAAt5ACoKBhEOKgoREiQCABIAAAuQJQAAEpEMKgoJBhYKBgkcCgYKBBwKCQYEBCoKBwkEKgYIBwAqCQcGHAoRBwAcCg8IACcCCgQSLQgAEi4IgEoAEy4IgEwAFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoHCggcCg0HACcCCgQSLQgAEi4IgEoAEy4IgE0AFAAIAAoAJQAAEqMtAgAALQoTCQQqBwkKACoICgccCg4IACcCCgQSLQgAEi4IgEoAEy4IgE4AFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoHCggcCgsHACcCCgQSLQgAEi4IgEoAEy4IgE8AFAAIAAoAJQAAEqMtAgAALQoTCQQqBwkKACoICgccCgwIACcCCgQSLQgAEi4IgEoAEy4IgFAAFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoHCggcCgYHABwKBQkALQgBCicCCwQEAAgBCwEnAwoEAQAiCgILLQoLDC0OCAwAIgwCDC0OBwwAIgwCDC0OCQwtCwoLACILAgstDgsKLQgBCycCDAQEAAgBDAEnAwsEAQAiCwIMLQoMDS4MgEYADQAiDQINLgyARgANACINAg0uDIBGAA0tCAEMJwINBAUACAENAScDDAQBACIMAg0tCg0OLgyARgAOACIOAg4uDIBGAA4AIg4CDi4MgEYADgAiDgIOLgyAUQAOLQgBDQAAAQIBLQ4LDS0IAQsAAAECAS0ODAstCAEMAAABAgEuDIBFAAwtCAEOAAABAgEuDIBEAA4tCwoPACIPAg8tDg8KLgiARQAQIwAADdkNIgAQgEMADyQCAA8AAA6YIwAADe4nAg8EEi0IABItCg0TLQoLFC0KDBUtCg4WAAgADwAlAAAKHi0CAAAtChMKLQsBCy0LAgEtCwMCLQgBAycCDAQFAAgBDAEnAwMEAQAiAwIMLQoMDS0OCA0AIg0CDS0OBw0AIg0CDS0OCQ0AIg0CDS0OCg0nAgcEEi0IABItCgsTLQoBFC0KAhUtCgQWLQoDFwAIAAcAJQAAE6MtAgAALQoGAS0KEQMtCgUCJiQCAA8AAA6lIwAADuMAIgoCEgAqEhATLQsTDycCEgQTLQgAEy0KDRQtCgsVLQoMFi0KDhctCg8YAAgAEgAlAAAI9S0CAAAjAAAO4wEiABCASAAPLQoPECMAAA3ZJQAACIMtCwEFLQsCAS0LAwInAgYEBy0IAActCgUILQoBCS0KAgotCgQLAAgABgAlAAAP+i0CAAAtCggDLQsDAQAiAQIBLQ4BAycCAgQELQgABC0KAwUuCIBIAAYACAACACUAABEOLQIAAC0KBQEtCwMCACICAgItDgIDJwIEBAUtCAAFLQoDBi4IgEkABwAIAAQAJQAAEQ4tAgAALQoGAicCBQQGLQgABi0KAQcACAAFACUAAAi+LQIAAC0KBwQnAgUEBi0IAAYtCgIHAAgABQAlAAAIvi0CAAAtCgcBASIAA4BIAAUtCwUCHAoCBQQcCgUDABwKAwIELQoCAy0KAQItCgQBJiUAAAiDLQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC4MgEYACAAiCAIILgyARgAIACIIAgguDIBGAAgtCAEHAAABAgEtDgYHLgiARQAFIwAAEE8NIgAFgEMAASQCAAEAABC/IwAAEGQtCwcBASIAAYBIAAMtCwMCASIAAYBJAAQtCwQDASIAAYBDAAUtCwUELQgBAScCBQQEAAgBBQEnAwEEAQAiAQIFLQoFBi0OAgYAIgYCBi0OAwYAIgYCBi0OBAYmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAEJQAAFAouCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEgAAS0KAQUjAAAQTyUAAAiDASIAAoBIAAMOKgIDBCQCAAQAABEtJQAAEpENKIBDAAMABAsiAASARAADJAIAAwAAEUolAAAVpg0iAAKAQwADJAIAAwAAEV8lAAAT+AAiAQIEACoEAgUtCwUDLQgBAScCAgQCAAgBAgEnAwEEAQAiAQICLQoCBC0OAwQmJQAACIMcCgEDBBwKAwIAAioBAgMsAgABAC1eCYuCuje0O5mhMWEY/SDUL1FmyenxP7XqZaltHgptBCoDAQIcCgIEBBwKBAMAHAoDBAQCKgIDBQQqBQECHAoCBQEcCgUDABwKAwUBAioCAwYsAgACADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCoGAgccCgcIBBwKCAYAHAoGCAQCKgcGCQQqCQEGHAoGBwEcCgcBABwKAQcBAioGAQkEKgkCBhwKBgkEHAoJAgAcCgIGBBwKAQIEBCoCBgEcCgMCBAQqAggDLQoDBi0KAQItCgcBLQoFAy0KBAUtCgYEJioBAAEFRafKcRlB5BU8BAIBJiUAAAiDLQgBBAAAAQIBJwIFAAEtDgUEJwIHBAInAggBAS0IAQYnAgkEIQAIAQkBJwMGBAEAIgYCCScCCgQgQwOqAAIABwAKAAgACScCCwQgLgIACYADLgIAC4AEJQAAFbgnAgIEIScCBwQgLgiASAADIwAAExkMKgMCCCQCAAgAABMwIwAAEystCwQBJi0LBAgEKggICQIqBwMIDioDBwokAgAKAAATUCUAABY4DCoIBwokAgAKAAATYiUAABP4ACIGAgsAKgsIDC0LDAocCgoIAAQqCQEKBCoICgsCKgUICgQqCgkIACoLCAktDgkEASIAA4BIAAgtCggDIwAAExklAAAIgy4IgEUABiMAABOzDSIABoBLAAEkAgABAAATySMAABPIJhwKBgEAACoEAQIAIgUCAwAqAwYHLQsHATAKAAEAAgEiAAaASAABLQoBBiMAABOzKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAUJSMAABQwLgCAA4AFIwAAFJcuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAUgy4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAUUigBgAUEAAEDAIAGAAKABiMAABSXJiUAAAiDLgiARQAFIwAAFKgNIgAFgEMABiQCAAYAABUTIwAAFL0tCwIFLQsFBgAiBgIGLQ4GBS0IAQYnAgcEBQAIAQcBJwMGBAEAIgUCBycCCAQEACIGAgk/DwAHAAktCwEFLQsDBy0LBAgtDgUBLQ4GAi0OBwMtDggEJi0LAwYMKgUGByQCAAcAABUpIwAAFZUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAABQKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAAFZUBIgAFgEgABi0KBgUjAAAUqCoBAAEF9C7lhLv0IdE8BAIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAABY3AwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuBIAHgAsBAIADgAiACy4EgAaACwEAgAkAAoAJIwAAFdQmKgEAAQUohpKwR9z9QzwEAgEm",
      "debug_symbols": "tZ3Zjl21Eobfpa9z4XngVRBCAcJRpCigkBzpCOXdj+t3DauDltvtTW7or/+2a3soT2Vv8vfTb+9++fKfn99//P2Pv55++PHvp18+vf/w4f1/fv7wx69vP7//4+NQ/35y9J/g6tMP/s1T8J5/lvkzBP7Jv0f+e+T0iX9P/Pc80if6Of5ex88yfm/0s86fNc+fbXyspwxtCD4M6E6AlehIaQSZAaXrBJkhOAFRoihRlc6Q4tMPwRE0BiruhMJQvIAo1QmkAZ6gM7TK0MkOlbCXCcl5AVG8KF4UKvwEUaKkofYFpCBAZR61SKUz1Cggf2qiNFG6KL1OyC4KcJrskwBbztSYAGrMCZSmEjQGNCagMmQvUBiKE5DsKDwBOcIEUZqkIU+IjiBPKM4JJIHG4INAYQiSOEji0BmiKFGyUy0mVAaqxQT59CzZiyQukrjKp1dRGmX3BIUB1QEkgTahuiDAiav3AqIEJ0DZx9iqMTAkJ9AYMpWwEDQGGoATCgP584QkIImbJCbHBnRROmdvzgkkAco+XLT5KCAKTR8TCgN51IQkIImTZE+iZMmeJXuR7ORRcXhmozInT1AZuhfIAn1CJ+efwIm79wKFIYgSsoBkj5KdhmfKA2j+m5AFKPFolp6TgCjkPxMqQ/UCWUASN8neROmSncZyGo3gHc0yTEXIjyZKHZSVulCISqpRVzCpljQdjYxJNDSYihB1SHagrNSFaIpiUo0qxqRa13RUtxwHeZr1mShdIfJViHopV1AXou7JDdSEkmrkVQX2qGdKAnUh6humKkSjm0k1Gt9MWUmtdLXSJUegPioVNFqtUFmwzDKpRjWq1AYhir2QolITyqpl1bSkoRYhLWloqnXRsKZWT0T+wqQaeQnT+IyKHNS6TNJHkVYnJtWyalk1moVqA9HGgDwnUpmbA1UhKjOTatSmTI0puagk6bC+Ng8a9W2BiNq0RRBpVHqssUxZKKlG9ZhE9WBSrWg68vaWiWg+bQVEGvV0ou1Na6Cs1IW6aJl8g6kIedW8pqPx26jVMq0C3YGG1qm+WJx7AHUh8hwm1WhFm0Sjlsk0TUejtkfQaPFO9c20tegZRBrVN1PPMFWm4qJSF6INBpNqQdMFykutVmhh6w1EGtW3UM8wFaGsWlatqIYaTepCtNQxNSHUaBL5JEpA44OpMFVsQ10CJsOu6E31pgZTaQwxRlOjpaXFgzHbp1HlxixIWJxhVqymVlObqS0pdlO7pm3kf4L6aY32VIJVkXpsrBDAqhiDYVFMzjAbdsVsxnJTLMnQ1GppKyyQ27QWDZsgFnjG2QEV2BVjNKyKOMYwZkPLls1YNrWYMcxr+Fxa05myEuXxNGw7ys3YFLupXdTgXDSsijgFMRZFnIQYs2FXhOsx4iPo+IV1XrAqZm+YDbtisWzFstGULqiqxwDC0Q5rOqM3FQPIR2BXhL8xVkUcQBmzoWVLli01xWxqCYJYXj3NaiGgxow4OBacep2hqeghOhKGSDt4H+bJ2Bk2RdSCsSqiFoEqj+Vy1BVYFPHBjMmwKVZL2ywBrTFjr0A4j9GEaRZyYlX00bApBlNnealJsFIyYmgzNkW0L6NlK97QLFSUtwC7IsYFY1Xs3jAbarbskqGpPhqqsRy8IYxRhCLPvpjYFOEajF0R08BEuBGj9kWuzlC7JTdTZy0aEHY7RUdmtwAR2piIIc1IxuiAGXCaZcRkxlgVMZkxZkPLls1YNrWYsWLGqhmrZqxatmbZmmXDfEbH1lCxxkxE0WmtD3MhZGyKtJ8ULIpYExktWzZjxdRixqoZq2asIZwTgAjxULfU7g2zYRfEaVfQVB8Nq2LwhtnQskVkK0CEoqhkbYanJpqaoZITtGp2q9mdFZpoale1W9E7Yj4TrejdmxpMRQgK60VHEIrRVJonGRHowZzaSzbUHuo1GZraTG2mdsTZJiLShhggaoEwnkMHTEQtGE1Fq09EBIvxolpatDriew6tjnieQ6sHRCEz1EhYomFVrKYimDUR4SxGU7ulRUSOZtqxclD70uQ4EGpBsBNqBVZFOBejqfAoxqaYTE2WFnE6RCs9InUBEVUEPmnwDiSVRmz0cDnGrNhMRQh0IoKgjKri+CsIC9SogRbLsQwCoVI7BAREYwZmw64YTU3esChmU7OlzbBAjRoQiYwVCBXBY4R2EwqJLkwoJMKpjE2xm9pVjS4aVkXEfBmLIqrJmA3hk1RIHLUFmyJGYarAoogaM5paTC2mIpTNaGqztOjNid0+bVaTHAZbCcGq6E31pgZTEeCeGE2NlhaeymiflpNhV8QMQ4GwOGPhE2cXTmyKLRhWRcz2jGosO2dYFL2p3tJiFFIELM5g+URMNhOTqeiAjFsGDCfGbNgV4XKMVbFbtq7GivOG2RBulHGVEQ2rIopOYZmBWRFFZzQ1mZoualfEPMnYFGlvJFgVq30wvG8ilq+cgNmwK2K8MVbBOis/MRtqNpzKBU2dRad2wFZC0FRM8RRijNhKMNZgWBRn0ScmQ8vWLdssOmFzqjbMDxOxl6OI0sCqiL0cI27BkBYbIsZk2BSxOWUsitWyVTPWTG1mDGdTCj6NM0UwrIId2zqKSQ0sijgEMSbFYCo23hOjqdHSYjc4EbtBxqo4T2oOWBTnSW1iUqymosYTm6nN0qLGHbd52L0yVsaEYLtgUfSmzlvJidjOBEJs3RmbIuImjFUxmTr3v8C5/43Apog+puBcmkfwidVUHDUo8jywC3ocmBhN9aZ6U3EYZDQ1WlocBhn107DBEDS1WFr0RcFdKM1nI9qG21BKQBHmgU0RwaiJwRKgUSdGS4AIVM2EKBljVsymZlOLqfAdxqaICBRjVWzBEGohxGihyOFAqFQ3bA98xc0uznqoccQxdSLqxpgVcTZl1IaKydRkaXHAm4hDG0XFE+6qGefoBs4hPREji5w2zXt2IEo2EadmRgx08sk0RyxwDtOJMEbuifC5oKmICFAEPc2IwMQ5MU00tZnaLmpXhFfTqpdmGIARKpUXN9sjUE4In2SkWtDikzKKw2gqmo/Wi4FQqY9zg1qARbGbClemm6iEpdnTtVPCVTMjYgoZd/gInUzMpmJ0F6rFPI0XD4RKRS9wREZTcQSnq62BUBOeCUDNwCZYXTQ01ZvqtWQ1aMnmAZq2zWnGlxmzYje1I7yAbOghIA7Qgk0RH8xoajA1mBpNxeQ4ER3LWBWLpYXDJGpU3Pp62uaPHWBQFUFU2oMn3P2OUxOwKEZTEWicmJKhqSjDREzQKQGrYjUVjUqXxqnDuWhrORAqtWSHc9GmdyBUvNuAc1Et8lyHJmLlnThDoIkQg4z2fdlhkNFJYiDUikcgzvCiIp6KT8MqQkfwjEOQp/Pb2OiiYyPh7MKJVREPhxgRHqMHHfNxDmNWTKYmU7Op2dRiajG71dQZdpvYFDFXM1q2btlQzVm36bTUfGlWCAjXQIXmNDgxmooKMcICtXqClzCaijFPB9KBTREOw2gfUYOhtnrCZD5xDr2JWgacZgSTYVP0wVA/bQZGY/z69c2TPBP7+fOnd+/oldjl3diPfz/9+fbTu4+fn374+OXDhzdP/3374QsS/fXn24/4+fntp/HX0bjvPv42fg6Dv7//8I7o6xvL7e6z1kqLCnKPjXJQAz3vWhjBEnosAhODc7mzEe5t0BBhEwObWijP6xHvLYwpKks9xsi5s7CuRwlWj3bbFvneBs1+bIKmvLtSlEU9UpLGHBNwOqvHtT9aOujThhP4LMWIVKuF/LwU/d7CCJt7tlDGhHNXD78qRG1iYpyfwkFTPKtGzXfVWFqo2h0jLntnwS88kyIAbGIcuc23x2biuY206lPa4XKX9m42+jc2Fr5ZW5QxNvYU/rZHFs5ZS5Bi1LFjujVRFzUZ62uUqoy9Yjkrh/daDl9vTSxbI1hrlPKoc/Vy4lwx6tw7gll3FsJi4hwrWZLWHMdDc4z8zdy7cFDsrGEiXEbZiDo/t5BWi0hSv6iXphjXOM9tLDokZmmLdJk4x3n1uYWFVwSEBWZFxmXOvY2Fe2Z18Osi8ioLXVaAcct4Vo/QpBB0931mo3rt1Lqqycq3kpZjHNTKrW/FhY0yYojiGeP+1Jai584VV+7Zs8yf48ojXObPcjTQ2u1Aiwv3HBGQpJ1S/FEpki4EY2m/XY3iwrkoTCWjxB22RdKt1ghxupNpK6tvtZzbnYXkvm9rZl0S23WkfVuK8Hgp0sI7Q9YNwghxuXsbq9W9BWnQEcGxqoxw1LaNEfSR5hjbxnRUDgp9iI0RuLi3Ub+vDXqkKO1Rcr8sSfkVNprMw+N+tZ3ZqFknwHqZNr61QXGwW/9wvurqmi6TeQnPbawm4mL+US7+8a2NdV26bhTG1ue+LulfqEv+znWxnezAQ/+42rgsbv+wsRr7Rc84YUQYb309L85JIxgg7ZFzvp+Dint4Z1/8wzv7Ev6Fnf26OSwQUEI6m5JLy7r38fdTcskPH19Lefj4ul+TftYatjcf9yr3Tlr6agtWnA58Fy+Dxe+Xo9tg6fmwLr1oXcal4a2NGpYBFt3/pGeLy/OjdF1uSZ1OYj35WxurukRXNCzgLrGJf9Rl5aU5yYgrZeHpdeGmvcm60C/xjW8DC3UxlY67dGmNEfe9n47XNpra6P7QRg9RbUR/Wo5sNvKhDWuPHsthXbLVpR2Wo+v5LV5HyyvLocfycSfyaHsMG+HIBl32q43iDm1orOTZ4emV5WhmozzeHrUelkO3c8mHM/9IXtf8cRV9XA7d7vsUHm6Pcat3WBddoeiNw5mN4LRNgz/0D69HhmGjPtweYXF0WZYjVR23I4xzb2OxMtB3VmWVc5drnX8EnZ17PDTonX80NuhdeDw4iO9APRYdXJvYCg+uqxJsJxVSODSyGSBcbj9K0E1ySffbMe/aKjanM3uLod9fFC32p+OeW0b/wMX1yLIgwW5Co0v3BVlGlFzUiJL3p/27F/9djbqu3j7w6OoMbxv4Xjic3EM21/uDFryejZuP+agMup0bFu7vmnxbnWuL03CUL5cF6hV3si6oCVfySZd6bwGLEZk/M2EX3L6dlSLq/EVfFT8ykfXmbVwr1DMTxW4mWj+riFMTMZxVJCZdH2M+qsjuLLwqRdGdD33x+shE1ZjtCBMeTTjjRKzN2cPZnJXEOWsqJwZ6krHe81E72OONHs5KoOOr1/xgFc4MtKbjc+Al/N62LXSbdPsl8vWNBbwxuXXrprGN0Jo/KkXVKM2zS7+235n6RqA/i6+8ogx6hdB6j2dl0OCKuwTdX2UhmAX/qIV4VoaoXulSfLQvrpdTr7Cgz6JGb57VItXH/CHgefX0at/vz/4rE0HDB/QV+EMTegkTFtG25e2rXso/26W+yoTeZYeYD0txuX2t8chE0p0ZfdX+zETQ5ky5HZrQRTzVs+ZMXf0iu7NSZN1ihutF0utMqF/kcuadWeNB4zo8HZkoNkZKaocmtFNLOWsLuz8eo6yemNh+cLd66Zb0EFWvrzVeZcOuGAfWMxt7L+6WrbH14M7XhY0RH7Bz/uW127cPJXz1q7OY7XbdNTSWvzWyukW6BC3SwsQiElS80xvGsjCxrErxWpXLqvgPI+uuzdWufk/dwzbv5zY2H5e2f+EOenWUaXbcb9fwa45HJkI/MtGzXTGWcmgimIl6ZkIvGOn/1HRi4tmTtXb/IGhlYvNt09LE3rMk3+p3NrL7uOkFI3uvm9ZGNp83vWBk713R2sjmg559I+loe+7xP6eaJoK7X192TVz31vsmdp8ULncvey+TfF9MprtPk3zvD2+CwvIOaW9lCKsrpP3vHaybZO950npjufU6CZeRt3uHvedJwS1ubx7/es3u86RlAHTvdVJY3dzsPk9alWPzddLSxN7jpOAXbrr7Oin4sAzGbj1PWu20N18nhdW3lnafJ4XVF3X23ieF1deFdh8ovWBk74XS2sjmE6WXSrL1Rmm7TVaPlF6ozt4rpReM7D1TeqkkW++Udttk+VBpaWT3pdILRvaeKr1Ukq23SvttUutpSfZeK62NbD5XeqkkW++Vtttk9WDphersvVhaG9l8svRCSfbeLG23yerR0rokUa9DU4yLho3LGIDTrz/7cL8Df6EkRb/IHVczW3LfuySbL7mWi+juU66werG8/S3P1XeMNr/mmVZfxdv9nmdaNOvmFz2XJva+6bmsyuZTrrWR3e96Lvdqm2+5wurLTptvucLqy067b7nWBdl7y7Vu1s23XC908OIt10/j17e/vv/07N+K+krGPr1/+8uHd/zr718+/nr56+f//Sl/kX9r6s9Pf/z67rcvn96RJfsHp8Z/fvQutDfepf7TmydPv9NDujEbVfqdEqQRuR1zDP3Kfy9vaOL66SsV8P8=",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "claim_deposit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7428360812483913122": {
            "error_kind": "string",
            "string": "Game has not ended yet"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZrbbhw5Dobfpa99oSNJ5VWCIHCSzsCA4QQee4FF4HdfUcWf1fZCgl09c+P+ml1iURQPUpX/nH6cvz3/9fXu4eevv0+fPv85fXu8u7+/++vr/a/vt093vx669M8p6J9Y4ulTvumfdPpU+meN9mnfqX+PQYEMOHVICmwgkIhKVFtLG6QQALUDdYhdklQSK6AZpAKAJEOSISkZwAY1AchAbd5Ab9FnkYQMWgDYTzkEACQRklgAYpAygA1yAtgtsnp0A1WYFJpBLQAxoARgA44ADJcAIIMGSbNrStBRVYEMIiTDzwOawZjFADbIuDjj4hIALsHwMYsBYjBmMQB3ZwxnXMy4WHB3gUSjJbGCDpebUw3FICYAGyQ1tSmQQQ6AAhCDkgC4uGJ4hYQwnDCcMJwxnHGx4GLBxboWOSjIBhT6qJwV2ECXYIB6fgO9uE+H1OaiozTCBxSVkEIzqH146fciNbUmhS6pPcZI/bwBJAKJWrhBM2iQNJNwyAAxUIdvwAYJEnX4AI2WDfSmfQVZo2UDSCokGi0bNAOChCDhDBADLSkbsEGDRINEQTRzKylUQDOIkERIEiQJEvX8BpBobdmADTRaNsBwwk0xC8EshCFhSCQDbF7SIGkmaSEBbKZNM3cDm2lLkKQKMJsbZtE05gdozG9ABhWSCglFACQcAFDIUCgYLuaW1jC82fAYQnJqoFhAKTj5iOyy7NdlH4u16CSg6tfB/k6uj90C9hHDdBlEoGH8Rt2bpC0tar0xaqDov2oGGDEoZycfoTZTGiQg9b0Rg8hlmrVUBqkWtTlq0JAMYpAGvxEZJS35Ri7TRrVRyk4uyy7LLisuK7jb6KhGrlnjfiP1LrGSeteIQepdDoPIaLRYowqKLtMU5aik3t1IC8tGWlkGFV0Zrkqx28zqq6KJYdRAGk1GAtKcYB7bHB0rgxikLdeoOjWQ+HUNv9YxozaIQMOqjQSkOxqjBsouU/tEfTDa00ZacYwaSEuNkY/QaDfysdLtE/XVaEpGxUmMRoMyIlAMTtBCyWWpOLmW7Fp06yMaz6R+NmogzdqNNIaMKkhLvxH8TBKd4HFqkI3GJLrJ5OE/zR4e992IQMOTG1WLHFYLjIoT4orZZewycZm4rEE2WpDRLhOQ9lIjAiUfkXyExsaYkWiGypAN6zeqNo/Re4x2WQMNT9IgAYnLNIpFM0C0lhiRUQvQ3AL81zSejeDnNuJgI9x3dCAjv87Xo/l6tOr3qD5WNyKcxjkhOwlo+G8jAo2M30hXdRwtRm4NGrk1qLhs5Llu+cPI80Hi16k3jNgohuTksuiyYcugsZYbFScB6VoawYI46tBGAhrROWhE50YEYh/BLhO/bsyjvLzcnHC0+/r0eD7rye7irNdPgL9vH88PT6dPD8/39zen/9zeP4+L/v59+zA+n24f+6+9ipwffvTPrvDn3f1Z6eVmHx3mQ/sGtNnonsnNFdTXGuJCQ84RGvrZyTXQaw1prqEHPjSIhDTT8N5ZiMxmsdTQfBYSeKahzjX0M2E1DZkubOh19pUKmqvoTRrT6H14X4yeoq9U8FwFS0Y0cC9GM1/KQgMlGMFEMtPQFtPoLTdjHr2F0kzHch5pnwdNNcS4MqNV92bcXdGP/Efiqp9SjsSV8K6hTeMqlrmKGgSu6DhdkLiIzR4JcIX0c/eRDJMLT/A0w+JiSWPWLfO2HiWWPbprfa1jEZxRzwdDRbooFP1Bz2sNi+DsuwUP734mdR1J3tSrhTOyHuaHihIvNIQ3Ghax2R+eodykdBFY/6djUTar5+nlkn5IQ2OsaazH5pEERqR8sSIf0sHRF5VXM6F/V4dudBGfdBHiH9LB7JWvP/o4pqMF7wItzXUsc634uugpZZpredXYOSBG+zOk7Dra62TLadVLXANfdsRypOy0UGdlJ5dlN/I2EDlMrcj16q6a6eq2mvkf6KvrqbyrseZVf6fInii5HGqsLXnpaWW6riVev98q6foNV8lXx0YpV8dGqf9AbCwXpQnMCHHa48siREt/HIrW2OLUiLJo8VIKrJBC5cA8+uPxfR6Vpnv5cPWeq8Z/dc/V4p4kEqbzyKtUDWVP1Yu9CqV36+jv5bzH9zPi3gfau1WQb5iILhTEA57gfkCfemJVPKmQe4J2ZxZ6v4p+jPDC158dXJStN95cFM8cCnpivgzOt5G1VOH7tv7sdaqCVmejENk3OyHlcsiOTMiznGV6bqdVfAbOXrZCf+l0yI7iFTiXwlM7VuWz57uHR5B5uq7tiHG3Y1o0aBVi/TWH71b6iw45ZEdNSPr+6nruj+URPnsv6K0l5akdy3zJUnYlF8eDN/kSVhvZsh8aK08LWFhuV7zJ9yfis8wPV9eOlYaQki8rzc9aYenNsDtTjqkgt6I/oD6kInvt0RA5pKL6DjRehueHVNB+vJF2bCL7KSunYxPJe2zmemgiXLAgXOiIguaHm8ti8REFvmFr6ZgFHlON65VTeKvgS/96+/3u8dV/QL2oqse722/3Z/v68/nh+8WvT//9jV/wH1S/H399P/94fjyrpv3fqPqfzz0Eb/oLui83p9K/ld6Oiui3qt/6KbqW3L/pe7bP/RR8k8al+q7/swZh5fjlRQ39Hw==",
      "brillig_names": [
        "claim_deposit"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3Rruw6cmD5L/VcDwqSQQb9K42BUe32NAoolBvV9gADo/99UiFFLO19nDzamXnnxWfV9TmxJKUiJJEh6j//9D/+9b//x//857/+/f/+t//9p3/6b//5p//+j7/+7W9//Z///Ld/+5e//Ptf/+3vj//6n3/a9v8jRf70T/Lnx5/l/LOef7bzTz3/7Oef4/zTzj/n8Wfdzj/PePWMV8949YxXz3j1jFfPePWMV8947YzXznjtjNfOeO2M18547YzXznjtjNfOeHrG0zOenvH0jKdnPD3j6RlPz3h6xtMzXj/j9TNeP+P1M14/4/UzXj/j9TNeP+P1M944440z3jjjjTPeOOONM944440z3jjjjTOenfHsjGdnPHvEK/uf7fxTzz/7+ec4/7Tzz0c8ffw5H/HG/qecf5bzz3r+2c4/9fyzn3+O8087/5z+Z9m28899+8oOJaAGtAAN6AEjwALmCbIFRGSJyBKRJSJLRJaILBFZIrJE5BKRS0QuEblE5BKRS0QuEblE5BKRPXceB7d48jhIQAmoAS1AA3rACLCAiNwicovILSK3iNwicovILSK3iNwicovIGpE1ImtE1oisEVkjskZkjcgakTUi94jcI3KPyD0i94jcI3KPyD0i94jcI/KIyCMij4g8IvKIyCMij4g8IvKIyCMiW0S2iGwR2SKyRWSLyBaRLSJbRN7zTuwBe+IdIAEloAa0AA3oASPAAs7IddsCJKAE7FWi7NACNKAHjAALmCfsOXiABJSAiCwRWSKyROQ9B4vuYAHzhD0HD5CAElADWoAG9ICIXCJyicg1Iu85WOYOJaAGtAAN6AEjwALmCXsOHhCRW0RuEblF5BaRW0RuEblF5BaRNSJrRNaIrBFZI7JGZI3IGpE1ImtE7hG5R+QekXtE7hG5R+QekXtE7hG5R+QRkUdEHhF5ROQRkUdEHhF5ROQRkUdEtohsEdkiskVki8gWkS0iW0S2iGwReUbkGZFnRJ4ReUbkGZFnRJ4ReUbkeUZu2xYgASWgBrQADegBI8ACIrJEZInIEpElIktElogsEVkiskRkicglIpeIXCJyicglIpeIXCJyicglIpeIXCNy5GCLHGyRg23PwSo7aEAPGAEWME/Yc/AACSgBNSAit4jcInKLyC0it4isEVkjskZkjcgakTUia0TWiKwRWSNyj8g9IveI3CNyj8g9IveI3CNyj8g9Io+IPCLyiMgjIo+IPCLyiMgjIo+IPCKyRWSLyBaRLSJbRLaIbBHZIrJFZIvIMyLPiDwj8ozIMyLPiDwj8ozIMyLPM7JuW4AElIAa0AI0oAeMAAuIyBKRJSJLRJaILBFZIrJEZInIEpElIpeIXCJyicglIpeIXCJyicglIpeIXCJyjcg1IteIXCNy5KBGDmrkoEYOauSgRg5q5KBGDmrkoEYOauSgRg5q5KBGDmrkoEYOauSgRg5q5KBGDmrkoEYOauSgRg5q5KBGDmrkoHoO6g4loAa0AA3oASPAAuYJnoMOEXlE5BGRR0Tec7CVHXrACLCAecKegwdIQAmoAS0gIltEtohsEdki8ozIMyLPiDwj8ozIMyLPiLznYGs7WMA8oO85eIAElIAa0AI0oAeMAAuIyBKR9xxsukMJqAEtQAN6wAiwgHnCnoMHROQSkUtELhF5z8FmO/SAEfCIrNsO84Q9Bw+QgBJQA1qABvSAERCRa0RuEblF5D0Hte5QA1qABvSAEWAB84Q9Bw+QgIisEVkjskbkPQd1/3X2HDzAAuYJew4eIAEloAa0AA2IyD0i94jcI/KIyCMij4g8IvKIyCMij4g8IvKIyCMiW0S2iGwR2SKyRWSLyBaRLSJbRLaIPCPyjMgzIs+IPCPyjMgzIs+IPCPyPCOPbQuQgBJQA1qABvSAEWABEVkiskRkicgSkSUiS0SWiCwRWSKyROQSkUtELhG5ROQSkUtELhG5ROQSkUtErhG5RuQakWtErhG5RuQakWtErhG5RuQWkVtEbhG5ReQWkVtEbhG5ReQWkVtE9hzsO0hACagBLUADesAIsIB5Qo/IPSL3iNwjco/IPSL3iNwjco/IPSKPiDwi8ojIIyKPiDwi8ojIIyKPiDwiskVki8gWkS0iW0S2iGwR2SKyRWSLyDMiz4g8I/KMyDMiz4g8I/KMyDMizzOybVuABJSAGtACNKAHjAALiMgSkSUiS0SWiCwRWSKyRGSJyBKRJSKXiFwiconIJSKXiFwiconIJSKXiFwico3INSLXiFwjco3INSLXiFwjco3INSK3iNwicovILSK3iNwicovILSK3iNwicuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ5a5KBFDlrkoEUOWuSgRQ7OyMEZOTgjB2fk4IwcnJGDM3JwRg7OyMEZOTgjB2fk4IwcnJGDM3Jweg7OHXrACLCAeYLnoIMElIAa0AIiconIJSKXiLznYH/cH849Bw+QgBJQA1qABvSAEWABEblF5BaRW0RuEblF5BaRW0RuEblF5BaRNSJrRNaIrBFZI7JGZI3IGpE1ImtE7hG5R+QekXtE7hG5R+QekXtE7hG5R+QRkUdEHhF5ROQRkUdEHhF5ROQRkUdEtohsEdkiskVki8gWkS0iW0Tec7C3HeYJew4eIAEloAa0AA3oASMgIs8zsmx7EvbhJEklqSa1JE3qSSPJkmaQpEPSIemQdEg6JB2SDkmHpEPSUdJR0lHSUdJR0lHSUdJR0lHSUdJR01HTUdNR01HTUdNR01HTUdNR09HS0dLR0tHS0dLR0tHS0dLR0tHSoenQdGg6NB2aDk2HpkPToenQdPR09HT0dPR09HT0dPR09HT0dPR0jHSMdIx0jHSMdIx0jHSMdIx0jHRYOiwdlg5Lh6XD0mHpsHRYOiwdMx0zHTMdMx0zHTMdMx0zHTMdMxySeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnknkumeeSeS6Z55J5LpnnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nnJfO8ZJ6XzPOSeV4yz0vmeck8L5nn3jA0NidN6kkjyZJm0J7nJ0lSSapJ6RjpGOkY6djzfBSnGbTn+UmSVJJqUkvSpJ40ktJh6ZjpmOmY6ZjpmOmY6ZjpmOmY6Zjh8KaikySpJNWklqRJPWkkWVI6JB2SDkmHpEPSIemQdEg6JB2SjpKOko6SjpKOko6SjpKOko6SjpKOmo6ajpqOmo6ajpqOmo6ajpqOmo6WjpaOlo6WjpaOlo6WjpaOlo6WDk2HpkPToenQdGg6NB2aDk2HpqOno6ejp6Ono6ejp6Ono6ejp8PzvO7keX6QJJWkmtSSNKknjSRLSoelw9Jh6bB0WDosHZYOS4elw9Ix0zHTMdMx0zHTMdMx0zHTMdMxw+GNSydJUkmqSS1Jk3rSSLKkdEg6JB2SDkmHpEPSIemQdEg6JB0lHSUdJR0lHSUdJR0lHSUdJR0lHTUdNR01HTUdNR01HTUdNR01HTUdLR0tHS0dLR2e58NJk3rSw2GbkyXNoD3PT5KkklSTWpIm9aR0aDo0HT0dPR09HT0dPR09HT0dPR09HT0dIx0jHSMdIx0jHSMdIx0jHSMdIx2WDkuHpcPSYemwdFg6LB2WDkvHTMdMx0zHTMdMx0zHTMdMx0zHDIc3R50kSSWpJrUkTepJI8mS0iHpkHRIOiQdkg5Jh6RD0iHpkHSUdJR0lHSUdJR0lHSUdJR0lHSUdNR01HTUdNR01HTUdNR01HTUdNR0tHS0dLR0tHS0dLR0tHRknmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp5r5rlmnmvmuWaea+a5Zp73zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vm+cg8H5nnI/N8ZJ6PzPOReT4yz0fm+cg8H5nnI/N8ZJ6PzPOReT4yz0fm+cg8H5nnI/N8ZJ6PzPOReT4yz0fm+cg8H5nnI/N8ZJ6PzPOReT4yz0fm+cg8H5nnI/N8ZJ6PzPOReT4yz0fmuTeDWXWSpJJUk1qSJvWkkWRJM0jToenQdGg6PM+bkyb1pJFkSTPI8/wgSSpJNSkdPR09HT0dPR09HSMdIx0jHSMdIx0jHSMdIx0jHSMdlg5Lh6XD0mHpsHRYOiwdlg5Lx0zHTMdMx0zHTMdMx0zHTMdMxwyHN5KdJEklqSa1JE3qSSPJktIh6ZB0SDokHZIOz3N16kkjyZJmkOf5QZJUkmpSS0pHSUdJR0lHSUdNR01HTUdNR01HTUdNR01HTUdNR0tHS0dLR0tHS0dLR0tHS0dLR0uHpkPToenQdGg6NB2aDk2HpkPT0dPR09HT0dPR09HT0cPh3TzDYf9P3WlX2E6+GwdJUkmqSS1Jk3rSSLKkdPR09HT0dPR09HT0dPR09HT0dPR0jHSMdIx0jHSMdIx0jHSMdIx0jHRYOiwdlg5Lh6XD0mHpsHRYOiwdMx0zHTMdMx0zHTMdMx0zHTMd83QUb/c5SZJ2x3SqSS1Jk3rSSLKkGbSXq7k5PRyzOpWkmtSSNKknjSRLmkF7uTopHSUdJR0lHXu5ms2pJ40kS5pBe7k6aXd0p5JUk1qSJvWkkWRJM2gvVyelo2XkvUjN4WRJ+7/1323P35MkqSTVpEcU2fwH8fUBTuzgAA2cib5SwIkClh3FsYINdJsffV81YPOD6esGbL5/vnLAiTPRVw84UcACelw/13zNgBNHor/vf65bMUADZ6K/93+igAWsYAMVxDaxTWwzbd6GEyhgASvYQAU7OEADsQk2wSbYBJtgE2yCTbAJNsFWsBVsBVvBVrAVbAVbwVawFWwVW8VWsVVsFVvFVrFVbBVbxdawNWwNW8PWsDVsDVvD5lkozXGABvo27Kf9sRTOiQIWsIINVLCDAzQQ28DmWehrWhzL5ZxYwQYq2MEBGjgTfV2PE7H52h4yHCvYQAU7OMDdVsRxJnrOnyhgASvYQAU7OEBsM23ekhMooMctjgp2cIAGzsRjBZ4DBSxgBbEJNsEm2ASbYCvYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bo2xabYFJtiU2yKTbEpNsWm2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoFtYBvYDJthM2yGzbAZNsNm2AybYZvYJraJbWKb2Ca2iW1im9hm2o5Vg04UsIAVbKCCHRyggdioJZVaUqkllVpSqSX1qCXVsYMDNHAmHrXkQC/x07GCDVSwgwM0cCYetwcHCoitYqvYKraKrWKr2Cq2hq1ha9gatoatYWvYGraGrWFTbIpNsSk2xabYFJtiU2yKrWPr2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGtoHNsBk2w2bYDJthM2yGzbAZtoltYpvYJraJbWKb2Ca2iW2mrW0bKGABK9hABTs4QAOxCTbBJtgEm2ATbIJNsAk2wVawFWzUkkYtadSSdtyMdMcODtDL1XCcicfNyIECFrCCXhzddtyMHNhBt5mjgTPRa8m+FkrxFqPAAu62Wh0buNtqc+zgAHdb9d30WnKg15IT3ebb4LXkxAo2UMEOelzfTa8PbXPcIzTfdK8PJyrYwX17m++Q14cTZ6LXhxMF9O1Vxwo20G2+m14fThyg246/OxO9PpwoYAEr6PvmJ4HXhxM7OEADZ6LXhxMFLKDb/FB7fThRwQ4O0MAZ6B1HgQIWsIJua44KdnCABs5Erw8nCui26VjBBirYwQEaOBO9PpwoILaCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2BSbYlNsik2xKTbFptgUm2Lr2Dq2jq1j69g6to6tY+vYOraBbWAb2Aa2gW1gG9gGtoFtYDNshs2wGTbDZtgMm2EzbIZtYpvYJraJbWKb2Ca2iW1im2nr2wYKWMAKNlDBDg7QQGyCTbBRSzq1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTSzq1pFNL+rFQ8ea42/blnUo/Fis+sIMDNHAmHssWHyhgASuIrWFr2Bq2hq1hO5Yybo4CFrCCDVTQ4+4X7H4sWnysSFxAj2CODVSwgwM0cCYeyxgf6Db/AY6ljA+s4G7r/rN4fTixgwPcbX2/3/Emp8cQrmMBK9hAj+vHwStBPxZf9rh+SLwSdN9erwTdt8wrwXCxV4ITC1jB3TZ8y7wSnNjBAe62vdm9eLPTY+TX0RXd0RXD0RXTcVdYcVSwgwM0cCZ6+p+428y3wdP/xBZniTc8BXZwgAbORM/5EwUsYAWxFWye83YsfT1AA32H/O96zp8oYAEr2EAFOzhAA7E1bJ7zPmnrvVCBbjPHBrrNf03Pbp/h9eanEz27TxRwjzvFsYINVNDr5PHPBmjgTDzuFA4UsIAVbOA4+iCKNz49hvwdZ6Kn/IkCFtB3wk8zT/kTFezgAA2ciX5LcKLbmmMBK+g233QvBD4b7K1Q4tO83gsVaOBM9EJwooD+wOqkST1pJFnSPMnbkYrP9Xo/UmAFG6hgBwdo4Ez0RZBPxFawFWwFW8FWsBVsBVvBVrFVbBVbxVaxVWwVW8VWsVVsDVvD1rA1bA1bw9awNWwNW8Om2BSbYlNsik2xKTbFptgUW8fWsXVsHVvH1rF1bB1bx9axDWwD28A2sA1sA9vANrANbAObYTNshs2wGTbDZtgMm2EzbBPbxDaxTWwT28Q2sU1sE9tMmy/KFShgASvYQAU7OEADsQk2asmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWTGrJpJZMasmklkxqyaSWzKwldctaUresJXXLWlK3rCV1y1pSt6wldctaUresJXXLWlK3DZtgE2yCTbAJNsEm2ASbYBNsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxVWwNW8PWsDVsDVvD1rA1bA1bw6bYFJtiU2yKTbEpNsWm2BRbx9axdWwdW8fWsXVsHVvH1rENbAPbwDawDWwD28A2sA1sA5thM2yGzbAZNsNm2AybYTNsE9vENrFNbBPbxDaxTWwTG7VEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiJHSldHAQvoiubYQAU7OEADfdhrJx8gOEiSXNUdK9hAV5ljB3eV+C54Pp84A70pMlDAAlawgQp2cIAGYhNsns/78EX1VsnACjZQwQ76CJuTJc0gHzo8SJJKkkesjr6lzdG39Pi42gYKWEDf0uHYQAU7OEC3+TZ4dh7o2XnibiubYwEruNv8u3He+Bi424rvkGfniQbuNv+rnpwHSVJJqkktySP6IfJcOz8y5/+6Oxawgg30LfUd9Fw7cYAGzkS/bh8fspOkkrSrfKv8mn2QJvWkkWRJLpk7em6fKGAD939f/eB7vp64R/BD61fggyRp38rqR8/z9cQG7htafVs8X0901fGhPgNnoLcjlr1PpHo74uPUcnSbOfpBEccGKtjBARo4Ez1fT9xt+2dt6vFxw73hox6fN9x7COrxOcN2fFHQ4/pG+pX2xJnoV9oTBSxgBT2Y76an6okz0VP1RAELWEH/Z36gPOdOFLCA/s+m434k98m+WuNDTbXGl5pqjU811Rrfaqo1PtZUa3ytqdb4XFOt8b2mWuODTbXGF5tq1XRoOjQdmg5NR09HT0dPR09HT0dPR09HT0dPx5FuB+4HxI9HfrCQLxbyyUK+WchHC/lqIZ8t5LuFfLiQLxfy6UK+XcjHC/l6IZ8v5PuFfMCQLxjyCUO+YchHDPmKIZ8xPD5WuE+Z1uNzhScWcA+0T0zW46OF++RoPT5bqEeEfdv2ycZ6fIRwn0Csx2cIu/9dv7Kd2MF95/Z1HOvxOcITZ6Lnz4kCFrCCDXSbOnZwgLtt+L55Kg3fHE+lE/e4w/+uX/VOVLCDg39m4Ez0DDwRW8PmGXhiAzs4jg+G1eNDhQfNIE+8gySpJHnw7thABS3RL3XDj6Ff6ob/5n6pO7GBCnZwgAbORL/UDT9r/Fp3YgF3m/m55Ol3ooK7zfwM8ww80cCZ6El4ooAFrGADFcRm2AybYZvYJraJzTPS/LzzlDxRQY+7/+beL1f2udvqnXGBvjnd0TdnOBo4E/2qts+mVu+BC/T6UBy9uLjt+IynK44PeR5o4Ew8Pufp23B80PPAAlawgQp20OP69h4f1D1QQI/rm358VvfABirYwQEaOBOPz+VOxwEaOBOPz+YeKOCeY/u7qfX4aOCJDVSwgwPcs9mfvI4PCB7onxA8UUC3+e/mn+705zHvCKv+YOUdYYEGzkT/iOeJAhbQ98J/Y/+Y54kKus1/N/+k54kGus2Pjn/Y80QBC1jBBirYQb9i+zE7PvS5H4d+fMazOjZQwQ76PcS+m/34fOeBAhawgg1UsIO+Zepo4Ew8Pul5oICu6I4N9GD7ad+Pr3Oao4un4y725yNvtgq041uI1XutDtqT6SRJKkk1qSVpUk9yiTgaOBP92nOigAWsYAMV9Lj+e/o9nT9XeI+V32R7i9VJLUmTetJI8oi+/Z5VB3pWnShgASvoh9mDef74w52vFRXoEZxKUk1qSZrUk/yY+i/rmXPiTPTMOVHAAnpUPyE8G/xBzReD8jt67486SZL2AzqcalJL0qSeNJJcUhxnoqfRiRXc93N/RaB621Oggftm7gfRu55OkqSSVJNa0r7j/gTpDU+BAzRwJvq3b08UsIAVbCC2is3zzp9MveEpcCb693D9IdUbngLdNh13294fVL3hqfrTpjc8BXZwt3kuehtU4G7zk93boOpxdPzLZB7WP012UE1qSZrUkzyi/9p+WTtOmuNbuP4Xjq/hHqjgvqX+1DSOb+IeaOBMPL6Me6DH9R30VPPHDO9fqv5s4f1LgTPRE/BEAQtYwQYq6DY/cJ6GJxroNj+cnoYnClhAt/kx8wvYiQruh9d3zT9LdpAlPVR+DI6vAx4kSSWpJrUkl5hjBwdoiX6NO9E3czoquEfwpzfvjwo0cB7fLqv5TcCaHwWs+VXAmp8FrPldwJofBqz5ZcCanwas+W3Amh8HrPl1wJqfB6z5fcCaHwis+YXAmp8IrPmNwJofCaz5lcCanwms+Z3Amh8KrN4IVfc22eqNUIEN3A9Zr44dHKAfMnWciZ6h3Y+/XyJPLGAFG+g2/4F8dOTE3Tb8V/EL5/At8+wdfmb4CMmJAu42f+D1RqjABurxgbh6fFjwoJFkSTPIPy54kEdsjvuW+mOxtzVVf6z0tqbAmejZfKJvqe+2Z/OJFWyggg/bcYbGIunVYsG16h1J/tDkDUknjaR9m8yPnn8x3tHbkQIFLGAFG6hgBwdoIDbBJtj8RtSfF70dKbCBCnZwgPM8Bt6CdJIkefzqWMEGKtjBAfreqONM9Kvsib433bGA7fyRZqyDXmesg1695ciHHrzj6KQZ5BdVO1DAAlawgQr6rpjjAA3cj9p+Ns1YQLXOWEC1zlhAtc5YQLXOWEC1zlhAtc5YQLXOWEC1zlhAtU5NR09HT0dPR09HT0dPR09HT0dPR0/HSIff8e7t1tU7iwIruB+zefxdBTs4QANnoqfziQIWsILYDJtfnKfngF+cTzRwJvrF+UQBC1jBBrrNk8SfLk8c4H4Y/Xz0Rcwe1I5FzA6SpJJUkzzigb6lbUdP8n3gpHmfUGABK+hbOhwV7OAADXTb3NGfNk8UsIAVbKCCHdyfAPbRh+Z9Qm0ffWjeJ9Q239495QMFLGAFG6hgBwdoILaGrWFr2Bq2hq1ha9gatoatYVNsik2xKTbFptgUm2JTbIqtY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2gc2wGTbDZtgMm2EzbIbNsJnb+o5zA93mKTILWMEG7rZ9hKl5n1DgAA2cgd4nFChgAXfb3grQvE8o0BXFcYAGzkRxRXUUsIAVbFF35CggB3ZwgAZmuZKjgBwoYAH1uOlqx/cNDxpJj6D9+HszyL97dpBv/4EFrGADFezgbvJD6F8/O2gGeYXYB9iad/8EFrAeHw5r+aHDlh86bPmhw5YfOmz5ocMm8QG0lh86bPmhw5YfOmz5ocOWHzps+aHDlh86bPmhw5YfOmz5ocOWHzps+aHDlh86bPmhw5YfOmze59P2ccTmfT6BA/TT6/i7M9FrwYkCFrCCDVSwg24zRwNnon8nyc8U/07SQSWpJrUkTfKI+5XJG4Za8f/qmV385/fMPrGBCu5bWjxTPLNPNHAGesdQoNuaYwEr2I6vTrUSXz1rJb561kp89ayV+OpZK/HVs1biq2etxFfPWomvnrUSXz1rRdIh6ZB0SDokHZKOko6SjpIOH2nbRzubr6TW9kHG5q1DgR0coIEz0W8JThSwgBXEVrFVbBWb3xLsY57NG4pO9IQ/UcACVnCPu0/2t2NJNP/ljkUGnPZ/VP339iv7iQ1UsIMDNHAm+pW9usKv7CcW0G1++P3KfqKCHXTbns3eM9T2tpjmTUOBBaygx/Wj4Hm7Dz427xxqzQ+I523z7fW8bb5lnrfNxX4NP1HAAvqMgm+ZX8NPVLCDbvOf1S/c6pvjF271zfH0Vj85Pb3VN8fTW32HPL1PVLCDAzRwBnqDUdtHxZo3GAXWOEe8qyhQwV3hlzrvKgo00Ie3/e/6hftEAQtYwQYq2MEBGoitYDuG05tjAd1WHRvotuLocdVxJnpCnyigx+2OFWyggj2KdT0S+kADZ+KR0AcKWMAK+tHxX9Pv5k80cCb63Xz339jv5k8sYAXbOYjVjg6lEzs4QANn4jEId6CAfnSmo4IdHKCBM9Fz3i+GvlpZYAEr2ECfyfFTw/PYy763JbXhJ4Hn8YkV9Ah+7ngen+gTRL5DnscnGrhv7/Bf3lP6RAELWMEGKug2/wk9pU80cAZ6H1OggD5gPx01jkM7prkOHKDHNceZ6Hl8ooD7XuyjK817ngIbuNv2AbnmPU+BA9xtPnTgPU8neh6f6DbfdM/jffyuec9T28fZmvc8tX1wrXnPU2AHPa4fB8/jEwUsoMf1ffOM9bPEu5sCDZyJnqYn+vTCgQp20CcofN+ORqYDZ+LRynSggAWsYAMV9IPqx8wvwgf6RfhEAfedn/5j+UX4xAYq6HNyfnR8putEA2eiz3SdKGABK9hAn1n0AzUM3Pdi+unpyXuigAX0vfB/5sl7ooIdHKCBPo/pR9KH2E4UsIAVbKCCHRxgzAU3XwiszQMLWMEG+l40xw4O0EDfi/1302OW+kABC1jBBirYQf8t9tTzJb8CBSyg70V3bKCCHRyggTPRk/dEtw3HAlawgW4zxw4O0MBodGjeiBUoYAEr2EAFOzgSj2aR4uh7MR0LWEGfrvajfsxX+0lwTFgfOEADZ+Ke84ECFtDnxv2E8UkvH0o6GrH8uc9brtSHknxprsAGKugR/KiPARo4E20DBSxgzW04ekkOVLCDAzSQvTjaSQ4U0PfCf/npe+FH3WesTxyggfte+MiWL8IVKOC+Fz7I5e1ZgQ1UsIMDNNBt+wnjTVuBArqtOlawgQp2cIAGum0/H7xpK1BAt6ljBRuoYAcHaKDb9nPHF+EKFNBt5ugtAH58fdbbRzO8L0w9nbwvLHCABnqzge+Fz3374763hqnnpveGBVawgW7zzWlum47e2OBb1gyciXvOB/q+DccCVrCB0fPW+vFuwIEDNHAmHu8HHChgASvo3Rl+JH2m+0QDZ6JPdvv12JvHAgtYwQYq2MEBWqJXAr8sek9ZYAU9rv+EpmAHB2iJ0+P6z+0576MH3kIW2MEBGjjPnuM2jqbkAwUsYAUbqGAHR6Jnt49V+BpbgQWsoO+FOfovtP+a3kwWKOAewUc7vJ8ssIH7HvsYiPeOqY+BeO+Y+hiI944dx8F7xwILWMEGKuhx1XEmehaeKGA5G/DbOF4KOLCBCnZwgAbORH8X7sQ9rifv0AYquJ8P7fi7A/S9OP7CTPRr7In7XvhIjneQBVZwPzr+HOAdZIEdHKCBu0396HgWnihgASvYQAU76HH9F/L3AbxGea+Y+giR94oFDtC3zM8+m4nTt8yPg+fbiQX0tiVXeBaeqGAHB2jgDDz6xXyo52gYO7GAFWyggj322L/7pz4A5B/+CxSwgB63OjZQwQ7u56RfZo6ltk6cif5yz4kCFrCCDfSj0xwNnIlH/9iBvhf+z44OsgMr2MA9A+T4Zx0coIEz8Xil9UABS+J+qRs+oOKNXoENVLCDAzRwJu6pFyggto6tu803pyvYwQEaOBOHx+2OFWyggh0c4B7XR0a8CexEnw86UcDdZn6m+pTQiQ20jOutXwfODRSQTZ9s+mxp27MwsIMDtBTPGei9Yif6Z+T8kcvbsAINnDvupcJbsqY/43hPVmABK/jYyMcU8+asF+4XHrCv7Lh5x4Yv9/Tg4twurBcel79vztV5wm27sFy4XLheuF34cKlzv/C48OHtzhPW7cKHtzmXC9cLtwtf9vH88NzB48J24QmfH587WC5cLnw5tv1ybD13fOzOu7BOHBsoYAEr2EAFOzhAbAObYTNshs2wGTbDZtgMm6ecD1x6H9aJnnInCljACjZQwQ4OENsMm27bBgpYwAo2UMEODtBAbIJNsAk2wSbYBJtgE2yCTbAVbAVbwVawFWwFW8FWsBVsBVvFVrFVbBVbxVaxVWwVW8VWsTVsDVvD1rA1bA1bw9awNWwNm2JTbIpNsSk2xabYFJtiU2wdW8fWsXVsHVvH1rF1bB1bxzawDWwD28A2sA1sA9vANrANbIbNsBk2w2bYDJthM2yGzbBNbBPbxDaxTWwT28Q2sU1s1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglctSS5ui24ThAA2fiUUsOFLCAFWyggtgMm2EzbBPbxDaxTWxHLTFHBTs4QANnoPeKjX2eUL1XLLCAu22fx9KjV2yfptKjWezEDg7QwJnoteREAQtYQWyCTbAJNsEm2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYGraGrWFr2Bq2hq1ha9gatoZNsSk2xabYFJtiU2yKTbEpto6tY+vYOraOrWPr2Dq2jq1jG9gGtoFtYBvYBraBbWAb2AY2w2bYDJthM2yGzbAZNsNm2Ca2iW1im9gmtoltYpvYJraZtrptoIAFrGADFezgAA3ERi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSSi2p1JJKLanUkkotqdSSRi1p1JJGLWnUkkYtaUctqY4ddFtxNHAmHrXkQAELWMEGKthBbIJNsBVsBVvBVrAVbAVbwVawFWwFW8VWsVVsFVvFVrFVbBVbxVaxNWwNW8PWsDVsDVvD1rA1bA2bYlNsik2xKTbFptgUm2JTbB1bx9axdWwdW8fWsXVsHVvHNrANbAPbwDawDWwD28A2sA1shs2wGTbDZtgMm2EzbIbNsE1sE9vENrFNbBPbxDaxTWwzbbptoIAFrGADFezgAA3ERi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiR61pDvOxKOWHChgASvYQN3f5t4cOzhAi1rtzXy2Oe61JFDAAlawgQp2ENteSwJn4lFL/O8eteRAbIpNsSn7puybYjteoT/+LvvW2bejPvjfPUY7puNMPEY7DhSwgBVsoIIdHCC2gc2wGTbDZtgMm2EzbIbNsBm2iW1im9gmtoltYpvYJraJbaatbxsoYAEr2EAFOzhAA7EJNsEm2ASbYBNsgk2wCTbBVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVW8V2VILm6JVgOBawgg1UsIMDNHAmHotoHIhNsSk2xXZUAnPs4AANnIlHJTjQbepYwAqOKBX9uGk4cCaODRSwgHswObCBCu6bvvewqnf7BRq4b/redqq+rFyggAWsYAMV7OAADXSb7/zcQAELWMEGKui27jhAA2eg9wsGCljACu62vclVvV8wsIMDNHAm7qUiUMACVhCbYBNsgk2wCbaCrWAr2Aq2gq1gK24TxwFaYhXQIxRHBTs4QANnoqf/iQIWsIJuU0cFOzhAA2eip/+JbjPHAlZwt1XfTU//Ezs4QANnoqf/idg6to7NV9TZe2PV+xADO+i24+8aOBN9XZ3j7+71IbCAlb/bQAV3W/Pt9fpwoiV6bjb/LY4VrQ6sYD6uDwYHBoMDg8GBweDAYHDAGBwwBgeMwQFjcMAYHDAGGo2BRmOg0RhoNAYajYFGY6DRGGg0BhqNgUZjoNEYaDQGGo2BRmOg0Y51r6qjgAWsYAMV7OAA/RdSx5lYN1DAAlawgQp2cIDYPI/3t6fVOw4DBSxgBRuoILaGzfN4fxNNffU629t61VevCxSwgBVsoIIdHKCB2Ho+Gh1NjScWcLft/cTqTY2BCnZwgAbORM/jE/d9U/+NPY9PrGADFezgAA2ciX6dPxGbYTNshs2wGTbDZti8aqhngF+71X/YYyE8P77HSngHDtDAGej9jYECFrCCDVSwgwM0EJtgE2yCTbAJNsEm2PzavfdKqzdhBs5ErwQn7hH2rmj1tsrAARo4Ez3nTxSwgBVsoNuaYwcHaOBM9Jw/UcACVtBt6qhgB/OxevIQP3mIP9a/29/d12MBvBMLWMEGKtjBAfq++S/kOX+gX7tPFLCAFWyggh0cILaObWAb2Aa2gW1gG9g8u4cfKM/j4T+s5/Hw4+t5fGIDFezgAA2ciX6/fqKA2Ca2iW1im9gmtolthq0fS92dKGABK+i27qhgB2ei5/H+/kn3psnABirYwQEaOBP9On+igG6bjnuEvYu7eyNk4Ez0PD5RwAJWsIEK7tu794F3b4QMNHAmeh6fKGABK+g2P9Sexyd2cIAGzkTP4xMFLGAFsSk2xabYFJti69g6to6tY+vYOjbPY/MTxvP4REv0jD3RI/jP7bl5YgcHaOBM9OvxiQIWsIJu8zPK8/jEDg5wt00/NTyPD/Q8PlHAAlawgQp2cLdNP0s8j0+cgd7cGChgASvYQLepYwcHaOBM9Gv3iQIWsIINxCbYBJtgE2wFW8FWsBVsBVvBVrB5fdhvLbs3NwbORK8EJ3qE4djBARo4Ez3nTxSwgBVsoMfdzyhvN5z7pbl7u2FgAxXs4AANnIl7xgbur6JsfhL0AlawgQp2cIAGus0P9dhAAQtYwQYq2MEBGojNsBk2w2bYDJthM2yGzbAZtoltus1PmFnACnbQI+w/t7cQBgpYwAo2UMEODtBAt+1nlLcQBgpYwN22j2V2byEMVLCDAzRwJvorTycKuNv20dDuLYSBDVSwgwM0cCZWt6mjgAWsYAMV7OAADZyJDVvD1rA1bA1bw9awNWwNW8Om2BSb14d9ELV7C2FgA0ei57z4+eA5f2IBK9hABTs4QANnomf3voZB9wbAwAYq2MEBGjgTPbtPFBCbYTNshs2wGTbDZtg8u4uftJ7dJxawgg1UsIMDNHC37StzdG8AnPugb/cGwMACVrCBCnZwgAbGFGr3BsBAAd3WHCvYQAU7OEADZ6JXgn0YtnsDYGABK9hABTs4QANnYsVWsVVsFVvFVrFVbBVbxVaxNWwNm1eC/cX67g2AgQ0ciZ7d+1vZ3Zv6AgtYwQYq2MEBGjgT/Xpc/Xzw6/GJBXRbcWyggh0coIEz0TP2RAELiMJTr/qJ6Kl3ooD+z/yM8tQ7sYEKdnCABs5A75cLFLCC/s/UcSb61fRE/2fdsYAVbKCCHRyggTPRc+hEFJ4M+wIZ3TvYAmeiJ8M++9C9gy2wgBVsoIIdHKCBM7Gh8OvbvhxH91a0QAP3f7Yvx9G9FS1QwAJWsIEKdnCAlthR+KVun2/p3mkWqKAHK44DNHAmejqdKGABK9hABbF54uxTDt17ymbzs88T58QCVrCBCnbQB1R8347hpgNn4jHcdKCABaxgA/3oeAZ4Zp04A717bO6zD927xwILWMEGKtjBARo4EwWbp96+hEn3PrG5T3B07xML7OAADZyJnnon+iC175s/ep5YwQYq2MEBWmKNib+utYAVjMmxrtmp3jU71btmp3rX7FTvmp3qXbNTvWt2qnfNTvWu2anetWFr2Bq2hq1ha9gUm2JTbIpNsSk2xabYFJti69g6to6tx8Rf9y91BirYwQEaOBPHBsbEX/eessAKNlDBDsbkWNdh4Ey0DRSwgBVsoIIdxGbRpdiPnrID5wb6ub45FrCCDVSwgwM0MCbHet82UMACVrCBCnZwgAZiE2yCTbAJNsEm2ASbD03tk269Uwl6iemq3ksDFezgAA2ciXUDBSwgtoqtYqvYKraKrWJr2Bq2hq1ha9iOyabNsYMj8ZhWOjAmx/rR+3Wigh0coIEzsW+ggAWMybHejwmkAxXs4AANnIljAwV0m//yxwTSgQ2MDtd+NIedOEC3dceZaBsoYAEr2EAFY3KsH81hJxo4E+cGCljACjZQQWwT28Q203Y0h50oYAEr6JNCm2PerRwNXz4bdTR8nVjACjZQwQ4O0MCcHDsavk7EVrAVbAVbwVawFWwFW8FWsVVsnvM+p+YLzwU2cCS2nBw7Gr5OLGAFG6hgBwdoYE7FHQ1fPul2NHH55NjRxHXiAA3MqbijietEAQtYQZ+Q8ZPgmEA6sIMDNDCn4o4mrhMFzOmqo4nrxAYq2MEBGpiTY8M2UEBshs2wGTbDZtgMm2Gb2Ca2iW1i8zz2OTVvJAvs4Az05rBjRsybwwIbqGAHB2hgTsV5c1iggG6bjhVsoII5OWbHBNKBBuZU3NEcdqKABaxgA336Rxw7OEADcyruaA47UcAC5nTV0Rx2ooIdHKCBOTl2NIedKGABsTVsDVvD1rA1bA2bYlNsik2xKTavD35reTSHnZhTcd4GFpiTY0fD14kKdnCABuZU3NHwdaKABfS4fkZZTo7ZMYF0YAEr2EAFOzhAA31Cxk+CYwLpQAELWMGcivPWrsAO5nSVt3YF5nTV3DZQwAJWsIEKdnCABmITbIJNsAk2wSbYBJtgE2z+jO5zasf6eicK2MCcHPPWrsCcivPWrkABC1jBBirYQbdNRwNzKs5buwJzcmweE0gHVrCBCnZwgAbmVNw8JpDEUcACVrCBCnZwgDld5a1dJ/YNFLCAFWyggh0cILaObWAb2Aa2gW1gG9gGtoFtYBvYjikoP6OOKagDC6hgTo5Ny8kxb+0KFLCAFWyggh2MqbjhTVw+czW8iSuwgBVsoIIdHKCBM1GwCTbBJtgEm2ATbIJNYnJsbMcEkmPZQAELWMEGKthBn3qpjjE5NrZjAsmxbqCABaxgAxXsoD/ruc2v3SfOxGMCqTkKWMAKNlDBDg4wpquGN4edqBsoYAEr2EAFOzhAbIqtY+vYOraOrWPr2Dq2jq1j69i8EuxzasNbxgILqGBMjo1tzETbQAELWMEGKtjBkXjMO/n5cMw77SjbBsbk2PB2rcAKNlDBDg7QwJkoG4jimHeqjgbOxBKTY8P7rgILWMEGKtjBARo4EyuKY95JHQdoYEyODW+2ChSwgBVsoIIdHKAlKopj5nU4dnCAMTk2jr6rA/sGCljACjZQwQ4OEMUxYTsdFexgTI6No4HqxJloGyhgASvYQAU7iMIvdc3Pdb/UnVjBmBwbvhxbYAcHaGBMxY2jl+pEAQtYwQZ63OrocZvjTJQNFLCAFWygD6iIYwcHaOBMLBsoYAH96KhjBwcYk2Pj6I86sG6ggAWsYAMV7OAAsXnq7ZNu4+iE2qfMxtEJdWIDFezgAA30QWrfN3/0PFHAAlawgQp20CdZ/CTwR88TBYwJpMGyaYNl0wbLpg2WTRssmzZYNm2wbNpg2bTBsmmDZdMGy6YNlk0bLJs2WDZtsGzaYNm0wbJpg2XTBsumDZZNGyybNlg2bbBs2mDZtMGyaYNl0wbLpg2WTRvleJvRM+t4m/HACjZQwQ4O0ED/3faf0LumAgUsYAUbqGAHB2ggNh+w8nP96Jo6sYAVbKCCHcQm2LwS+GlfS0z8jVoELGAFG6hgBwdo4Eys2HJ5klFzeZJRc3mSUWtM/I1aFezgAA2cicdk04ECxlTcqK2CDVSwgwM0cCbqBgqITbEpNsWm2BSbYlNsPnS9zwyO2rPu1B5TcaP2ARo4E8cGCljACjZQQWwD28A2sBk2w2bYDJthM2yGzbAdk03+wx6TTY5zAysYE3+jzgEaGBN/o20bKGABK9hABWPib/jyZoEGzkTZQAELWMEGuk0dOzhAfxjcHGei5/yJMfE3WilgBRuoYAcHaGBMxY1WN1DAAlawgQp2cIAGYmvYGraGrWFr2Bq2hu2YgvIDpXlv5H1iPmU2vE8sUMEODtDAmdg3UMACYuvYOraOrWPr2Dq2gW1gG9gGtoFtxDt4wxvJAkeiZ/eJMfE3mjVQwQ4O0MCZODdQwAK6zX+sGRN/o82Y+BveHBYoYAEr2EAFOxgTf0M3A2eibKCABaxgA2MqbnjLWOAADZyJZQMFLGAFG4itYCvYCraCrWKr2Cq2iq1iq9gqtuNtxu5o4Ew83ls8MCb+xrFc2IkDNHAm6gYKWMAKNjAm/saxXNiJAzQwJv7GsVzYiQIWsIINVLCDA4yJv3E0hx04NlDAAlawgQrGVNw4msNONHAm2gYKWMAKNlBBbIbNsBm2iW1im9gmtoltYpvYJrbjbUY/o463GXc8msNOrGBM/I2j4etEA2eibKCABaxgAxX0uPsZ5a1dPoM3emmggh0coIEzsW6ggDHxN3qtYAMV7OAADZyJLabihrd2BRawgg1UsIMDNHAmKjbFptgUm2JTbIpNsSk2xdaxdWzH24x+whxvMx7YwJE4YuJv9CFgASvYQAU7OEADZ6LFxN/oxwTzgQWsYEz8jW4KdnCABs7EY7LpQAELGBN/o88GKtjBARo4A8e2gTEVN8ZWwAo2UMEODtDAmSgbiE2wCTbBJtgEm2ATbIKtYCvYCrbjbcbu2EAFLbHGxN8YtYAVbKCCHRyggTOxbWBOxY3WQAU7OEADc+Jv6AYKWEBsik2xKTbFptgUW8fWc+Jv9AJWsIEKdnCABuY04zgmkKpjTvyNUcAKNlDBDg7QwJxmPJrDfA7waA47sYA58efNYYEKdnCABs7EuYE5FTdmASvYQAU7OEADcyrOtg0UsIAVbKCCHRyggdgEm2ATbMfbjNOxgQpaYsmJPysFrGADFezgAA3MaUarOc1ox3SVOBawgjnxZ03BDg7QwJz4M91AAQtYQRTHdFV1FLCAOfFnvYEKdnCABubEn40NFLCAKI4J273oHu1aJwqYE39Hu9aJDVSwgwM0MKcZj3atEwVEcczzDscZePRdnZgTf0ff1YkVbKCCHRyggTkHePRdnYjimOedjgbOxJITf0cD1YkFrGADFezgAA3Macajw+pEDyaOCnYwJ/6OXqoTc+Lv6KU6UcACVrCBCnYQ2/FaYnXMib+ja+rECjZQwQ4OMCf+jgWxDuwbKGABK9hABf3oqONMPN5QPDAn/o7+qBMr2EAFOzhAA3Oa8eiPOhHbMVPsGWA58TetgwM0cCZ66p0oYE78HQtindhABTs4QANjmtGOpa/2k8COpa9ObGBMjtmWy2Halsth2pbLYdqWy2Halsth2pbLYdqWy2Halsth2pbLYdom2ASbYBNsgq1gK9gKtoKtYCvYCraCrWAr2Cq2iq1iq9hqTPzZsaTWiR0coIEz8VgO80ABY+LPjiW1Tmyggh0coJ9903EmHpXgQN83/7vH24wHVrCBCnZwgAbOxONtxgNjysGOJbVOrGADFezgAA2cicdktO/bMRl9YAEr2EAFOzhAA2fiMRx94L5v+9XJjuW3Tqyg/27iqGBPnDFsbMeSWidWsIEKdnCABsYgtR1Lau03kXYsqXViAWPY2I4ltU5UsIMDNHAm5iC1HUtq7SOydiypdWIFG6hgBwdo4EzMQWqTgq1gK9gKtoKtYCvYCraCrWKr2Cq2Y5C6OzZQQUtsMWxsx5JaJ1awgQp2cIAGzsQcpDY5BqmnYwEr2MAYNjbRDg7QwJmYg9QmOUhtkoPUJjlIbZJLWZvkUtYmuZS1SY+3U0xykNokB6lNcpDaJAepTXKQ2iQHqU1ykNpkxECuSQ5Sm+QgtUkOUpvkILVJDlKb5CC1SQ5Sm+QgtUkOUpsYNsNm2AybYZvYJraJbWKb2Ca2iW3G2ykmOUhtkoPUVo7F9Q6MYWMrOUhtJQepreQgtZUcpLaSg9RWcpDaSg5SW8lBais5SG1HI5nX1GNJrX0E2UoOUlvJQWorOUhtJQepreQgtZUcpLaSg9RWcpDajpaxfTDZSg5SW8lBais5SG0lB6mt5CC1lRyktpKD1HYsqbUP2VrJQWorOUhtJQepreQgtZUcpLaSg9RWcpDaSg5SW8lBaisNm2JTbIpNsSk2xabYFJtiU2wd2zFI7SdMDlJbyUFqOxbaOjGGja3kILWVHKS2koPUVnKQ2koOUlvJQWorOUhtJQepreQgtR0LbW1+RuUgtZUcpLaSg9R2LrTlp0YOUlvJQWorOUhtJQepreQgtZUcpLaSg9RWcpDajoW2xM+SHKS2koPUVnKQ2koOUlvJQWorOUhtJQep7Vhoax+ytZqD1FZzkNpqDlJbzUFqqzlIbTUHqa3mILXVHKS2moPUVgWbYBNsgk2wCTbBJtgEm2Ar2Aq2Y5C6O1awgSOxxrCx1RyktpqD1FZzkNpqDlJbzUFqqzlIbTUHqa3mILXVHKS2Y5msvffLjmWyTmyggh0coIEz0bP7RAGxKTbFptgUm2JTbIrNs1uLo4AFrGADFezgAA10m/+aXgn2TjM7FvA6sYAVbKCCHRyggW7zX8grwYkCus0cK9hABTs4QANnoleC7nvsleDEAlawgQp2cIAGzsBj3a8TBSxgBRuoYAcHaCA2wSbYvBL06ljBBo5Ez25/aPPmsMACVrCBCnZwgAbORM/uvWXMjtXATuzgAA2ciX5FP1HAAlYQW8PWsDVsDVvDptgUm2JTbIrNc74Pxw4O0MCZ6Dl/ooAFrKDbzFHBDg7QwJnoOX+igLtt+GnkOX9iAxXs4AANnIme8ycKiM2wGTbDZtgMm2EzbBPbxDaxTWye88OTwXP+xA7OwGOVsdEcK9hABTs4QANnoufxiQK6TR0r2EAFOzhAA2ei5/yJbuuOBaxgAxXs4AAN3G0+2uGNZIECFrCCDVSwgwM0EFvD1rA1bA1bw9awNWwNW8PWsCk2rw8+zOJNZ4EV7KBH2M8+byQLFLCAFWyggh0coIFu8/PXs9tHRrxlLNDj+u/m2X1iBz3ucDRwJnp2nyhgASvYQAU7iM2wGbaJbWKb2Ca2iW1im9gmtoltps1bxgLdZo4FrGADFeygD2DuJ4H3iU0f3/E+sUAF93/mozP+sclAA2eip/SJAhawgg1UEIXn5rGRnpsnNtD/WXHs4AANnImemycKWMAKNhCFJ9n+IVg7er9OrKD/s+aoYAcHaOBM9IQ8UcACVhDFiJltOxq+TixgzGxbz2lnOxq+TuzgAA2cibaBAhYQhcXMth2dWycKGDPb1nPa2Y7OrRMV7OAADYyZbTs6t04UsIIxs21HC9aBsoExs20jp53taME6sYEKdnCABs7EsoEoSsxs29FhdeJMrDGzbSOnne3ouzqxgg1UsIMDNHAmNhRHMqjjAA30U9mPr1+dThSwgBVsoIIdHKAldhT7SfCYxPCN2M+Ck71tJ1mch3O5cL1wu7BeuF94XNguPGHZLnzxysUrF68ccfbf3/t1Hjyd6+W/+7btXTbmfToPFud+4XFhu/CE63ZhubBv294rY76YU3K78OGtzoe3OR9eP8718Hbnyb607cKXfWwe08eyvA0oeVzYLjxh3S4sFy4XrhduFz68vl96eH2/dFzYLjzhfnh937tcuFy4XrhdWC/cLzzgccT34zmOOH48x/Fv/ZwZx7/1c2OMC9uFJ2zlwkccP/7WL3yc236OzeP38mM1j1zwYzX7hceFj3PYj8+ZgzvPMwcPlgsfudCc64Xb5e/ohfuFx4Utj888cvDgIwdPlgu3PA6+ONO57746U/KAj3PMh5TncY6dXC7s278df79dWC98xN+cx4UN9gnrdmAB9wlrnyH2hpZABTu4T1h7T4c3tATORH97+kQBC1jBBirYQWz+xXbvWvAulsAKNlDBDg7QwHni9BWBAgV0W3OsYAMV7OAADZyJ3ttyooDYBJtg884U9S3zzhQ9/msFG6jgvmX7gOg8OlNONHAmemfKiQIWsIINVBBbxVaxVWwNW8Pm62xrd6zgI26vvvN7+Q40cCbuedWr7/yeVoEFrGDb0cV7SgV2cIAGzsS+gQIWsILYOraOrWMbHtd3fniE4ej/zBw7OEADZ6JtoIC+kdOxgg1UsOc22AANnIlzAwUsIDs0G3hc3w+eyXLUed9kOer8yeXC/SxqU478O3A/78aBM9Hz70QBy1nqpkgFo1BN7x0J7OAADZyJZQMFLGAFsRVsBdt5izWd7cITbpe/c9wOnVwuXC/cLqwX7hceF75428WrF69evHrx6sWrF69evHrx6sWrF69evP3i7Rdvv3j7xdsv3n7x9ou3X7z94u0X77h4x8U7Lt5x8Y6Ld1y84+IdF++4eMfFaxevXbx28drFaxevXbx28drFaxevXbzz4p0X77x458U7L9558c6Ld1688+KdeMu2XVguXC5cL9wurBfuFx4XtgtfvHLxysUrF69cvHLxysUrF69cvHLxysVbLt5y8ZaLt1y85eItF2+5eMvFWy7ecvFeakupF2+9eOvFWy/eevHWi7devJd6VS71qlzqVbnUq3KpV+VSr8qlXpVLvSqXelUu9apc6lW51KtyqVflUq/KpV6VS70ql3pVLvWqXOpVudSrcqlX5VKvyqVelUu9Kpd6VS71qlzqVbnUq3KpV+VSr8qlXpVLvSqXelUu9apc6lW51KtyqVflUq/KpV6VS70ql3pVLvWqXOpVudSrcqlX5VKvyqVelUu9Kpd6VS71qlzqVbnUq3KpV+VSr8qlXpVLvSqXelWOeuW3AOWoVyePC9uFZ3I96tXJcuFy4XrhdmG9cL/wuLBd+OKVi1cuXrl45eKVi/eoM36P4X0rfZ+rm963EqhgBwdo4H4ruE/FTV++KHC/Fdwn0qZ3swS6bTg20G3m2MEBum06zkS/899nrqZ3swTuNvP99Dv/E3eb+R77nf+JHdxt+wzT9G6WwN1mvpt+53+i23w3/c7/RLf5bvqd/4kKus332O/8T3Sb72afif48YL6bQ8DdNn03/SnhxAbutul77A8MJ+626RvpDwwnzkR/YDhRwAJWsIEKdhCbYTNsE9vENrFNbBPbxDaxTWwT20ybd7MECljACjZQQbeZ4wANnImygQIWsIINVBCbYBNsgq1gK9gKtoKteNzpuD+v7A2s05c6GltzFLCAFWyggh0coIEzsWFr2Bq2hq1ha9gatoatYWvYFJtiU2z+dsrmv7G/nXKigpbo38/a20+nd7MEVrCBCnZwgAbORH/j5ES3DccCVrCBCnZwgAbORB/A2/x88AG8EwtYwQYq2MEB7jbxk8uXPzzQlz88UcACVrCBCu428d/NR/hONHAG+hJKgQIWsIINVLCDAzQQm2ATbIJNsAk2wSbYBJuPMOyD99M7X070EYYTK+gRuuMADZyJnvMnCljACjZQwd22D+/P4/t6J+62faB/Ht/X28fz5/F9vRN3W/F985w/sYINVLCDAzRwJnrOn4hNsSk2xabYFJtiU2yKrWPr2Lw+FD9QXh9ObKCCHRyggTPR68OJArptOFawgQp2cCR6zlf/3TznT2yggh0c4L691X9jz/kDPTd9kNZ7UQ70XpQT/bT3kVnvDgk00P/ZfoJ7d0iggAWsYAMV7OAALbGi8Azw4VjvGQlU0IMNxwEaOBM9A04UsIAVbKCC2Pxc91FQX1Bo+BOMN5UEFrCCDVSwg17BN0cD807Bm0oCBSxgBRu4B+v+c/up3H0v/FQ+UcACVrCBCnZwgAZiM2yGzbAZNsNm2AybYTNshm1i80td9x/LL3UnVrCBCnZwgAbOQO9QCRSwgBVsoIIdHKCB2ASbYBNsgk2wCTbBJtgEm2Ar2Dzn9yUup/e4BFawgQp2cIAGzkRP/xN9kF4dfZC+OyrYwQEa6FMC+0ngn5gbzffCE/3EBirYwQEa6HF9Iz39TxSwgBVsoII+fbc5DtDAmejpf6KABaygzxCKYwcHaOBM9KJwooAFrGADsQ1sXhT2l0SmLzMUOBO9KJwoYAEryI9l/FjGj2X8WP5I62MrvopQYAUbqGAHB2jgDPR2pEAB3dYcK9hABTs4QAPdtp/K3oQUKGABK9hABTs4QAOxFWwFW8FWsBVsxePu+eaNSd1/C+9L6v4TeltSYAUbqGAHB2jgTPQhrxOxNWwNW8PWsDVsDVvD1rApNsWm2BSbD3l5B4H3KAV2cCb6MJZ3EHi/UWADFezgAA2ciT6MdaKAbvMfy4exfNLfVzIKVLCDAzRwJvow1okCum06VrCBu21fb3t6E1PgAA2ciT6MdaKABdxt3ffYc/5EBTs4QANnoLc/BQpYwAo2UMEODtBAbIJNsAk2wSbYPOf3dbynt0EFjkTP7hM9QndsoIIdHKCBM9Fz/kQBC+gRhqOBM9Hz2O81fLGkwAJWsIEKdnCABs5EReFp6rcd3uYV2EEfB98cDZyJPjJ9ooAFrGADFewgNk/efQml6Q1lfX/XaHpDWWAFG6hgBwfohd933pP3QNtAAQtYwQbqibIdrVZ7XdnZr97nf28X1gv3C4/zlm9nu/CEj+aOk+XC5cL1wu3CeuF+4Yu3XLzl4q0Xb714j/6sY3+PBq158LiwsY9HN9bBRzvWyXJhv7veDq4Xbhf2G2w5uF94XPjibRevXrx68fp9a/Dlt9PLb6eX304vv91x83ryxXvcs9r/efyPP/3Tf/5p32Xdh/T3/T2gBNSAFqABPWAEWMA8QSOyRmSNyBqR1SM/fizVgB4wAixgntC3AAkoATUgIveI3CNyj8g9IveIPCLyiMgjIo+IPCLyiMgjIg+PPPcl/QLmCbYFSEAJqAEtQAN6QES2iGwReUbkGZFnRJ4ReXrkvTZoQA8YARYwTxC/fG5+fu9Fa/OzeCRZ0gzya+RBklSSalJL0qR0SDokHZKOko6SjpKOko6SjpKOko6SDr96bmWnGeTXzoMkqSRpkv/bupP/28cV37vPTpKkklSTWpIm9aSRZEnp0HRoOjQdmg5Nh6ZD06Hp0HRoOno6ejp6Ono6ejp6Ono6ejp6Ono6RjpGOkY6RjpGOkY6RjpGOkY6RjosHZYOS4elw9Jh6bB0WDosHZaOmY6ZjpmOmY6ZjpmOmY6ZjpmOGQ7vAjtJktzRd6pJLUmTetJIsqQZdOSvkySlQ9Ih6ZB0SDokHZIOSUdJR2ZeycwrmXklM69k5nn3Vd/n6rzH6qSRZEkz6MjGuZMklaQ93j6X5j1VJ2lSTxpJljSDPBsPkqSSlA5Nh2fj/q5MObKx7jSSLGkGHdnoJEklqSa1JE1KR09HT0dPx0jHSMdIx0jHSMdIx0jHSMdIx0iHpcPSYemwdFg6LB2WDkuHpcPSMdMx0zHTMdMx0zHTMdMx0zHTMcNRty1JkkpSTWpJmhSRvWOpi5Mk+ZmjO9WkluRnTt+pJ/nZaTtZkp+dj3PcF/o5aXfs85K+zM9Ju2OfoPRFfk7SpN2xvwvk6/6cZEkzyLP2IElyx77NnrUHtSRN6kkjyZLcse+lZ/JBklSSalJL0iR3jJ1GkiXNIM/kgySpJNWkluSO/eh6Jh/krwfsR/d4YcJpBh2vS+xH93hbwqkk1aSWpEk9aSRZ0gwa6RjpGOkY6RjpGOkY6RjpGOkY6bB0WDosHZYOS4elw9Jh6bB0WDpmOmY6ZjpmOmY6ZjpmOmY6ZjpmOI5mqIMkyR1lpxp0dsWOHSt49Ezajgr2RJpdG32pjbbURldqoym10ZPaaEltdKQ2GlIb/aiNdtRGN2qjGbXRi9poRW10ojYaURt9qI021EYXaqMJtdGD2mhBbXSgNhpQG/2njfbTRvdpo1m+0SvfaJVvdMo3GuWVPnmlTV7pklea5JUeeaVFXumQVxrklf54pT1e6Y5XmuOV3nilNV7pjFca45W+eKUtXumKV5rilZ54pSVe6YhXGuKVfnilHV7phlea4ZVeeKUVXumEVxrhlT54pQ1e6YJXmuCVHnilBV7pgFca4JX+d6X9Xel+V5rfld53pfVd6XxXGt+Vvnel7V3pelea3pWed6XlXel4VxrelX53pd1d6XZXmt2V9Fda3ZVOd6XRXelzV9rclS53pcldqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTSzq1pFNLOrWkU0s6taRTS3rNFwF67eAADZyJbQMFLGAFG4itYWvYGraGTbEpNsWm2BRbP182eIzCln0Udj8uOvx2PKAGtAAN6AH70N3wG6aAfehu+G1LgEeu57Cug0du57CugwZ45BjWHTGsu7+m4MO6O/iwroNHHuewrkMN8Mh2Dus69ACPPM9hXYd5gg/r7u8r+LCuQwnYI5ucw7oOGrBH3l9X8GFdBwvYI+/vLPiwroMEeOR2Dus6tACPrOewrsMI8Mj9HNb1NbS2AI88zmFdB488Hj9x3X9i8WhzH5kK8AHXfXTVB1z3wQAfypXHP2n5T/YFko6/0B7/Xf2/7/+zz8f/7P4/94B9H9EfPqK/b8k+f+e/eN83wPy/7/u1T/z5r+wwAizAI/f/8/g3f/u3f/nLv//13/7+z//+j3/91/3fx3/433/6p//2n3/6X3/5x7/+/d//9E9//4+//e3Pf/p//vK3//C/9L//11/+7n/++1/+8fj/PnbuX//+Px5/PgL+33/927/u9H/+zL/env/T4qs++7+u22OTIsAcdyM8Hrh7RpgjIzwmQW6HkH2U7QjxGKN6GqI+DyF+bnuIx5hpuYRoX0K05yHafu55hMctDwHauL0NViLCY7zTnm5Dfx5C/RWmYyO61QyhcjuCd4EdEYa2ZxFscUroPj7iER6DZfIswnwewT/Z4gFscEo9xvO/BJDVaSn7U9+xDY+x94zxqOVfQsgihHFiPw2wPpDCgbRnh0GWJ8SI3+IxJF2fnhCyOCsfsxF5Yj8uNU83o61y3GYeiro934y+2ozRcjPksiv27RcZz2M8bsrOEI8bm0uE+3vyqDVxWjxG8p5nmCxOzse0V8lf5TGjcP1ZvqZ62d4/HkXePh6rfXnMPcRJ+pim29rzfamrZNtvYc5ks0v5ta9HtazOsbFljFE4TfsP9qWa5b60tvhdFudp6Xk1eozHX8r4Y7++xBiry1GxPMv0GuPbdiyK6GOQNc/UxwDa8xir7ShN87Joz7ejLs7Tx2hObMdj3GY+jbH+ZfrGWTa+5N23LSmr3J1ZkMv1l/keY3Wm+ou251km83mM1ZlatqiGpZTxWoxW8xLZ7PmZWhdnqrfOHtnf2Yrav2ZMXZwfk3zZLgfjlxCL0/Tx5EoN0u15jNXpMaTHOfbgy8n+PUpbnKidG9E+5fKz2NcQi3q6f4Qk7jsek3bPQiyPR8kLzOMx+/nP0pZX/Z5nx87t+VFdneojd+aBz9NlmbiPKhQnmTymacrTKG116X9M1Of+POrG9qS4t/GHXh7alrfG0va78qf7Mv/QS27rLW/IWl8kv65uTuuIDXlMol9L+9d7ZC3vHtPlVjTJctra9nQrlrdktV8udP3pLdn+SPA0RucGddTrud5vx2g1j0Z7zBE+jzHev6lT+0NvctuWD9TtS+a3H8TgobwtfpUuq7qep+jlJrmMrzdSfXGGWj7WW53PI9TVJS52Y87nEZZHQrc8P63L8yOhqxsgy/Oi1utN9tc86X21HZK/yGOw7aUYreQgx+McL89j2PvneH+7ii6PaM2Ha+lfHsG+7smQ5Y0c1as+PxrLs8O4TZ+lvZZrvhD4GcOeP+WP9m6uDX0310b/Q3PNV3M/zs/Hz/r8SKxGn/yF/fOq9iVPvp6fYzX+JJUbwa2/FGNuPXJtXyTyaQyT93PNyh95PWmSo1CtSH/pHG888LSxGEJajqdtjKddfpRvA1mrYeJSs4Q+7p+eDhPbWN5qbHmrMZ+fGssY1nM7bMrbMeZWXoyx1Ywhz1NlyrtlY5Z3y8YyQs8s2S6H4nuI5aHwr9edh+LLs8G3Q6Fvj70vQ9w7x9chCiEuwxM/CnFrCmDO5QBH58ngxRA5ivYI0V8KoTm6WbQ//UVkW9bPvEt4jGK1l2LozPuuVYz1rtyaVJFteYmP38TaXEyr6PszM+P9qZnN3pybWW/FNhmzvmTaLxNEi+uJWfwkU8rzg7GaZHoMh+Sopuwf6KB6zfbiyfF8qmk11+QLnXiIMZ4ejt9UjVvzXaLvl+FlkOZf1TjuNTabiyDL6zxTyv16w/JtOne9JZJV8DG80BZbMt+9wspqsunmnfl6VxgeEVkc1OV23LtQrzek8+uO68TILxvS3j+m+vYxXYb4xOGwzJjHRMLqcNibub/cjEcBynsf0cWZXpf35zPnzerlMtl/EKLmU1etl/H37yHK6kzPrXg87jwNcfdolMXN+TrIyIEnHWORcVVXT8M5PvFAe3o89AMz9/X9qftliJzP6Je7hp+F6EyZ2SLE6mio5CyCXofyrPzkkDJ6pdfx6u9B2uI8lXkZVdwXfH7pTLUSd7c61Z6fZK0t54gz9y9HZNi3EPr2/M5qK5TnnmaLrViFyMk7tcWOLA+of47tOMeqymup39vIuUx9tX70miMEXfuiJOvbj/eibz/fr0N84ELZafDrfXUvpsvsnzlk8uBLNfxBzg1fZ+K83K7uT3U5IdqVwv780XYdg2cgWzza6rLHJLshank+3PC7GNvbMZrkI2Er22sxKvcfTZ7HWE04XR71H6VgvBTj7pDDze1Yxlgf05q/bdPnYw59fOB4jD96X8ZlQtPejnEtyz87x0o+4ao8Px5jdeVnDFpGW4w8LDdkMIZyfY76ZUPa+z/uKsbdk/3mdrx+gjB8UVfFcDX3JNuk0eU6aPCjH8ZKY3bg+Zlqq669fHRoZXF+LOeeKIbyqK0Z5DFz8oPtqFs+q9vicKwvuZXnj6lP7w2trYOUS5D+SpCbD4a/25l727F6irERR/UxlfZ82sZb856Pf9LFeG25+2V8a/k8lRMe/Ut76U8eybjTtUUrwNvzHfb2XIW9PVVh789UrAZg71bS5SDuzZmK9ycZ3h+aX42I3xua9/vO94fmb78L87SYl9Xs0b3RuQ+8V7R8B8Ty0lbml/Hfbz3+q9mjewN86xC3BvjKaurnZh1fHoy8iStz0c3gz0bvPVoXeXtcfx3i5qP1+wNz74/L9Q8My/X3R+XKMsjdUbm5uqRV7qovm3E7gEjPkawHj+sw1LfXR1ZhbqbrMsS9dF295XQvXVfTTvcGwZdvWt06xZcRbp3iyzfGbp7i67fObp7iq9eK7p7iy1fGSk4IlFKunePtfgxt2b+p+jzG+tUkP32PfSnXN1h+fQFO3s6UZYh7mbJ65ePmhe3+4eiLwrF8h47b4X6dk/z+Dt3tGOP9GNdxkp+8y7f1HJvc+vP338ryDScblzvJxct8qxecuOewJi+G0ChCpuPFEC234jpd9GKIXl87oEUrj0vXRvafBeGy0EVf/GknCTMXv8ty0rrn08r+JstLMR7PsLy+sjjFbr7r+RgiXfy6d99bXcW4+w7uWOStvvvUtNyKQU+9bYsqposnhf2bo3GL/hiUe3YzV5ZvN1XebqrXBTK+HVFd7cy8dMxdZxS/x1hd9+XyBt1jqNOe7k1fPjrluJN9uWj/oK5bPrQ8sD+Nsb7SafZoyJeOyl+vdIur9uT9yO060PDt+X75LrBInmer1xLLarrHctb5SyP3Lwd19aoUY9fbZosYqyGoey/hltVLSjffwl3uy2MoNGdItrY6IKvR/NlzBHzO1W3MfL8AjO39ArB82elmAVjOO90vAKvfpubV7jHHUF47Wb8GmU+DrF/kz+URHs87z+/81zHysD7u7u21GDWbqsuXpR6+xxirO7u8p7LX3uR/zPXmGzrtsic/ifEY7Mz5QLHn760XWz4p56TRA+W1II+JkZZzJJeOsx8GyRWdRp32YpCW03mj1fpiEMvpgXG9af7Rj9Nyxkev3Q0/ijFY4+o6Iv6zGPlEpVZWJ8lyZYKNRXgeD2aL4zpX4yGFWd8H98XZtnoJ6jHnx4y89m17eWtY+OGxNXMRZlUbmylTtzbs1UPMMjYP1lfPmOtbAeO1GJO+vHmZaPzRQiVbnrld5LXt6JJPrl1WWTjfvrtZPnJ2raxVp5cgP1p1pSuDEv2RiS9G6YwF9rGNF6OMwh6N1l+NkvMhD14U7HUUy2nUB4u8ui2Xo2uyOLqrqar79amuXpfa6xOLwF0nFX4c5l6Z+91O3SxzdfnqVDNWlWrLQ/ybMDer5W9+b72ce/3lcy/fjXuwvppN87I4wuzt1SisytTnmK9FGUWyPjxYX43CCkKj2PMTb7Wu0mfWZhrMwthQeTGK5b3Yg2V7Mcq8bMtc3Cqv14kaLIm2GAZZx5isNfXlpfgfxLDGcJs+fwpaD+pMriNlzsXibOXtl1XWIW5NGK5D3Jox/M3CW9RrmZf79e+nx2qEi9Ufpjydl1qHKPlyx3w8ML8yL1VVWIhMFw/r6yh95vGoQxaP/PXtLpZ1iFuTfbW+38Vy/3CUlw8q9xaPKP3FKCNndB6sizrU3p6HXYe499O0P3Ye9uvhWMzD/u6nsUuUxfJ9891Stoxwr71nuWhezUGhB68uMasNudcIsgzxqIbMG4zeXgwyLvczQ+eLQXKC6sHWXznPWiNG0/J8/V9d3kJ/ZEnDMhlK/TJSrq/FuM7H/CSGMiys18z7QYzH9pccbf8yG/stxvtvhy/XNNyy+7RJu/64P1gXUVgz7nEP8TRGXS3kd7MuL0Pcq8v97Qb+5cEoLGNVvqwg9X0zVqvw2WSa/fp6xi9BVu9E3ekRXG8Go2ptXjtbfrQvzBrqVtrLQUoGafZykBxo3F5cv/P2GqD27uVyGeHW5XI5U3+zVXC9lum9VkHv93g+hXqzG3aVtVwrm5XnzdZ1vN1sXe3tZut1iJvN1qujUQqvdvXXevlbzRUd2pf3w74f0dXbUD0nx/tlPKZ8m0+21ctQG8PY5XqGta8nx3LNyXtH9DenRpxfti3ek1/G0Mm6WKO8FmPmCOLjAiEvxXg848dt8tyKPo2xmmu8vXBlebcILiPcKoLLFxhvFsH1Apw3i+D8wCsBqzdLHzdN+epxGc+XnfSXNp8/MTBGPfrTl7vWMVjfolzbhL7FaKs3q26+qLaMcfNFtd/sS94Bla2W59uxeta/9aZt25Zr907hd5mXS9z3F83WW3LrXdvlASm+9t9xQB4l+aWDWoRPW8ilfPxyUO39g7oc+7j3+vJ6O24d0mUZu/WG7DrCrRdk69vXyOXi4y3fIKzXF1x/tID5zLmt9qV37EcLmBOjvLiA+e1F0N8eE+tvj4kt2xNvXt/Wi7nfu7618oGFqMZytYEPrOfOClBfXwr4SQyWPHkM/jxfZb+t+pPvPWy0Mt592FiHuHlrvDyiOQVcdD4/oq0u31u7uWZSXV6pM8Tsz5fZb3X5vZNbSyb9JsatJZOWMW4umfS7GNvbMe4tmbSOcW/JpLZu77q1ikxbt3fdu6W8uR3rGMtjemvJpNbK+8fjZow39uXWkkm3YyyWTPrNOXZryaS2+n7U3SWT1htyb8mktpq1uf3jzvdP9pvb8foJcm/JpKbLNzXuLZm03pB7Sya19VzJrWeO1UtWt585fvMdqhvPHL+74t5aMqnpXAe5s1TRMsi9GZff7syt7VhNHhXjyx/Snz+/tNVz1N0lk5a3/beeB9cR7jwPLucXbm3DOsKtbVjeWWZnwgPn/3lponbUyxcOt9didCaM+6yvxbBsgClz05diPCae8hq3lefHo66y7e6s8zLI45zIZ1sbT1vGliFmDiP1WcZrIXjCnvp0qvb22dFePMMKMerzA9rG26uorEPcmvtuJn9oiJvT58vj2f/L/puf/Sa8cTfmq5Xjsh2vxuBTKA98NUYrd2K0t68o7e0rym86PHMsapbyYpNodrw98GlHVHl7OcLfhLh3LFa/ab56XL4utvaTXui8GX2MMowXY/BRdhuvbgcLMdh4/rns3/S6N7rUr53dP+yYv0ZZvPP0uyiNKOP52wi6yfL6ductd10t6nfzPbDf9P8XlpWZi7dcf3NMJu8izO3ldxGu21JfjsKDi8324psro1QaIx8juq9G6Zd3Tl5+/6VuzO3VUl6N0i5R9NW3aGq9RumvRrkMpVR7+biMS5T56pfj2+XtolZe/aXbdo3y8lnHkgSj1UVtkWXbVc2ezQcvTpjfhaFNudXFe0q67g+++3Lc77YmHyoevHh19ic79UaYHJTcm8kXh7jU/z+OzWSn2tY+sVNvhGn5PSlpq/UKdLlE4KeODUszP7jpR3aqvVo+t43O/2179SXlyUs34zox98NVJbL97oHzxSA979pHL+PFIJqTv0Pnq7szchR42Mtrflx35/UgrBvWx6trfvAZ1zGkvbol2Sb+CKKvbomyDJq2D/w6sigJy89V/WBViuVKKNkrtTxT1gvu0ChQ2/O3VdYLmGbXaCnX11W/LT6qqxc07w0NrUPcGtfRZn9oiJtr9K6OZ+WtmzqeL+aqq/GUWy9FLLeiMbjUvqxv9X0r6vuPh6t1A+8ugrZcHrew9Py1F/hHS+xeP0tgixir5ZdvrtO7DHJvWHod4taw9G9C3BmWXq4DfWuMah3hzhCVvP/ZjreHyVbtu5VVga7fkba7AcqWt1GPgnNJsjZvh7gmyGX9mx+EqHlJa9cvY7Z2N0DL8Y52/Sma3j6QOUKn/bUA+Ryu1xG+HwTItR++NO69FOAyaf6DANezcXspAGtDzfZKgJEzw+O6COBLAa5v0P8gAC+gbC/tAiuS2Gu7YNn3bdcGm5cC6Es/Ix8Pn68dxMkURHvpTOQVntn7mwHGSz+jbMrKp3177Uwo3HoQ4Nub3HbzHcj6WgQjpe3FCPmRrO3pNqyOQj7z2PVectw/l/KX1KdLtupyHb+7y60u90LYjevHecv904G1Red2XVLnWwhdvQPVWNJbv7xk9+1auwyim/Gh4euboL8EWb2fcutLw+vtkJxf0C/dRD/ZmX2ZuzjFR99eDZJ3Qf26HufPgjC11r/MQt+/D5qSI+hTpL9ymn0JcRnJ/x6ir74OJXaZP7q8Sf5t2fffHA7hcNRXfxi73GPP5+d73+z9H2YZ5GbXxnpneFnl2l75s+QtfGm8tOdJ0+XtdSTWIW6NdvTV+9MfCPGBX0UJoV8+XPPLAV2uFMCn4fTL9/q2nwRhofQvr4n8KAjLPku/jFS+HqS/vCV5mdkn8p4HKe+/trfcDhZKlnF9OvxlO1Yvl87J3szrMvbfXy5dhmkjX/tt166WX4Isd8jyi/RyHYD5vkO/qSMsH/1l1fbvp/3qKyXlshi+PLtKLCPcG49ah7g1HvWbEHfGo7blrUwezPnSQA4BvrTg3g5wb7HF7d7DhrwU4NarmNu742nbu8ViNZQ18+bpkZGXz918Wx6gr77L9IjB4hEmiyCrIXimofVLc8jjQfD2ljyeuPKRQy4v5v+6JXU1ImL5HLtd2pr25WN/ECQvbXb9wMuvQVYf1S3ZiqflcmB/PSarIDXf53ygvhrk7q+z+tbMJhyTSy/Sr8dkruYUc8m4cV0y9pcguhx+zeWaLg8dZfseYtWCK7wA8BhTfjEIvauPecHyYpCRM5tlXJ47vgdZHY8tRwGrXF4J/yVvlt8or3yx4sGXi/2vYVYfadI6/qtZn1p/tC2VJrza5qIUrN5XuV0K1kFuloJVkNu50+UDubNcT+9e7ixfiLqbO8sgd3NnGeRm7qyD1HxP/bFN8uru8DJQ3V4tBXe3ZF2Ubm7J+oKRTY16/ZzfD686rO/XtufXv21ZCPIppl4uofZtM0Z9d65tGeLebNs6xK35tnWIWzNud0Ms5tyWIe7Nuq1D3Jp3W4a4N/N2N8Ri2mgd4tbs2zLEvfm3dYhbM3B3Q+iLP+q9Wbh1iFvzcOsQt2bi7oYYL/6oH5iNE5Zeknbplfhe+ebqWi85GVblesPQv91Eraaj6pbLp9Tt+jrE9v3159XQ6cgH1X31gEWQ5ZaUfM9VLqP8vwbpH7idm+MDT3bLIHef7NZBbj7Zzf7+3enYPnB3Ora3707H9oG703WQm3en6yB3706XOVxZ8ade3lH5NYeX8yflv/w68/cgY/vA09RvgtxLv2WQ2+erfOJ8lffPV/nE+SqfOF/lDz9fW96x13Ypjb+caqsZgyr5ImyVy3sb8n1lueWqpywtN6537eNbjJvr/dXXItxpaPlNhBsNLb/5SYTFqS4Nj7/8JKuWYN2ETo7r56r7/RhtMnW5XSe2v8dYrZPDI0zr16mHl2PUZzF+cFD74qAu12HceEHp+tL4951ZrgrVWNFpPj8gy8V2tsnHfGSr/SNRnv7Ay9vezW7c9q7r2M1hlN9U1HvDKOs7gLtbsn1iaGl9n3hzQGcd5O0Bnbt3ztsfuxU375qXO5Lrub02aK+Tj8rqKwGEx6HHQ+ZrIYS+iesT1Y9C5DSqiL22FXUyyDdf2wotfKH0cnX6UYjOt1JtvrYjfN6xltd2pLJSRdWXduQDE0rSaUG5vg35kxBj8Fr8LC+FmBzO6wdzfhBi5EI7168L/yDAzFa8qS8dh7n9V8NiPwmQ+TWHvrkLrwVofHrkMnRT5vfPdSxHongoKE9DrLYhvwPZLsuD/LoN7QMPfF3ffuBbLWZ++4FvGeTu7ckyyPuVQitvdNXL7fhP5njyU3Tl8oDzy3rVqwWr7628PcbiDL238vY6xL2Vt5d3v/Pyve6ny+aOoatjkZ+T+dLYqT8IoXzVpi9CLG4VHyd2ttvLZc2Eb712Y/XxE8tb1illsRmrLz9WPlvSLms0fl+a9e5vMp7+JssT/PrVx+vi8t9+VluuQH7n/YX11TRv1L5Mr2w/2JFx6Sktix3Rt3PV+tu5av2PzNUivDN+/cD5rwdj/f14RgAeM6vPvxG0DlKvH6F/ttL+mMs1CSvTPNeXWr/vzlwuP55vT/XtcgNs436MTr716/vrP4mhU3k/pi9irK70vAlWr0uSzR9sxyh5bdvXBnm+Hct28MvyM9fvNdbvP8xqjfvtv2zX/SXE/GOPx+V3GSZPj4et5pm0t3wbzC6fc5jfY5T3pzJWN6SM7LYh5ZVy2roQojy/Ltj2djn1m4L3yuk6xM2PjvymjF0+BvP868i2faAWLoPce0tnXU51Y/GL633Y999Wll/YYfm/66cBv5+m6yDcRpWtrIK09xPmN0Huzf0tg9yd+7PV/NLdR0FbTTDdexS01dzO3UfBdZCbc3/rIDcfBZcnfWU4sX79ZvT3754tx8zzPczS6uJ8LR84X5cXTdt4DKpPL5q2+iTU/Z0Zn9gZWbYA5OW7WFn8NsvzlcWvr+s9/7I7dfujfxsW3bwuyffLj7P8qNPtvamf2Jvlq4e03o+x2p3VDeu28XabrYJ84oStHzhh17vDuNCXT139ujufOGHbR07Ye7e+ttlrjzXdJ5OPx5px+dDDq49Gw9rTW/D2kZdLl2Huvlw6ll/ZrZ3vxNTri3i/bssqA4V5ZynXb/j0n2xLzR9I6qMcL3Zp+eSZsxaP4St5/qS1isF3ntq+vuGzp6TVmwS379e0vD/huw5ys1XyN0HuTfouj8nt28/VO1K3bz91vH37qfaB289lkLu3n8sgt28/V0/1Wi9L0j4dfbK+/uhcTlRdxvS+fTp89SaQXpa8GdfPAhX79gS6faaSzA9Ukvl+JenjA5Vk9dHa25VkGeRuJVkHuVlJVsfkdiVZTTndriSrtxVuVpLRPlBJlkHuVpJlkNuVxJZjjPH7Xte9+X7nOZafm85Jn1asPS8D68dHbl9rH68+Pt5MvvKJs9U+cbba+2erfeJstU+crfZHn618gmWqPj9bbTk/MPKMl2ub8fezdfU8rSIE0b4I8oGVF5ZBbp+t8xNn63z/bJ2fOFvnJ87W+YGzdflc/2XNEl2Mq61O+bblhFbbrsPrv5xqn6iu9RPVtX6gus7tA+fr3N4+X/0nfPd8XQe5eb6ug3zifK2MDDzGxp6PQ83lanzXoY7rDOwv5+v8QH1dD2bdPF+XC/XcPV/lE+ervH++yifOV/nE+SqfOF+X8+MlO0q0XM6S+ZM59pZz/Xptp/4WYy6/ISUbveXX75hsP9kQzUFg7ZeVyr5vyGrh/P96sfZvL5TMUn4a4fty77/pOLiZdsuPB95Nu9XLT7fTbvVgcjPtVk8Ut9NuGeRu2i2D3Ey7dZCbr/r8ZnfudfWuq8jdLVnXs5tbsn1iS7YPbMn6zvXmlvzmHvrmltgntsQ+sSXjE1syPrEl6/G0ey+n/SbIvdfC1uPQd4/JekT85jFZz1bcPCbrIDePyepTU9L5il6/rC73fWpseSGvlgMMdW7PF5lcB5m5UmWd+ny5y7mawfnIfUmddP9tsi22pL57Y7L6XNTdG5PV1923fHOuia72pL8/Q/6bIPdukZZBbt8i6QcWqZz97UUqZ//AIpXrIHdvkfoHFqm832Jen7eYz/7+Uv+/aTG7O6z+iW7G8oFuxtk/cbqO90/X8YnTdXzidB0fOF2XzW73h7M/MdxSPzHcMsYnzhJ7/yyZnzhL5ifOkj+857XkyF6ti9eqlkHaVrmd0OfNmXP1UPCRIPfWt1+HuLW+/W9C3Fnffv3j3n32XJ9mN5+Ch3xiSz6wquv6Kn53S/oHtmTdbn73OUs+8OssP6PIu0SXOfpx+0Nbsg3Wv9iu72f1H4TgS/CbXerqD0KwgOeDL7fxPwgx85uvD+7yUgjj0eralv2TEDnyvIfQF0I8/tllFaLybCsef629vy/rKPdeJNqWV5cbHz5aBbj1zaLHXtgfG+PtIyFF81ct19cg7f6b3IWu5XJ9ffnVEP2lEJX3sOtmr4XoLJhzfTXlByE03z0Uba8di8qL8dd3618O8dqPel0nt8prIVjtpvX+Ygh25MtnzH8QIu+tpdlrP2rLde0eQznbi+cFqx2Ul37UNpjqfulgcmpqeX4c9tK+GmvIVYuL2fW0uL0VeQt6nQH9yW7kiOeXdQp/EECZ+2wvBchROZ31tQC5aP1s7wX4smT9Tw4iixu+VCt7LhzU63xzC177GUW4vSvb8/HzuyFEXglRZk4F1O16KMvtjKhbVuv6ZcWLbyFkWzag5IpcZFW7vVhQGTmeUsairXYVorFwR78Mm0/9vherpUxF6Iq/DMno/MG171Lw5fKrzvtf/y45MDTKZfBBt++7sn6DqrEdl0OqvxyQ9ccg46BeHsWq/HJq2PtDVLKtPjF1b4zqWKL/3UfLR5TlVNO9tRF/sy03h6keUVafJLi5Ht8jyuKB5t5yeOsYd9et/M3+3Fwc8DfnfmPFWr1+nfaXc3814dtHvnk7ymXJifn95F9NOn1dPPK6KfOlcnBdqur7IenLlivGRL68/fBtOx5RVu9WsxTwY6jncv9V9AdRKst6Vh32apSed6R1fGm+/CXK6mtGt5bQecRYtU3dW0PnEWQs6/XNN14fcWw5UHLrldffbc3dN9V+c2juvWb2+H994O3MR5QPNKY+otT3L0Of6K55RNFPXIaWUW4ubvuIMt6/gKxi3L+A3NySoa/+PrcvzSafuDSvXq66e2Rvxlgek1WM+7/O8pjcvrwva/at9/geW7I4T+6+yLfekntryTy2ZDlpcm9tjsfY9Qcmkx9RPvD1FNlmeb9GzvqJHFz1dt7PwdWqC3dzcBXjfv4s9+cj+XPvzULZVu+P33218Df5c2+9n8c9zbJB5d5qMPu00QcSSFYvWt1OINna2wkkqxUEbyeQrFYAvJ1A/mmfNxNoGeN2Aq33534CrQrcaDx62OIxSFafqpqDlZDtMq7//YlMZL3aVZ5xD748Tf36YLdcftMyncdlllh+3Zi2HC3Kh4Z+/RJQ+f4byQdeJX1EWfzSd98lXW/L3dW3HlHsA5d4WTVG3K9QZftEhVq/fXWvQpXyiQpVPjECJuX9EbBljPsVqnxiBGx93t58vfWxLR94v/V323JvybfjszXvX+XrJ4YSpH5iKEHq+0MJUj/xqCqrl6Hv59Dqxfu7ObSKcT+HlvtzP4dW+cxa0PLlc9S/XM1WE2Ot5r1Ce8wNPR0BkybL4bg7H0z/TZB73x5+BFmdtDc/PvyIsrrBvfn14UeUVWGp+Qxf62Vh2h9GaYPR6M1ejaKWRa5fxvl/GOXmB5V/d3TvfVH5UbU/MaIg+okRBdH3RxREP/DBvUeU9oFR13WUu6Ouoh8ouPqRgntzS4a++vvwSdTSr4uP/hKlb584sqvHobtH9maM14/J7ct7/8QomHT9wDH5xCjYen9uX96XV7KbX89+bMtHHsrGRx7KxgceylazZPer5GqW7H6VHB95QBwfubkdH6i14yO1dugffvbf/KC3+P3e4jHzzhe9RdaTQvmGk8z29HPa6yCPvc+rx1bqIshqkdc8U3Reuwp/tB2NjqlrQ/sv26F/7HZINpMX+fISzM+CyAeCZMPrG0GuZakszpG5vDegEtRLS8PPgvDNyscD1UeC6KtBCt3prb0chC9z6/zA7rweZLA7Zu8HuT7M/SzItVv++hbFL0Hm2zm83o7O2xyLzCnLtbbubcf6WpHH43GtKM+vFWU1NaZbXs11u/be9x8EaTNfONJN5yLIorw+TtF4ym5fur9fD1KfX/ruH9m+OrKrlq/G1wbb5YsLv+7P4nztY+MLEmV7MYive3wEsWvj5Y+CzDztx/WzYz8KMko2iYwvb4X9LEjeUT+C1NeCPB4LWEVlLs57WT440Xm5z0D3z4SZL+5SzVkxu375+ddtsc/skn1il34zOErb5HpwdPnpv2zhbN2eLtL4mBVbdVrdXMlISlm+yXDny9qPGB/4tPYjytvf1n7E+MB3saWU8YGn0vW23H0qLatlSG4/lZb69nfs1zFuP5Wu9+f+U+nyJcNclKxde7p/SaC6nIcV3vzc5DK98L2ZoSwnkTaG9PfmibII099PxDo+kYjV3k/E5Ze3Sh7aR6qtTv4fHNrLbO7PfiHh0zAPtvJqmH5pme9Fn4dZvjuWw4mtyeKHXs7cCIMyZRXjA5W/9U+ccG28f8I1+0S1bR+ptvqBaqsfqbbtE9X2Jyd+fd479puizXdzrvfrvxRt1Q+Moxf9yHmrHzhv9SPnrX7kvO0fOG/7R85b/chdwnIV45ZtSUVred6YUVazSI9Z+nyHvKxuElYTWvfbL3+zLbl6Wq+XVw1/DbK6vb0seKHXPqv2o07QuWU2X79OLb9uy+oZPt/w6231Ay3XLrz57lj5yLtj5SPvjpUPvDtW1u+O3b0BW64tmb2xtv551muyRlXpi5NtuR2Wh/W6Kt1/sR2rFaIt81htlcfr5Qtv5vFyOQdlMaNHjMvN1+1X/1vd6Ba7fhnhfgQbUe0fo+j2LIKU1URYaVy9HhOFGaTfXphCSy7qrF9env5lM1YfNZBsExvXqaNfflpbjh00MqaXZ/tyrAH1NHW3XKqjSrdFkNVQlY5cTuHBY1vUkeUbY5KjrOU661p+qYxzvehVbky5TA38MErteYfSLktm/xrF1o+Vhaq22qP16ZL3BY+R20UlWL1iVbNZ+cu6U/X+CkMzt6JfFxHfz/z/6/G//vIvf/3HP//t3/7lL//+13/7+//e/6HU/aK8PxdKS1Knx95K9wfmR0wZSZY0g8rml/bHlhVJKk6PX6jUpJbkjv2+pLhjL5BlJFmSO/YjX7ckSXLHft7XmtSS3LF/Jb32pJG0O3y8s06nh61tSeJ3go8tbSWpOj3+bWtJmrQ7PDvaSHLHPnbV3LEPkag79q+oqiSVpJrUkvQYY3hQTxpJljSD+pYkSSWpJrWkdPR09HT0dPR0DHfsN4VDktyxn8WjJrljf793uGN/2We4Y68Bwx17fg537PeiYwbZ5lfkx29kklScHvGsJjWnRzzbHUX2v9eTRpIlTaeHY25JklSS3LFfkWZLOhyPbZ7u2O8350iy+N3mDHqcZr6BY0cBXbO/6/KYPNix+t91UfP/qmAH3XXENdD3aL/Ne5zBjnsqi9u6/9cCVrCBbtuXVBBP/BPdtr9cJZ76ZX8FXjz3y96fI578J7ptb6YQT/8TK+i2/QVe8QpwYgfd5r3q/89f/vHXv/z3v/3rXqf2SvYff/+XKFuP//nv/+//iv/Pf//HX//2t7/+z3/+X//4t3/51//xH//4173EeXXbzv/z32w87kwed2j9/3o4Hv/7MZVrf378Ktv+H+r+F+ZjRsNmrftf2P9Fs0cBbKbb/h/E/8ajWj3+T98LqUTg9kjz1sYZZR//aqVkjMcZ2UQiwmNu8899tP3fF6+9+995lKLHebD/t5r/7TExUub+nxr/afy5+t9S/pP+uW77f+r5nx7nZPH4Y/9P+xYV+3O13J725+ZxLf7fdd/e+H+r/Fkfe7dfKv4/",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "join_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "slash_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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p9cTp9cTp06cOnHqxKkTp9cTp9cTp9cTp7vzdHeeZRe8xzK9xzK9nji9nji9njh14tKJSycunbi8nri8nri8nrjcnZe783rRheU9luU9luX1xOX1xOX1xKUTl05cOnHpxOX1xOX1xOX1xOXuvNydV6cLy3ssy3ssy+uJy+uJy+uJSycunbh04tKJy+uJy+uJy+uJyzlxOSeusAveY1neY1leT1xeT1xeT1w6cenEpROXTlxeT1zOics5cTknLufENeyC91iW91iW1xOX1xOX1xOXTlw6cenEpROX1xOXc+JyTlzOics5cU274O68vMey3J2Xu/Nyd146cenEpROXTlxeT1zOics5cTknLufEte2C91iW91iW1xOX1xOX1xOXTlw6cenEpROX1xOXc+JyTlzOics5cZVd8B7L9h7L9nri9nri9nri1olbJ26duHXi9nridk7czonbOXE7J+5GF7b3WLb3WLbXE7fXE7fXE7dO3Dpx68StE7fXE7dz4nZO3M6J2zlxd7qwvceyvcey3Z23u/N2d946cevErRO3Ttzuzts5cTsnbufE7Zy43Z23u/N2d97uztvdebs7b524deLWiVsnbnfn7Zy4nRO3c+J2Ttzuztvdebs7b3fn7e683Z23Ttw6cevErRO3u/N2TtzOids5cTsnbnfn7e683Z23u/N2d97uzlsnbp24deLWidvdeTsnbufE7Zy4nRO3u/N2d97uztvdebs7b3fnrRO3Ttw6cevE7e68nRPLObGcE8s5sdydy9253J3L3bncncvduXRi6cTSiaUTy925nBPLObGcE8s5sdydy9253J3L3bncncvduXRi6cTSiaUTy925nBPLObGcE8s5sdydy9253J3L3bncncvduXRi6cTSiaUTy925nBPLObGcE8s5sdydy9253J3L3bncncvduXRiOSeWc2I5J5a7c+nE0omlE8s5sZwTSyeWTqzJ/YX6OPETDsH5DnRxz7H08/17455j6e1+gOvEbzgE7X6A68RvOAT9frTrxG+YhkNwfkJu3HMsTzgE5ycUxj3H8oRmOARxQa8Tv+EQxMW5TszP70zDMhyCvOW9TvyE68RvOATn+x7HPcfyhEMw7id3nfgNh2BcnOvE88034p5jecI2HIJz8Dc/51i+4RCcn8GXn3Ms3xCGQzDXDcNwCM7hpvycY/mGbTgE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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "storage_read",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5752904658887916296": {
            "error_kind": "string",
            "string": "Game has already started"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "7428360812483913122": {
            "error_kind": "string",
            "string": "Game has not ended yet"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZ3ZriU5Ea7fpa+58BCeeBWEUAMNaqnVoKY50hHi3U/GH5OrOMuVO9fum8pvR9mRntIOh4f1n+/++sOf//33P/3489/+8a/vfv+H/3z3519+/OmnH//+p5/+8Zfvf/3xHz9f0v98l/if2vt3v8+/+66OJs95iQs/mzyX/r3s74UnJdKn/p317zzlWao+hzxrkWe79BA/lzw76VP/Hvr30L/nFb9dz5X12fFsKemT9LnkmS/943qWpE/S55QnpwPPIU/Sv6nLs13xJj+bPpc8e9XnlOfQv8eQ58wSf6qepe9f+v4l7++p6lP/zkWfHXp6yfps+pT390r61L+p6vN6f7+ereizy7MnfZI8h/7N9czPqX9P/f855bmqPkXvSFmfEm9k/TvLe0bRv4v+P6eXn5X0KXoHFX1qPE3vaPqern93/f8h5TdG0+eS56z6lPobq+hT/p4p6/OKt65nrvq8/j+nC0ox0BjaImaVmpuU9En6lDfPpn83qbnJKc7XJzM5qQJXiFwZpgKnVmApLJMsDbMSGZgkVwOTINHEMBRqNmgGS4GbhoBJmkk47YBuks4Krw9njWLQFbiJCJDBVFgmWSrJiRu2ksu4cecOGkbFZaUb1eRETtOIPAZ5jJadXMZNPg9QMxouQ+UITaNZnLrR8hjLY3CnB8qJnFjLZEJ1CbkMuRTqRsilEDl5DPIY/EkLNZdxLktl4rwJjasMCoGWEX8WQvxhFMTlOqoco3AdKQ2j7LLs4YrLiofjBqfUnJYReQzyGJx6pW7EdaTkWrprGa5leFqma5muZXlaeFiqnN/KA4ISOU0jbolK3ah4jOIxuPsSqi7jOqrcnityKTSMuCUqNadl1D1Gdy3DZcO18PBRF2gYcQ0qXXGJ00Jcb0Jcb8RxibtgpWXEqSeOS9ydNcSg5rSMmsu6h+sh83CcZqVhxGlW8hjTY/DXozSVWipOpqXl7GRaMHgrkZNrqdWJtXB+MYwrdSMeypXIaRp1j9E9Bn9RSi7jXrB1UHNaRtydKw2lzkOQksXoOTmFzLR0/t56Ai0jDKAgrsFeQM1pGXHelFyGXg+wFKaYZxnjPGCJgXb1IgmW1gVksBSKSYpJqklQ4ICu0LJBM1gKnRTUCslDzZCMcR0wq8FQWCZZYkPkmaqBhpnceniEvKgZcetR6kbVZdXDkccllzUP10LGSeTkTxhTE8Qy/r4w6AtxT6XEpgUX7oR5Ai0wUJhWKk4s4+JcMAOFuhFMWCFymkbVZdwLC5HLyMNxLzwaaBjxFy4EM6uDmtMygrElNIy471VSWcHYr+Qy5EjIZSU7NadlVF0Lf9ezMMHMJdA0YmtmLpBMPkrq1WAqsDnThYYRd1hK3WiZLHO1ZAa0KQZOWsb/YcAWmkYws4Rc1uytudlbr+/cyd6KoVto2luXvrUke2vJ5GRvwNCs5LJqby3V3looO9lbS3NZ17eWYW9daoVepEZnqak6LaPssuzhCjm5rHq46jLuM1YCdSNOk9KV9oVwnLpFoGE0XMb1uRoTl51SN2LzTYmcphJmrUrLKLssezg23xY3RQyfl0kL5B4hcWkRugnFkMIATQXYApcjj6KGw5GbpWFEW6FsbVJX1lINdGUYTi8rFdgdiytrxZW1GtIaUgop53gNJh5llLg6E5cS5sSGIR0hlUwC0c4VQ7pCurohBlDD5phT4CZdjvg00gBOx1oChyOFFJMjBvsoMDcmABkshWWSpZKRVDKyjIgFU2NAyQbNYClUUtDZ5gXNYCm0ajAUejEwycgGXCScegykShZqWbwlc9wyUzIgA33tzCbJU4G/hgkYCjUbNAVKBi5ZCs26gskZEUJZC1n3MIfLhoebHne6bHm4ZbIFN0UDdRmjr0lClvG4YEwVKuTEDYcdAQVDaUaRySRakEKKiTT62tUocDqKL0CwO4pjQDCk+NwVQ7oiLLpiyRY+d8aKkVUR02qevVeZVwuWkMLuEcQ3rkiB05EiGoW0hbTFK3pIe7xixCtGvGKEMnz7PEe/cDhiwFNsgcswo4NT9GgyOit2xxLS0gJDWQ1l6AZ4Wl1l0q0YUjgXFFvgckTHpxjRRigbIZ2hbIayGcrgEcpXm6wFeSsZ2B3ReStS4HREF6cY0SiiYeQSbCFtoayFsh7KUMfsTahiJyi2wOWID1VxOK6ItlxZTTmwBboyMTIUoYxLp6J/rwk4HZF5xe4otr1gSMW6F6TAUNZDWY9oaODsb6jiJq9IGdxjiiHFd1y5nVFyvZRL4HAsIS0hjaSLxSEYSReLQ7CHVJyPA7gcZ0il2xSEF5GjYUpu6DUkVoRiSEtIS0jFEynIUnZAXMULaQd2R+RCMaQodcXhOEI6IixKnQYQnk/+huBtz+zvuJCljTPUUwokxxxS5E0QeVMMaY2w6D1bBnL5Nl4N6RgkWgVCyuWAObnhdOwhRYtSbI4zpDPCitOVCxVz9swugwsh5XIY4nmdwOmIJqcYUnQgisuxhrRGWHSObQHhvuVygOP+mtMAIeVygGVi2B1HSDEcCKKrUAzpirDoKjoXKtz5l7cDCCmXw0QVKjbHEtIS0hpScS4LTkfM4xSHo2RTEK0PycH3ptgCuSTZqqiyBKA4HWdIZ4RdIV0eFt4Bw+4oORakwIiGzlFxOOLbVAxlFMoolJGnTNYLFENZj5Shjge3BzFyFJvjMikl9CUjA7sjKkuRAqcj+nXFiEahjELaQhk+PcLKpCx2AKWHEUQ0XlrUxQHB5jhDOkO6QirrAoLTUKwVxeGIr1DRXyzWiiJewSubsj6gSIHTER+kYndsEa1FNFgrgj2kPDfrWKbl1ik0i9MwWibDkgEXbMlFgWR2dAEZ6FotLAoBk9jybhkyO7qgK8xs0AyWwpLZEcGp3wHNYCnkajAUiknKVKgmqRbGfH4XNSPz+V3UjbrLuocbHne4bHq4GTIU/WSUprKAy5ASBbJ08ncCP4ThdJSFJMHuKEtJgiFF5hRD2iIs2sfMwOWIMVcQHTZ72UgcFJNrgWC/K4YUHfbswGHY0GErtsDlKKtlgiFFH6AY0hphYbTPwSgrZUDJmyDexqXeUHmKFDgdJZuC3XFGtBnSFdLlrxDTQpEC/RVY1zd0ZR29Hju5SKwM9miRmBaCyJsi55h9LoTF/cJOqAt5gY+9MwR/hWFIR0g5b4r8sRmGdIUU+zuAg/NmSIHLMYcU2z0ESwn05IyaA/3F8HoUdk0R/B6Gy7FRYEix9snOHsJKgiEFTsdZArvjimjLpTOlQH8FrAxDCvRXzFICQ1lFtAlkZegUsNhQeDp8YXfk9mtIgdMRdawY0UZIR0hnvGKGdMUrVrxi+StgcBgiGjc5OE8KT1AJ3hPFElLkuHCbhJVh2AKXI5tYhsOxRbQW0fjjNdykoWyEshHKzLdPy3z7BCNESRfOWkrJSN38TUwRBh5qCXuKisFQaCZpJukmGbYTadhWpKF7kRJbugLDdikVAxmjWtY1rZZ1Tatl3WJzQVMoJildoZqkWpiqLvomCxNC06iRk8u6h+sed7hseLjpMuwuYN9Ak+0Fit2w4ENSpMDpmEtgSEtIi78Cbg3DeAXFKyheQaEMnWXpQEgXI1aIeKZ84XTE1yNoDagVa0DXSJScrAFVb0DVGlC1BlStAVVrQNUaULUGVK0BVWtA1RpQtQZUrQFVa0DVGlC1BlStAZE1ILIGRNaAyBoQWQMia0BkDYisAZE3IPIGRN6AyBsQeQMib0DkDYi8AZE3IPIGBPOBJ1UN1gO7aRuMB55VNPgihLjrVcJ2Fy5dLGIYUuB0RINR7I4U0SikLaQtXtFD2uMVPV4x4hUjlGHTJDt9GiyHUrGTEKOrYgtchtgLaDgccw4MaQlp8Vf0GtLaAuMVFK+gUIael7eWtC4bi4CSeUEKnI6SecGINkOK/kFwhXR5WDEtFClQ5yJt5Oo0jEpxchkmRQwwkhhgpuP/MKsTIqdlNF02/a3L37rsDTMVJ5dxj8Wej2sxqzq5rLqsuoxcRi5rLmsu6y7rLhsuGy6bLpsuw5ckNJQwpiu5LLsMyyEg/qSUmtMywhYUIXvb8hxhJBdqrrm5Zqx6C7nm4W8brnn42zxvy/O2PG/L8nZZ3tmpG+Xk1JyWUSGnaWS11bHZQIiKk2tu/rbmmru/rbvm7m8brnn426Zrnv625ZqXvS2n5NScTHPO5GSas7XEi0xzrsXJNVN2cs3N3wbjk4CwOAVhYyu2wOU4I9oMKXYWAQsMSkF0a4ohLSHFyC9YQ0N1vTLcK4Y0ko7NhYYtMMKOCIv+iT1CFw7DmkogElkZJemCLXA5YrO74nCsEa1GNAxHiiGVXDBigYDYddZlZ58i75tnF9fVpVdHyoGdkZNOLQeGlEuHBl4Br4zichwhHSGdIeXvUpGLj9iD1bET37A5Ynui4nQsEQ0jNAGlYgV5tOEVhN5aDQwprH9eCrhwOmIMUuyOmPooNkNM3Q0pEMp4J36X5smb6zvsDEFM4CSAfCJA+UQEQ8OshrKFjp1BffBnSbytqWP8uswiRtSbINxnilwBExq4KRPvd+oY2gwpcDryiw1DispS5LexA6LDtW7YHHNIc4QtIS0RFrsCBdEmFYcjRTSKaNztGFLgdOyhrIeyEcpGpGyGshnKZqRsQRk3riU5FkRyuEXBtW5IgdMRjVaxO9aIViNaXY4UUoIybmdwrRsOx54DW+ByHBFthLIZ0hnKcFSGvUUdo2bjzUmX5dVUOpL0MJMRtclt8lpFytr6LlyOmMAIYgrDbXIkr6yRvLIuHI4jpCPCzpDOCLtyYAu0KhyYIht6NLjWDbtjSYEtMJTVUFY9ZXCtG4aylgOtwYzcUyAFTsdRArvjjGgzos3luEK6rI5HSTVwOOYc2AKXY4loJZTVkNZQRtZgBnbvS4MpzRsMPPSVXUQDPnpFTq+hS2X3vWJIccpAMaQlwvLnZOhvg7u+8lmSgcFSsaXAkPaQ9k26HEdIZ4TFqQLBFW/jD0eQ2CZQrMAORDT+GIjIEUceFIdjz4FIA396JC9ejCsFUuA0bJIGYE6BEQAnNtgTNuA/V0QiBVGSisMR6VUMKdLLzpQLlyOPOIo4k6E4HFdEw7EMRdeAMbYW7mw62oPicCw5sAUuxxrRaiijkFIoa6GshTIczeDzM9c6dXMcJXA4zho4HVc3xHRWKmAkCvRqgadcUXLBrXpILrhFDakWweXYKBAv5iY3cJZEcTiOHNgCl+OMaDOUrZAuVwabwLAFurKZa2BEKxENB4aKnNRrjmLpLuByhIXHuysuD30OXI6w13nPxcDmekO2z3j7xRDntmJXm2ssuE0E63SkCCDWtuBSvPLO/STP9CdmjMQ7ECamjIroPRVDSiGlkGKwVOQxgPcwzIRxXrEFLkeYdYohxbgJhE+48iLKxFBnSIHTEd2V4nCkkHKRKKJPTRUIDQ2HJpdJ4dpVRHULijIgmqfgiACbhkmBeEVnxOcElKFDEMOBooetFGHxxSac20RnrjgNsZyqWDwsVQ+LqZFkE/MhRdELXF4O2BqlmD0s9i0V3vwzcYZIEcfyFIfjDOmMsCs0LJdi/7NhSLEcxZt/JvY/lyaHUFNgSLEGxbt4pvgFFZcj/IKKwxF+QcWQSjYFQzoiLJwDvFFoYguT4XSERwBfFvYtFXwX2LdkOBwx2VZsgcuxhLRG2BpSzLAVN2loaPHiFi/uoQzeA/ZOT3SvhafgF3ZH1CafVZnYZF14MX8OOXJZgCzlhfQJT6JhSHNIMd8UhDtEMaQ1pMimILKpSIHLsYUUE2hBLIQoIjnclGVFUTGkM6RotILwayu6FJMrw+aIRqtIgcuxhBSefEF48nnh/8LhiCm4YkhbSFtIe0jxbQqOkKLRKi5HzNwVQ9mK5HiOV/IcL3giFXNIc3MsKTCkNaSVApcjPlPF6dhC2oaj53glz/HC6qQhBU7HGdIZ0lUDXZpTCfRX5JwCKXA5lhoYymqE9YpdGJIUW7ytRbQe0shmHqHBK3ZhymUYYSNvOfIm65WCkSFxVfLejVWkCgVbIGeTDzCtAltDEPWmGAGw1iKIylIcjiOi4StchRFfoWJ3xFeo6FJMuQq7OBamXIUneAtbpMri9Fb0MIrdEQ1RsTlSSFEXiqGsh7SHdIR0hHTGi2e8eMUrsDsBiO3Shbe+XNgdJemCsIISLjtIgRS4HCmkDSZKZsQcR3E5Yo4jyCkjXqtcmJMZTkOZk6HUcf5KkT9/wxa4HDFTU4xoNZTVkFIow/QXFdswURDEREGRrZWFlMESUxyOMMoUQ4qpnGJIV4TFVE5xGcJzaogXczuTWZ3icIS5qBhSybFgSCnCwmPYubpxRMuQ3Ra8NLy6WNCCSBlQ8gbkJkeoeWx6UlwulRPPQ3A6ipOaG8GAk09xOsLiZ6f6hdOxhRSJZEf5glVh2B1HSEdIZ0hnC4QvnusYVoUgrArFnAJboEeb0sA5ZXNQ4HScJbA7ohEounSlFGgG/cLiIqzitWp1aYsAmJsKirILr+UuNBPl0oJdCfMMlvlGB7e08QyeFLwifE4RHhtpMA+4uFIwleA+g8cWfkZ4DBXIN/MMLj24leC+he8RXm6lwJUWCV20c9t4BaN8jEcwbXFp09k2edt0tk1n33Si36gTLLdyLOEZLDdzKPdguZ1DOeSE8jemjUMnen7nLa7c1VGEOf2EdErvb7zJCXKULTasmJ6+6Zc8Co9NPjb5lhccw1VuW16w6mWcN7ncKtKFV3Dd5GhvxvxekrhoM8ZRj+KaM97kY5OPTY57RZoyy3FxRpIOHhdcJMw8lbE45rzJUS/GI7hs8rKFR73gcouEGWhtcjEP6qVNYciRx45v2ZiC+yZHfpWRX+NNPrfw+E5xhUbCAd7Ka90Xw8WKizISjvHWjvIRF57xDM6bHO3QuAXXTV638Oi7Osocw0bFRRIJ40btKB8MHLXL1URoq8poq8abHH248Qqem3xu4dEH4tqKJL4+XFKRMITUkYRZPlA+mJo69+CyyeFlUkZfZLzJaQuPvghXYqSJvggXYCScram4qCLBB+jcNl7ByLvxJoeT0xh5QTljc4xzd5ZRzLgF502OejdGvlBfWAQ0Rr0PuSRK8q5XR+G9U7gHS96VN3nf5H2Tj7QxbbyCJe/KMxh5b0W4G2fMW50571MYeTem4LLJyxa+bvK6hUc5KKMcjHtw2+K2LS7GI2WMR8YjeGw6x6Zzbjrnls656VybzhXpxMy28jIncw+GOa9cNjn6avaiZLmly7kHo+8ypo1n8Njijk3n3ORz04mVInaDM9PG07lIXoZwD5a8KG/yssnLJpf6VaaNVzD6NOMZ3LY0YGVJGe186sVoPRjt3Jg2nsFSJspb3LXFxRg99bq1kIs/mbdAMLdg2uSYKPLsm3kFo382HsHIi3HbeIs7trjIi/Lc5HLPF1i81isLz2D0vcac94V2i228zm3jFUx14xHctrht09k3ed90dpt3ZrkPzHkG+3SSeQT7hJK5OeO4kHMPzps8b+HzCi514xnsM8ucm08tL/a5JXMLbptcykG4b/K+hZdyQHuWRVHjGSzloDyC1yZHnywsdteawm3jFSyza+UZXDa5TLCFpW0s4RWM6WtKwjO4bXLMSgvam0yjjSFHe5CJtF5FiFUyZSyT6cWEmDUr0ybHewvqSybOpQtDjjLBeqfzJsfeErnaUPY+FeRLJr/K2AZSk3ALrpu8Qo58wZl+Le8LQ468yF4l402OPSC4HjDDViFc45dxFyjVLtyC5yafm3xt8hXphH1iLPUyhEcwDhAYox6Rd9krZLzJZ9l4BK9Nvlx+LfiVjTc5yta4BWMDkfEWHvXIN61kuYKL+FKVLJdwmRzlwPuymVknrl4rmLM7b3JsLzSewWWTIz3GeBeBsSvNeJOjrnFxaZHtPrhWtMh+H1z6WXD7JuFKzoKzMpSX8PR84byM83AuUm7C2G+UijDKCunEuEmJhEdw3+TwI8GPUXCsluBDKLpmWoTbxisYY4HxCG5l403e88bunykyrul7F7mccoSRLTLKbQSPGTy3MLuetZxx0ZX4beR6K+cVjP5cuW3h+xYe/TC+lyJeTeEu+oUxT1euEV7mqsqyut2EV7DoB+Mgg3HJG0d4bLmngvYvuwmNaeMVTJucNnnb5NJ/MsudOBX9pFx0U9E3Vln1V4Ydbtw2xrapDoYdbjyDxyYfm3xu8rnJ1yZfoV9upTUewahr47bxFrdscWEDSH5xdqyi/5Qrb5zJ81hkK5Bw3+TIo7L4hbLwCJ6bXHxfBSz+IuW2cbyrpihnuZfWeATLfi7lSI/4/Yy38LKPSHnTT9t726YH4xH8MxWbJowxFsBXU7EHThmb4IyRTvRpV3cyg9G3GG9hYF8Z9+C+yWVfnPIKHpvOsemcW9y5xZWddMq0caRT+hPj0Cl9i3GkE+fOnGnjSCdOqleMXxfPYHx3xj1YtjAq08Zb3L7FxfxXeWzysemUMlFuG6/gtaVzhU5sOXGOuD2njXc5dFawlInyDJbdkso9GHMu4y0ubTrbJm+hU27bg09GLrsxluMGyiNYTlAo92BZ2OnCtPEKbpsc4yx8O1VXbITnFl5WZ8C6PKO8yfMmz5tc0qncNg79ssfeeAZTpA032BjLgpSwHP5QbsGyEKW8xZ2bfG7hJb/Ml/uc9WONgLDqZgw703iTr02+Qo6fGHDe5LlsPINL3XgF101et/AoB/jk5a4A4uuuslwWQHJdNq4IMIYtahxhpE6Vc9oYOrvwDEY6jTd53eR1k6MejXswdqEbt2DUqTHkqBeZg9AUZnlDfqVO5VJwqVMpB6zzOU/nhZ3nxis408abvGzheR5qDFsFvimS+YsybFplpNkYaS5g2NLKSKfxMr6WYjg9WONouBrRGPa2MXQSGN++8S6HzgbGXNV4BrdN3jZ53+Q4BtHaf//7u+/sB1f+9OsvP/zAv7ey/QLLH/7z3T+//+WHn3/97vc///unn3733f/5/qd/I9C//vn9z3j++v0v1/9epfjDz3+9npfCv/340w9M//1dxE6vo/JFgxqb7QtXMOddDWVyLwMNF84HGjLmLdDAH+MrDfWg4VoDa6aC16tcR79dEpfryMqR73R/ko/VrCyvefXLsuyvNcxsCmYlj38N7rcV8AxEFYyXCuahNnGhqdTmNdMOFZe6RyrmExWXm8ra1DW5iBZxTb9uN8vOk3BJRR/0qjLYWnml4ur/i5Xm5Tl2FavdVkHYLwoVl0MqaqSl+yqqfx2X/6k/U0HZVfT5TMW04iTa2sVHVGA4VBWjPlOxvCxaaS9VrEO7WNVqhCfDruJqZ1/oKIe2NWa1rmJcg++rzoY9oi9V9GKf+uhblXyt4lAY7Ci3rLCD+2Wndy6OZV9aTTm/LI6Tjoqb6kTH5Qh8XaTt0HGV+NauBv+yPI5932z+udaXpcE+4tdF2lPxIr384E+KtBZPB0/lXxfHOg1olWI8i7xcLpIvx8RTKx3kTWxsQ2KZX+alHpopVoHle8ubhvSVhnIaDZaPBpfn9pmO4kbKteZYnukY2c2Ua3L3Use5ZqsbS6W/rtna327odbzd0Ov8jIZ+6o2bN7DL8/OyQ6f0fm9M+e3emMrbvTHVT+iNz8Vxrzem9H5vTO83Unq/kdJnNNJjcdzsjVt6vzdu+f3euJV3e+NW3++Njzpu9sZHHTd743PN3uuN23i7obf5dkNv6xMa+nEaXmZMw9fLyWc+JSOV7MlI1J8MCryUagnhZdL+atrUD82jpWld+oUv+2PeNvmyWlr2amlbC/tYVnqJrMyXM8B+6Eovz5hNyfmizJdZOTVS+OokK9TpE2pl0pPJ7OVztxGut/5yvB+HVtqxJCYqrrWeV1kZh1bKZyutNObW/XygNL7IyChPZqJXvOYqVn2mYkvFao9UdB+Yem/PUtH7dBWvMzIO7fNa1PEhts/XRtw4jfU4Iavtc62XQ+xYbxuCM71tCM78CYbgOSslstJfqpgng7TnET60zZtY+7P21V+6r2Y7Ond9TKEytsZBX+p43xyd75uj87eeMw3yEh3X/OnJFztouoqWXqpY+e1ueJXftBv+IiP5Ue91LcEWV9HmMxXuax6tp2cqIiM9v3TRrmMfmqv3oXXvQ7/8Wtd8v1bX27V6Oyc0XufkqKMN17EZs491bBOur3XkdOpEV/KFiEUxpNRcb6+wpZjT50crbPy7a66hvFyZyqn/xrb9xFWI0jpKf70Ukd5vpDmt37Tv+SIr45HxdcVzs7wseqZiS8V6tLYzsYFMx8ZnA8oXKuZrFfkwzBfcXKVOgZ5ff22ndJDbkdc853Wd5MNXzz/1Y9OttJn2H0uHzz5nS49GhMv89Io9jkvpNy7S5mY1Xwr0Oh3lM9Jxcvi0EcuxX3glP6Kke99R9unO/yo5tNQW431r7ZSd/vZUI58Wm27ONXKZn7EGeC6ScLf0Qk8rxy3sy7t3qOH6vmGa62dYprczsx6WSLh8yxiH5lpP86fVrW74Z9Q3CyR/ICUrPpzVnmZndc/OWuOQnXn0ZXnfSltKvjaocl3vW2XH7NTU3WuRRnudndPa0+7D6adGf1p9Wj57WJsZ8bXnI59Wn+qsbmTOvhdr+4iS6UpWfqpkFTf/r1b3OCUtlLSnSqJM1jbl/2B2WmRnPk3Jik12+5fz0ZT46k9K+e0yuZSUZ0ouj46v+6ZtxvxBJZ3+f4baR1MyQ0n/hDIZ42lKYmdSLg/bCWW3CCjX5ynxLWdXt/N+mWSqT7PjQxftK9EfU1Ji+1vJT9tJ9p2Zl5LxfplcSygPU4ILoEQJzVMfW95fj86nham7C9L5tDR1b0U69/n+kvRZSQkDp1B5qOTuFqGjRdDdz9JP7q88jjPybSNwWS9N2HFqrtVnwhe+XlE5J+Se5/00Bb0sCStVvi3x5RR09PenBadVqk9wGn2RlfLIaXTFm66CHrlrvkgF9Wep8Gpd+xaOr1XM8n6dnNaoPqNO9qxsW6Y+Uhr4LQFVUcvbBVqfVSv54L+opbdV9NepmMe9KL5L+3K0pZfrdXm9v0E6r/d3SOf1KVukT6Xa3P3Ot2E+qpje/JPdDyP8z771k5Pm3p4YdA4Ht+S7m2LW8OF6zcP39gkLVXn9tmsAq09bIVq7x+qrrJR02o0yoy9+WZ5nDSO5hvpaQz1VSYwpo61HRTFr81ptz8aU6ZbtNd09lGZ/u42XNH7bNr6Xxsivs7Le3/dQcnrb/Co5v73zoRy3j33G1oe1UnU/12bUfqSNre6dz9X7vKyY00rVzc6n5P7bdj57Vtaz4X4v0Nc7F8rx/M8nLDLllIZvNUppPdqG8aWS/bjd19n5xpmoW9ZLOXmG7x7vKvS29VJOyzKfYr3gCmIv11Lm63Id73fMp7Wqz9iRm2Luc2WmPvps+MIjL9bycM38KyWvD1WW01LV7UGi1vcHiUrvDxLHlarPGCRywQVzWq707LzrV0pe2zPltFR1t2s87dyh5Y7/thXrVzt3yumYg1tVm2ua6ge8WtVHibJPkD/oX7t35uN4vt6XyvK1Bh+ez6+Ohd9WsZ6ouHfC/qTg1gn7cjoadfd0ezkd0Wr+0bdZD+k4edV8j/Geio+pyKGiP1ThU+O+LwPdr5Gbx/RPpxKGLw/0MV5apqXR+2Zla2+blXdzMl8OSkcNPr/vV1t/pCHSMNN6omGO0LBepqH09L7FcjoQddNiOeZkK4vxqD42DSu112VBn2AV9/a+VXxcc7ppFffxCVbxN3Jz64BF6acp/s0TFqfaXWV47dLr2j0diLp7/KaMo8l07/xNGZ8wcRqfMHEanzFxOtbMMqfaSPm1eX9acrp59q+M84apO4f/TuNjqpGTgy08P6E3nb9tb7pyfC3ztcPjeCzqbkOfx+2BbkZefVUMUJe+2zq6L53vJ6tWflAY/JvlrwvjaIlSWKKbB4n6B3Tw5cb+sZW9E/vKnD0tO10TVzM76t5I/6eBHXUsP/FRxmsdp1Un/iWnzV1S6VlKqh+qrHWW1yk53mk2wsOQRnuYEvIume9cfZ2SU3d6ffzhdZmvP91vpMSvBbtS8roLOZ3p4d9ZiXve9gtDPpSS5hP7y/tzKJPjMmn18YF/ceH1ys3526m+9/PSsq/E377oLNcet+flbf9ouz3/4WsdfV697Sj4WkU9rUL14b6sUbbT4eurW/zScfB3FWO+NFOPKnJNnpf9urTc1geUrLhOcB1OkRx9Fb6X6It9ll+XxjxNbG9e4JTOjd1MkNMNTqdVqNtXOB2V3L3D6ajk5g6tkyXj5mV7qMAHmf1AzUccYam4mzT1Zyqy9+r8MyrPVMTdFnk+S0X1ouDe8JlTsMSlm1tX/CEVPTqvuZ5lZO8znmXkGtNcRXuUkU9o3GzEuT03nmVkDLc6xnrm6V1RnKs8UjHiWDf1JwqWezx2K+EjCnzqtsqzFPj3tUZ7MwvPFNw9c3e8RfXeibt6Wly6e+Ku1vfdT7W+736q9TPcT98oknsn7o5Vc++8XaX37+Op9P6FPLezsh6Vxs2zduimX3dc987anS80vHXS7qji3jm7Suc7o26ds6vHC/g+4/aDe6fs6un+vbun7OrpAr57p+zq8f69m6fsvqHk3im7s5Kbp+y+lZJbp+xul8nplN03snPvlN03lNw7ZfetlNw6ZXe3TI6n7I5K7p6y+4aSe6fsvpWSW6fs7pfJGE9Tcu+U3VnJzVN230rJrVN2t8vkdMruG9m5d8rurOTmKbtvpOTeKbvbZXI6ZXdOSfWpFNX6tGDx89iq5GmnRBRX71N7mh1a3im1/LSKb548PA6it+8lP15ud9evdVqRuunXOi1I3fZrHZXcPHl4VnJz6n+2km6ePKyn6/punjysp+v67p48PCfk5j3px2K9ufXtGxX8/ta3GRu+5m5o3d8oQLHieK0CP5ow8u9xmYqRXl8xV0+rUp+iJHe/cCr3duiKzkr89E4ep4HiqCT2KuWxXX31QSVulfDvCj9UEv6NC9cnKKHXltrJ87a8U7zwyWx+Zj9OOXN5smNhJt82+1RD9i9u5toepeHe/fXpM3ZEn9Ix3cl+4fbB3b4+cK4oi32P0Vca6LQUVaZP48vcDt58JBW+rj6/WFK7rWElX0BeX7gSPpAG7zLm2u46/lAa3IuQtk/9QxpKaMjvaqjP0hDn2xLVd+tiH44+oCFO1abxLBc03msPGTdV6ue51cUHxuWC8+3yYeT1qMctJX6prLT2UMVwFQfH1PG2QV++/8JW+pAK34hYanuYiu3MxaiPVJD3uYXyQxW+K7OcJm1nFW7R03hWnOQ7TEpLz1LRfKm57CsvH1Ph7aL1Z62zua/kWoeiRyr2X/Oj+VCFV2rvz8oiTM7rKxuPzKubP1Z0WoIacapo7PeTfkjHfut1Gc90dB8ELhwPjJubu7DptPx0zVJjtplf78Km841KseqddudI+1rJ6SDerbNFdFqBunee5htZ8U1UeR9Y/0fJuWr98uyxb0/9WPOIRfznOu79MBetT1ixPc7gw5Cf+2Sz1UcqynqkYrVYj+v9oYoSKsYzFXEKb9GzjOCmE1FR0qOTE1+oyI9st7sHJ6h9wg+XUHv/l0vodODp7qfSP+O3S76RklvjwjdK5NbIkN7fYlFPG45LCqMh7d7dr45q0unU093znvV0Z879lPy2v6t879zpyU1969RpeneMPO7g9F88SuNRCt49stp9PWdsvd81gbzd+4U7OO+Nm+73n/eOfpys4elu/stFvl52n+fdMvd+/vMTfvaJPuF3n+hTfvjpWCD3fgD0NKrd/f3PSW+vvtBxBefuL4D239aDevcXQOn040/3dg8dVdxdO6XjzXo3105pvf2rznS6We/u2ulZyc31ubOSm+tzZyXv772++3OktN7/PVJa7/8gKa3P+EXSb6Tk9TrOH6+/vv/Lj7/86ad//OX7X3/8x8//uiL+l3X98uP3f/7pB/3zb//++S/b//76f/9p//PnX3786acf//6nf/7yj7/88Nd///IDa+L/+y7pP38o/FNUpVf64+++y/w3r23VlNb1d+W/29V0Lu8U/03897za49VbzOvvhr8vE7WsXDk+K8w19d/lq6mygDVenXS9NOb2x/9ylv4f",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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vLk+z1vg07fQx+din+ct8XneuT7PO8+n73wfnxf4PO8in+dd4vO8Z3yet0u72p+3l0/fEJ++kfk+XY0wzud5h+X7dNr7JJ/nPZjv0627D/v0Pe3T96xP32f5Pl1t8Ve+T1dbNGxfO79D2tfO73ufvp99+rbJX+XQ1RYPda6d38M+fU/49D3l0/eST98rPn1v+PS95dP3kU/fJz59X/r0fe3T971P348+fX/69P3t0/fvzZJa+hr69K3j09fcp69Fvk+nTV/oWvvzXvLpe82n7w2fvg98+j7y6fvcp+9Ln75vffq+9+n73afvT5++v336/r05VktfE5++dXz6muf7dGtIzKcvke/T7Sub+TxvC5/nbeXzvG18+rbz8bmDz/N28nneLj7P292nb08fn3v7PG9fn+ft5/O8/X36hvn4HO7zvJE+zxvl87y0T1/Wx+don+cd5PO8sT7PG+/TN9HH5ySf5032ed4RPs872qfvWB+fU3yed4LP8070ed4pPn2n+fg83ed5M3yeN8vneTf6PK9Pj9qfV5Xv091j2MTneTGfvs3yfTrdurPP8/bM9+l03Qk+z7sn36dbk+/z6XvMp+8Jn76P8n063fpbvk+nW/99E0Yt/Mb3rJ1fi161963n0zci36fTraP61s4v6dOX8+kb49M30advkk/fET59R/n0TfXpO8mnb5pP33Sfvtk+fXN8+hb59J3t03eOT99Sn74VPn0X+vT92K/2vp99+v7x6WvQv/a+Rj59TXz6ynz6Wvr0revT19qnr51PXwefvh4+fb18+jb06evr0+fk+3R1x68Dan/e7z59f/v0/fshlFr6mvn0lfn0refTt75PX3ufvo4+fT19+nr79JX79G3o09fPp2+AT9/G+T7dHjDcp29kvk+rTX2el/J5XsbneaN9+g7y8TnW53mH+Dxvgs/zJvn0TfbxeYTP847yed4xPs+b4tN3go/PE32ed7LP8071ed7pPn0zfHzO8nneGT7PO9PnefN9+s7y8bnI53ln+zzvHJ/nLfPpW+7jc4XP8y70ed7FPs+7zKfvCh+fV/k87xqf513n87zXfJ636ya1P2+vWvq65P8+ntcizfP/LhQm/HZFfnvMwPy/neIOt7niF+0/7iSDzQM1DzD+UHPFp4D/YMF/Yxn//37fMR/Lp9b0H/C8bqv8v5W3o1c/p9CnFq/n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",
      "debug_symbols": "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9rdu0MPXR5lPXo2x05nf/tYG7dABPXx9tOfJK3+OJc789rdu0B1aoBXaoB16+I7x25nf/tbDd4zfzvx2GWO2M79dnnk4cea3v7VAK7RBO3RAJ3RNffLqpeHr8HX4Onwdvg5fh6/D1+Eb8A34BnwDvgHfgG/AN+Ab8A34JnwTvgnfhG/CN+Gb8E34JnwTvgXfgm/Bt+Bb8C34FnwLvgXfk1djbH/mt8sYn5/57fLM0Yozv/2tBVqhDdqhAzqha+qTVy8N3wbfBt8G3wbfBt8G3wbfBt8O3w7fDt8O3w7fDt/BK33m+cSZ3/7WCV1TD169dYPu0AKt0AYNX4GvwFfgq/BV+Cp8Fb4KX4Wvwlfhq/BV+Bp8Db4GX4Ovwdfga/A1+Bp8Db4OX4evw9fh6/B1+Dp8Hb4OX4dvwDfgG/AN+AZ8A74B34BvwDfgm/BN+CZ8E74J34Rvwjfhm/BN+BZ8C74F34JvwbfgW/At+BZ8a/qe+e1v3aA7tEArtEE7dEAnNHwbfBt8G3wbfBt8G3wbfBt8G3wbfDt8O3w7fDt8O3w7fMErA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68MvDLwysArA68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68cvHLwysErB68CvArwKsCrAK8CvArwKsCrAK8CvArwKsCrAK8CvArwKl68qqGH79jTOfPbdezjnPntb53Qw7cPffLq+W5FnPntbz18x9r7md+uY9/wzG9/6+Frpx6+dsYM6OE7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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACDScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHABAnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjYtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI2LQIAAC0LBgELIgABgEQAByQCAAcAAAGeJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2QtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB7yUAAAR3LwoAAwABHgIAAgEKKgECAyQCAAMAAAIMJQAABIkmKACABAR4AA0AAACABIADJACAAwAAAjUqAQABBfeh86+lrdTKPAQCASYlAAACDS0LBAYLIgAGgEQAByQCAAcAAAJYJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAvAjAAACcS0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAApslAAAEmy4CAAeAAygAgAQEAAQlAAAErS4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAALbJQAABTstDgoBLQ4IAi0OBQMtDgkEIwAAA2MnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADZC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABK0uCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAANjJiUAAAINLgiARQAFIwAAA3QNIgAFgEMABiQCAAYAAAPkIwAAA4ktCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAAA/ojAAAEZi0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABK0uCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEZgEiAAWARgAGLQoGBSMAAAN0KgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVeEKDJz12ECzwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAEyCMAAATTLgCAA4AFIwAABTouAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFJi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAE9SgBgAUEAAEDAIAGAAKABiMAAAU6JioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "tZjRais5DIbfJde9sGRLts6rHA4lbdNDIKQlp11YSt99JVtymoUZ6Cx7k/+zx/5HtjWaIR+7p8PD++/74/n55c/ux8+P3cPleDodf9+fXh73b8eXs/Z+7JL9QMq7H/VOtQ0FdK1D0dvo7eztzENLciVXGUrFVX2bapWhLbt6v3hbRhtTdq1DAVx5KCZXch2+mIur+rBqQdc6lMCVhnJyLa4+r2ZXGdq83fy66Hgxla45Fdc21PavKw+1eLv6OPRxObt6u/g8i9fU4u1Krn4/9nns46qPq36/5u2m8wAMdCKggtQBJZEDpAANDrKBOGAOqA4ZAiggBpeYXqKHYjrZ9KLAFGBjNDNKLQ4NHSQF6GDUwCjpTZEMdHmo+0+WDwPEwXYAq4HN0hwgO7MOAgE8gFMK0LujbhRbIuVkIA52NAOqQ4GAGGPp3YExwAbrhrNlUIeWAsjB4hnAA2qCABujS66QA5oDsoMdwYAYbEfQocQssniyQXVgCKAAceihdojBLaa36JGYLjFdfHqzZzUXA3GwrO+AEFAdrHB0sIoxwPewleZAGBA9zcZoAkjfHzYQh75RHZqD1SrLBLGbdsgQwA4lekr0UPRQ9HD0cPhEjknPsQ7i0JOtQwyWGNxPmay4WtrlXmZ7sJ0sWgtbqQbl2WcBD+r71TpREM2+nojSSYKsRjhN55qDeloOoqB+yIPivpBgEk2SoNh96G+KQT1R+fPzbhcvmvu3y+Fg75kvbx59H73uL4fz2+7H+f10utv9tT+990F/Xvfnrm/7i17V8z+cn1TV8Pl4Ohh93l1np+WpuuO1+nRladOCbj1gxSNzCQutkNMBiG4scMWC2B0w4TTI0G4M8rJBrUXcoVbhaYHtdhll2SITukOBLwbp1oCWDRAEYhWYZNGCly0IYxWU0yYDidNkoE2LwBYhYP5yFt+xqDBPs64sA9L/6wHM8WQA17bNQ0t/eFTBbR5aisNDS++yx4pFmaeiH4y8+IjByrGwvkPjEUHO00NuHzJYyS59Rc6H7LqfwGVbudFCuFhu2oqJfkOHB9S0GAfIykpajtyojWB68G0YmNY2Yz6slbktWsDqSmSmFxDyksnqliLMNNd35WIFx5XySfqyi8KT2vJaVsqn7mKcSvtavL6zEhC+ruSLB31nN3Ba8HIFXLOAmRp6Pm2bBc8ooG2LIs9KrrgtCsJ0LRp1mwVf606TbQu5Vr+M2xaSy/zAyLRpIbXEgdTCWwxk1hyhTYuQFOcpuC2CmVP6cf0fl/Bvg1/a3D8eLzd/fHya1eW4fzgdvPn8fn78cvXt79e4En+cvF5eHg9P75eDOV3/PdGfn6hf+Ej8yz6etalf6Xf6mWxNsKtU9ar8+rRg/gE=",
      "brillig_names": [
        "slash"
      ]
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+19B5wcR5V+j3ZX0q600lqyJGcrWBa2MUzYCAZkHMDYgAM5bzQG4yTZsnEaSeuAc8A2OR6ZI+dwhMuR/91xkTvg7ric4TJ38K+S5818++3rnp6dV6spa+v3q92erurvvXr16tWr6uqqQvJo+GBXkox3PXpdcLGr9n+Zi5vpnvzH6x4l3yrlXr9yb61y7zDl3kYXd9K945V8m5V7W5R7W5V7O2r3MCyr/d9Z+19sL5R2AFalODw4OD1Sni5VSuPF8tjE6FBxcGhieLQ0WhoaHZoqj1Yq06ODoyNjE2MjxbHSYGW6NDM0Vpmpga3usuML5eBxvRy6SQYYCsZyKdhhFRV2rbBHNOx5wmi3YvvNKrZcDMnnmq4wlWbN59qF81nmG563dUmjcRwwbA7/J8C3XK+B+2tr1/LcgPt9mIvrXFzf9eh9H3sBJ0smxfZCacCw7pDfw7sCMlwHN1SO7qTRo8Uk9OXA54aaXDbW/m+q/T+i9v/I2v+juBvf2DW/G/SZV5IglhkL3dDcl46IxAodbdhdh+TzmIXzOcQ3NGt5NFjFDXC9Ea6PIWt5rPt9nIvHe33tatyX0EUyKLYXSpsM6+rYLru62RJI163lZ2joSscZym+rca/Hur0FdHgrXB8P15tJt7e53ye4uN3FEw+CJ3CkgXynZw6EaeR3R1dAhj24VackzO8wVNrHGSptKBl6Hq06D5Hh4yLpjE+y43MwJJ8nL5zPCt/QDNZJYJh8lOttcP9kMlinuN+Pd/FUF5/QNRdvSUft6v6JdnxWtLp/ItTxUXB9SkbdF93vkotlFyuKI2Y9X7ba0I4OBpovG4T5sgg77Rnkdyhkpz1k32nPDBlW6nAEnfawvUGcGTY2iNazBdtqHYGVHD1WscveWG0z1J+RwCOVtI5/JMP4j7rfYy4+ycUnB+74O13PW+lQRzNkepr7/RQXn+ri02D0tyxZnI5kg6FM+oHPnbWO5PTa/6fX/p9R+39m7f9Ztf9n1/4/o/b/mbX/59T+P6v2/9za//N4KvPpXfPfTJ6l3Humcu/crvnCtvbmnm0m6ErQEcdzFs7nFN/QGsmzoTHshOvT4fo51Eie636f7+IFLl7YFX767+mGnc1zDTuFiwKNXKzld4ah/M43lN/zIpHfmYbyu8BQfs8P3IFeBDbgeXD9fLi+kGzDC9zvF7r4IhdfvAi24SzDunmBYd28JBLdPttQfi80lN9LI5HfMwzl9yJD+b0ssG14CdiAl8L1y+D6xWQbXu5+v8LFV7r4qkWwDc80rJuXG9bNeCS6fY6h/F5hKL+JSOT3LEP5vdJQfpOBbcM42IAJuJ6E61eRbZhyv6ddnHHx4kWwDeca1s2UYd28OnDdvBrqYBquZ+D6YqqbS9zv17j4WhcvVerGesz7OjsZzGgyeB2U9RK4Pi9jYugy9/tyF69w8UqYGOpKFmdi6DJDvVgGfF5Va1i7eALHJ1Tp3q7aPQzWDfMyw8Z0VX6sySZYpV2GFYCzimkhL61mfCcBlfIqY2MlYTcr425lRpAVz1JZmvBaapJe3G2oxFd3mSlDEWV6dY7G3C7vuwzlYCnTa1qQaTNaKNNrwGiuBHmiTIvthdJPsvHKkzOlytD0yFBxeHxwaGq4Up4qjxSnBodmSo7h8tigE83M5ODo1Gi5MlMeKU/+xJa/Azomhk06EulVd9Wu97j/17p4HQoogP5ZznzuMdS/1xt3Jou1zuH1gQz+9V0BGb6+yx73BkNlCFXuG6BxGeFmDpfblYPlNPu1hvVzY6SN9cZAjfWmroAM3xSgsd7c4Y3Vl/vmRW6sxfbCnN6w2F4wNaZVY6WXxloFL+barrkfFcr6hTPg/plKnr3u/z4X99d+C/aeFOzrALtZnln3/xYXb+0K0zZvqOmo9VzPbcZzudb8hSr37YbtJ4FgvdjvOsO2+QbjMlsvGPTt07JefJu8LYDu3NEVpo+w1p2zDHXnzg7XnTNqo1krPN9W7gigO3cZ604IndljrDd3BfApLRdqau8o0tbiPT3jHcXd7vc9Lt7r4n1drX+62K6s7waZlMeHpqYHR6anKu59t5tnmhhx81Hj46XBkeGym34aHp0ZmpyZLA1PTo2WSsPTE8MTxbGJ4kx5eLAyOV6eGEN+7+8KyLAHZyVul/n7DQ3BA4EHLxYyfEBpYO3K8AHjUbffFmlZ0rwRFNsLpbsDdc6JLZ9FfIn7YK2BvbH2/6Ha/4ehXs0Vx7CC53z/9RCMmtiqPgjW841w/VCGVX3E/X6Ti2928S1d8/dhsiqDNCRL+T7SZd9DGyp46ZFAjcVaV99qxmdlSNOddvnzn9IYfqJ04NO707rsdXzEUL/f1uEzB779PRxAhg8byvDtgb3Yt4JdfRtcvz3D3r7D/X6ni+9y8d1d4b9pHjSU53sC9Wked3NNRsuTue+VE5C3pVze0eHty382+rYAI7u3LVKfVGwvlAZD8OkVbEXyqLccWsEGAgk6seWzIg0xpCw2BJCFNY8bI+BxUySNd1skfL4ncBs1783fY9ibvzdQb/7eWm+eVXHt8v4zZryXJzXP7me69K0CszZZfZ/7/X4XP9D16C7XMj/JK+U47DSsg0ITuRfbC0GMZAg+37fYDdti7tKq8I9LwhTeuswFwzKfFEmZlxmW+eRIytxlWOZTkjgM0OMXqW6K7YXSqYb1/L5IOocnJHHw+cRI+CxGwmcpiaNNlhO7NjnSFUeZK4ZlXh3LFFcSB59DkfA5HAmfI5HwORoJn2OR8PmkSPh8ciR8nhYJn0+JhM+nRsLn0yLhc2ckfJ4eCZ9Pj4TPMyLh88xI+DwrEj7PjoTPZ0TC5zMj4fOcSPh8ViR8nhsJn+dFwuezI+HzOZHw+dxI+Dw/Ej4viITPCyPh86JI+HxeJHw+PxI+XxAJny+MhM8XRcLniyPh8yWR8PnSSPh8WSR8vjwSPl8RCZ+vjITPV0XC53gkfE5EwudkJHxORcLndCR8zkTC58WR8PnqSPi8JBI+XxMJn6+NhM9LI+HzdZHweVkkfF4eCZ9XRMLnlcZ8WvPnP/V/MMCn/lcldms+H+zqfBm+MYAMdxnK8I0RyPChADLcbSjDhyJZb321YZnfHkmZrzHDqhQttjJ69KToqaBnmOxJ4ugDr42Ez+si4fP1kfB5fSR83hAJnzdGwudNkfB5cyR8ViPhc28kfO6LhM/9kfA5Gwmft0TC562R8HlbJHzeHgmfb4iEzzsi4fPOSPi8KxI+746Ez3si4fPeSPi8LxI+74+Ezwci4fPBSPh8YyR8PhQJnw9HwucjkfD5pkj4fHMkfL4lEj7fGgmfb4uEz7dHwuc7IuHznZHw+a5I+Hx3JHy+JxI+3xsJnz8TCZ/vi4TP90fC5wci4fODkfD5oUj4/HAkfH4kEj4/GgmfPxsJnx+LhM+PR8LnJyLh85OR8PmpSPj8dCR8fiYSPj8bCZ+fi4TPz0fC5xci4fOLkfD5pUj4/HIkfH4lEj6/GgmfPxcJn1+LhM+vR8LnNwLxucyYz28CVrvfx2yL5PuYnzcs83siOYPhF5I4+PzFSPj8pUj4/OVI+PyVSPj81Uj4/LVI+Pz1SPj8jUj4/M1I+PytSPj8ViR8/r9I+PztSPj8nUj4/N1I+Px2JHz+XiR8/n4kfP5BJHz+YSR8/lEkfP5xJHx+JxI+/yQSPv80Ej6/Gwmf34uEz+9HwuefBeLTeo7yzxO7Ocp3RDIv+xeGZR7s8D2+Huf4e1uAPb5+YCjDt0Uyt/2XSRx8/lUkfP51JHz+TSR8/m0kfP5dJHz+fSR8/kMkfP5jJHz+UyR8/nMkfP5LJHz+ayR8/jASPn8UCZ//Fgmf/x4Jn/8RCZ//GQmf/xUJn/8dCZ//EwmfP46Ez/+NhM//i4TPn0TC508j4dMDxsBnIRI+l0XCZ1ckfHZHwmdPJHwuj4TPFZHwuTISPnsj4bMvEj5XRcLn6kj47I+EzzWR8Lk2Ej4HIuHzsEj4XBcJn+sj4fPwSPjcEAmfGyPhc1MkfB4RCZ9HRsLnUZHweXQkfB4TCZ/HRsLncZHweXwkfG6OhM8tkfC5NRI+t0XC5wmR8Lk9Ej5PjITPHZHw+bhI+DwpEj5PjoTPUyLh8/GR8HlqJHw+IRI+nxgJn8VI+CxFwmc5Ej4rkfA5GAmfQ5HwORwJnyOR8DkaCZ9jkfD5pEj4fHIkfJ4WCZ9PiYTPp0bC59Mi4XNnJHyeHgmfT4+EzzMi4fPMSPg8KxI+z46Ez2dEwuczI+HznEj4fFYkfJ4bCZ/nRcLnsyPh8zmR8PncSPg8PxI+L4iEzwsj4fOiSPh8XiR8Pj8SPl8QCZ8vjITPF0XC54sj4fMlkfD50kj4fFkkfL48Ej5fEQmfr4yEz1dFwud4JHxORMLnZCR8TkXC53QkfM5EwufFkfD56kj4vCQSPl8TCZ+vjYTPSyPh83WR8HlZJHxeHgmfV0TC55WR8HlVJHzuioTP3ZHweXUkfF4TCZ97IuHz2kj4vC4SPl8fCZ/XR8LnDZHweWMkfN4UCZ83R8JnNRI+90bC575I+NwfCZ+zkfB5SyR83hoJn7dFwuftkfD5hkj4vCMSPu+MhM+7IuHz7kj4vCcSPu+NhM/7IuHz/kj4fCASPh+MhM83RsLnQ5Hw+XAkfD4SCZ9vioTPN0fC51si4fOtkfD5tkj4fHskfL4jEj7fGQmf74qEz3dHwud7IuHzvZHw+TOR8Pm+SPh8fyR8fiASPj8YCZ8fioTPD0fC50ci4fOjkfD5s5Hw+bFI+Px4JHx+IhI+PxkJn5+KhM9PR8LnZyLh87OR8Pm5SPj8fCR8fiESPr8YCZ9fioTPL0fC51ci4fOrkfD5c5Hw+bVI+Px6JHx+IxI+vxkJnz8fCZ+/EAmfvxgJn78UCZ+/HAmfvxIJn78aCZ+/Fgmfvx4Jn78RCZ+/GQmfvxUJn9+KhM//Fwmfvx0Jn78TCZ+/Gwmf346Ez9+LhM/fj4TPP4iEzz+MhM8/ioTPP46Ez+9EwuefRMLnn0bC53cj4fN7kfD5/Uj4/LNI+PzzSPj8i0j4/EEkfP5lJHz+VSR8/nUkfP5NJHz+bSR8/l0kfP59JHz+QyR8/mMkfP5TJHz+cyR8/kskfP5rJHz+MBI+fxQJn/8WCZ//Hgmf/xEJn/8ZCZ//FQmf/x0Jn/8TCZ8/joTP/42Ez/+LhM+fRMLnTyPhM1kWB5+FSPhcFgmfXZHw2R0Jnz2R8Lk8Ej5XRMLnykj47I2Ez75I+FwVCZ+rI+GzPxI+10TC59pI+ByIhM/DIuFzXSR8ro+Ez8Mj4XNDJHxujITPTZHweUQkfB4ZCZ9HRcLn0ZHweUwkfB4bCZ/HRcLn8ZHwuTkSPrdEwufWSPjcFgmfJ0TC5/ZI+DwxEj53RMLn4yLh86RI+Dw5Ej5PiYTPx0fC56mR8PmESPh8YiR8FiPhsxQJn+VI+KxEwudgJHwORcLncCR8jkTC52gkfI5FwueTIuHzyZHweVokfD4lEj6fGgmfT4uEz52R8Hl6JHw+PRI+z4iEzzMj4fOsSPg8OxI+nxEJn8+MhM9zIuHzWZHweW4kfJ4XCZ/PjoTP50TC53Mj4fP8SPi8IBI+L4yEz4si4fN5kfD5/Ej4fEEkfL4wEj5fFAmfL46Ez5dEwudLI+HzZZHw+fJI+HxFJHy+MhI+XxUJn+OR8DkRCZ+TkfA5FQmf05HwORMJnxdHwuerI+Hzkkj4fE0kfL42Ej4vjYTP10XC52WR8Hl5JHxeEQmfV0bC51WR8LkrEj53R8Ln1ZHweU0kfO6JhM9rI+Hzukj4fH0kfF4fCZ83RMLnjZHweVMkfN4cCZ/VSPjcGwmf+yLhc38kfM5GwuctkfB5ayR83hYJn7dHwucbIuHzjkj4vDMSPu+KhM+7I+Hznkj4vDcSPu+LhM/7I+HzgUj4fDASPt8YCZ8PRcLnw5Hw+UgkfL4pEj7fHAmfb4mEz7dGwufbIuHz7ZHw+Y5I+HxnJHy+KxI+3x0Jn++JhM/3RsLnz0TC5/si4fP9kfD5gUj4/GAkfH4oEj4/HAmfH4mEz49GwufPRsLnxyLh8+OR8PmJSPj8ZCR8fioSPj8dCZ+fiYTPz0bC5+ci4fPzkfD5hUj4/GIkfH4pEj6/HAmfX4mEz69GwufPRcLn1yLh8+uR8PmNSPj8ZiR8/nwkfP5CJHz+YiR8/lIkfP5yJHz+SiR8/mokfP5aJHz+eiR8/kYkfP5mJHz+ViR8fisSPv9fJHz+diR8/k4kfP5uJHx+OxI+fy8SPn8/Ej7/IBI+/zASPv8oEj7/OBI+vxMJn38SCZ9/Ggmf342Ez+9Fwuf3I+HzzyLh888j4fMvIuHzB5Hw+ZeR8PlXgfhcRnxWisODg9Mj5elSpTReLI9NjA4VB4cmhkdLo6Wh0aGp8milMj06ODoyNjE2UhwrDVamSzNDY5WZGvYOwzL/9SKVudheKP3NMjv5vbcrjnruNpTf30ai2z2GZf67SMq83LDMfx9JmVcYlvkfIinzSsMy/2MkZe41LPM/RVLmPsMy/3MkZV5lWOZ/iaTMqw3L/K+RlLnfsMw/jKTMawzL/KNIyrzWsMz/FkmZBwzL/O+RlPkwwzL/RyRlXmdY5v+MpMzrDcv8X5GU+XDDMv93JGXeYFjm/4mkzBsNy/zjSMq8ybDM/xtJmY8wLPP/RVLmIw3L/JNIynyUYZl/GkmZjzYscxLJ/PYxhmUuRFLmYw3LvCySMh9nWOauSMp8vGGZuyMp82bDMvdEUuYthmVeHkmZtxqWeUUkZd5mWOaVkZT5BMMy90ZS5u2GZe6LpMwnGpZ5lWGZHdSBNT4/qBX4cS6e5OLJLp7i4uNdPNXFJ7j4RE/PxZKLZS8TFwddHHJx2MURF0ddHHPxSS4+2cXTXHyKi0918Wk1GZzu4tNdPMPFM108y8WzXXyGi8908RwXn+XiuS6e5+KzXXyOi8918XwXL3DxQhcvcvF5Lj7fxRe4+EIXX+Tii118iYsvdfFlLr7cxVe4+EoXX+XiuIsTLk66OOXitIszLl7s4qtdvMTF17j4WhcvdfF1Ll7m4uUuXuHilS5e5eIuF3e7eLWL17i4x8VrXbzOxde7eL2LN7h4o4s3uXizi1UX97q4z8X9Ls66eIuLt7p4m4u3u/gGF+9w8U4X73LxbhfvcfFeF+9z8X4XH3DxQRff6OJDLj7s4iMuvsnFN7v4Fhff6uLbXHy7i+9w8Z0uvsvFd7v4Hhff6+LPuPg+F9/v4gdc/KCLH3Lxwy5+xMWPuvizLn7MxY+7+AkXP+nip1z8tIufcfGzLn7Oxc+7+AUXv+jil1z8sotfcfGrLv6ci19z8esufsPFb7r48y7+gou/6OIvufjLLv6Ki7/q4q+5+Osu/oaLv+nib7n4LRf/n4u/7eLvuPi7Ln7bxd9z8fdd/AMX/9DFP3Lxj138jot/4uKfuvhdF7/n4vdd/DMX/9zFv3DxBy7+pYt/5eJfu/g3Lv6ti3/n4t+7+A8u/qOL/+TiP7v4Ly7+q4s/dPFHLv6bi//u4n+4+J8u/peL/+3i/7j4Yxf/18X/c/EnLv7URd/YCi4uc7HLxW4Xe1xc7uIKF1e62Otin4urXFztYr+La1xc6+KAi4e5uM7F9S4e7uIGFze6uMnFI1w80sWjXDzaxWNcPNbF41w83sXNLm5xcauL21w8wcXtLp7o4g4XH+fiSS6e7OIpLj7exVNdfIKLT3Sx6GLJxbKLFRcHXRxycdjFERdHXRxz8UkuPtnF01x8iotPdfFpLu508XQXn+7iGS6e6eJZLp7t4jNcfKaL57j4LBfPdfE8F5/t4nNcfK6L57t4gYsXuniRi89z8fkuvsDFF7r4Ihdf7OJLXHypiy9z8eUuvsLFV7r4KhfHXZxwcdLFKRenXZxx8WIXX+3iJS6+xsXXunipi69z8TIXL3fxChevdPEqF3e5uNvFq128xsU9Ll7r4nUuvt7F6128wcUbXbzJxZtdrLq418V9Lu53cdbFW1y81cXbXLzdxTe4eIeLd7p4l4t3u3iPi/e6eJ+L97v4gIsPuvhGFx9y8WEXH3HxTS6+2cW3uPhWF9/m4ttdfIeL73TxXS6+28X3uPheF3/Gxfe5+H4XP+DiB138kIsfdvEjLn7UxZ918WMuftzFT7j4SRc/5eKnXfyMi5918XMuft7FL7j4RRe/5OKXXfyKi1918edc/JqLX3fxGy5+08Wfd/EXXPxFF3/JxV928Vdc/FUXf83FX3fxN1z8TRd/y8Vvufj/XPxtF3/Hxd918dsu/p6Lv+/iH7j4hy7+kYt/7OJ3XPwTF//Uxe+6+D0Xv+/in7n45y7+hYs/cPEvXfwrF//axb9x8W9d/DsX/97Ff3DxH138Jxf/2cV/cfFfXfyhiz9y8d9c/HcX/8PF/3Txv1z8bxf/x8Ufu/i/Lv6fiz9x8acuesei4OIyF7tc7Haxx8XlLq5wcaWLvS72ubjKxdUu9ru4xsW1Lg64eJiL61xc7+LhLm5wcaOLm1w8wsUjXTzKxaNdPMbFY108zsXjXdzs4hYXt7q4zcUTXNzu4oku7nDxcS6e5OLJLp7i4uNdPNXFJ7j4RBeLLpZcLLtYcXHQxSEXh10ccXHUxTEXn+Tik108zcWnuPhUF5/m5wldPN3Fp7t4hotnuniWi2e7+AwXn+niOS4+y8VzXTzPxWe7+BwXn+vi+S5e4OKFLl7k4vNcfL6LL3DxhS6+yMUXu/gSF1/q4stcfLmLr3DxlS6+ysVxFydcnHRxysVpF2dcvNjFV7voz6r358D7M9b9+eX+bHB/7rY/09qfF+3PYvbnHPszhP35vP7sW3+urD+z1Z+H6s8a9ed4+jMy/fmT/mxHf26iP5Ow6qI/S8+fU+fPgPPnq/mzy/y5YP7MLX+elT8ryp/D5M848ucH+bN5/Lk3/kwZf16LPwvFnzPiz/Dw52P4syf8uQ7+zAR/HoHf69/vo+/3qPf7v/u91f2+5X5P8He56Pey9vtE+z2Y/f7Gfu9gvy+v3/PW7yfr92r1+6D6PUb9/p1+b0y/76Tf09Hvl+j3IvT7/Pk99Pz+dH7vN7+vmt+zzO8H5vfa8vtY+T2i/P5Lfm8jv2+Q35Pn6y76vWT8Pi1+DxS/v4jfu8Pvi+H3nPD7Ofi9Evw+BP4bf//9vP823X/37b+p9t8r+2+B/Xe2/htW/32o//bSf9fovxn03+P5b938d2T+Gy3//ZP/tsh/t+O/ifm+i/5bDv+dhP8Gwfu9fu28X5fu12n7NdB+Ha9f1+rXefp1j34doF8X59eJ+XVTfh2RX1fj15n4dRd+HYJ/L+/fU/v3tv49pn+v599z+fc+/j2Ify/g58n9vLGfR/Xzin6ezc87+XkYPy/hx+l+3OrHcX5c4/38ZY+6DIlfp+zD45JGqJkTD3kg3a/r9etc/bpPvw7Srwv06+T8ujG/jsqvK/LrbPy6E78Ow69L8O/p/Xtr/x7Xv9f07/n8ey//Hsi/F/HvCfy8uZ9H9vOqfp7Rz7ttdnGLi1td9ON2P4714zo/ztmRzA+r4XpN7f+GH5x+5JW/9oGzMN+G2v+3r7umuuMyX3uNcGTt/19suOCtN6163E8w7eQMzHNr/9/5oeM+e/QPlr0E087LSLsgI+2ijLSZ2v+LX/+Xq1/83l+8CtMuq/1/9xHj7/qrn3x3FabtzijDtSlpfbX/z68Jvbf2WwTndcTrx87a72J7odQLuNb4o8Wxid5kbjDmv9ILmAHwy4LfHQb/wJpuH95cnYufEN3+2u8CyFKekTRsXG+ppa2spcu16F0v4YWod+TJWm7rFf6XQdl8OKMagnZ5UvDPrOEnc7BLldHhSnl0uFyemi6OTw2PzIxVRoqViaHK2OREqVgZKo9OjYxXisXpyvTkYHFqeGxoanp8bKgyMzE+NizYZ6nYlekJBzU0Pjw6UZoZH54pTgyOjFbGZ0ZGpsanxtx81lBxqjQ5XJosl2ZGR8eHhsYnh8ZKpZnpsaGZ0Tr22UHk8mhb8eEZQfArQ4L/zDD8123hOYBv+D1RUfCfFQa/zv+5YfDr9XteDT8JIJtnA++FALJ5Thj8umyeGwa/IvjnA35XAPwLguCX6vV7YRj+BwX/ojD4M4L/vBp+Atil0Uq5PFLx7wlGp4qlwanJ8qiz/hODxcni+GR5emywNDYzWB6sTE5NTrh3CuOlmeLM+OTYzOij4IL9/CC8V+qyeUE1hG5W6v3KCxXZFNsLdZv/onTsBYtfsF+sYJfHK5PFsZni+NDo+Mi0ezlUdJ35yPTE6PTMcHl8wnXc5alSqTQ96P6Up6cGxyamhksTw+6N0tCEI1ev05dUQ9Rpqe6DvNQYf3i8ODY9PDwi+C8zxp+YGB4Zd/IU/Jcb41cmh6dnKiN1e/wKY/zxocGZmaHKuOC/0hh/qFScHiqP1HXzVcb4YxPFoeHR0br+jBvjO7+zMjU2Xh/3TVjLZ2K6ODlVGpMxzWQNX2j4ILSnjGnXwliB6CXJ3DFbQvT7iFdrv7VA9JAflI+Mj0R209X5vA4oaWhjOK1LuSd0NKyXGWK93BDrFYZYrzTEepUh1rghlrTrsG1tsN6PTgfBr4wK/kwQ/OK04F8cAr/U8B1fDfiJHf91/EsAvxAA/zVh5F/Hf20Y+dTHlZfW8ENgvy6MbOo+2GVh8OvjgsvD4Nd91CvC4Ndtw5Vh8McE/6ow+HUfdVcY/LqPtzsMft1HvToM/pTgXxMEv1SXzx7At7Od5bptuzYIfqWOf10Y/Lp9e30Q/ME6/vVh8OvzKjeEwa/b5xvD4Nft801h8Ou+z81B8IfqY+RqEPzhuv7sDYNfn6PYFwa/Pqe7Pwx+Xf9nw+DX9f+WMPh1/b81DH7dP7ktDH7dP7k9DH7dP3lDGPx6/3hHGPy6/3BnGPy6/3BXGPy6/bw7DH7dft4TBH+k7j/cGwa/bj/vC4Nft5/3h8Gv288HwuDX7eeDYfDr9vONYfDr9u2hMPh1+/ZwGPy6fXskDH7d/ryphp8sHLvCN/xCNr9e6B/XPYqnrbMy9OWKsoapu1GUOfP5/roH7huO06YKRC9J5s/nI/0+4tV4XFoqED3hh+WD8/k+bbnC64CSxnW4XKGzXKEzoKTNVu2w7jXEusUQ625DLMsy3mmIdbsh1l2GWLcaYu0xxLKU/awh1n0dilU1xLLUiVlDLEv92m+IZdm2LXVinyGWpY1+0BBr1hDLsu8Qnzqsb1Uc7ldoS5C0FUAbfSoOXfQb+fa+6o/WNXA5nwT/3cra2vXM9O7JVz9v/OKLp6fOu/ziXUnGYz6cWdXvd5oIC5S2MkcZkqS5eFesb+ByPuYHq3EFpfUozxYULG1JDas0yrw7hQfEkLpid3hn7XexrVCq5CkH0l+soYRmKrShhMhnRRj5lAuEj/ysUOTDOsx1V0gaS1B6AAvzr4AyYn68lufx3h/U/g8k89uRLIEvKGldyj2Rr+f9t6lsWDesp2HqYbCUV0+Ffl8Sst009FTTC61L603m17PlsqM89arZtl4lTbBkGSDqKeZfCWXE/Hgtz+O9v6z9H0jm6zTraa9SHryHevq92nVvSnl21n4X2wojI1o/xe0A5WS5jDpvOxD6fUlIvWu0A62eNHsisutTeB1Q0njqp0+h06fQGVDS2B1tB+tuQ6x9hlizhlj3dSjW7YZYdxli3WqItccQ6w5DLEu970R5ZfWDrWL5YKmr9xti3WaIZamrlmWsGmJ1att+2BDrWkMseYXIfqbgJ0nDV+L+fmftd7Gt8OjYDelJOfAe0u8jXm35afhKmlw1n1bksyqMfOr8rFL4WaXIR+pytZImWDLXgmMGzL8Kyoj58Vqex3tPrFXYAGH6wGOG1Up58B6OGU4qzC0b1g3rach6QHrCN95D+n1JyHZTzNQLrf33JvPr2VA+xTz1ivxKXfYraYIlWwChnmL+1VBGzI/X8jzeewrpKeo062m/Uh68h3o6QnqKdcN6GqQeSjO59VTo9yUh201DTzW9WKXIsTeZX8+G8inmqVfkV+pyjZImWDL1j3qK+fuhjJgfr+V5vHcu6SnqNH86tUYpD95DPT2rhtubUp6dtd/FtsLQoFaXdvgjpX6lnNzOUNZ2el3J3c6Efl8yXy9CtLO1xE+aHojsBhReB5Q01pEBhc6AQmdASeNxTTtYs4ZYewyx9hli3WGIVTXEut0Q605DrFlDrP2GWDcbYt1nhKXZ53b4uteILx/uN8SybNsPG2JZ2kLL9niXIZZlPT5iiGWpE5ayt2rbiXEZLXXibkOsTrUTlnwdCj7TUp928GRv2R5vMcSyLOMbDbE61Z+wLCO/H8CxZaH2vzeZ3/YMx9nTBaIn5cB7SL+PeLXlpzHO1uS6VpGryO4whdcBJY3H2YcpdA5T6AwoadxntIM1a4i1xxDLsoy3G2LdZYh1vyGWpewfNsRaqsfWsB4xxLLUif2GWHcbYs0aYt1niGUpe0tdtZR9p9ovS12dNcS60xDLsh4t9cuyDVnq172GWFVDLMsyzhpiWbZHyzJa+hOdWo+d6su90RCrU/0cSx9zyZ94bLQhSzthyZeVfvlrnldth68HjPjywVL2lj7AbA2L17sJvg9h59DKudfY8hxakDVYTebQtLV1vcl8PTSUTylPPSO/UpfrlDTBqn3WPGdNGOY/DMqI+fFansd7T6sJZYAwfeA1YeuU8uA9ka9fEzZW+9GbUp6dtd/F9sIoz4cKDaSNcjLUu1xHLCD9viSk3jXagVZPmn0R2a1XeB1I5usO68N6hc56hc4SVmdhPdsIK8uGSboPvcpz1vYW6Uk58B7S70uC2oVSllw1eynyOTyMfOprlA9X+DlckY/U5QYlTbA21n5jf4T5D4cyYn68lufx3iT1RxsgL7eBDUp58B72Ry9fNrdsWDesp2HqIf83H0K/LwnZbhp6qumF1v57k/n1bCifYp56RX6lLjcqaYK1qfYb9RTzb4AyYn68lufx3pWkp6jTrKcblfLgPdTT19Z+rE3S22ee9oy4mt1mGeJz3B6C1Hdpupi3PQj9viRk+2y0hw055Sry2RhEPlMzefQH+ZW63KSkCdYRtd/YHjD/Rigj5sdreR7v7aP2gG2H28MmpTx4D9vDDWS3sW5YT4PUQ7E4k1dPhX5fEtJONvRU0wut/+tN5tezIT/TeeoV+ZW6PEJJE6wja79RTzH/Jigj5sdreR7v3Ud6ijrN3+odoZQH76Ge3kHjXS7PztrvYlthuqTVpR3+eLFXkbUdfnmsV6kvO/yJUcE/Kgz+sOAfHQR/tF6/xwTBH6rL59gw+FOCf1wY/anzf3wQ/EpF8DcHwZ+u878lCP5gHX9rEPyJevvdFgR/rK7/J4SRT71+twfBnxkS/BPDyKfO/44w/Nft/0mAbzkXIfinBMEvVkQeJyeN0KWUSeiLL/I4yF9I+S9YnCa0+ggrlN+nlQ3553HfycAPyiAN6+QWsXqVtBB1elJGuZF+fwavXA4feA+chcrEh/2GWDcZYt1rhKX5tu3wdZ0hX5uM+NL833awjjTE6jLC8oGPBGyHr6OM+PLXR3co1jGGWMcaYh1niHW8IdZmQ6wtRlg+PFS142urIV/3VO342mbEl78+wRDLqu/w19sNsU40xNphhOUDz512Cpa8Qw473zU4Fna+qzIedr5rcCrsfNdQJex81+BI2PmuwUnx1aU/FBqoW9i/2Y0rBnN/Cyr0+4hXW34a47vjiB+WD6/fOV7hdUBJ4zZ6vELneIXOgJLGa3nbwXrQEKtqiHWHIdbthlj7DbH2GGLdaYg1a4h1X4diWerqrYZYs0ZYWr/dKbpq2R7vN8Tq1Pb4gCGWZRvqVNnfZohlaScs+9pZQyxL2VvKq1P1y9I3mTXEspT9oWAnHjbC8tc8hm2HrxsM+TrSiC9LLB9eX7Xj6yhDvqxk78PNhliWOsFz6e1gdRlh+WClEz7cZIh1vSGWpX5Z8mWlq51sC1cb8mWpq5b1aGlXO1VelrrKc6ud0rYt7dcjhliW/tcthliWcwqzhliWYwXLuUfx72Ue+xhIK9T+h30HUFzwO4BjwvCT+Q7gGEWu2npYQ36m8tQz8it1uVlJE6wttd+4th/zHw9lxPx4Lc/jvXfXKm6AMH3gtf2blfLgPZGvX9v/1q65ZcO6YT0NUw/5z4AV+n1J0HZTytKL4xQ5anohzw4oaezTb1bobFboaHXPa9/awbrbEGufIdZs1Q7rvg7Fut0Q6y5DrFsNsfYYYt1jiGXZhizr8UFDrKoh1v2GWLNVOyxL/bJsQ5Z29VCQ/Z2GWJY2Wmyh9h2Vof9R1L5zMsSvf3OwJUMWSJ/X4ki69l+wOE1o9RGWcdlKWWXLGrttAX42w3Ua1pYWsbRv40LU6eYkvdxIP+y3gEPlsN8CDg2H/RZwcEZ0fhvIs0Cy2x6kLkdz76Ui9PuI11Btajvxw/Lh8dCJCq8DShqv3TtRoXOiQmdASeN+ux2sBw2xqoZYdxhi3W6Itd8Qa48h1j2GWPcaYlnKvlN19X5DrFlDLEv9srQ5dxtiHQqyv9MQa9YQ674OxbJs27caYs0aYflrXpfbKbraqT6AJdZSv73Ub8fSdyz120v99lK//diUfafq6gOGWJbysrQ5lrK/zRDLsg1Z9tuzhlid6q92qn5Z+r6zhliWsj8U7MTDRliFZP76nHawNhtiWc2T++stRlg+8NrjdvhabcjXDUZ8+XCzIdZNRlj+emtih/VYl72/5m8n2sE60hDrKCMsHyzldYIRX5a66oNlG+pUve/UMj7WbaElXz4s9R3x9x0+3GiE5a8t1zxYyctfH23I1/WGfFn1tT5Y9o+W8urEvsOHRwyxLMd8txhiWb7TmTXEspyfsFyfw9+34dqwQu2/tl+8p7Oz9rvYXpgqED0pB95D+n3EqzE/pSy5blfkqu13b8jPZIHwkZ8dinykLk9S0gRL9snE79sw/w4oI+bHa3ke7/2k+9H/A4TpA3/fpu2VjvdEvstd/K/uuWXDumE9DVMP5dzftwn9viRouyll6YXW/jW9kGe1+uJ+P299aVi3G2LdZ4i1zxDrbkOsBw2xZg2x7u1QvvYbYu0xxHrYEOtaQ6xHDLEs5XWXIZZle7zfEGvWEMvSFlrW4y2GWJY2x1In7jTEspR9tUP5uscQy1InLH0Ty37bsh471X5Z6pdle5w1xLK00ZZYlvp1qyHWbA1Lxis4vinU/vfSc4XEdKw3WCB6Ug68h/T7iFdbfhpjPU2uOxS5tnK+mPAq15iGdBb7HC8f7jbE2meINWuIdV+HYt1uiHWXIdathlh7DLGszkbyoWqIZdke7zfEstQvS3ndYYhlqV+WbcjSrlrqxKwhVqe2bcv2aNmGHjTEsmyPh4J+3WmIZekDSF+7tpaG/jbuR4JpSCfL58fnJV+/8lyh9r+X+Csklj72WO79OoR+nyKTED7/yTnlKrI7ReF1QEnjtSunKHROUegMKGncN7WD9aAhVtUQ6w5DrNsNsfYbYu0xxLrHEOteQyxL2Xeqrt5viDVriGWpX5Y2525DrENB9ncaYs0aYt3XoViWbftWQ6xZIyx/zft1dIqudqoPYInVqf22pewtfQBLG23pT3Sqri712wevT1vyyVvDWvLJD55+LfmFB0+/OtEv9MFSXp2qqw8YYlnKy9LmWMr+NkMsyzZk2XfMGmJ16nioU/XL0vedNcSylP2hYCceNsIqJPPXOLXD1+sN+dpsxJe/Xm2IZfl+yFJeRxvydbMRXz7cZITlr7cmdlhWOuEDf9vcCbK3bNvW7dGqDfnrLUZYPli2x0NBv3i/oXawjjTEOsoIywdLeZ1gxJelLfTB0kZ3qt53ahkf632tJV8+LPkm8fcdPtxohGXpT/hgJS9/bemTX2/Il1Vf64Nl/2gpr07sO3x4xBDLck7hFkMsy/dWs4ZYlvNflusLeb+h1ZBWqP2Xdb5o6zydnbXfxfZC7n1chH5fMr+vMuSnvs53YzJfrqsVuYp8NoXhZ6JA+MjPJkU+UpdHKGmCJXYY9xvC/JugjGy3jwQ+eujeHy9/9P8AYfrA+w0doZQH74l8PeS3l88tG9YN62mYeijl3hdL6PclQdtNKUsvNipy1PRCnh1Q0ngOJ299aXV/b9UO625DrH2GWLOGWPd1KNbthlh3GWLdaoi1xxDrHkMsyzZkWY8PGmJVDbHuN8SaNcSy1C9Lvizr0ZIvSzthqROW9XinIZalvRe7Kr4V+wQ7a7+LbYWhIfFN0JcRn6o30X0TG9ql0QLRSxLdrxP6fcSrLT8Nv06rN5QP+3VHKrwOKGlch0cqdI5U6Awoadw228F6gyGWJV93G2H56xWJDZZ1GfcYYt1piHWfIdathliW8rrfEOshQ6x7DLFmDbEsZX+7IdZ+QyzLMj5siHWtIZbMR7Nv4cPO2n/XHVZGhyvl0eFyeWq6OD41PDIzVhkpViaGKmOTE6ViZag8OjUyXikWpyvTk4PFqeGxoanp8bGhyszE+NhIWN9haKw30ftXG/xSSfCPCoNfFvyjw+BXBH9zGPxBwd8SBn9I8LeGwR8Ou4dGqa7/p4TBHxX8x4fBr7evU8Pgjwv+E8LgTwn+E8PgTwt+MQz+jOCXguCXi4JfDoNft5+VMPh1+zkYBr9uP4fC4Nft53AY/Lr9HAmDX7efo2Hw6/ZzLAx+3X4+KQx+3X4+OQx+3X6eFgZ/QvCfEga/bp+fGga/bp+fFga/bp93BsGv1O3z6WHw6/b56WHw6/b5jDD4dft8Zhj8un07Kwx+3b6dHQa/bn+eEQa/bn+eGQa/bn/OCYM/KfjPCoNft2/nhsGv27fzwuDX7duzg+AP1u3Pc8Lg1+3Pc8Pg1+3P+WHw6/7hBWHw6/7hhWHw6/bzojD4dfv5vDD4df/w+WHw6/b5BWHw6/b5hWHw6/b5RWHw6/b5xWHw6/b5JWHw6/b5pWHw6/b5ZUHwh+r+58vD4Nft/yvC4Nft/yvD4Nft/6vC4Nft/3gY/Lr9nwiDX7f/k2Hw6/Z/Kgx+3f5PJ43QwK5MT7hXIUPjw6MTpZnx4ZnixODIaGV8ZmRkanxqbHB6ZKg4VZocLk2WSzOjo+NDQ+OTQ2Ol0sz02NDMaJ33GRW7ndB4b3FxCLmUZup24dWAXzDjf7SOf0kQ/GK9Xb0miHym6nb5tUrdlgenhifGiyMzI+PjozOuEy1PuX/DTmtmhsrjY5XJcadFUxPT4xOVybHy5FR5qjI96mzNdGVseHq60Wddaq03pWJd7q8LIvfG+4rLzOU+euCvX6b+5toiD9mj/XKg1UPluqL2W9bh+/CaaiPP5ZCO+b/V9+h/T+/tNXr9UJ4E6Pgg5e42L/cBuY4ViF6S6GuohH4f8WrLT2MNVTfxw/LhNVQ9Cq8DlOYDv1PvUej0KHQ0rEcMsfYYYt1jiDVriHWXIdZ+Q6zbDbEsy3irIVan6lfVEOteQ6z7DbEs9ctSXncYYlnql2UbutsQy1InZg2xZK1lbzK/L7Trm4eHpa/FcYcEScNxQ4HSXg35z6o28nHoot9YppUublrfwOV8zA/6TRcDfprP4IPIcTmkW/o4gt8bBr8isl+ZzJUpl6k3RVaSrv0XLE4TWn3JfLmH8A+1siH/3F5WAj8ogzSslS1i9SppIep0eUa5kX5/Bq9aOXh8o9kjzf+W/L0ZfGH+tQpteVZk2AdphjIsZ8kQ26LQXw18Tk1PXH3xeZdfnFDoIjmI3I6gfM+sNuTAOrgyBSuh30fQvS7AwxB2zHhw+wEpU6v9AMr2YkpbqN3zgW0Dy9wHX9c/prmFLqVMrENpcwtdkD6nra5s0Ptpjd4qoNmfQXMN8Y35fXhmdW7+tVC2LiVPP/Eo+XtWNljdUas/TXbCTy89/1jSZSlTq7qM9ci81eWcNOoR6zatXg6Dejl5fYNnprcmSS+H/J5W6Anvh1FeH6SO18F9wzmu3OcRCv0+4tW4H6r7MOuIH5aP2BbfD62qXV96+fjUGeNX7Lr60ullJMoBuEb4AYKTPJgXwwCwlKTk42r34YLq/Oc4iCh7iOcTwXQdXbtem8xv+rzNGfLQpdxj87xa4V+bfn11dW4aukPnUdryjLSVGWm9SrkkrQ+eew09t0rB9DxcurKBh7JNEl29xFxrck7TpTSsswkLn19HWOubYJ1PWPj8esI6vAnWhYSFzx9OWBuaYL2OsPD5DYS1sQnWZYSFz/OWP5uaYF1OWPg8HyV2RBOsKwgLn+etW49sgnUlYeHzvJ3cUU2wriIsfJ63bj26CdYuwsLneTu5Y5pg7SYsfP4Ywjq2CdbVhIXPH0tYxzXBmiEsfF6e7VewuEvGo4UNu8DcW4cJ/T7iNVSXfHwyX64oH37ttFnhdUBJY7u1WaGzWaGjYR1uiLXBEGujIdYmQ6wjDLGONMQ6yhDraEOsYwyx2G41668vqj76P6u/ludQdzFfF+TR+mjESPMHupL8fsEFxLNGU/MxX1udm4ZTcOyb4nTRAKXhVNo6SkMfk+0+TrOtp7RVkCblQR+zh8pzee1+2OF6sYi+YJqseNyi/U+SfNM52pRcP9G1oIPy4j5mwJAO+/VI5zBDOoh1VnUunfUKHdEbboM7a7+L7YWZPOVA+n2Jbld22vBTOnjbYQ7mng5Z7O0wtfEE6gq/ctDGDNr2mTh9cvH0bjeJ//Trnjd+8QrIiqaT2VlD+Q6n3xtS2NpJ+XiHLHFLmA/EwsB8ZE3PaPQ1syjXPcp9H7ThFruyre4kgs8fmUFnY5t0Nip0wu7K0Xize0wY/PpbQG2Ii2US+rzDmKRr/wWL04RWXzK/jkKYAa1sWfWMrm+eqYCjW8QKu9NKo06Pyig30u/P4FUrB75NQju3ruYberfubSvnYmu2IuzqkspwXn0U+ou1EjXvm3DNVZdnByjNBz7NQnsrvVyho2HdbYj1gCHWXYZY+w2x9hhiWZbRsh4ty7jPEMuyjHcaYt1jiHWHIdasIdb9hli3G2JZ6oRle7RsQ5Y6YSmvWw2x7jPEspT9LYZYlrK/1xDLUl6WtrBqiGUpr061hZbysrQ5h4LPZKkTs4ZYVrL317yTdafovaXsbzPEstR7yzJa2glLH8BSXg8bYuX5WlMb10t+bYW7Ni91qKxwH6J8Fivch+heV6KvcPfYP6avp4+mZ30IOx9bKReIHpcxIfp9xKtx/dfnrLRlS9q8p8juWIXXASWNT6PWljQdq9AZUNK4324H605DrHsMse4wxJo1xLrfEOt2QyxLnWAfsx2sPYZYljphKa9bDbEs5XWLIZalvB4wxLLU1f2GWIdCPd5riGUpL8t+qGqIZSmvTu2HLOVlae8t9cvS5li2R0udmDXEspK9v+Y5mE7Re0vZ32aIZan3lmW0tBOd6n89bIglczDaJy68tF4bwx6TQQefPyYHljYelvzaZyBZcz34WYo8G/YEpcZcj1Yf+NmO0F/IXI/IrUT5eK4HbdtxKVgJ/S7RvbS5Hl63dEttIivsCV76UnNer5j1aaL2ySTeY/3F59elYKXtCHB4osvqzpqsfL2fun4uZrPltvx5KPLE6wmPTKGPdd9Dee8D3orr02mFkKtGZ3WbdFYrdPqV5wop/4UO32M6Gs9CB9cQin74udK39jae4frqUp6VTyS5zr4Cu1e+o4apfUaZpr8FoIfrqM+uzs0vtnl50pAJ5mF9l/zvBZ3aQfp+OJUZy6nxLJi4KwXyLJ+IMw8fJPsUaC2wap+ElvYpUm+iyyNJ9DphvetV5KDR2d4mne0KnX7luXbbkcZz1ruEhdJBLGmTYXWj9V1NWM64OzOvO74E0ngHMdwVGd9xceii3ygL33YrOXZDCfsubfFkeBSloQy5jWPQZCiyyCvDtcl8GXLbXqeUQ2v3/L1Gq+1+YwYPSGctpfGnhpiG7bOP+OtS+OvK4K9PoRP224DWdXAjpaEObqI01MEjKA11kPX6tZDGn15eCmnLKe11kMa71OGu3n2UdjmktdoepF48vYuNdgtDP+fVlLZSwQ37aWOlkqdfQvp9xKstP4130Fr713ZVFNltUngdoDQfrq828nFal3JvWQbW7YZY9xli7TPEutsQ60FDrFlDrHs7lK/9hlh7DLEeNsS61hDrEUMsS3ndZYhl2R7vN8SaNcSytIWW9XiLIZZlPVraL0t53WOIVTXEspSXZRuy9Ccs5XWHIdaSXT14dtVK9v6a30F3it5byv42QyxLvbcso6WduNUQq1P91esMscRf5fktf43vU2QOALeis3wXfDD3HcEy8b4jKKtCyn/B4jTed2RTmLJl7juSpQc458dbDLaz74hgLda+I0dklBvp92fwqpXjcEOZ5DmdQptbarVuta1q5dnAbay+nuPwDDkh/Xa+3SlTPnm3uiyZX3dHpGAl9LtM99LWc2h7EuG76ok+nWd8V61t/8unIbwF3lVP16619wIDydw01DXZxi7s6S6tz/N3URrO86ft5ZUk+hy5lKnVUwjw+y4+hUAw004hWA7pmP+qvgYvT96qYxYAE79z4xMq5N0kriHAPMyD5L8GeOA1BJKnO6VcK1Mw7wJdvK5Px0wUTK1cfVQu5qGXeJD8N0K5nrq1gY955Dfa10urc3lbpdBKUu4hNj7LaVl0mz3rr/GECk5jXWF54fNpMmVdkfy3ZujKcoUHLC/XK/PAefpSeLhD4QG3PJy8/IrraidGJBT44Jsu+s1VyVWwXMFJC4Lvn7mrT8eR31nqh8tQVio0VqbwiM968Yj4pqYvnd49nSKgZUoBNGLLEj1oR0SILQ18Yljub1P55LblYfjJPLlN+4Zb26ZYntXeyfP6prx0VieNdXS7dl9+VZoucN3z754U+gXl+YSeLSj3kmTud86af8JlbvUUyV6Ff41OX5t0+nLSWd8mnfU56Wxsk85GhQ5jaf6qD1PVRjrm/xDY8dO36pjLUjDlyBTJr40htLUtkl+bAzlcKaO2t8GmpDltlCX3e0e0yGuzOQheO6SNZfPyevYi89rTIq99Cm3s+13ndsk101c95/Ld02himI2Errnf553OuTtbmcLqasrHy6B5eqiHfm+g36sU/rQgfGBgXrqS5kGaqMjqi9BEz0xpokmiN1FRex7+4rPa8Fdbpo9Ti2lLp9PMz0x1btkk/9czzI/2+UzWztzaJynapz7aqTnHUhrKCZfVH8CuzsesD9EgzdCNmfTyecbWBh8sn55qfln4wLLTTvbBz2t4q1/89OhoSsPlcvxJVDO9Yn3FZW/yLH5aIPV1HeTjrvH18LuL8iNNyX890NGGRPJsD+X/tjIkGlB4En566XlbnRmZFBnekMwPknZjMrfsmHYT5D+z2sjHQZvekTJ5WaxoYXoH65F5E0y0MVi3afXyfagXPmQS6b0+SS+H/O5S6LEsJd0HqeObCGNn7XexrTA0XiB6SaIPt4R+XzJftiGGWzcRPywfzW3IOGTyBrhG+BcTnOTBvBheDCwlKfm0aj9CeY6DiLKHeP4xzML9Hc0IY9Pns3GRhy7lHo8OuhX+NTrL26SzXKHDq6Z94MMsr0jml1XSroTn+ODJqyCND7Pclcwvl6TtzsC8OgPzmoy0PRlp1yppnqdLVzd4ZHOsNQ3+AhLrLq0dpGGdTVj4/E2EdXMTLD4gE5+/mbCqTbD4gEx8vkpYe5tg8QGZ+PxewtrXBIsPyMTn9xHW/iZYfEAmPr+fsGabYPEBmfj8LGHd0gSLD8jE528hrFubYPEBmfj8rYR1WxOsXYSFz99GWLc3wdpNWPj87YT1hiZYfEAmPv8GwrqjCdYMYeHzdxDWnU2wLiIsfP5OwrqrCRYfJofP30VYd2dg+WseZuHzdxPWPU2wjiIsfF6e7VewCrX/4n7dC/ft3J1S7q9ghH4f8WrLT8P9ujeZL1eUD89236fwOqCkYV+EaUjnPoWOhnWDIdZNhlg3G2JVDbH2GmLtM8Tab4g1a4h1iyHWrYZYtxli3W6I9QZDrDsMse40xLrLEIv7siy/3l/zV8yaXy/PoT3j6aEuegbzI0bauKELeL6pCc+bieeFjh/89RbCWuj4wV9vJayFjh/89cmEhc+zzd3XBOsUwsLnWxk/+OvHE9ZCxw/++lTCamf8cE11LlY744eXENZCxw/++gnJXKyFjh/89RMJa6HjB39dJKyFjh/8dYmwFjp+8Ndlwlro+MFfVwirnfHDIGFljR/ubYI1RFj4/L2EdV8TrGHCwufvI6z7m2CNEBY+fz9hPdAEa5Sw8PkHCOvBJlhjhIXPP0hYb2yC9STCwuffSFgPNcF6MmHh8w8R1sNNsE4jLHz+YcJ6JAPLhzOqc7Hw+UcI601N+HoK8YXPv4mw3twE66mEhc+/mbDe0gTraYSFz7+FsN7aBGsnYeHzbyWstzXBOp2w8Pm3Edbbm2A9nbDw+bcT1juaYJ1BWPj8OwjrnRlYPjy/OhcLn38nYb2rCdYzCAuffxdhvTvJLuOZyVwsfP7dhPWeJlhnERY+/x7Cem8Glg/T1blY+Px7CetnmvB1NvGFz/8MYb2vCdYzCAuffx9hvb8J1jMJC59/P2F9oAnWOYSFz3+AsD7YBOtZhIXPf5CwPtQE61zCwuc/RFgfboJ1HmHh8x8mrI9kYPkwVZ2Lhc9/hLA+2oSvZxNf+PxHCetnm2A9h7Dw+Z8lrI81wXouYeHzHyOsjzfBOp+w8PmPE9YnmmBdQFj4/CcI65NNsC4kLHz+k4T1qSZYFxEWPv8pwvp0E6znERY+/2nC+kwTrOcTFj7/GcL6bBOsFxAWPv9ZwvpcE6wXEhY+/znC+nwTrBcRFj7/ecL6QhOsFxMWPv8FwvpiE6yXEBY+/0XC+lITrJcSFj7/JcL6chOslxEWPv9lwvpKE6yXExY+/xXC+moTrFcQFj7/VcL6uSZYryQsfP7nCOtrTbBeRVj4vDzbr2AVav/l/dPX4b7d+57BUoHoSTnwHtLvI15t+Wm8f/p6Ml+uKB9+//QNhdcBJY3nHL+h0PmGQkfDutkQq2qItdcQa58h1n5DrFlDrFsMsW41xLrNEOt2Q6w3GGLdYYh1pyHWXYZYdxti3WuIdZ8h1v2GWA8YYj1oiPVGQ6yHDLEeNsR6xBDrTYZYbzbEeosh1lsNsd5miPV2Q6x3GGK90xDrXYZY7zbEeo8h1nsNsX7GEOt9hljvN8T6gCHWBw2xPmSI9WFDrI8YYn3UEOtnDbE+Zoj1cUOsTxhifdIQ61OGWJ82xPqMIdZnDbE+Z4j1eUOsLxhifdEQ60uGWF82xPqKIdZXDbF4zrHZOrnx2nXWOjl5rgpp/IlhFz2D+REjbR1eF/BcbcLzBPHcznq8ScLC5/cS1r4mWFOEhc+3uh7vCMLS1uNp38G9tjo37Qp4jr9huBLS+Nu6qyDtBkrD7+B4Xno3pN1EaVdD2s2Udg2kVSltD6TtpbRrIU1khN/ByfeRIqPLa/d7qWyigztrv4ttBu3kMpYj1lsh5X+SzJ9j94FtwOWQp0B0bjCkg1hnVh/9LzqK+svbZdxIdPge08Hnb0zBSjsp8kpIx/zX1+peOylSW5t8Bdx7ZkZZ5VnRKbZrO2u/i+2FkuDvDYNfybK/WCZugyi7VvQLafUlidqv7DSSXVbZkH/Wwyrwk2fdeLVFrF4lLUSd3pxRbs3marxq5Uhrm0gna9favRl8Yf6s/llkiH2koQzLWTLEtij0F7JrrcjtaMrHpxBrvg5jJfSbT3rsSvRdazXb1pvCp9BtZsfxecmXtYVFHruh0dF4Fjq4vwDuwvtm+lZe9A63/MDvWvgEYMn/nXUNzLfVMLXvbtLaSgHo4d4EvFWM0EvbKubKFP7eDf0e7+B5pVLmIzN4Fkzc/wF55hNjJf/7ye8K1EeqfpfQWkv8cv1wWbQ6Yb27XpFDmmx9QD8F/RjM/9EW/RTUb/ZTkCd5VhvrsRw0Oln95PU56fS1SadPodOuH6LR0XjmMZUPaE++SPZE9A7bFj4r38H3UP5fBXvylQx7wutT2HdiG8v2ROil2RPWT8n/jQx7ovnmF1TTeRZMtCfIM9sTyf9LZE+qydyy76z9LrYZNHsitLT+clWiyyNJ8vWXqxQ5hO4vVxGdmw3pIJa0Fc2XY/tTJTp8L8v+VKk8ae3126t1mlp7Rd3tofz3Q3v9A2qvqO8ic01vuI+6WaHLbSZJ5o/PfMiyZTenYOXtoyT/9zL6qKyxhg9ZY+msOUfMh3my5v+6Mmig3uJ98Y2x77yS8lYp780ZedPGjf56pnYddmw/Wpa2gHOYEiRtv8KzpOE3v8+rNvJx6KLfWCavKy/f2sDlfMxPFdL2p2Bq9oJ31ZcyL1Nw9xKupPUk8+Ul+2xx+/9prS349v9vq3U81hMfXlhLDDt+Ha1w/WLg+mX5cNDqV/j29XtXC/WLdThLaWizeW83tPWC4WXfWyPaqW1pIe3lrjbbiyZPfkeg9Z0ozx7CeHx/I8+q/rk8SR7uL3yQ9iNtVuTXrTzvA/t+kn9tjaaXzx9u1elntbck0e0CyoH3ZNyf6LxoZZa8J5E+Yhuz08fBktTjLcQz0r41EO0C0UsSfZ5X6Pcr/AjffUpadxu8DpVGRsrDg1NDMxPDo0ND0wXCF175Hs9RantBrFXyi6xvDyLrypS2JfRtIFcfuiHtVkrrgTTh0beh72ydy/9tgfjPI3+kP6DkP7vayNdKXQ4odHjM0Q7WzQvEWpfMbQNaX1iF57gv3AtpuA/oM1Psch5bJ7aN7T6Wk+3gWWTrsP8z1KFBzR9lW3dLINp5bZ3Q70/S67ZPSWvH1k0NDZYGZ8aGJqZmKtNTIzOFZH6f0KXcY1un6e0aJX9gW1HUbB3bs25Iu4XS0NYJj5qtC9MvVop55I/0B5T8bOvy1uWAQodtXTtYNy8QS2wd+kHsp1bhOfZT9yrlQVvH47JzySaF2fpenyNkm4r8+oBj6L0gJ5Yv4+A99JvxGZ6zkfwXgd9+fr/On5ThPIU/bU0Rluv5/en59ir5/FBZ/KiLp3df9Orxq6anLpqevGp6d1eis8dF5OLzcCqhfD50071r6DdP31xBONIFdyfNA6oEYmlVh9jc9b4Yhjx/RSbsSqK1s/a/2GbQho7c1YZ5jVfOPawQ+n3JfJULsXxEm9pE+XD3WA0jn6I/tJWnvn24uDpfNsyH6Iu2HX4h5b+Ul+9xN4G6yHqTZQLTTNY1YLIu7m/kZxuQZ8lWnlfxeA/zv5rS8NVZIQOfp0FeB+34qTS1g66OlCPsST/lknbSD+oTulFp+q8d3yD5q0p+7ZVQ1tIiTbdQl0RHtHqWZ7TX4f3Ea6uv/vsVOqHbVD+VB/WYXbxWXz1q+tvsFdq+lDaZ9gqtBOmYfx+8QruF6hOfRzkfKFe1kbZIbabcapvR6iGrzTRbsi8y1F6xvqA6N01rM5pcWXeuUHjQ+jlNd65IoePDZHXhdPh5yZfHT0E52OlCKbefIvQXy0+5MqdcRT43hpFPMY8t0uyn9jqV+xS0MdrwR3vdVwU+eLj4nppRyVq6kNVGtVfwB5YE0rAotL+V1R4WSgex5HiYntpvGbN8FHy1D/enPy9HwiyHZ7RlD1we1CHsgz5OfRC+jsl6/c9jrHOgD/rUAn2KkMsJm/UjfNQOPp/m765S+PLXr6tdSx3LVMxXoY6/nDLc9wHr5+tUP2gLtfoR2to0gjyLuMzjLwCP38xoe8jjL6Xk89eXJfPzsS1KEt3f4TrcC1hafsHrofy/lnPcIPoQ1gcqqeMGrH/2gfL2RywnzI8YYoMGKD/L0AfRiz8Dvfhdat+aHV1oG07zV9Nsf+DpybG8PorQ70tC+kwNH0U7CjBLJ6oK/5PV9PzNdEjyH5bMt/MDgFWtXeMnaXvpHvdRWT6ND2h7ftCvY2D5NL9ItsFHjDy2v1V91srUCe0mj15rdLJ8pusN6WB75s+99kKaYdsaFNnvAz41Hxnp+7gfytBFGFr+KvHP+PspvzzfnejLeaU9cL+3o/bu0ev4f1Lfm1VGH+TYx4LCU5eSp0o8y2uq5Sk8X0g8S/7/hb6al8fL8+ib4jIy/iRA8v8UME/fqvOZJPnsqPa6Dl/J1ZdZJfPlcgs9h68Fuc41bH41r+Hwdo1czmVwb0DB1l5N+7iz9rvYZhA8eXXbDTRuU/jpofz9a+by9QaSaZbMfLxdoYvbLA4Q3duJrtehvyUdEt5wPFAFTK6TKtFgPi+hdMm/HtrzYbVrbSkL9o9HrtFp4/jh1gxeb1F4xTazpzo3XfJvAnn9w1adV+QHeT1485O6by48Hihnda58NPuB+RdqP7SlA3spDfviKtHR5gaz+hh5fnlKfl6mKfm3Qz3L2CprXtPjS7+kzVvwHMD1UIasfqrZ6/VT1ui4aZ+XzVTnllfyPwnmOZ6wRqftA7bBYou0z06h/cPDGpgVkqE292Hp/2l1hUs3uF6y5vUGlOf5k4kQn1EhTa1/Zl+/mswvTzWDDj5fpfLgc8JrYH8299hV6PcpMgkxdt2bzJdr1judfUr+GzPy71fyV5X8OHZF25oQXRy77qd7Wba4mV14Vot2AeeOMf8vgV14NtkF5Is/k0ObsT7ReUmS7DoaUJ7n7ZBCjQvXU3luzChPq+9z8fnF+pR0PdFJ05uXkd4s9FPpD4DevDJDb/jdp/auW6uDPHPwWXVwZU46N7VJJ+9npo9lnbrcSKceAp26KsPPe6zLuWpIpwpp/Bn4XnielxbvJTp8L8tP2kvlSdObvWt0mnn1RvLfCHozm0NvtDpI22oJ6S7W2p/FsodZWJrvLfmrSv4sH0zTJW0+Wvu8U3Q77Oct+deTCP0+4tWWn4a/q80R7FNktzppzH2MT+8qlUfPnJ686rordnNlCOBAMlfI+wlQ8if0m5/zTHVTnhsVGj7gfiSoSAP0/F66z/h5eGqWt1m61gj3pZQzSfI1Qny+1b0V90M65n8bTKLk2Q8ClaeV/SBuTuG9SylDX8pzLHttD4xnZpRZ8r83o8y1x1PLfDaVOW1fN/zN+bqUMqxM9EUVgqHJ+PBkLu+t6hM+v1jOyuFEJ61z/3jK5HHaAtXXQDrmfw107p+izl1zvkOXP23vJyzXayBP2h4k3QqmD/whiuT/cq3sgSd+1G+qhJY2UYoL8r+6prlssupc8r8M6vzrOeo8q/1oe5pl2YqoHZnSdDGPjiP96B2Z7xXmCjmvI8PPZTkynDetUbfryGg8peVt1ZHBEQA7Mq2uGMHnJV/Y1VTleSua8a0ONqa0DRVxhUXWCI5XXzE+dwD4UagmO15hIfm/DU7MP2999Fqrqw0p/CVJvrrC5xdrdc8GohNiFtcHntFYbGc9TQdLtetmTtJftNhh8tdtkn81dJh/RR1m3lVkeWZqWeeTJN8Mf1Z7y9t+WEbdCqYPaRvhLqt98Rz2C9qh4sF7azeUu/MX+lmrKvqUtLY2BRqZKRWHh0cqM+Xx0emhYe4jhVe+l+eN3rFK/rAzRoPqpkD7QK4+dEPaXkrrgTR8M8gbZYRxzAan8sgf6Q8o+Xlj27x1aYklm1tUgeest5WLYcvyHpAh+VfWbFPejaex38r62vomek7beNoHtok+7Kz9b6ZJM02C0KvW8FYovPCXQZJ3Lcjlh1vnliVt5U93SnmxbImCkSY7prFMefa1yVzeqjl40yaeEOP6FD49xmKtQNHoHNMmnWMUOiHffCHNZv7YlrWNZ9DepL2RurraSMf8/zPQwDyhhql9/VtN5tLTJlazDiaQ52XlHedheyP5T4J21exgAixnlp6hP5Z1MIHkfwL5Y3vh+cWa0OIydyeN1b1oH8+pzi2D5D8W6rm0tjXMZ6VgvmJtA3OwRcxzUzCfC5gjGfq4KZlLr5WvxPl5XHWLvBjXb/1wpl1h8OsH+VylyALLJPTb/QoYaS3WV+ta2bLqGQ+p4zfTGtZVLWL1Kmkh6jTr60ik35/Bq1YO9is0OpsUmUj+3Rl8YX5pw6j78qzIEA//M5RhOau+8TBCob+Qw5lEbpsoHx/OhLLflYKV0O9NdK8r0Q9n8jbzLTU7r82bbEzhWXjge6z/+DzrfxibOTKjrZSWwL4Y88ihi34j376+f7Sugcv5EIP1OO2gU83mpmFoc7nN2r0P+DJCXnju2n35VdPnX3XJNeO7p8+6Zvqy3Yr+rqTysd7xjne7KC/vsiNp/DLzKvq9h35fq/DDgWWCoV/Jlxa09oHtcQdcL6R/wOcln0bn+DbpHK/QycLaoWBJ/quV/Mcr+aUcmr0UG4CHsIaw31obwj5D6C/EfovctlE+GXMtS9L7r2b2exvdS7Pfmq5ckcKn0G2mK5qPwFg4fpJFJ9iWeyj/fhoPhfFnx+qHUqCPITIL6zOMVQpET+SN95B+v8KP8N2npLUzP10erZRKo+4V+nRxsDg+Vcxqy3iP2/4eJf9JSn6R9bVhZK1u5LwH5OpDN6RdTWk9kIb9Cc9Ph7FPY7nkj/QHlPw8X5K3LjWssxeIJfPTaOOlbS+WbQprU1r3J3n3h72Qxgu58H0PzqVz0PxQKa/X23/f2sDlfMwr1ke1dq2NtbiusvxRH7LqSvJJXaG+xFhX2PY4aHUl5W21rrA+qrVrza/iutLG2Hgvq652Z9BZ3Sad1QqdrD47T5+q0dF4brZb1/tpPlLsHc6P47O7qo10zN8H86YfypiPRB4Ru5Do78LYRsvzOD+e5YtJ/o9lzI9LHvTvpJzMI5YZ58exHnl+XPJ/mvzBQOMAdX5caIX1B1u3RQVK2wv5z6o28nHQ7I2UydfxpvUNXM7H/KBOVgGf5bRbweJx+rTCj5Tz2mQu/9g2fOD3vvj8tYTVbMcvXhSPz+f5wgmxziesrHfvzXZ1v5CwtA8UBKvaBOt1hJW2SzvrlYZ1GWHh83sJa18TrMsJC5/nNWz7m2BdQVj4/H7Cmm2Cxbta4vNpO72kYV1FWFm77NzaBGsXYWmHumhz+dgv5dkVMMwBNaWWD25brF0BNblnLW6/TeF1QEnjOU7tULfbFDoa1lWGWDcZYl1tiHWtIdb1hlg3GmLdbIhVNcTaa4i1zxBrvyHWrCHWLYZYVxhiXUNY2joGzbatThpjoQPve84Yv2LX1ZdOJxTQnxQa+HtPCv0B5fkkAwufySoL+po854U7N2vvZwWP14z8FMZAT6W1d9pOnj7kOREg0Dv9ct5+tVPXVmjzGfLsgJLG48xW3mm2q+M+nFXV6ReU55MmWPIb3yVKPm2eFcvKY35pezgngRi8Zk/yr6nR1Xb6bDYW43cA2ngL+3XhZ20y317wdxjamFKb28f3hj50Q5qhXk9quxyifHqq+WXhA8su66QjrPsByo9y1Oa42K9qpldiR3msgM/inJhWl8cRTe3dEN7jPu04pWwanePbpHO8QicL6zgFK6v+st59Z+3WXIU0674irV1r8wILefctcjua8vG7b22uhbES+n003Wv27hvrdFcKn0K3ma7g81k6eUWbdK5Q6KTZeB/Q7+F5Xcl/Vs3Gh333OlrJ+u4x7Pdno7nfsaftmol89ylp7bxjnxktFycrM9PFocrExGRxKstmtLoD0TYlf9i15aPqO/YqyNWHbki7mdKwrxQetXfs1UD855E/0h9Q8vN4o9WdXC2w5B079iXSthfLNoW1KZ37jh3XhrTy3hbro1q71t4/cF1pfbbmT2p1dW0Gne1t0tmu0NH840LKf6HD95iOxnOz97YvozGVtlssPru72kjH/H8D721fmbEmmn1tbhOogz5wu8fdt/P075J/CsZw/N5W+zZzdzWdZ6GR9ztzyX8J+Rhh+nn9vW3Wd688X9Dqd6/aXgGBfRn1W3oJml3jb3BwDpbXUuyHNF5viHOkPD/Dc56Yhu+M9lCa9u5B0m6HNN6jA0+YQB3loNlm3Jzs4hbecaPe7KU0bY8NbW3UiXCNacIr32N9w+d3pTzHdiTwNy+lwG26/l2S9s03lol994WuC0JafYRlLbussmWth8L3dPyeTcO6qUWsXiUtRJ1enVFuzSZovGrl4PG81s5OVGQi+W/O4AvzaxuwLfZ8jSZDq/kakdsplI+/NUMdvCkFK6Hfp9C9tPmaZt+nPzyg85x3vyDJ/y3w494M1/wdD2JdnsxNuxzSbqhdh33HMzKhzauw7G4A2jwGulEpT96+VMrk9WpFC30p+k3IG2Ji/b0e8vD3+5L/A+DnPnmrjllIsue1WYfy7iEg+T+S4WtLnu6Ucl2VgvkN0MWPpeh6omBq5eK1n8zDLuJB8n8KyiXvPZMkUfvZy+H3pdW5vF2t0EpS7nFfcHVKWhbdZs/66+vgWuvrWV9fT/nlvXqaTFlXJP+XM3RFW9Ob9T6beeA8u1N4+JrCg+8nVtXSJy+/4rqUV6HdcM3mWatKroIrFZy0IGLwxZPmwDjyO0v9tNfISco9rgZ5FvfinJq+dHp32rviZQR2RQqxZYke8qzH67R1A6HX42XtN4Gy1NYl87oB7dujVuksdN0A68LlKfQLyvMJPVtQ7vlwwI9Z8ei1NhbluY9Wx6Ja42CstD2CpqqNdMz/exnrDXYBHxqmrLGW/JpfnLWRcbPxJX+fpo1TsmijLPPM6WfxWlXyo8/PaymQv2qLvJ69yLzuapHXtHYpfZgz0pdcM33Vcy7fPY1NhdlI6LqX7nEe/mxhdwqrqykfT3vzlmrcb3KfdI3CnxY008C8dCXNA58z8JfQRM9MaaJJojdRXj6ifeqnDem0adks9107bAkxeLmT5P+HDPNTTbLLxmq/V8lfhTy8pEk7LEj7lAJfoxzArjbSJF/g5U5T2nInLG9Pda4s9imywPwsu/1Kfpy25uVOOG3Nhxbh9LDQ1Iah+HqFXw1pdanpNZe3J6W8M9VGOub/SYb+aTLRtmqW/NqnLCgn1jGU7yyl4XPV2rWmf5IvsP5Na/qH5WX90z7FwfwsO+2zD3zFgUuXMT/KUdKqkCY0Nfsn9YFbLmqvtwsp/4VXvpe1tOC86lw6VUM6VUiT14LcnjRXzl+Xkrn58aB3bk9afpEzTrVo9ddD+Tcd9uh/PJScp559mHMg+GE6bWz7Nym8Mu0h2K78mNp1lvvGW3kfD7wXtqU/z69Dsd/hrdCrkMafzexVyin5fWAbJ/m3A5/dNT41W4LT6D50Q5qhLZlptS/T7GpWX9bsgPJq7Xogma+naefqIFYV7qX5QcsT3QfBrfUxfxHqiA8hxz5zL/F+fYu85/UNb4Jy/AVt5Y+y3Ec0tbrS7P5Akt4H5ql3rby3AM9afrQTmP80RfaM2ZPourQ/BfNpgMlbaTfDfE0K5tMBk30Vrf9EH5DbiPZZE/ap7I9gG7mN0pB37jdvBfqc91Kir32Omyh0kwx+teX4WfxWa9fcN7wYD6SuXfcSnrFdrGTV5eOU8uSty5syys9Y8lx3Ml9ftTZ0qyKv5x2mY/a0iPlCpX/VfJ3XVhu0X5ziG/jAvoEPbANvUvhCnyNry3P2D16ptNeDNoYsTRe1fhdlwf3uXkjLWtYg+bPGnNi/DCj5L6nOTctz1h3SWUi/9tWUswE1XH99JPEhZdP8MX99MaRj/ssy7LgmwyyZNxu3V2vX2rYO+ymtCmm4NPcAdnU+5sHQV5QP62uWLHxodbzO+op2cy+lZR35VFXo5NVXeRbPstTqkg9t1nQgr87wUme0g1p+9oEk//4cfhXykPWpRd75Aa2PuzXRaWO7RZnwAd+S/w057bnUS9hxVKmktQ+UK7ePLBn60KqPKDLL+rxfax+3UFoV0rjt7FV4yNt25FntkPdmW/6kHXGBOoM+Jtt6yf/mDFuvla2d/pXnGaqQxktkNdvRabrcKba+SmmarW92Ju3lOXyNKzP413SlqvDf6ruN64H/A9jVZF65D0bdY3m57q3fbXDdZ73b0Jak57UpaefOp9kUnreU/J9v0aZk6ZWlTdHOZj9484ydrVdVSkOb0qpeZfWBaINeluNIziw9ynr3lXfsl6VHXQpfVcDVPqP1YWftf7HNkOfITKxfw7mfoQLRE3ngPaTfp8jRkJ9SVr1W4d4yks/+MPwMepPHbcWHi6vzZcN8cHu6EXgXGV8IOLxcWzvq17en36e5JqGTtgZCaPB8wJ/A3NkfEWazLTOz2j6+X3/WGp1XxM06UnIfYGn5seyY//sZY0DNflbhXqs+HK/vyPt+/eYUOtpaAq1flvx/nXN8uDjv7Mulg/3OXmSW55091gG/B9J0FdsFtwHNR9PaKx6lqbUttAnIo/Dhwwzk4XmTWlKqPZBtUtm/+88W/bvD4F6r/TK3mSqk5RmLa/WQZTO0upm3JifDZjRb58MyrZdhXQMzzzqfLJlarPPJK9OzqzqveWUq+VdC+dPscF6ZSv5VGTLVZJQl02bv7FmmKG/+FLqZTHnZsja/mSVTyb8uQ6ba1gZZMpX8Gw6iTLHMt9BzaDOqcN2VzLd3fSnPDWRg7kvBzPI/GSOtLqsKHa7L4zPqsqqUa1/Ocu03Ktf+Fssl+bcHKtf1KeW6vsVy7WtSruupXJL/FKVcWh+WNq7V5lx84Ll/yf9EpV0eynNmPC+m+eFZ65ey9GUh45sizW1kbTmirVXX5ul4jdZTc+oAbkviQzekhdYB1GXWgSqkabq/0DnnASW/jJM1HUg77h7pLEQHTlkzN18VMAop/4Um3+N1atVkftlYTjiOwDkKHkfsB7paW+T80u66E93f5PUnkv8C0FdeW5v2af9F63TaaW2F5zQk/8y6BuYLatdZR88v1HajnNNs90uXbPcc2y0y02w3t+ks232FQkfbTkvb9kCePbCuob85/3uVZyW/5vNhfhzfYP7XZPhG2hwQyqmcgnk56P3r1s0tP9ajrHfy+fass6F9VcbYQRsLZH1C2GxuR/jJWm/B5ea62kN2QXs/wjJBXxXzs6+Kaa2MLbS1vSzD5Sn52QeX/DcpepZn7YPGX95+Ef1qtunWn5Pyux3t/U3Wtw8H7x1huazZ4hqpA4Ft8V5FFph/oe/FtPXwbKfRFleJTrPjsLJ0RZ71urKvVhna3FXaOwGkqa3B0N6dc1up1n4/DG2F181X4Zk8frvkf3OGXdTKkNUWmvWtWe8592c8VwXcXoXWztr/YnGmrSD0xG6tUHhJ6y/fDXL84Vad18I8ftsLWt9ZIDmhDTa0DcUC0UuS+WMF7pu0/manCT+Nd7LaPKDW7kQ+twThpzSD72SrQP/i6nzZpPkPmv+L45GPUN8ldNLezRUhHfN/Evyyj6VgJknrtlOe9bjfXj0XN8tW+NDue4UqpGW93+S1wVgnPBZv9m0Sr3OU/F8E25D1jaHwFXbt+MxBXxvL61+zjgqrKlioC/xeTZsL1tYr8lzwL2T4oVnrc29ukfe9Cu/czrntfCSHj9rO+twjIR3z/2aGb7BX4SHLN2jm6y10fS5uyXkAu9pIk3xL63P1bUmFZrO1cV8k2619Y5T1rlubU0Y+joJ0zP+9DP2rKjy0s/8JfweYd43wQf8WqFgqH+w5M36ngbrJ70K0dVHa2hT8Fu3NNf0LKceR0WLdp5U6FH3l0A3pmP+HNX3tg3LI/+42+JwZGS/NVMZnxofGp6YGJ8d5W3kfpM78NlNeH/5xXUNmIidrmfkg+D1h8Ovf/XZDWbuUMgl90aVlkL+Q8j9J9DGL0OojLOOylbLKhvzzXEE38SPXaVjdLWL1pqTttCl3vU67MsrN9NPya21A7i/PwMf8YtdRh5eTLFaEkUU5q96WA02hv5Bts+X3MZSPjzlDefekYCX0+xi615Xo22azXepP5pdbnglsU3JvJyr0+5Kg7aFuB3qIn7S2i9sJXnr5+FRtl082eVx1KE6E42Jz1dW7RbrH6rCMnhM3UOtCmc+CgqGJQDDXJnN5wGc1U9KVQjdJGurK5qMZllx3ZfCShlEgjP4MjKWms9R0lLDUdPI1HWtvvDw6OjxWnigOjkxNzkwNVpp549b0JyeGJwanJyaHS4PDlcHi1GLTn54YHBuZGJscKk4Vx0pji17+kfFRR31scHxwuDhZHBluZTQkuo+eFbd1zWtcrmAPKM9LPo0O6/CKDDpsMgtJw+tbnmR7iD2U/7Tam0JtJcdyeEbKsbs6H5N56FbK7AMfuCb5dwIPK7Y9ei3tFk03vt14+vpsXtkudydzaUv+c9Y3MM+qXUv9aN7tQKLbGUzDuhQZrUry1bvIJEn0euyh/DLrkVbvK6nckv85Sr2vpTyaDHoV/vBelv73pmBpdebDrqrO+/OAd57561P461L4k/yrlPxok4QfTTarKK2PsDU6WFas691UVsn/UqWs2myi0D4YuymjDHuqc8uNu3h3Kfm5PvqV/Kshj8hsgPJj3WhtdBWlId3lxINm41Ev+c2MNjOANkpzz1EGwmevUl67upssFYielA/vIf0+4tVYl0qt6ojIpz+MfIpZOtivyEf4WROEn2L9EPIBhbbwKl8xoV3B/P0gQ8yP1/I83rsBDsjy99fCc4I/QGk+yC7NBSWtS7m37CBhDShYKDepU9+OryRZ8MkE2n/B5XvMI9an6HyWjVgoHcQSP0prTz7urP0uthUqZSnHGqUcQhv1yq7tDI3ktXVCvy8J2pZLWTqM8pF609q+PDuQzNfh11cb+ZrpN9LRsO7vUKxZQ6w7DbHuMcSylNfthlh3GWLdaoi1xxDLsox3G2JZ8rXPEGvWEMuyHvcbYlm2ofsMsSzr0VJXHzTEmjXEutcQ6yFDLEu971SbY1nGhw2xrjXEesQQy1Jelr6JpX51ql9oqfed6stVDbHuMMQ6FHy5TtV7S99kqU9rDatTfblOtYWWvpylLbSsR0t5dar/dZ0hVqf6X7cYYlm2bcs2ZCkvy37Isg11quwt7ZflvNysIVan6pel79upPmYn9h3+mt9ZWfQda1Ow8Trr3bBGp6DwrL1TXgYYvcn88lq+Vxb8dYHwpdyHKbLCMgl9fscs6dp/weI0odVHWMZlK2WVLetdNL53RxmkYR3WIlavkhaiTgcyyo30+zN41crRbyiTHkMsXhuktX/t/a3kX6fk1/RkrUJbnpW6XQ9phnVbzqpbtBFCfyFfGYncXkD5ZEfhZcn8tnFYClZCv19A97oAD8Ni2Xf+LWtrcE3vpdVH/x+8NRLDlQLRkzInVK7HyhqJG6qNfO36DG80xLKco581xOrU+YxZQyzLd8Wd+t6mU+e43mCINWuI1ak6sfRO4+DJ3lJetxhiWZbRcj5j1hCrU9eeWer9bYZYnTrfP2uIteR/PTZstGVfe7Mh1qFgCzv1ndleQ6wHDLE6dV7dsk9beg/RGtahsH7Asg116tqzpb7jsdF33GKIdSist1iaUzh4srcso+U3CZ06HrKUveV66k6dL7T0c5bsxMHzJ5bsxMGTfafaCfG/+B2xDztr/4vthXJCdPk9NtLl9R6SjjyGWW9UmSgQPZEn3kP6fcSrLT+N99ja2g9t3YnIbr3C6wCl+XBjtZGP07qUe8sysKqGWLcbYt1hiDVriLXfEGuPIdb9hlh3G2JZlnGfIZZlGe80xLrHEOsBQyxL/Zo1xLLUL0tbaMnXXYZYlnp/KOjEbYZYlvp1nyGWZRktZX+LIZal3t9riLVkJx4bdsKyjA8ZYln6E7OGWJayf9gQa6kNtYZ1syHWUhs6eLK3HLtbjpEfqWHJHAnOqRRq/xfj+xikJ+XAe0i/j3g15qeUJdd1ilxFdocrvA4oabxPPcoVy7SQutW+J+Lf2vcysn9rL/Hrw87a/2JboTIkctpAfCHdjXD/YOiY0O8jXkPp2Ebih+XDOrZJ4XVASZP6W5vM1z/WscMVHg5XeNB0TPKF05tihcurzZNzeVEWG6i8m5TybsooLz6/KYPOujbprMtJJ0R5epXndtb+F9sLg4J9RPvYQ3xD2gWeS4DnWHx1w1xZ4TkVXfRsAWTVQ/m3bWxgfr2GyWffJMl8e7YM7tvZj/wnwAv9PuI1lD1bRvywfNiedSm8DlCaD9dXG/k4rUu5l4V1uyHWfYZY+wyx7jbEetAQa9YQ694O5Wu/IdYeQ6xqh/J1vyGWpd5b8mUp+zsMsSzr0VL2txhiWZbxYUOsaw2xHjHEspTXXYZYndq2Zw2xxJ8Qvx/9RznLRDs/jc/KwjPiEAPTkL+sU6rx+e6U57gc4v/yWX87a7+L7YWS4K8Mg1/fj6fZOYFCXztPr5DyX7A4TWj1EZa17LLKhvyzHuB4m/ft0bBWtIgV+LTvep1mnT+G9PszeNXKwWdGau2soMhE7q/M4Avzr1Voy7MiQz5jcGftd7G9UM6SIbZFob+QvYxEbsdTPjkXblkyXwdXpGAl9Pt4utcFeBiyzuktKPhZ9TuQ8rwPWefn9ivPSfnwvMsjIX0l0ThS4fHIDB7xecmn0Sm0Saeg0GEsbY7Gh6lqIx3zP742R6OdW3mUwl9B4U/uH63kPwryCD+abI7O8ZwP/Qot4Una8TFw39oWIj3hF+8h/T7i1Zifep90DPHD8uG2cazC64CSxnbhWIXOsQodDeso4gF1a5Hqr7zQ+jsqDD+Z9XeUItdW628tyfXYIOUoTQtfxyXzg6QdD7RZFzZDGrYVDl30G8vk7VfftgYu52N+UMeEt16FVzs5lYtc3kThawvce1N1Pv9JhiyOB1kc14IsUL+3UBrWx1ZKQ33aRmnHQdoJlMb+hPY/Sea3TR/YxmTp1VGGdFBGRxOdow3poLyPJTrHGtLBupO6WpvMrztsJ9zGu5R7TOcYhY6UB319fP80uVGnib4NPiv7dfZQ/sdtbWDO1DCljW8BvgzbeP180a3J/CBp24D28ZR2AqSxPm+HNNbBEyEN65aDZjdEFt5unNaC3dgMadz+s/r3QP5Q7v5d6C9W/57lF/uQ1b/Ls1q75ffdKFcsUxoPmo+4UHsX1sfIX7dCf7F872NzylXzg44lmWMar83QfOksHrL88qMUHjQ6R7dJ5+icdJbK0znlkT5U7P/Ta0rp+9CHNs7NI9/gvvSYRp5HKI+sn9t/ZCPPmymPrFF6J6wXeWvtmvs+H15dnZt2IqSdR2k7lDSP/ye1hTUi15Nqefw1zwedBBhdyr2s+aCTUrC6AasXsNiXkfxfIf/lZMC1s2vDIyK3U4AntvGPD0Q7r40X+v0KP8J3n5LW3QavM5OjxUpxeHhqenhwYmhwpkD4wivf4zmyU5X82j7iIusnJEFkXa6f+1Ft4J8KcvWhG9IeT2k9kCY8er3/zta5/J8aiP888kf6A0r+86EMrdRlSCy0BxZYKxaItS6Z257Q5oS1QeUJzQZJ0No8v0/ENibjyoKCpY2FpEwe8/ktjIXQziNvXA6t/5B3NGuT+XI9hbAe3wTrbMI6ReGrX8FiGx+m3eb344W+ZsdD+PGaXdbahcjuCQqvA0raKYsi1/I084VB0p4ItFGeHLR2IXz7dvGGFtoF6h/ST5M56rLY1LVJul3n57i95fFnAun64EJ1/ZQw/GTqOspnobqOdot1sUu5tywD6yRDLNEbzdfn7w9a9fXXKTyH9ZPLU1o/J0Grs1Mo7Ykp5eeg2QEpk7cD9y+wf3wCpR2Efmj4UOqHfJCzndptT4caltbWCin/hQ7fYzqo0+yTPQ6ew3ciXZsaz+Bz+E4En72w2kjH/FfCPMzyGqZmF4VHaYdFSLPT+0pJyl1K5gdJKwPtI+Cag2avhO9W34liOy9TGtZfhdKwPQ5SGtrdIUorKvwsVL+wrvL4/Aulo/ljodsL9x1PMKSDdSd1tTaZX3fsmzyR6PA9pnOSQqdZ+9+6SaeZ1v5fV22kY/5xaP/ba5i9ShkPZhsvUloF0lifByGNdXAI0rBuOWh2Q2TR6jtRrFspU9i5vPIM25dE4QvtC8+fl4CvzXDNQZMTzv19aIH2lesb27vwtjaZL0OeG2m1vz9FKYdGZ12bdNYpdAK3uaJW7xK0eucxQjml/ByatZ1Wxggo8xKlZY3fw8gw/xhB6C/W+F3rb7LG70WFV/YVfGD/uajQKSp0DnUszf4WUv4LHb7HdFCnuW2m+QgvIR9Bnss7RpD8zwUf4eU0RtDm86Qdos0wtGUV9gMwaH5Aq2ME4bvVMUK7vr6/HqY0tMkjlFZW+FmofmFdLbZPHbq9sD8RamzFvonWnxYoTejwvSzfhPvCtPZ/3SadZt4xguR/GrT/G2iMgGU8mG2cx+Sary9pw5DGOjgCaVi3HDS7IbJodYyAdYtlQt674R6O2Z9bffR/D+W/s1ZPvs7esGkuvccBDaF9YE7piLn5tPYYdv4n/zc1Qr8vmd/eQ/hYml+gjek1uy3PDihp+M3kQuyCZmM6bY6O1y3j+B3rjUOz+bu+BbYxHocjP4ZyGmQ7lSh8DcG9Vr/vqIAsWvFTQvoi/nqU0ioKP3nauQ+s75ruPNb8B619tUsH607qam0yv+7YTykTHb6X5adwn4x+JPopn9+k00Q/BZ/lNZGS//Hgp3yJ/JRAY5GW2jjq70J9EUkbhTSsWw7NxjenLXB8g2VC3vP6KZL/V6ieAvkVRZ6z0mS65O+E93dOhWu2ca36Ozx32in+Dn8fczD8HWyrS/5OI23J39HpHKr+DrYTTBM6zfwdrZ1p7yjQ3/m3HP4OPpvm7xwJ/s5/Uj8a5t1inP4OvpNc6LwM241mcygFop3mFz2n+uh/nr9ZeUQDc/kR6Xw9DmhXl+ZvOEQ1fyN1uTR/M58fbG9L/kwjbcmf0ekcqv4MthNMEzrN/BmtnTWbvxk8QqfZ6vzNcvBnRmqYS/M3cwPKYjHnb9hPkfxnUT0dzPmbrO8GAvkXuf0dXhMU+rsBbU1Q1ncDedYE+etT4ZptaSvrZVAfO2k9pL/m+Rtsn61+J4djj1b8HZSz8Bb4nXuZfYFE4Qt9gVb9HXw/vtC199br69GGh+63F2vt/WN1/c7axN4eae2Mxxw+oL9z5RE6zbR1NezvSP4fwRh/N/WjyNfBauOov+wnafrc6pqbvHZDZNGqv4O+LNuNZnMoUg/opxnWw5jwMZbMD5L2JKCN39Jy0GQmfHuZ7T6hgcv5mCbakSdRGurkkykN7cJplIb1/RRKw7b8VEpD2/k0SsPxwE5KQ/09ndJQf59Oaai/Z1Aa6u+ZlIZ+/lm1607TH26rT4a0UyntNEhr9TsZ1Luf397A5XzMK+q38L06aexpd/H07nOnr3vB+KWXTI3vvuTyyy6cvvLq6V27uwmWu9RT6fcTUthFnCSDXR+WUdrJlC7bSi1L9NCvPCc0RG3G4P7BGK4I/b5kfvWEGK6MET8sHx6uPEnhdUBJ4+UsT1LoPEmho2GJrmhL3/k4QW2Ll1My6GxQeO40E7KB0tCEtNM9LXQZn/DWq/BjKKdJNouJwtdT4F6rw6IngyxaGRahzLlbRZ3hbhVtC3erWN87Ke3JCj957IkPrO+a7mTZxYXSQRnxtPaoIR2U9xjRGTOkg3UndbU2sbd7WjtrNiz6dRoWNduSgIdFkv/7MCz6LXLHw3xK11obR/2VtKdCGuvz0yCNdXAnpGHdctDshsiinWER2w3cVvO11blpuKX0SfTcDkjD4dSf0CvprZBvO2Fsg7QTKQ23wd4B+J+pzdWxDv056NC/kF6iT5jVN0t+7fPeU5XyattS8RRnoGF9R+mvpJ0Oae1sL9Z9YgOX80nQ6lnbGg/tj2yzp7WLxwOu2DWevvl30LGuI+fS1l67od6xjlWU/NprPW0KTJ7ttM8ueeoIh9c8HMXhNU8d4fCapxyx30WZcGj2Gi2vjnE9a9ONeXWsCLhXko7VeYNXohuJ9mAT2qxjQ0p+rC/e8gD1SJ7tVZ4z1LGhfoVXCZqu8LReq7qi+cSst+hXoUw4aDomcmpFxzbmsCXYJ7GOaUsS8TU969jRoGMn5dAxbWuLvDom/eySjs1NW2wdOymHjqFPxDqmfeaDS1tZx54AOnZaDh3L8seW7FgjrZN17LRAdow/F9N8pyz90fQNXxmwr4WvIeTZTlp6iPIJ4U9l6VZe/cGljnn0p0B0BBfrx4cs/0qe1bZCOCUnbhYfWf2gpuvaUl/Nn+flffjcE1PopH06wFs6SP4X1tomHvMp9YFHAAht2YK+G9IM3wMMez6eAXywDHuqc8udNV7yodU2LzIbSOb3C7z8G+uA213aZwEvSdmKA/k5KYP/VvVJ47GTlg9p9iXv0oJTKa1VW5fXZuFypVZslrb0Lq/Nkme1LR7zzmdk8ZGlY1mfSGg6hv0zL9HB505NoYM2C8vGNkvyX5fTZuE2VD50Q1pom4UyZJultXltaVLeNi8yG6D8WDetLHNCTNxiWOoU539XEq8nJvN5PVEp24Dy/IkpWHmPRJL876rph9g5nJO2q/fGkUjY9sQOCO2TAtEuED2RN95D+v0KP8J3n5IW4kikvFvoS/6TlfxrlPxh3wnpRyLh3LgP3ZB2EqVh+8d3NXwkUqCju8p55I/0B5T8fIxRq8chhMBCe2CBtWKBWOuS+fZTbM5i2cywtq48qtk6CZpt4aOXsC3Lu+KCgqX5X1KmVo9e0t5TFpRyaDLno5e095pZeoJYZxPW4zL4OrkJFh99o7XffuU57pcCrePKfbSN0O9L5tdViHVlzeTK68q04820NRGoF5iGdLLWe2nLjy2wRC80/V1HdHYodHZk0MHnJV9Yf6c8rtkRCVqd8bqBx6eUn4Nmf6RMrW5bjTLnrXpPUp4N3DZzb1vNbTNMnWa3Ta2fbaVt+sBbOi+0PR1qWKHX3/GYBNca4Tqy79B7A3kO5wvwWd62WvKfA8cQf7eGqdlFPsYSx8qGtqzlI/la3bYa18y0so406/gRrD+eN8jakjjPcTnIz0L1C+sqbcxrQSfL3wrVXrjvOMWQjnYMqLZ+jf2cVo+e3aHQadb+/+dInWZa++f5Qsk/Bu3//2huKNBRfC23cZ7LxvdArM8498c6mLaFJwfNbuARfqct0M/hrf/DzMmUJ9m+JApfaF/4aBucs94M1xyarbf90ALtK9c3tndet6D5tQvt709UyqHRWdcmnXUKnU47/pLHCAfj+EvtqKE84/dA20bkHiMI/cUav2v9Tdb4/VSFV/YVfGD/+VSFjrZe91DH0uxvIeW/0OF7WVsXcNtM8xHKRzWewefyjhEk/w7wEYZqmNrcrfDYacd0tTpGwKO4jlugvVqIr++vF7J1B/KzUP3KOjoptE8dur2wPxFqbJV1HB77Jq0eh3eiQqdZ+7/gKJ1m3jGC5N8E7f95NczAW6i23MZ5TK75+tr6mjxHY+a1GwvdQhXrFsuEvOOWYzhm5y3jJf9krZ58nY0fNZfedqAhtA/MKVG+g3DEeO5v74V+zEeM+2veGnWhx29jXXbaHB1vjYrj93a+eetbYBvjcXgnbCHrQ6vfxOM2sUvHdC8d051FJ+8x3eynaOsjn5hBR2tnmh+Jfsq9R+k08271Xt+WE/yUB8hPCTQWOaSO6da+ZyoQ73n9FMn/LqqnQH6FujUqy3TJ3wnv7+BcLtu4Vv0dnjvtFH+Ht0Y9GP5O1pHDS/7Okr+z5O/MbyeYJnSa+TtaO+Mxhw/o7/xGDn9HW9fI/s6/Ht3A/Bb1o4H2AIrS31noHkDoy7LdaDaHUiDaaX4Rbxkv+b8P8zffPSqdr+1A+0VHz8235M/ENX8jdbk0fzOfH2xvS/5MI23Jn9HpHKr+DLYTTBM6zfwZrZ01m79ZfbROs9X5m++CP7O2dr00fzM3oCwWc/6G/RTJfyzV08Gcv8n6biCQf5Hb3+E1QaG/G9DWBGV9N3Cqwqtm43j+RvOrTlXoaFg8f9MJ6yH9Nc/fYPvEeuPQbOzRir+DchbeOukIIB9a9Xfw/fhC195br69HGx66316stfeP1fU7axN7e6S1Mx5z+ID+zjlH6zTT1tWwvyP5fx38nfOoHw3znVvrx3yxT4vrU1ifW11zk9duiCxa9XfQl2W70WwOReoB/TRDv3NY+BhO5gdJw3158PtXDprMhO9Wj7ZBO8LHn2btE492gfc4PhSPy+k0/eG2invY8XcyuIddq9/JoN61crQN6rfwvTpp+Wgb7lL5s7NTUtht52gb3vYh79E2WVvj4HZdB2O4IvT7kvnVE2K4Mkz8sHx4uDKi8DqgpPFylhGFzohCR8MSXdGWvvPRNq1uW7JB4bnTTAgfbYMmpJ3uaaHL+IS3TjoCyIdWh0V4zE8rwyKUOXerqDPcraJt4W4V6zvtuBzkJ4898YH1XdOdLLu4UDooI57WHjKkg/Lmk1KHDelg3UldrU3s7Z7WzpoNi95Lw6JmWxLwsEjyfwGGRe8ndzzMp3StH/PF7i8e1cT6jCcFsg7icSNYtxw0uyGyaGdYxHZjK+Tno222wXM76Dk8egaHU5+hV9LHQr6thHE8pG2jtC2QdgLgv/W4R69Zh74EOvQrpJd5tzuS/NrnvScr5dW2neIpzjDD+s7SX0nD43JanTbFIX/erdR/JcX+CA22P7zF7HaFX7RrPH3zm6Bj30l5BYa0taMaJX+zbWVZx3DYLM922meXPHWEw2sejmrbTGvD6zxbHufVMXyNllfHvpMy9Sc0WtGxUwH3HNIx4e37oGP/RLRLTWizjjXbKpe3PFjaHnuu/8My4aDpWKvbY2v1rNmSvMeO4FbZq1N07EegY4Vj5tIuNaHdqo5JP7ukY3PTFlvHuJ41HdO2/NTG4ahjsrSVdWw5fJpzeA4dy/LHluxYI62TdezwHDq2EDvGn4tpvlOW/mRtMa/5WvgaAo/64OcO5rIkXqpl6U9l6VZe/cGljq0cE6Etp83rX8mz2lYIJ+bEzeIjqx/UdF1b6qv587y8D597fAqdtE8HeEsHyf/EWttsdkwEHs3qQzekGb4HUI+JQBn2VOeWO2u85EOrbV5kNpDM7xdOpTSsA253aZ8FlFO24kB+dmTw36o+aTx20vIhzb7kXVrArytbtXV5bRYuV2rFZmlL7/LaLDxa5H9StnhthpvFR5aOaWNZlBnrGPbPp1IaPpe2RAdtFpaNbZbkvyCnzcJtqHzohrTQNgtlyDYr64hsH1pt8yKzrC2cWlnmhJi4xbDU6TbIx8c0bEvm87pNKZt2TMO2FKy8R9tI/mtr+iF2Duek7eq9cbQNtj2xA2HfU+Q/2oa3iNOWO2nbE4Y42ibvu3DJr225v0bJL7IOszZBP9oG33v40A1pJ1Iatn/hUTvaJtARTOU88kf6A0p+Po6m1XUNIbDQHlhgrVgglhxtg/ZTbM5i2cywtq48pNk6CZpt4aNtsC23erSNlKnVo21Q5vwefDvRZJnz0Tbae80sPUGsswlLGxv0K1jcl4SxD8Vy3r5E6C/Wdraa/c/azlY7Wkpb/7F9UeTa+nFQKE8OWrvAI5/esMD3/ny0kiZz1GU+WknrP/g5bm95/KZAup776CXW9e1h+MnUde0dXqu6jnaLdTFrfaWGtc0Qi9//IDZvq95q/7hO4TmsP14e0fo5CVqdbae0k1LKz6HZ+p/7F9g/8lqPg9AP5d5W/bHQD/nAW44vtD0dalhaWyuk/Bc6fI/poE6zT7YVnsN1jt+k91ratur4bNq26sXjG5i/WMPU7CIfIxfo07AJfu+GQdJwXq/VbdVxTVcr65y1LeZZF/w1z2the+R3oXmOc0J+FqpfWFd5fP6F0tH8sdDtZbHWbfNxjVh37Ju0esTtNoVOs/b/Z8foNNPaP89nS/7N0P5/QHOXgY6KbLmN87sWfE/J+oxz06yDODfd6rcieMTkaQv0c/CdAPNgKN8xti+JwhfaFz56Cd+pbIZrDpqccI7xQwu0r1zf2jGd2lG9PDfSan+/XSmHRmddm3TWKXQ67XhWHiMcjONZUeb8TjVr/B5GhvnHCEJ/scbvzd7J8hhBO+qTfQUf2H/WvlnQ1pMf6lia/S2k/Bc6fC9raw1um2k+wpHHNp7B5/KOEST/GvARjqlhavPJwmOnHSPX6hgBj4pb6LeQC/H1/TWvwcyztQzys1D9wrpabJ86dHtZ7GNgtbUp7Ju0elzjdoVOs/Y/eqxOM+8YQfL/5LgG5pNrmIG3y2q5jfOYXPP1tfVfeY5uzWs3FrrFr7ZetEC845Z4OGbnIw0k/7Nq9eTr7JnHzqW3FWjgd5LfpHxZW9mFmf/JvzeE0F+srew0vyBrK7tTFF617at64HohdkGzMZ02R8db9+L4vZ1vMhe6dS+Pw5EfQzm1tMWxD63u2XAqyGLpGPmlY+Sz6OQ9Rp79lFaPkdfameZHop9yzbE6TfRT8Fleeyn5/x78lOvIT1k6Rr6RZ6HHyKPvjmVC3vP6KZL/NqqnQH6FunUvy3TJ3wnv7+BcLtu4Vv0dnjvtFH+Ht+49GP4OttUlf6eRtuTv6HQOVX8H2wmmCZ1m/o7WzrR3FOjvfDqHv5O1R5Xk/0Pwdz5H/Wigd4tR+jv4TnKh8zJsN5rNoRSIdppfxEcaSP5fhvmbXzw2na+tQPtpx83Nt+TPxDV/I3W5NH8znx9sb0v+TCNtyZ/R6Ryq/gy2E0wTOs38Ga2dNZu/+ZHR/M0vgj/zH0vzNwdCp8zfsJ9Sz1+rs06Yv8n6biCQf5Hb3+E1QaG/G9DWBGV9N5BnTZC/5vmbha6XQX3spPWQ/prnb7B9tvqdHI49WvF3UM7CW+B37i0dUeVDq/4Ovh9f6Np7tr8h19wgP3nauQ9Z/fZirb1/rK7fWZvY2yOtnfGYwwf0d4rH6TTT1tWwvyP5PwX+ToX60UDfBbd8DB37tLg+hfW51TU3ee0Gfmt82gLHjGw3ms2hSD2gn2ZXD5WK8FFJ5gdJw32j8FtaDprMhG8vs1aOXkI7wsfzok7yHtxoF3gPbqzvQ+U4p07TH26ruMcifyeDeyy2+p0M6l0rRy+hfgvfq5OWj17iLpU/O3tcCrvtHL10AqWfV52fD0O/8pzQELXB7eQOxnBF6Pcl86snxHClQvywfHi4MqjwOqCk8XKWQYXOoEJHwxJd0Za+89FL2hYv2zPobFB47jQTwkcvoQlpp3ta6DI+4a1X4cdQTi0dUeVDq8MiPIaqlWERypy7VdQZ7lbRtnC3ivWddpwT8pPHnvjA+q7pTpZdXCgdlBFPa5cN6aC8+STfiiEdrDupq7WJvd3T2lmzYdEdNCxqtiUBD4sk/zthWHQ3ueNhPqVr/Rg6dn/xKDHWZzzJknUQj8PBuuWg2Q2RRTvDIrYbx0J+Pnop79FIOJx6K72S7oZ8xxLGMZB2PKUdB2lbAP+Hmx+9Zh16N+jQx0kv8253JPm1z3t3KOXVtqXiKc4ww/rO0l9Jw+Oc2tleLO9W/x9PsT9Cg+0Pb4G8VeEX7RpP33wGdOybRNt622PWMW0r3U777JKnjnB4zcNRHF7z1FGrW3Ln1TF8jZZXx76ZMvUnNFrRsZMBt0g6Jrz9MujY7xHtJzShzTrWbCtn3vJgafv2uf4Py4SDpmOtbt+u1bNmS7BPYh3TliTia3rWsT8GHfubHDqmbW2RV8eWjgjoDB37mxw6tpDjAj6domP/CDr24xw6luWPLdmxRlon69iPA9kx/lxM852y9CfrCATN18LXEHgUDT93MJcl8VItS38qS7fy6o/IKa/+FIiO4GL9+JDlX8mz2lYI23PiZvGR1Q9quq4t9dX8eV7eh8+dlEIn7dMB3tJB8m+sDbB9fZxeY0bqA48awKODfeiGNMP3AOoxJijDnurccmeNl3xotc2LzAaS+f0CL//GOuB2l/ZZwJEpW3EgP9sy+G9VnzQeO2n5kGZf8i4t4NeVrdq6vDYLlyu1YrO0pXd5bZY8q23xmHc+I4uPLB3L+kRC0zHsn3mJDj6XtkQn73Fxkn80p83Cbah86Ia00DYLZcg2K+sIdx9abfMis6wtnFpZ5oSYuMWw1CnO/64kXo9P5vN6vFI27RiR41Ow8h69JPlfWbsQO7cFcO3qvXH0ErY9sQNCe1sg2gWiJ/LGe0i/X+FH+O5T0kIcvbSNeG1mh05Q8mcdvRTmnZB+9BLOjfvQDWnbKA3bP76r4aOXAh0RVs4jf6Q/oOTn45Ly1mVILLQHFlgrFoglRy+h/dxSu14smxnW1pXLmq2ToNmWlZSGbbnVo5ekTB6zlaOXtPeUBaUcmsz56CWU61bC2tYE62zC2prB1wlNsPjoG6398ropztejYKfRxueOJ4ywdqv14762UJr2blabU+I+En3W5XDNQdNVPCbsqTnGCpquSpl6k/llNJRvS8fF+MDbg6OcNsM1B01OeFxMK9uDo67xGC9rC9pOOV6LdRTne1hH0cdnHUUfv1UdxXfqrego6iHPPwnv+Nkg2hPZ9kmzW0cRVqt9OD4v+TQ6R7dJ52iFjow9pPxvhS2S31y75jU1KMsDc0Kb5+ZDHqQewupx/vXAfOxRmPFN9rFHWh1pdj3rSDLerqHVrfsRi48Rw3bCuq3N3WQdDXqUQqfTbBpvC4E2DfWDQzPb1Mp6YM02ddL2GT60uh54oUcUocxjPqIobe7Cgg7K6FA6ogjbCaYJHb6X9XkpvzNMWw/8a8frNPOuB5b8G7Y2MH+T5vjCfNZve0QR63OnHVGkHW3GvlIz/66H8n+H6imQ/6JuC8EyXfKrwvtV7R69lNevYl++Vb/qaIVOp/lVvP3Ekl+15FflsSc+LPlVNnQ62a/q26zTbNWvWgZ+VX8NM/DcY5R+Fc5ZLvQ7K7YbOCeE30vJnFBe/4u35ZL8x21uYB6zOZ2vY4H2w5SPv6X3oVP9ptDbaYU4httfW85HSV3GNE/Uzndhrfgz2N4OdX9GG+/F6M8s1nZah5I/g+0E04ROM39Ga2eav4n+zLM26zTRn8Fn0/yZf97SwHx2DTOmeSLW5xiOsi4Q73n9FMn/0s2P/u+EeaKs/XgC+Re5/R2hv1j78WjzKln78exQeNVsHM8TaX6V9p20hiX6GHYdYHlY61+SjPLz/A22z1b3ycF1g30LbKvCWydts+pDq/4ObqW60H1y2P5mHavarp+E/ORp5z5k9duLtU8OHy+93ZAOynux/be1SboNWag9ypr3wr1U0N+5bbNOE/0dfJb9Hcn/J1samHfUMMOuP299K2X2aXFtE+uzdgxhlp+U126ILFr1d9CXzfpmQptDkXpAP82uHipF4aOYzA+Sht8+bYFrDprMhO9Wtw9FveMjJrL24kK7wPvIHIpbknaa/vBcK34nzO0YvxPGeuXQTO9a2T4U9Vv4Xp20vH0ovxLhLnZ7CrvtbB+6hdLzbh+6RaEhaoOfRB6M4YrQ70vmV0+I4UqR+GH58HClpPA6oKShmcc0pFNS6GhYoiva5wC8faj2mcLWDDobFJ47zYTw9qFoQlA/ODQzEws9RUp466RtVn1odViEW6m2MixCmXO3ijrD3SraFu5Wsb7TtiRFfvLYEx9Y3zXdybKLC6WDMuJp7Sca0kF582kURUM6WHdSV2sTe7untbNmw6I/2zyXpvTFeYdFkv9XtzQwf1DD7FX4OlhtHPVX0nA7XNZn3I2ddRC3dMS65aDZDZFFO8MithvoB/H2oXm398ThFG/vKfgrakLqJTzjep3K42sF0qmpPG0c6Wt9nPDdp6S186l3eXpicnh8fKYyOVOcHJ+ZbtVv4TaO+Q9T8of95LAyLnqPn3rjkMeHbkjbSmk9kIafAvKn3mGmZSrjeeSP9AeU/Lx9SKs+KNJZkSwMSz6p3gLPs63gMZsPYe1A/nGP0O8jXo35qY97tE/IuxW59mfIVfN1eFnKFoXOFoWOhiV2v9M+VedlKWhbsN44aH2plKnV8Yj2qXrgKdxB7fUB84XzHK2OR3C6tZXxCMqcp3+1z+E0neYpeLRJPBXNcz3a/yRpfflrd0q5LOigjFh/jzKkg/LeQnS2GNLBupO60uZHeIugVvum4xU6zcYjlS06zbzjEcn/uS0NzOHadVjfsbU2jvqrTbmzPuOUO+sgTrlj3XKwHI9g3bLdyPIVUMcPhq8g9BfLVziK+GH5ZPkK8qzWbjfDNduHVn0F3tYmjD9XLmm2LKHyY9vkJR2avc+r51KmVn0F1Fee4w1kRypaX8l8oY1p1VfANr9QX4FfP+EnXmwPtO1WWvEjkJ887dyHrHHSYvkKrL9HG9JBefNY7XhDOlh3UlfaNk289cIWotPMHmX5Pmm+wqVbdJp5fQXJ/17wFS4nXwHn3Q5WG0f91fwI1mft003Nj8C65aDZDZFFq74C1i2/2xXee5S8R1Ka5L0B6utdteu1yfz2tzqZm3YkpK2Ca6SLunNk0ghTVZ3PvTX6B7ar3aZjLkvBFH3U5sGkHL21/92QZqeHkyVtO1W0Uz3VuWXC9tSl5Oe5Rm2uBNsU+ziok5sJq1vBQv8Kt/g9kKfaeF54PBjyRB7zyBPztypPkZEmz2MI62gFC2WcJU/h8WDIE3lkeR7TpEwsT03+KCeRkfapxXGEpfn62N55rlewlyv52SZh/rdvefT/gS3Fts7lbzU8z7qwSsFGG5rVzvqUcvRTGj7rcb+6YS7/NTLJ+8B+f5poa+8mstpDs20Upb40n0We7aS5P62vzzsvkLUEnn1EbZu8QjI/NJtrzHssCdfzFqLBbZF17FiFX/QBef7nC6Bjv0S0m237yTqmHVuBvhnrGI41+FjhTtm+k+eeUI9Yx1CPeO6p1e0W8+oYvs/Lq2Ncz9p8ZV4d2wq4FdIxkd2vg479UQ4dy3on26qOoa1aHB3rrPUWkoZHaKJMOFjp2B/l6K/y6tg2wP2zzY9e8+cG3wUd+weibX3UBOuYdnxB4E87x/sVXiVIGi4H5/dLuByc56hOhTSeo2r1GJS8OoaffebVMa5n7fOYvDq2A3DlExj+hPdfQcd+SrRPaUKbdazZ8Rmin0tH5sxNW8wjc7R6bmZLWMe2KfziZ+WsY91bG3nWbZ1LW9MxbZuPvDrG7zRj1zH21WLRMa5nqyOaZCsm1rFNoGPbl3TskNCx7YF0TLZRFR2TuZ6TQcdGifZmhTbOR7GObVHyb4Y8Mg5bSzzgs73KcwfznS3PM2A/kbX2i+cucD7kWErDcSzKhIOmY5tr163oGNfzcUQD68oH1rFuhV+PO7nx0es+oivP7Kz9LrYYylNT06XB0sjY6PTg4NTYEG/D4YPo4qoA9AeHxkcmx0dKpbHB0vRgadHpTw4NT0w6JorTpQPiWGz6Q1MTo8WR8vjY1OTwVGVoshn9tbXr5dVGOs61+7Ci9luOZ+P8gtdD+c8Fe/VsmEc/kFeh5/O9LCNfIeX/AQzlXnd17r3e6vz8XdX5+YV2X3U+j5K2CtJ6iM7q2m+UF2IJHz2U/8W1skudrIRn5PkBhf5Koj+Hb+Ue9gWM1aXck/y+fi6s8Sh6i2W3XsN0gCbh4z3mTXTH67W3sf9YU/6Qay18uLT66H/pD5cnQWRSFvwVxJ8Rfr2/7Unmy0lorwxStpmZPPWA9PuI1xD6h/SEH5bPMpJPbxj5TPtvZET3sP0uV2TDfKwgHvsC8ai9q8Xj4XzohjTh44A/tGMuj8sC8Ri2jc7Uvx9D/w/XDV1F/pzUDa79QL3HvhXz74G+9WroNwRXnhc7tQrSVyjp8lvqa5mSl7/xWUEy1OSK+UUnl6eUdTmVVfLfWCuf523Heh0T5Yd8LUvBrALm6VQn+L45q81L/lVKfmxjws/aZH7bXEXPIe+9ydyA97T6KVBe9i2ln8Ln0n73KjhpPKxUcLQ1ib3EK9JkffCBxzJdCh1sU9jn9yr0DfuHIa2vlCBpy6m8mIZlf1G1kY+DNo6UMvnyvpz8ZczH/GhtzdI3kvs9cJ/pdlHe5ZSXv0NDHnsMeBxQ6Cwn3BUZ/BcIp1t5rj/R26P2Py+/BYVfra9plw5ivbg6lw7WM/Zp7yf7iXa8S3n2mmojHfN/BPq0D+Xs09iWYBleUm3cY5vNfiy3SV4vxX0X58F+HPN/Qum72D4glr/3qRw+gub3sY/wOyDPz5I8NR9gbTJfNqzDvUQL/WPpX1gGXwU+vrQ1nZbItT+jjP7e17bq+ZAHzMcYWt8pGFq7lufWKnxx22PbsTyDhtafaTR6KK3d+tH6bfQ1NB9GS8f+HOnwvWVK/mb+R18Ktoa7XMHR7PxKSisoaWzDsLxow9g30cZkaBu1dpdWd1m+t8Z7Hr9qeQbvmvzQDlnPURZHi6Xi5MjQzExpanh8YrDZHKXcl3lFKdeB/3CvB8rlA86f8fwdzgV2V+fSl7kynL9DLOGjh/L/Jc3f4TyVPD+g0Mc5Lqal0ef5O21es1fJ7+v0uzBHZj73PzQ2Oj42USyVZ8rlyujwYs99Dw8Ol0ZHx0cnhydnxgYnJxZ97n9seGasUpkoVcampsdKi17+6cHKxExpZmxkojJTrIyWFv3dw3ix7N65TEwMlabHx8ZmmtHH8VoB6PuQdz5E8v83+Fmn0hzBsgxMH66uzsWU/P+bMUegrVPXyin3e5T8PDb1YW0yvz+RZ3lcgfmC6FOpVJoZHpwYHZ4su6mtyUV/lzczMj48M1IcKk8NTpenxheb/sTU8GRxrFKaGh8fKY4Mj7ajzz5oeiJ9sdR7F/HeDGtZBlYhA6unCdbZhIXPsz7y+N+H3mS+/2U4/zJYIHpSjoTKXe+jk/ntKsT7gmZyXUay0/z8ASWN5yA0/3S5QkfDKhhi8Xr9NNukvY/L0hueM9pZ+11sL+TWm/p702Rx9KaL+GmmN1rfob2blL2Fs2yI9o3aYmFlzWGFnsPNqwtCvy8JqpulLLl2KXLleVF8lse/PnD9abZKe88RCxbaH21e+9XVuWmardLG8zwvpb3bYxu3NkmvG7a7Wt+K/PI86dO3PfpfWw9gqI/qEUr8LjlQ/z6sze1J6FfKzfWO8zlct/yOHtO070kLCg9d9Btl4Wlv2tHA5XwSNB0pUNpypRzaXBL3AZoPlLV+IGtOUrPfstdrgTCTJHvOSfNNF+JDI73ziRcp73IlP+L1UP6X1NoVftvMmDKG9GF3dT4m85y3bUu+VwAPzwUdYjlwH9lpfnbova2yxtM+LMTP9oH7ooX6xqGwQr8LZX8+bR3LZdsaz3Cb0nwW3v9G8u/a1sC8snat2QjhcVWSbRe0uSKWf9r6E7YLkn9Phl3Q3nUiX7urOubrAfP0lPd9WC6t/uS+tkYt6/2e9l6t2Tj/AHZ1PmbYPTiKg9oeHCifnmp+WfjAstPea2nvJAcov9Z3Yjti36SZT5+11gX3tbgM9Ib7SW0MWVBoaHOMXSm8afkYO402yxrztjJfkCXDrPJlzaX1NMHKM/+VZdcR63zC0taeZGHlnePjdSFZ8yuB1ijnHlML/cWaX2kmV/YXstYGaH53lu3W7I+G1W2I1WOIJfXWSptlPvjdig/i0/QQ7iUnPPrfy/1nt83NI3ifAr/h49t0/nx4bnVumjae8vdmajS19cc+7qz9LrYVRsY1f90Ovzyl9ZHc9sOs4R+czNv2eQ1/oPmLUqs+gTY/wGtG0F+4qdrIx2ldyr1lGVh3G2Ldb4g1a4i1xxDrNkOsqiHWfYZYlvKyLKMVX5qd7RRdvdcQy7JtW+rEXYZYS/ZryX6FLKOl7PcZYlnq/QOGWJZtu1Pbo6WN7tS+1rIe9xtiHQr90KFQRku+LO3qrCGWpb/K4/ZO0a9ZQ6w3GmLdbohl6Zt0ap+21B4PXhk7td8+FMZpljqx1xBr1hDLsoz3GGJ16lzHg4ZYs4ZY3B4lr7bW0AdZK8XvQCbpnUOYNTyDU7wmTmgg7d5AtAtEL0n0dwJCP2sOvk9Ja+v7jtJMZbo4MTFYnpgaGh4eblU3JL+2X4j2fkFkvSqMrCe0dRp9IFcfuiGtl9J6IE141M60DrN/0OBEHvkjfa1tvgbK0EpdyjnU+G4s7bsrHy6pzk3T1mrhe0VtXUeB8PH9L65VuvKEBq/4HPKI5dPWuhWAvnYfrwt0H+kivedU5z7Ha9KYFy5vl8KnJotliiy0d9FdhIHtFPeM0L5F6SLefehVeDF8Pzmd1zZ26vcH/rwf2VP04und5189ceklk+dOX7fr9Mumzh+/avcl45eePjV11fSuXaxhuMqQS4vS0PJwPs6vaaNWCl5J0+oKH8Ti1UJZK3ya7XrEq4W0r/PluZUpdDAPvl3X3oRr+FwfvU14vrA6l+e0nejSekvEeh1haZZfsFY1wbqMsPB53nlrdQodzIM992qFtobPsuxvwvPl1bk8I1/9hLWmCdYVhIXPryGstU2wriQsfH4tPTeQQgfzrIX7AwptDZ9leVgTnq+qzuUZ+TqMsNY1wdpFWPj8OsJa3wRrN2Hh8+vpucNT6GCe9XD/cIW2hs+y3NCE56uJZ+RLns3Tm26A+4a9V+6RhtBfrN60mVx59dFGhdcBJY1XC25U6GxU6GhYPYZYKwyxVhpi9RpirTLEWm2I1W+ItdYQa8AQ6zBDLLGFYpvQN9tZ+19sK1TqJzCir8I2EWV9MEYYQr8vma/fIWyi5mugfHjGZH0Yfqay+uv1inykLjcoaayP+EUQ5l8PZWR9RL3toXu/WRv5DiiYbHO1Pgfv4Yj6l2lEra0czqNHiKutIpf6bbab5O+cMLcs8lzabpL8hZXk/+T2Bubv1TC1L0P4i2YDGzDFNwQb69pOj0sjItNNyfwgaUcoZS4o+bvoN/Lt++PjtjVwOR/TRDtyBKVhuzmS0rDt8cktqPd8csti6e4qQzooI7Yzaw3poLzXE531hnSw7qSu1ibz645nQvPaLO1LdR5/pNmWH56g00yzLbwzmOR/N9iWf6e3OGHGN6VhHh9g4PaP+qu1f9ZnPPmbdfAoSOOxIwbNbogsvN04rQW7gXW7idKyvmwJ5LdU8rQFpL9YX7Zo819ZX7asVXjV7AO3Tc1fW6vQ0bBknqCXsBM7ecwcRB+7nFc3OtXH1vpceVaz6V2LItdSReubEuIZ56DYpqX5xxw0u1U/gcnFvgXaLdZ75NVQTkNc3kThC/uMN1Xn859kyOJwkEUrvh/KfCOloe6zfUd9Yp8R9ZB9xsMVfvK0TR/YfmFdrUgplwWdQ8HHXJuk25BCMr+Ndyn3snw/9mXTfL/Kdp1mmu/HO5ZI/nvA9xuuXYedp2itjaP+hvAL89oNkUU7vt9GwNf6TLlOO/1nlUKP526z5gI0X6VUqZTcEH+kNDM1UxkaGStPlIYrw8MzgzMjw6ODUzNDg+NTI9OlwfFKeWx6pDhTGp2eHhmqTI4Mz/hDGWeElshzWUbZWvCZypMzpcqQo1QcHh8cmhqulKfKI8WpwaGZUmm0VB4bHK1UZiYHR6dGy5WZ8kjjBN8snynQvFvuXaWE/mL5TJodyvKZDld45T7EBzx5idO6lHtZ/RHbzoVi+cA7Ima9twukC5WF6kLo93bN3uEuRBfYPrWrC9yXZ42NA41/crdlHv+EHht3yDuGSlY9d2XwE+g9eVn40d6baXMH/n3b8iTdv2OdRL6x/5Z7XA8a7aydnLj/XtsEi9dmab5wVptHLF6bpcmjh9JuAH/x0u1z88h6oWshz2W166y52bBjyvxtWuj3JUHbUCmrDWnjBK+zK5Js3cG6S1uv1qeUNY8uI095dFkbM0s+rxOv376wfLgCFk/2uSkj30olH9PiHZsQo4fy7q1heNwLd8yli7Lg3ctwXWIfpWG9DFAa8sS7WWqnemk7BvdTGsqHVyrj2pmsrxjWUBrq4mGUhvW7mtJwvYis61qVzB+n3gc25R009s27Jimrr0A7L/m1sb4822nvR3iMrL0f1cbB3Gbx/Qj7Y0dDWjvvTrpPbOByPglaPWv9Gc5xZJ1ith5wee5E04cs/dmk5Mf5CtYf1BF5tlPfoYfQEUk7BtJQJhyavbPPoz9ZtiGvzsiz2rvWVTlxs3Q3S8c0vrHNsY6tVfjW7Ffa2hqcc8Kypb0z/iL0g6dvffRa+2IL16T50A1plmvDtJ11UYY91bnlzuoDfGi1zfP7R7TN/P4J6yDtXT9i4joi/NpH+NBOT/FBbEyYHRKLY+wXYGDfxodW39UI362+q0E/jH0t9G/YrqGPxn4K1hn7U9qXqPw/SeaPOXzg+ZCsE2S7DOnwfDPSCbUbe5pPbEFH++6H18AdTP3HutV8Zq5r9Iu5fnBdNMuUv4NJkvztTeSUt4/tVegcSvJFW81Bk6/kW5JvIy1Lvq2eWLNQ+S6jcuys/S62FzpKvnllKLJo9T0n6qiUKe0UKe3EPcEQG6R9Pe4DnzQj+ftq9R3Y51FPkcpzorpWvi6lfOenlG97rXw+75oTm9PLOqFb+66VxxO8KwViSP325CyD5N9Q47vZmAH7bx+6q3PLt7N2v9heUE/jQH+1pzq33NqYD/PzmEH7phbbNO/Er7XpAv1GLO1EKtaz5Up+xGM92wx1JKfDDCTpbVzStDnXLF9T0lC3eoHnp1B7DnTCw4j2rlGCNpdaoDRsJ/wOlXcWwTTUg1b7OZFFqyezabtXaHaCbcFKhVet3Qr+wWi32Mdyu9W+0c/aAadZO5d1WNp6NNZvbDO9lKa9z+A248MziZ42749tJm1XEG28FXiMlPvdW70fT4K29xLbR+GH5cNteaXCqzZmL9C1tkfFSoWOhrXMECvtZOMkma8Lgfzh3GvLhX5fMl+mIXRhmSLXgiJX7b0byxx3m5F1UtpaTpZ5p50KHEgHMnflQfmwzLWThXg+1Qdem7bQk4JiwGJ9FHztv9Dhe2n6q/kz6IPiWuTJExvP4HM4PsBneXwg+X8IY5wZGuNopzpy2/FhZ+1/sbUwyDfC7g5XnGA/EIM2xm/VRxS+W507b3cO3F/z2gD0kfl9YSjdXey5Zm0c0S4dba+r0O8cpK60eYB2dwvPWluS9p3D/hN1mmnfOcjeXT2U/8/BttxKY8swu4UWx7U5hYTKrY0DtfbP+oxzfKyDOIeKdctBsxsii1bn/7T3as3eT2a91wo87s+9TptPduwKw0/myY7aOgHNJmed7Gh5giKfwMvzg3it+XndGXQKCp2wOwoXh7U+QoIm5wKlae9s87Y3KVOr32aizBfpfeeo1vcwX2j/W33fj+8fW/FZUGe4Xwm5FiAh2vg/SVrv41mvCoZ08LnH6rqCPO+XNPuadWp9lk+Z5rN8/USdZt5vMyX/t8Bn+XnyWQLNF7TUxjXfg/c0xbRW32fmtRsii1Z9FpzjYLuBein5cF2y1NFvQx19j+pdm6/T+r5CMt928vwe8qHpuTzbSWu+NP3g710wbTXxjGno77JdQX+31ffduMYs77rk76W0b6HB7TtrjSnujM52Q3tvgTa0lfcWmv5gO5ZnO3Xeo9W1I6x32vcxkob7OaJMODSbZ2llXbLW1vPqDL4n3Z8y94a4PQpulo3S+sO8Nkpoae8VeW5Bez/BdFod5/9PzjUGQjvwu8qhg/muEmWmvavk91jau3jNVxZMnPut62S1kS/EuyORV1fSaI/dtXtIX+p8JaRJvnpfGYbXovDaV8MXHUaaWJZllJ+ve+jexh0NvrGMUg68h/iSfxWkSf4uuCc8is1cDmmrqq1hrSSsFW1gCV8DSv4VC+RLw1pOWL0KFt7D9rCyVjdp7+DT3qEcBXWKNjjvOxTJX9rRwDy2dq29Q8nyJfOcF5E1Zmp1zXfgeYvc70A7YQ2C5t8F9ukHs/p2rZ79951rkvl1pr1HwPEOn6vBeoZprAuYpvkN2jwHr8XR/G5t3iKrXxTaq5LW1ntq7ZjbOeYfgnZ8HrVjpJdnjcjB8OcKdN2XQUfjq5lfw3xpY5lEod2sDFl6p62JPYjr4FTfEsvOvmXWelQfuA76lfzaPM0A5UeZa+2S14dq37y12i5xTHReSl+K5dDGRJqvi+Nz6aP5PB3hZWftd7HFMD4yPTY4XClPVmbGxkeLo7zGPEnmzkFZ0x8pTw6NV4bGipPTQyPjwyPN6L+39qOX0qz7yV6lnFb4o8WhaZ7DMua/Eng9XYn3UzPGL0p7e2G1gc9l8UF7XyHP+LYu+uSvd8AzPrwIsAuU9mKFrqS9pKrz4cNLIY3t9MsgrYfSXg5paMO1fmFn7XexjeB0cDSwbze8Pkn300T/z6gGoV0W/DPD4Nftw1k1/MQOuyjYZwPvhQC8PyMMfl32zwyDXxH8c8LUbR3/WWHwBwX/XMAPoT/nhZF/Hf/ZYeRTx39OGPnU9f+5QeRTrvN/fhD84Tr/F4TBr+vnhWHwhwT/ojD4Y4L/vDD4dd/t+WHwZwT/BUHwRwZlfvDhWsOyXIvRaSfrauvEeJ6k1XVi+HzavmiSrv1PknwyDLTOoi7Dnpzl1ubMWIYaljafmLVWJ/Rau6wxuaY7kn9Fi/lXtphfmwfLWqvR7NzfPPNZWflXt5i/v8X8a3Lm5/fnguGD6Aq+Pw/xzi+rzSL9PuLVus3yegFNFoeFoT2SVxaHkSwC1U0pcHnr9lE7x3itUt4Bys9lx7walg+i877tif24eHr3cy7fPb1rWQoW1gfS5Px8LWF5Ck5XMl/P+FkeW/D6Zc124v2VKfd7U+73pdxflXJ/dcr9/pT7axI9nFmd+/vZ9Pvsanp+7MsGkvmhQJHvh/qdLCItC15FJ7XrQkaePN8bB/JTc9tMubdY3xt3ET8sH+57Nb9Z+974rGojH6fl8akx7dmGWJZ8WWKdF4Cv0GvqJV/IbwR8kPoP/X26tpZeaPv+7OJkbtmz1tIXkoaN53Uxw4UG5mtq9w7impTRvLbpsbAvhg84z8ppWesBNKyzDLGe3aF8WWKdF4Cv0N9CZX3Tk7UeqEBpvQpmgdKEP77H/GnfWzSzX7cRzWb2ayWkY/4fJA3MO6iMmr2Q+818jTOrc7G097vMexrWGYSFz7PsVzTBOoewtG/us/QZsZ5FWGlr1tJ0AuXL375qa97yYvEaJm09S+D5uBHhqa9FXrGsfcRrgeSw04TXwWFNFnb4w5Paty+G+CPaGq0CyW51kHou5V4DK/QX64y6vGvStO9/5Flt/RnroDY/2q/QGVDS+B1iO1gXGWFp7aAdvi404suHCwyxnmuI9QJDrOcbYlmVUbNdnaITlrK31AnLtm3J1/MMsSx11bIe+Rs+yfuntf+aP2HYJw5r3+Rwf9wXiHaB6In8Eipv1llh9e/ClLR21gOPjU1PD5VnxkvFocpwZXowy0dc6P7HmF9k3R9G1oPaGn3c08OHbkjro7QeSKt/V+ji2wpz+Q/ku+WSv+YPYX6e58hbl+sS3dcQ+WjtE9NQp/mbbG1PP23Om7/XRj1L+77MX8sYpdm3OtqYpkBpfQrNVmWpzSNwf91sfgC/i8b8/1D773/L5latljnE/AhjdSvl8kH0k7/n/lHtv9eBDxTmYmpyxzmKM6tJallZ7quaYPHcBj7Pe1qsboLFcxv4/GrC6m+CxXMb+DyPh9ZkYGGbW6s8z+fKrG2CxfMF+PxaSkvbT/EAdrWRtkjfVY16XftwocEHlxf7Ax8HFFlo6wokv7YOATGkLQwo+WU9riaftQdRPstblM/yNuRzZjVR5YNtvNP0J2vPB60taXY2r76dQfLBdTB9GfLBOcfFlk+W/jSz8ywfTZ6IcQ7JB9cT4T5wLJ9O1R/r8w2eRfLR+qfHsv40+/aYvzlH+fRnyOdQ0B/s+zX5rKE07Vts9GGFZrM9ts6sJnPKq40R8H0c+8/yQt7L7usptPP6rpL/yYDJvqv2/mutUp6Fvv/K8oNbff+V5Qdnvf9q1u7YD9b8c5434HyYR/PJMT3N/0eem40D2N9e6DgA7Ui74wBsc1njgDzrXcLMweRfyy30F2u9S7PxFb9/WqPwOqCkrVoUuZbqa9LRZ06IZ1wTra03xvJjQL59O/956FM4H9NEXV5HsljTIbLgNRx4Tnar+6ZLmfxzv96CnLA+1lEa6ozwptndPPNYBeIT+zK0+dyXSf5XQ1/2rmUNPn04CPvqjbTq42hzH1k+jjYGXaPISRuDdsAYS5XPygz5tLo/jyZPxDizmsyRj2YbY9If6zEWj9E7bIwVXH+ayeecDPlkzREeTP1ZkSEfza/WzlvIq288RtfeT2jyWaSzVUdaHaNb71vGY3TsE9lv09Ypamviz6zOLY82/sQ16yFlPDLa2GdU6hf3GcXQDemY/601AOv9pGZGxkszlfGZ8aHxqanByfFm+0nJ/RXVRnoX8XqA/9p13SfF/JTWW51ffqEj+6iKD8RYwgfvu/r+GoC2LyrvJ4r0lxP9OXwr91DXGatLuSf5ve69s/ZQiH3CJoeGJyYHh8aL0yX/s9ysXjU5oS3yQWSNdbFcKVsP5f9YoVHmT4CdOZBXoefzfS0jXyHl/wEM5V53de49rY5QdyV/fXxbnc+jpOFetGgnfVhd+43yQizho4fyf4V0F/VNntf2wsW9hZmWRp91V9uHd5WS39fPZ8keYdmtx/4HaBI+3mPevhawXU1PDI6NTIxNDhWnimOlsUqzdoX7hhSI/yRp9Ida35W1zr8rmd8fcj7GTqPN/TXm1daNpJVP0vm8cux7z6rOTZNHH6pl8vX3rcLcPIL3bbAjv03+CsqP94jU9mD19x6o/dD2/vNxZ+13sa0wOB14Lfyo9v2bHf5IRdv3zhB/XPB7w+CXA38rUJfPqjD8D2lr1uzwy1PavKch/6PaXKKh/Ov1uzYM/0Vt7xRD/GFtLrTuq9SusZ+x618HJ/P4UEi/j3gN0d8jPeGH5cNz/esVXgeUNLbx6xU66xU6A0oar9VuB+sFhlgXGmI91whL6//a4et8Q75WGPJlJS/LMlrypfkBnaCrmv/QKW3bUieeZ4i1ZL+W7FfIMlrKvs+QLyu999erDPmybNud2B6tbXSn9rWW9XiBIdah0A8dCmW04svarnZqv83zJp2iX5Z2ledu2uHrIkO+LMdWnepjLrXHg1fGTu23D4VxmqVO8NzwY1HveX66U/xoy/HQgCFfIW205MV9QWXfQx/k201+h3kvvTMMs9fX4JS2Tq2QzKW9MhDtAtFLEv2dAH/rr+0v2aektfP+faI0U5kuTkwMliemhoaH62cU5N0nUfJra9K09wth9xYZnMhaN6rtd7GS0nogDc+35/0uegPxn0f+SH9Ayb/QfT1lvwv0MfGcOMGTIHtramscz6ql4boAbV+MAuHj3hf47drblzV4xeeQRyyf9n1QAehr9/G6QPeRLtJ7RnXuc7yfDvPC5e1S+NRksUyRRZ49SLCdCl6IdTyDMyPjwzMjxaHy1OB0earpukdeJ8prbRbKB4XQ52gOod0LwP9j5hxNbCdcFh80+yLPeFt1ZNK4Pg6e8YHP+cO0cxS6ksbn62Ea7tnM52jinsJ8jibaXl6LjufJ8Tp+9Iu5T8IxGfdlOJ/J396gv8ffneCcBH9zgb5dfU1x7XeI79dGi4Oj2poTQz2cWq/wz3uGPFbOAg1hg3w4Owx+/Ty48Rqe9o0B++qB7NV0geglie6r19f/JmHtc4HoCT8sH7n2bVns48XTu8+/euLSSybPnb5u1+mXTZ0/ftXuS8YvPX1q6qrpXbvY42ELyOkYOA/n4/x5S3Fm9dH/2u7e7DV2N8HK2pG7m7B6mmCdRVj4fA89tzyFDubRTlnHdA2f66PZrhBnE88azV6FZ0PtHRJeV2bwivSzdmkIzGt95NvbIq/aqKyLfnM+zKPtHIfpKxXahcWRSeYO6VkyydohPRCvo8LrqhZ51XaxCMzrmPC6ukVetS9lu+g358M8y5XnMX2VQnuRdG1cZNLfoky03T4C81qfpVnTIq/aroKBeZ0UXte2yKvmKXfRb86HeZYrz2P6GoX2IunalMhkoEWZYLnlWe2rmKyZ3KxdjVdTGur2GkrLGkVrvo42q8QzTugj8I612m5VvHsA2hBtNxTejQfbg8h2VdL5Xw/P1H4f7K+HxdOPexZtcGRpFi07SNs7s9rAzzuLJs94G4Q79ayFZ3w4C7ALlHa2QjdkmZ1O1L/SCnT6Xnl9km4rZUbiiNrvLiUvtoW0HavZpmgYiMOyxXrcWftfqlRKrgsbKc1MzVSGRsbKE6XhyvDwjJuBHx4dnJoZGhyfGpkuDY5XymPTI8WZ0uj09MhQZXJkeGZsanJ4hsu6LKNsWV+rNnvD0Ok2/Nja74Ntw7fUrpdseGaoBLax5cD2RrXhWX6aZsO1mVGx283sO9pw9rND6NwonFoWqM5K65N0mys2/OikEVDO/MU84vRQ3o21/97HX5+Ctzxpbiu7Up6Tt1u9CkZiKK+sN/DIR9ab5Rhs++ba74Nt24+vXUdu28eXbHt2WAzbLqup/DXulumDZtslTXvzrr055/c/+OZc+A+5Sg/7i0DzPoPrFf6FlvQXYgP93Mum2rV7k+beob1g/NJLpsZ3X3L5ZRdOX3n19K7d+AoKRchiS4gsk8Z8HAr0m1+KFuj3MiUfhjyLhrIWJWnuftbirRi6C5lGOdjdBboBmLY0FJgTKoHNeSWkmfNB6y7SXin7IOYdr4WnhXYp3NYRG4cP/rq+sV+i246dSftyEb0JNRzxYX2S7qKL+Rf3fjVcX3b57ktmrnvO1ZdeesnMJdNTz7l893RCgU1/mlnGYvFzHCRfDCZUZsoOtgkt164jN6ETi2VCQ60c0PZQC21CtXNCRIdlrSdet2tCA8+ADweWYUVbty8yCPtNTHGwQPQSkmNC9BfrTIy8ezFr35nwCKq7Or8c2ncmUr8+zzGQj3WLz/vEYYOM1vhNrg+i7x5/B9B6XO06cLc+cTC7dbm3otqQR73vhXs9IL8D8sH8lBZif+UTa787eX9lmc1alTTcpccDHrcVfmuGeN69khmNR92rM66aHt+tO1faRzX4e1kKE3nH44ifZNBiTMwXi6NWqv0+2I7aWO16aaybGQ65sa7k42eaOWqBX2UNBZZTKbSzl2Wgs5Z9sc3U/gsWpwmtviSoDpeyyob8i25oh3bzx6Aa1vIWsQ5mnaKssw6NYYe2G9L4AzZ0WqWM3gnYDPm4DfIccdp80ymAJ07FY3m+KRbH9OTa7052TLfVrtExrQBeWhvBQb1c5/lcJlB7Lguv2qdN2uSGd6I31K537b78qulzLjvr2unJq/0rqjPGJ1+de5ZyWZLeMWNBNYwueF4LMTjFo7XfB9sp5hPONiT28iqCU3x4GPwi7rKSUFmQLjv/iSEPgid6oA3yllFa3TARfwV7/krMS5dCS4K8iDgc7ok8/z/FjU+25CoJAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgATLQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjRbts6DIbfxde5ECmKkvIqQ1GkbToECNIiSw5wUOTdR9qinAyQkDrbTf2ZsX6L8k9a9dfwtn05/3zeHd4/fg3rH1/Dy3G33+9+Pu8/Xjen3cdBol+D0z8pD2tYDdlPhzQewPlyjMOa5Ag4rIMe43TEco5yDnqhRwNV8ALkDSwSNKJqEQSSAgtkgQQGFskSQR2VwwTonIFFwCJQI7kAeoNUQGc4QSxAYGDDgwlGHS5TxUwCQUF0vFsN3nEBvfsEoQBaBKmA3nQCHSXr48kZhALBIsEibBEmg1RAJzZBLJDQQG8hk/fZGQQDWRYv6ZAjg1RAn+wEFtGlm8Ai3q4Zs1AYsxghGOgtZKEokEEqwGjABdQAE1gkOQMdLt6gjAZyDUmCQSc/gSgTCoA3sIhOnkghFfBFJ+hzH4EsQhYJFgnqZ5lG0KmOECVBUtAZEitoRC9Wi1JUCJNJ2IFBKqAznCAXQDKwiLdrRmcKRLU6ZYVUYMxUAcFAZhjEWtGTQS5AFtG8JtC6laWLHApEZ5AKJLlFQIVUIFsk63AxUtIEJ+ACYBGwCFoE9V7+clkN1naeT8ftVrvOVR+S7vS5OW4Pp2F9OO/3q+G/zf48XvTrc3MYj6fNUX6VPLaHNzmK4Ptuv1W6rObRrj00knp0HB3FoFUgfEMhVQUxYksB2wrymKEosBR/VeBbBd9WSDGZQkoOWwr3ZgF+yToELbOiEFJLgdsKntXio4K0tVkB2N9IxLaEvHZykQDMeZbItxKpk0fy5qeYArTWMncUpIBNgTm1FKCzmACUvSUCAbkl0k0E50S4qQDYm0YOdTlhXgt5ad1vC+RqC3aLjDVbk4FbCtqT284CX53lr511mwfww1UK8eEyvTsTiu1MuhohVo2YmxrYeSjEYB4nJmprwMOVhthrWznPzdctkrg2KMZFEgwwO7QtAQ8XK/baJ2aTEKtSs1ix1z9drG3HpdkaPvyh0ek7qTojeWordBoog6uVxm2Fbh4MNY/o2hpdi9e1INluNS3u8d9qyOvPXqzA4eqZQPiGRrKSl/+x0jKNGOq7NSZqa3Q8ig5sHuho7oDIeKvRe7ZcC1aWJrQ1urlke6eAVF47l/x4LuT+cS5zG4VE3Mzl7ldC5qZPqbMJhexqLpmuNgvgv9FJ6zxk67SwGc/70MUSd23gKP6FDVzPHLJHqA/2umiDXySBeZFEDvNjZV4ogbNEXCZBfjbXH4k8yenmdXe8+Yh1UbHjbvOy35bT9/Ph9erX0/+f9ot9BPs8frxu387HrSrNX8Lkzw8pz5WU15N++tJTqUjwUU9BT1Naif+fLjqZ3w==",
      "brillig_names": [
        "winner"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000003"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "join_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "first_capture",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        },
        {
          "fields": [
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "tally",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::TallyEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::claim_deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::claim_deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "join_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "219": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "402": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        },\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n    use token::Token;\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        join_fee: PublicImmutable<Field, Context>,\n        challenge_fee: PublicImmutable<Field, Context>,\n        slash_fee: PublicImmutable<Field, Context>,\n        deposit_size: PublicImmutable<u128, Context>,\n        token: PublicImmutable<AztecAddress, Context>,\n\n        deposits: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        first_capture: SharedMutable<bool, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct TallyEvent {\n        address: AztecAddress,\n        tally: u32,\n    }\n\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        join_fee: Field,\n        challenge_fee: Field,\n        slash_fee: Field,\n        deposit_size: u128,\n        token: AztecAddress,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.join_fee.initialize(join_fee);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.slash_fee.initialize(slash_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.token.initialize(token);\n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        let token = storage.token.read();\n        let deposit_size = storage.deposit_size.read();\n        // Token::at(token)\n            // .transfer_in_private(\n                // context.msg_sender(),\n                // context.this_address(),\n                // deposit_size,\n                // 0\n            // )\n            // .call(&mut context);  \n\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n        CTF::at(context.this_address())\n            ._join(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _join(sender: AztecAddress) {\n        assert(context.block_number() as u32 < storage.start.read(), \"Game has already started\");\n        storage.deposits.at(sender).write(storage.deposit_size.read());\n    }\n\n    #[public]\n    fn claim_deposit() {\n        assert(context.block_number() as u32 > storage.end.read(), \"Game has not ended yet\");\n        let refund = storage.deposits.at(context.msg_sender()).read();\n        Token::at(storage.token.read())\n            .transfer_in_public(\n                context.this_address(),\n                context.msg_sender(),\n                refund,\n                0\n            )\n            .call(&mut context);\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[private]\n    fn submit_score() {\n        let capture_note = storage.capture_note.at(context.msg_sender()).get_note();\n        let mut score  = storage.tally_note.at(context.msg_sender()).get_note().note.tally;\n        if capture_note.note.capture_block != 0 {\n            score += storage.end.read() - capture_note.note.capture_block;\n        }\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        assert(context.block_number() as u32 > storage.end.read(), \"Game is not over yet\");\n\n        storage.final_score.at(sender).schedule_value_change(score);\n        let (winner_score, _) = storage.winner_score.get_scheduled_value();\n        if(winner_score < score) {\n            storage.winner_score.schedule_value_change(score);\n            storage.winner.schedule_value_change(sender);\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n\n        let event0 = TallyEvent { address: context.msg_sender(), tally: note.note.tally };\n\n        // context.emit_event_in_private_log(\n        //     event0,\n        //     &mut context,\n        //     context.msg_sender(),\n        //     context.msg_sender(),\n        //     PrivateLogContent.CONSTRAINED_ENCRYPTION,\n        // );\n\n\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        assert(context.block_number() as u32 < storage.end.read(), \"Game has ended\");\n        assert(context.block_number() as u32 > storage.start.read(), \"Game has not started\");\n\n        // Ensure the game is initialized\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[public]\n    fn slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == context.msg_sender(), \"You are not the challenger for this address\");\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n\n        // New values assuming the reponder does not have the flag \n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let new_responder_note = CaptureNote::new(context.msg_sender(), 0);\n        let mut challenger_capture_note = CaptureNote::new(challenger, 0);\n\n        // The responder has the flag\n        // Update the values accordingly\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            challenger_capture_note.capture_block = challenge_block;\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_responder_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "91": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "99": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_tuple().is_some() {\n        let tuple_len = typ.as_tuple().unwrap().len();\n        let mut tuple_quotes: [Quoted] = [];\n        for i in 0..tuple_len {\n            let element_quote = quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name.$i)); };\n            tuple_quotes = tuple_quotes.push_back(element_quote);\n        }\n        tuple_quotes.join(quote {})\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    }
  }
}
