{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgADAAAKmCUAABT7ACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYlAAAI+AEiAAGASAADLQsDAhwKAgMBHAoDAQAcCgECAS0KAgEmJQAACPgtCwQGCyIABoBEAAckAgAHAAALDicCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAuhIwAACyctCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAALTCUAABT7LgIAB4ADKACABAQABCUAABRbLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAC4wlAAAS9C0OCgEtDggCLQ4FAy0OCQQjAAAMFCcCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABUNLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAUWy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBIAAMtDggEIwAADBQmJQAACPgtCwQFCyIABYBEAAYkAgAGAAAMNycCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABUNLQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEcABAEiAAaASAACLQsCASYqAQABBQLcbieAdhKdPAQCASYlAAAI+CcCCgQLLQgACy0KAQwtCgINLQoDDi0KBA8ACAAKACUAABDrLQIAAC0KDActCg0ILQoOCS8KAAQACicCEAQRLQgAES0KChIACAAQACUAABHxLQIAAC0KEgstChMMLQoUDS0KFQ4tChYPHgIACgUcCgoRBBwKERAAHAoQCgQMKgoPECQCABAAAA1PIwAADS4WCg0QHAoNEQQcChASBAQqEQ4QACoQEhEtChEGIwAADXAWCgsQHAoLEQQcChASBAQqEQwQACoQEhEtChEGIwAADXAAKgoGEQ4qChESJAIAEgAADYclAAAS9AwqCgkGFgoGCRwKBgoEHAoJBgQEKgoHCQQqBggHACoJBwYcChEHABwKDwgAJwIKBBItCAASLgiASgATLgiATAAUAAgACgAlAAATBi0CAAAtChMJBCoICQoAKgcKCBwKDQcAJwIKBBItCAASLgiASgATLgiATQAUAAgACgAlAAATBi0CAAAtChMJ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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAECAS0OBAEtCAEEAAABAgEtDgcELQgBBwAAAQIBLgyARQAHLQgBCAAAAQIBLgyARAAIJwIJBA0tCAANLQoBDi0KBA8tCgcQLQoIES0KBhIACAAJACUAAA3bLQIAACcCCQQNLQgADS0KAQ4tCgQPLQoHEC0KCBEtCgUSAAgACQAlAAAN2y0CAAAnAgkEDS0IAA0tCgEOLQoEDy0KBxAtCggRLQoCEgAIAAkAJQAADdstAgAAJwIKBA0tCAANLQoBDi0KBA8tCgcQLQoIEQAIAAoAJQAADwQtAgAALQoOCS0IAQEnAgQEBQAIAQQBJwMBBAEAIgECBC0KBActDgYHACIHAgctDgUHACIHAgctDgIHACIHAgctDgkHLgiARQAMIwAACC0NIgAMgEkAAiQCAAIAAAhDIwAACEImHAoMAgAAKgMCBAAiAQIFACoFDAYtCwYCMAoAAgAEASIADIBIAAItCgIMIwAACC0cCgYBAAAqAwEHLwoABwABLQsEBy4CAAeAAygAgAQEAAQlAAAPeC4IgAUACAAiCAIJACoJBgotDgEKLQ4IBAEiAAaASAABLQoBBiMAAAKuKACABAR4AA0AAACABIADJACAAwAACOkqAQABBfeh86+lrdTKPAQCASYlAAAIwScCDAQNLQgADS0KBA4tCgYPAAgADAAlAAAKxS0CAAAtCg4LJwIEAFQKKgUEBgsiAAuARgAEJAIABgAACngjAAAJMQsiAAWASgAGJAIABgAACk4jAAAJRicCBgBYCioFBgwkAgAMAAAKJCMAAAldJwIGAFkKKgUGDCQCAAwAAAn6IwAACXQnAgYAXgoqBQYMJAIADAAACdAjAAAJiycCBgBgCioFBgwkAgAMAAAJpicCDQQAPAYNAQsiAASARAAFJAIABQAACbslAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACeUlAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACg8lAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACjklAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACmMlAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACo0lAAAM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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "join_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "slash_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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nvOvxTznXzv7OWvKnH8dhjkwnPOvyzznX495zr8+Ax6c828Q5l+bvdqCtdk1mO3UIcx26obMdupGzHbqUGY7dRizneoy26lhZjs1wmynRpnt1DJmO7Wc2U6tYLZTK5nt1CpmO7Wa2U7dmNlO3YTZTt2U2U7djNlO3ZzZTt2C2U4dzmynbslsp27FbKduzWynbsNsp27LbKeOYLZTt2O2U7dntlN3MGCnXmOBnVrEbKf+j9lO3ZHZTt2J2U7dmdlO3YXZTt2V2U7djdlO3Z3ZTt2D2U7dk9lO3YvZTt2b2U7dh9lO3ZfZTt2P2U7dn9lOPYDZTj2Q2U49iNlOPZjZTj2E2U49lNlOPYzZTq1htlNrme3UOmY7tZ7ZTm1gtlMbme3Ukcx26uEG7NRrLbBTi5nt1COY7dRRzHbqkcx26mhmO/UoZjt1DLOdOpbZTh3HbKcezWynjme2U49htlMnMNupxzLbqROZ7dTjmO3UScx26mRmO3UKs506ldlOncZspx7PbKeewGynTme2U2PMduqJzHbqScx26snMdmoTs516CrOdOoPZTp1pwE69zgI7tQuznTqL2U6dzWynzmG2U+cy26nzmO3UU5nt1PnMduoCZjt1IbOduojZTl3MbKcuYbZTlzLbqcuY7dTTmO3U5cx26unMduoZzHbqCmY7dSWznXoms516FrOdejaznXoOs516LrOdeh6znXo+s516AbOdeiGznXoRs516sQE79XoL7NSuzHbqJcx26qXMduplzHbq5cx26hXMduqVzHbqVcx26v3MduoDzHbqg8x26kPMdurDzHbqI8x26qPMdupjzHbq48x26hPMdur/MdupTzLbqU8x26lPM9upzzDbqc8y26nPMdupzzPbqS8w26kvMtupLzHbqS8z26mvMNuprxqwU2+wwE7txmynvsZsp77ObKe+wWynvslsp77FbKe+zWynvsNsp77LbKe+x2ynvs9sp37AbKd+yGynfsRsp37MbKd+wmynfspsp37GbKd+zmynfsFsp37JbKd+xWynfs1sp37DbKd+y2ynfsdsp37PbKf+wGyn/shsp/7EbKf+zGyn/mLATr3RAju1O7Od+iuznfobs536O7Od+geznfons536F7Od+jeznepEeO3UUITXTm0XSdveMrJTcyI+2m8GdmquH7wM7NQ8f3i+7dT2fvF8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",
      "debug_symbols": "7L3Bji29jp35Lndcg6AoUqRfpQdGtV02CihUGXa5JwW/e+9gBLmUmTeVyr33aaCB3wOf7/51zloRsUWGQqKk//jbf/2n//t///f//M//+t/+7X/97T/9X//xt//7f/7zv/zLP//3//wv//Zf/vHf//nf/vXxX//jb8f5/1GTv/0n+ofHn3r/Oe4/7f7Trz/5uP+k+892/8n3n/3+89bjW49vPb71+Nbrt16/9fqt12+9fuv1W6/fev3W67dev/Xk1pNbT249ufXk1pNbT249ufXk1pNbT289vfX01tNbT289vfX01tNbT289vfXGrTduvXHrjVtv3Hrj1hu33rj1xq03bj279ezWs1vPbj279ezWs1vPHnrt/NPuP/3604/7T7r/bPefDz05/3zojfNPuf/U+89x/2n3nx5/tuO4/6T7z3b/yfef/f7zvL52giaMBEvwG+hIoISWwAk9IZUplSmVKZUplVsqt1RuqdxSuaVyS+WWyi2VWyq3VOZU5lTmVI7YkRN6giRowkiwBL8hQiiAElpCKvdU7qncU7mnck/lnsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKI5VHKo9UHqk8Unmk8kjlkcojlUcqWypbKlsqWypbKlsqWypbKlsqWyp7KnsqeyqfcUd2Qk+QBE0YCZbgF/AZfhdQQkvghJ4gCZpwZol2giX4DWcMXkAJLYETeoIkaEIqUypTKrdUPmOwyQktgRN6giRowkiwBL/hjMELUplTmVOZU/mMweYnaMJIsAS/4YzBCyihJXBCT0jlnso9lXsq91SWVJZUllSWVJZUllSWVJZUllSWVNZU1lTWVNZU1lTWVNZU1lTWVNZUHqk8Unmk8kjlkcojlUcqj1QeqTxS2VLZUtlS2VLZUtlS2VLZUtlS2VLZU9lT2VPZU9lT2VPZU9lT2VPZb+V+HAmU0BI4oSdIgiaMBEtIZUplSmVKZUplSmVKZUplSmVKZUrllsotlVsqt1RuqdxSuaVyS+WWyi2VOZU5lTmVOZU5lTMGe8ZgzxjsZwwyneA3nDF4ASW0BE7oCZKgCSMhlXsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKo9UHqk8Unmk8kjlkcojlUcqj1QeqWypbKlsqWypbKlsqWypbKls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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdBZgUx9bdsCywBixRAgSNkIRQ1dMz052EuLu7zUxPx5W4u7u7K3F3d3d3dyGu5K+b9D56hx52oc+dd+t/W++rN0NDau+5cuqe6p7ZGer+HV+PrqubY55/389gZn302sPMYRXX2l/j7xsS/l1zwrXWhGv9Eq61JVybxczFKq4NTfh3wxKuDU+4NiLh2tzRtfiYIXpdLHrNqJzrlvNOWWd0QTl+0csqN1vMedrTWS8bOF4mU/ZcL+8X/bzytZsp6zDrZ0L172itn7yWSjWcEqedfWF2KsVpZ7/pt9OpvEC2DTCzZ8xWitek6D2VSPv7vrHr/aL37f9df/PnNjMHmDlj/eTr7aNHhQ9UuqHnBvpzJlzcdby2aN1hMR/1qJtyzAD2ywx1PDlch7XTT1obXigz44gnk1QoM8cKgkZXCmUW8+dZzZzNzIFRodCcNbYOZ4LMAiS5uL2z1zMa/J/FgcnRs27yrm6T03vF7BwU+WVw9Dokep0jeh0avQ6rbGUG10/ZCtA/7lPhiB5gpwPpSc9hyXY9HLi9cNo5YvrtzFZeSGLL4TFWHBR7Pzj2fkQFW440fx5l5pxmzpXQVtRX+EClG3oIMFYj63GxmZsp19H+AxKdHgX03zzgXa8yt+eOt8yx93PG3s9VkdujzZ/nNXM+M+f/L3QCQwH+LYf/jHLc3jH1jAbT4qhNqd34McCkXQCYtFw+JBtRm0e7DxewZDMei7PT5bRTTb+dmcoLSYQ1NkZMNNvfj45dVxWEpc2fHTMzZrr1HdfrzlFc7LM4OxNlazYW42Gx93oqsc+ZP+fN9Mz0a3C+MxOQRxdkOt9ZMHa+Y+GmHcbtXYhz014Iv2mHCwGDurAFm/bCeEIMFwYTIvq0YHS0EaD8SGvl6vFkNRqYP+OYlUq1jX/cVMh/EfPnRckuMxdn3vil5/m0bKiLTMWnS5g/L2nmUmYuHVN/Pepqs5EMAvqkNWbnMtFGsmz0ulz0unz0ukL0umL0ulL0unL0ukr0umr0ulr0unr0ukblUeZy9VPenV0x4doqCddWr5/S2ehubk2YozOsimOt6bczqLyQVCRrxophmdj7ZWPv16ookrXNn9cxc10z16vnP/5bDrjZrA3cFNZnUi5o/y0P9N86QP9tYIn/VgD6b12g/zZk3kDXj3HABrH3G8ber1fBDRuZP29s5iZmbloDblgRGJuNgLHZzJLcXgnov42B/itY4r+Vgf7bBOi/IjM3bBbjgELsfTH2ftMKbiiZPwdmls0Ma8ANqwBjUwLGZnNLcntVoP8CoP+2sMR/qwH9Vwb6b0tmbtg8xgFbxN5vGXsfVnDDVubPW5u5jZnb1oAbVgfGZitgbLZjjs12sRhsHXu/Tez9thWx2d78eQczdzRzp4TYoDXveJwPwiQfjI9h3T72fo366gdDO5s/72LmrmbuFjsYqq+rzcHQzsC86BGzc/eosPaoPMChv9i/4toe0bX4QBfmzsBi2r3ra5U6WUvvAQxA/FSx2ujqz+rM7jrGpNwdTFbtY8/KZNwz4USwMvGQydKJrbqTv1d7ApN4r3pYMqi4T/fqQjGntX0PoB+QPt17Gnza2c+K+3TvGGn2ifkz7lOVbuhJU1/PKYU6ky3nsypXcLNBLuMETl4FbjbUxmDHd41rwpLrBZ6TCZ28U5qEte+fHGsntvaNpH1X3SN6v4953dfM/eIOYsg/5MnnPsD82x+8mdTqOYf9mQj/gHpGgw+ox697IDAZuHAfGCsu0LpTlctp/YA8Zt8XGJ+DLC3Wg5iK9eB6RoMPZijWQ4QXK+E+pMbFqtKNDruhSjegZHooOOkbo3gfGuti9q3v+KHC9ucXlo9dXyHh3xxmXg8384joz+1r71Nl7f1ia3f2b440r0eZeXQ9T20eGOUo+qznGPBZLto+LtzHAuunLjbQD/vtB6zN48CY0Q8MUn0i40I1eQxD7hxfz7NHoHNnRWDunCA8d5aP1CxqPaqV4xly50Rw7nDkzD7gvDmRoadEPqiZdI+i2rN4y9VXv0dxkvnzyWaeYuap9dP+0cW0vj4p5hOnkA3Kbr4cZJQqmHOmYt6cRxUK2s3nHHP8lPPCbCks6Vwp8LTOlYu5ovKLKnRybqZUcIp+3N7T6hkNpsUrkzit8acBieB0ZvGC8OHpCQWW1oeng1U3fTVUj7rOi0ClG/okps25Dmunit/EPSMqsDOj17Oi17NjcYUnDjDAHT7/dVZMNVWy6hkx9jwz9v6sqbDqOebP55p5npnn10/5vUEoDO2FhPTvOfX4HRqY4PocpmJB5+oFMDsz2aTcSWsffZQG+BGlfz56t0Q9PsfHAfP7QuEnB1R/ZzP48GygDy9i7mIviPHqhbH3F02Fby82f77EzEvNvKye/zPNCwL9eTnTnkbrDot81Kuu433lupi/kX65WHh90cdGL2RQdhfWaE9S6YZekMNOSrDedf92y9wJNguTo+vAdrYXIqcvBjH4Am3jYAtsHGJJ8Y62xM7LmWsUvptfDtzNr2Daza+IdvOpBS6t7RNgtmud1NlNqJ/2L1m90vz5KjOvNvOa6TifVOmGvhLc7baPa+sZDb42tvUsBkoOcvpsdbU5D5upTvQu/59HeeO+uC7y+fXtFdv+Sn/xTsW16xOquZ7RidMZfKf9gfDrgAx5vSV3IpGYb0jAPL1rxvPohii3annH5jowlvZxYz2jwTdO5VBlete/EbjV3yT8jg358KapCOfpXf8m5lvLKt3Q10e4kXG+CXnAF30hIjJ/bga3PO1kdXPsQKrygw7tA91JzFDHs9lIbjM57URu3vFvqL8lSoZbo9fbotfbo9c7otc7o9e7ote7K7utW6Iki1+7NeHabQnXbq+ffBew/dodCf/uzoR/d1fCv7s7ocvrDQ7IbdMakKl8Du32aVtrqp9ou2P6E2WKde+c3rUSLLwrfQL/Z9W7gaR7D/NdlXtiGvuW2Ptb66vfVbnX/Pk+M+8384F6/s9wP4g7f8jH7UQ3BVcC4/4QLu6J3xD8YH3yl0Q+NJW4P2z+/IiZj5r5WOzMpbGuNvKfSyGi7XwYaGf8d8E8Hm1uT0SvT0avT0WvT0f7T/RL7+qeMX9+1sznzHzezBfMfNHMl8x82cxXzHzVzNfMfN3MN8x808y3zHybFKSZ75r5npnvm/mBmR+a+ZGZH5v5iZmfmvmZmZ+b+YWZX5r5lZlfm/mNmd+a+Z2ZE8383swfzPzRzJ8qN+inY11grQ7xngCTa/v4uZ7R4J/r8ev+wiwzVbrxD+5f6ic7GLRuTT9C9yRTsv1az2jwrwzJ9pvwZCPcv1mebE8xJdvv9YwG/86QbH8ITzbC/QdDsnHY+ktUGOj+/s96O4vsaaYi+6ue0eC/GIpskvAiI9yTLCkyIoM/GYrs7xqJp9Tx7znddrqVF5KE7xMxgftk7P3Tsff0H8SF7wzmTQ8z683s2ZP/CwWBu7eeoScuNg09sYRXGZuGnpNj0CP2vj72vmdFbHqZN73N7GNmY8/qv7kiLXbij78Z6rIJ51NN2AfW1eYOyuNMfFIHtdPx+NZWzgwx37YfujSbILSY2WpmXzP7mdnfzDYzB5g5o5kzmTmzmbOYOauZs5k50MzZzRxk5mAzh5g5h5lDzRxm5nAzR5g50sxRZs5p5lxmzm3mPGaONnNeM+czc34zx5i5gJljzaSuiJLD6VnX8dCFjK28Y9GScK014VrfhGv9Eq71T7jWlnBtQMK1GROuzZRwbeaEa7MkXJs14dpsCdcGJlybPeHaoIRrgxOuDUm4NkfCtaEJ14YlXBuecG1EwrWRCddGJVybM+HaXAnX5k64Nk/CtdEJ1+ZNuDZfwrX5E66NSbi2QMK1sQnXVMI1nXDN6TmZJNvH6Oh1sehVpRsdSDPtxtEM2Njbf31SC26toBW3lt8Xt5buB1urrPvD1irpNthanh4AW0vpGVFrlZWeCbVWSemZUWt5Ss+CWsvU9qygtcpmrdlAa5XMWgNBa3lmrdlBaxEXDsKsVaa1BmPWKtFaQzBrebTWHJi1/tk7hkLWKv+z1jDIWqV/1hoOWcv7Z60RkLX+3WtHItYq/7vWKMRapX/XmhOxlvfvWnMh1op6k7kBa0W/Jk7PA1irGK01GrBWPlpr3vRr/efZ9/nSr6Xb15o/9Vpe2L7WmPRrFdvXWiD9Wv/58vixqdfK/2ctlXqt7H/W0qnX0v9Zy8Ed5rB+hgGhHdrXyuAw//NtauiDKjogbOqJP7hzwbFGP41GT/80A2NDcXYZ/Ji1wI/IHG9m8mMO6Md/zuPqKn4Fcs/Jh/C5nl37lGbevPHM9M1csCffr5Wmp9xaGHx61Ujem4Vp7SPMeQbcV4/k2cd6guOeB+5jCwFrHJg32pZYPAs821y4J08NS6qLJI5dKMarC3eRY8eZN4uYuSj5jJFj6SniVgauuUY4xxLmcQy4r7WkrscBa3FxIMcC80bbEovngBy7RE+eGpZUF0kcu3iMV5foIscuad4sZebSZi7DyLH0KY2+DFxznXCOJcxLMuC+3pK6XhJYi8sCORaYN9qWWDwP5NjlevLUsKS6SOLYZWO8ulwXOXZ582YFM1c0cyVGjqVPwfVj4JobhHMsYV6eAfeNltT18sBaXBnIscC80bbE4gUgx67Sk6eGJdVFEseuHOPVVbrIsauaN6uZubqZazByLH3KuD8D19wknGMJ86oMuG+2pK5XBdbimkCOBeaNtiUWLwI5dq2ePDUsqS6SOHbNGK+u1UWOXdu8WcfMdc1cj5Fj6Vsc2hi45hbhHEuY12bAfasldb02sBbXB3IsMG+0LbF4CcixG/TkqWFJdZHEsevHeHWDLnLshubNRmZubOYmjBxL35IzgIFrbhPOsYR5Qwbct1tS1xsCa3FTIMcC80bbEouXgRy7WU+eGpZUF0kcu2mMVzfrIscWzJuimSUzA0aOpW8hm5GBa+4QzrGEucCA+05L6roArMUykGOBeaNticUrQI4Ne/LUsKS6SOLYcoxXwy5y7ObmzRZmbmnmVowcS9/yOBMD19wlnGMJ8+YMuO+2pK43B9bi1kCOBeaNtiUWrwI5dpuePDUsqS6SOHbrGK9u00WO3da82c7M7c3cgZFj6Vt0Z2bgmnuEcyxh3pYB972W1PW2wFrcEcixwLzRtsTiNSDH7tSTp4Yl1UUSx+4Y49Wdusix482bnc3cxcxdGTmWvqV8FgauuU84xxLm8Qy477ekrscDa3E3IMcC80bbEovXgRy7e0+eGpZUF0kcu1uMV3fvIsfuYd7saeZeZu7NyLH0WyBmZeCaB4RzLGHegwH3g5bU9R7AWtwHyLHAvNG2xOINIMfu25OnhiXVRRLH7hPj1X27yLH7mTf7m3mAmQcyciz9lp3ZGLjmIeEcS5j3Y8D9sCV1vR+wFg8Cciwwb7QtsXgTyLEH9+SpYUl1kcSxB8V49eAucuwh5s2hZh5m5uGMHEu/xWwgA9c8IpxjCfMhDLgftaSuDwHW4hFAjgXmjbYlFm8BOfbInjw1LKkukjj2iBivHtlFjj3KvDnazGPMPJaRY+m3RM7OwDWPCedYwnwUA+7HLanro4C1eByQY4F5o22JxdtAjj2+J08NS6qLJI49Lsarx3eRY08wb0408yQzT2bkWPotvIMYuOYJ4RxLmE9gwP2kJXV9ArAWTwFyLDBvtC2xeAfIsaf25KlhSXWRxLGnxHj11C5y7GnmzelmnmHmmYwcS7/lfDAD1zwlnGMJ82kMuJ+2pK5PA9biWUCOBeaNtiUW7wI59uyePDUsqS6SOPasGK+e3UWOPce8OdfM88w8n5Fj36uf/Hvw4uum9ekzwjmWMJ/DgPtZS+r6HGAtXgDkWGDeaFti8R6QYy/syVPDkuoiiWMviPHqhV3k2IvMm4vNvMTMSxk59v36yb9XNL5uWp8+J5xjCfNFDLift6SuLwLW4mVAjgXmjbYlFu8DOfbynjw1LKkukjj2shivXt5Fjr3CvJlg5pVmXsXIsR/UT/49zfF10/r0BeEcS5ivYMD9oiV1fQWwFq8Gciwwb7QtsfgAyLHX9OSpYUl1kcSxV8d49Zoucuy15s11Zl5v5g2MHPuh+bnDGLjmJeEcS5ivZcD9siV1fS2wFm8Eciwwb7QtsfgQyLE39eSpYUl1kcSxN8Z49aYucuzN5s0tZt5q5m2MHPuR+bnDGbjmFeEcS5hvZsD9qiV1fTOwFm8Hciwwb7QtsfgIyLF39OSpYUl1kcSxt8d49Y4ucuyd5s1dZt5t5j2MHPux+bkjGLjmNeEcS5jvZMD9uiV1fSewFu8Fciwwb7QtsfgYyLH39eSpYUl1kcSx98Z49b4ucuz95s0DZj5o5kOMHPuJ+bkjGbjmDeEcS5jvZ8D9piV1fT+wFh8Gciwwb7QtsfgEyLGP9OSpYUl1kcSxD8d49ZEucuyj5s1jZj5u5hOMHPup+bmjGLjmLeEcS5gfZcD9tiV1/SiwFp8Eciwwb7QtsfgUyLFP9eSpYUl1kcSxT8Z49akucuzT5s0zZj5r5nOMHPuZ+blzMnDNO8I5ljA/zYD7XUvq+mlgLT4P5Fhg3mhbYvEZkGNf6MlTw5LqIoljn4/x6gtd5NgXzZuXzHzZzFcYOfZz83PnYuCa94RzLGF+kQH3+5bU9YvAWnwVyLHAvNG2xOJzIMe+1pOnhiXVRRLHvhrj1de6yLGvmzdvmPmmmW8xcuwX5ufOzcA1HwjnWML8OgPuDy2p69eBtfg2kGOBeaNticUXQI59pydPDUuqiySOfTvGq+90kWPfNW/eM/N9Mz9g5Ngvzc+dh4FrPhLOsYT5XQbcH9vyGXlgLX4I5Fhg3mhbYvElkGM/6slTw5LqIoljP4zx6kdd5NiPzZtPzPzUzM8YOfYr83NHM3DNJ8I5ljB/zID7U1ueFwLW4udAjgXmjbYlFl8BOfaLnjw1LKkukjj28xivftFFjv3SvPnKzK/N/IaRY782P3deBq75TDjHEuYvGXB/bkvvBKzFb4EcC8wbbUssvgZy7Hc9eWpYUl0kcey3MV79roscO9G8+d7MH8z8kZFjvzE/dz4GrvlCOMcS5okMuL+0pK4nAmvxJyDHAvNG2xKLb4Ac+3NPnhqWVBdJHPtTjFd/7iLH/mLe/Grmb2b+zsix35qfOz8D13wlnGMJ8y8MuL+2pK5/AdbiH0COBeaNtiUW3wI59s+ePDUsqS6SOPaPGK/+2UWO/Yv+nZl/04UGPo79zvzcMQxc841wjiXMfzHg/taSuv4LWIszNAB7OiDH2hKL74Ac26OBp4Yl1UUSx1IOtnNpj4aucWw98aqZDWb2YuTYiebnLsDANd8J51jCTD5GrzvRkrquB9ZibyDHAvNG2xKLiUCO7dPAU8OS6iKJY3vHeLVPFzm20fy7JjObzWxh5Njvzc8dy8Cx3wvnWMLcyMCxP1hS143AWmwFciwwb7QtsfgeyLF9G3hqWFJdJHFsa5xXu8ix/cy/629mm5kDGDn2B/NzFQPH/iicYwlzPwaO/cmSuu4HrMUZgRwLzBttSyx+AHLsTA08NSypLpI4dsYYr87URY6d2fy7Wcyc1czZGDn2R/NzNQPH/iycYwnzzAwc+4sldT0zsBYHAjkWmDfallj8COTY2Rt4alhSXSRx7MAYr87eRY4dZP7dYDOHmDkHI8f+ZH6uw8CxvwrnWMI8iIFjf7OkrgcBa3EokGOBeaNticVPQI4d1sBTw5LqIoljh8Z4dVgXOXa4+XcjzBxp5qgYx7aPHuA496/D+XN4A09u14MxPwzM7SeAa80J9B/lzax1k/eS+EDv10i74/bO1cBo8FwN+HXnBhIdF+65GyY7GLTuP8nWVDeZnDiTLV68KuXgtPOJep6imCeWt/hvcwF2TWRbfWRju9E9Y9e4EwUZgHhij44KaF7CxBGAeRiYaR7w1syFuwcj7tQfrWH2oUo3NCXmfAzycX7w9t5OALTu/tG6aF/My+SLMUy+GDMVX6T+agMmX/zx3z1OKXViH1sO/DlSNg/QxjcfA5cC462RPqSmgmZS91k3jT7oLKfia3LwN8on8QZrgal1jCrd0PMxEWLc6Gm0WXf2c8jmBRiI4S8hZ3vT0sikfr6tQSbB/DWSJy/Hxjbq6Y1PZz5HxkfF1tKZjKmNIK/DIMxk875T1LlMLhe6YT7nuUGYdQtBvqzdQsbxy3kVaq9czmczpXwu9INSLoyTtg4yGTfwiyWddXKFovKCTEGFbj7jqEKQyQdBxsvlCplMkPNCz/ccpxBmPJXN532VczK+wxUfFcWnlkrzYSalqSOl6dhC4Fz2aQayzjBtXBlGVUO+cBh84TL5wmVUNVx58bdwVcOVA3WjZPPAw0yqBhhvjfTh/xdVo5lUTdZGVZNlVjVZBmKYAUwM7UOyqsk1yCQYZCzieZmzTNXkgaomTtppVQ1XfPIxVVNtU5B8HMVpJ9cG49m4wXjMG4zHsMH0YNpgGsB2IgnMB66FPDZDblY9mMjQ78JmldanCzbgNoUOx2aCNiuu+Cz4/+gIbqGIRBZOethDpRu62kMPyKd4Uv/uEWAnzBH4dh/WW+LDtGuNEx4PKphxDE3CIkwN0yKMx7ULM/liUSZfLMp4XMuVFw3Mx5Zpj2u5cqCXBce14xiOa4Hx1r26j2srxz/8jfJJvPFbjFNNj2MixMUY1fQ/NjMQQ29LjmvHAZuixRtkEkxvJoW1eA2Oa5HxWQJ4XNsLqIC54rPEf0EBc33cYclIAS9lC4Fz2bckA1kvzbRxLc2oasgXSzH4YhkmXyzDqGq48qJRuKrhyoEm4armCSZVA4y3bupWNZVDL8mkapa1UdUsy6xqlmUghub/QVWzXINMgmlm6pqXs0zVLA9UNU1AVcMVn+X/Cw+hLNTAU/e2bDAr2LjBrMC8wazAsMG0WPIQCpLAVgSuhTw2Q25WLUxkuGINHkJZCfgQSodjM0GbFVd8VkqID/oZAeBDJ/op4PdIrQzk9Vp+j9TKTJvoKg2MBq/SgF93VSAxc+FetWGyg0Hr1vR7pJ6y5HukkE+2xYtitQbG75FaFShd46zebvT/h0cLV48KaI0Ghu+RogCsxsBMqzHfqEHh7sGIO62Nawq/2UWJuSaDxFqLSW6uxXizaw0mX6zN5Iu1GW92ceVFP+E3u7hyoL8Fj/CtycClwHjr/t03uyrHP/yN8km8wVqH8yxyTSZCXIfxLJJsXoeBGNosudm1JrApWrdBJsG0MZ1PrVuDm13I+KwHvNnVH3h+yBWf9f4Lj/A9xaQ014+U5ga2EDiXfeszkPWGTBvXhoyqhnyxAYMvNmLyxUaMqoYrL2YUrmq4cmAm4armKSZVA4y3nqlb1VQOvT6TqtnYRlWzMbOq2ZiBGGb+H1Q1mzTIJJiZmbrmTSxTNZsCVc1MQFXDFZ9N/wuP8K3ewFP3tmwwm9m4wWzGvMFsxrDBzGLJI3xIAisA10IemyE3q1mYyLBQg0f4isBH+PqPkrlZccWn+P/oCK4UkUiQ9LCHSjd0tYcekE/xpF0L+OAIy/cWtfsQ/Ywolw/TrlUWHg8qmDJDkxAyNUwh43FtwOSLzZl8sTnjcS1XXgwUflzLlQOzW3BcW2Y4rgXGW8/efVxbOf7hb5RP4o3fFpxqusxEiFswqmmyeQsGYhhkyXFtGdgUbdkgk2AGMSmsLWtwXIuMz1bA49rZgQqYKz5b/RcUMNfHHbaOFPA2thA4l31bM5D1tkwb17aMqoZ8sQ2DL7Zj8sV2jKqGKy+GCFc1XDkwhwWP1nOoGmC89RzdqqZy6K2ZVM32Nqqa7ZlVzfYMxDD0f1DV7NAgk2CGMnXNO1imanYEqpo5gKqGKz47/hceQik18NS9LRvMTjZuMDsxbzA7MWwwwyx5CAVJYOOBayGPzZCb1TAmMhxfg4dQdgY+hDL7KJmbFVd8dmY8AfnD/JBJ9XgO2oX5FAzBPbskPGuh0g3kPqR3AXLarsLjQd8puCvDXrgb+BkT9PNNdAqDtPGJaL06bF6znEA9GdmKjvnuwFyv5XfP7c7UeO/RwGjwHg34dfcEEh8X7j3/x4tsLyY1iyZYZC7tLXwzudfEGmkjxXjvGuV5Wuy31/9bk+jbGcj82cfSjekOpu9/3LeB0eB9GTam/YRvTIR7P0s2JirYfRg2pv2FP39B8dmfgaj2AebmAcLV4p0WkP2BlpL9XUxkf1ADo8EHMZD9wcLJnnAfbAnZU8EeyED2hwgne4rPIQxEdSAwNw8V7sNb6u1R27daZOttFtlKzc0BDPxxmPDcp/gcxoB7T+G4id8OZcB9uAXxPvx/MN53M3ERNc6z1SU/34Pek68H/vqcu9M34f95/CQBOmztuF+PiOJ3ZEOUIO33r4+IEjp+jf7RsAqjpvUBuc6M5ArIdK7ltD8dfASweTuyAZsoHI3/EQyEdpTwE4rrI9zo5wuQOY3Mw6OBtx3iPHF0jCc4CBvpg7uj9dDPTl1fj91oUWshfXcMcK14/hwTyx+OW05HMIj724E1fqwFJ7kcPrwT6MPjwD7kwHoEkH/pYJEwo5/3Re5ddzJxoqQ99XhLHrFAYj4B/IgFup+lmJzA0M+eyPT5hROj/S9JCKN5iPLgdmBd0t5Fd7TR34d2+//fem/Xch0+gVqHiXOi6D8p2iROrhT9JyWI/pOn0oypdOOfRx+OZSjMeYV/jPt2JoH91WiezQctjmwo5rRrfc0UC1CD95+DrZOAmE8GNgLAGtbAutCAuP6H8LuywSPqAy1OkzZ4lW7o25kOOVS6oRENfRiNuoQByqUOG/wpEUmcWrnBn5KwwZ+acKqPJplTgCRzagNPo4DcfCVsHvGkQzcwpKZOYmhgTrNEPSPz+XTh6plicjrDad9pQB+eIfxWOWE9g6FezgT4sBzxRC2fVz0TfHLSPs5qYDT4LIbnVc8W/rwq4T67YbKDQeuy2HpCZCu6yM4RfjumHTeaoE8A5ua5wm/H3A6+HdN+svW/cgx6HriJQTdsHLfbjmrgOY5HYT5feM2RsgZyqyaOOY+B/y8A+tHWZxtvs/DZxgujvuWiylOQCxNOQS6y7NnG24DPNl4IJJ2LGrCJgm4SiWDPZyAJLfyWEzVzFzDgdoR8MWonA1p7FwM3LWDeaEd4DhLPXMyQg5cwPYdxCeNziMTfFzI8a3xbPTZeKLyXMj0reqll+/Zl/yPc0T7QQg6Zk5cLP3mnXLmcgS+vYOLLK6by3Fq1fFDphr5NWG3W+lbvhEjkXFkpciYkiJwra0CWXAFJK3ImAInjSmCiTEuxCFDx7UNfhhN6NXvw8aqoWK6uLJarEorl6i4Ui9SApC2Wq4DFcjU4UdC7LO2wExh22WsseZYBGetrhXdUFJNrGY7trwH68DrhzzIQ1usY6uV6S59luJ7pWYYbGhgNvoHhWYYbhT/LQLhvbJjsYNC6LLZeHtmKLrKbhD/L0I4bTdCXA3Pz5hpt7CrdgCqxW8C1jcZKzS8wtzXF+BaG+ruVKXfgx9MwOx2XbBtQN1k80Z9p/Ukxu9vf962f/L5f9L79v7udPnlg5p1m3tUw+feA1Wqjv51po7+7gdHguxM2vLTJQU5vrrPP6b1idt4T+eXe6PW+6PX+6PWB6PXByqOCe6Njgfg1+sd9KhyBlmkzAJ16PziTK6t7eKyK74lV+r2x9yMqqvsh83cPm/mImY82TL7ePtA3yu4D7hYPAXfHx5h2CPjntYD+exjov8eZc/uxWA4/Hnv/SOz9ow0dc/sJ8+cnzXzKzKf/CzvXAzhpXY7b+0wDo8HPNOBItN34Z4BJ+6xwuUs+fBbYwrb78FnmAhsb2zxotr9/IlZgqmLzeM783fNmvmDmiw0d1+v2aV1dNubTB2N+fG4qPn3J/N3LZr5i5qsJGzJawl0BlKuvAes83ui9FrvDbSF5h3F7X+ck79fx5B2+DgzqGxaQ9xt4ognfAHeXaJXzRESwKD/SWi8xnCc+AcyfN/9LG+qbUyH/t8zfvW3mO2a+y7yhSs/zadlQ35qKT98zf/e+mR+Y+WFDx99jX4uN5B6gT1pjdn4UbSQfR6+fRK+fRq+fRa+fR69fRK9fRq9fRa9fR6/fRK/fRq/fVR7BfNIw5dManydc+yrh2rexa5VBXTMW1I9igfw49n6tiqBONH/3vZk/mPljDY4tPgGS40Qgif1kybHFp0D/fQ/038+W+O8zoP9+APrvF2bC/ynGAT/H3v8Se/9jxbHPr+bPv5n5u5l/1IAbPgfG5ldgbP60JLe/APrvN6D//rLEf18C/fc70H+TmLnhzxgH/BV7Pyn2/o8KbvibmhpzQ2oGM3v04ueGr4Cx+RsYm/peduT210D/1fUC3ou1xH/fIE/kgP5r6MXLDZTf7RzQM/a+Ifa+R6+O3NDL/Lm3mX3MbKwBN3wLjE0vYGyamGPTFItB79j7PrH3jRWxaTZ/bjGz1cy+UWyS1h4f05LNsfW+m8oBQT/z7/qb2WbmgF6TDwjatWvlQB8Q9AP6u0fMzhmjBy9m6lXXUYzTX+xfcW2m6Fp8oBO+HzBJZ+z6WqVO1tIzAQMQP12qNrr6szqzu44xKWcEk0D7mLkyGenCDJ0kHjJZOrFVdwZmZmASz9ILlgwdPhE6SxeKOa3tMwH9gPTprNPg085+Vtyns8ZIs0/Mn3GfqnRDT5r6ek4p1JlsOZ9VuYKbDXIZJ3DyKnCzoTYGO75rXBOWXC/wnEzo5J3SJKx9/+RYO7G1byTtu+pM0fvZzOtAM2ePP/bHkH/IE8XZgPk3CLyZ1Op+9yAmwh/ci9Hgwb3w6w4BJgMX7iGx4gKtO1UZmtYPyOPrgcD4zGFpsc7BVKxDezEaPJShWIcJL1bCPazGxarSjQ67oUo3oGQ6HJz0jVG8h8e6mIG9On4opv2e9aex84PPGqb8NyPMfzfSzFFRjrevPVuVtWfvNXntzv7NnOZ1LjPn7sVTm0OiHEU9DNIer3nAZ6Ro+7hwjwbWT11soB/6mh1Ym/OCMaMfHKP6RMaFanIehtyZj+m+Ajp3Pgfei5pfeO4Q988OtJFqZT6G3BkDzh2OnEEqbcqbMQw95T3M962rPeP2yVTuUSxgcI41kz5MqXtVfzA09W/FMT/3jHp8DZ0B/JSBI7yvIB+eyeDDM4E+zFjgw7MYfHgW0Icu831SJ6YFMrH3bq/qPJE1f5czM2+m16vze9hpfbAAcF/MAvcG39KDHR+cU+1jwV6MBi/IsAkvJPxgh3AvxHCwQ8lGz6j1qONPtgXAm0DlQPqkfSwc+Xxc9LpI9LpoLAfhu9FCQJaL31NcpFf1T0UsHGP5cbH3i0yF/Rczf7e4mUuYuWSM/dG76AJR8kP92wuvOJC702LgHaXal89ydFJp7Y4+3VWzL4xdKirqpSsfFlmq15QfLaJ/NKzCKHSbczrw174sBSycpXthg8uxiy/FcNSxFLN8UemGNbjbB4p4//0caKBPB8qsZWCYM7Rf1q1r5mrReiSxSFqRpLrI/CX9LLql0z27NtsHuH6ylD9UQygejz6fXELkZftayAZoWVxdZ3tEOV45QOsrppjrZXvJt3E5tI0cSmVhho1n0VHyN9zleuGfhVgYWOTLA9UIMh7MhKG5itEGwliemzBUumHDTltE7rQr4AKSs3WnXcGCwlnRhp12HMNOu7gFO+2KDDvtOGCRrwTcaRfv3mmtIIyVunfa1GsVkDvtyriA5G3daVe2oHBWsWGnXYRhp13Sgp12FYaddhFgka8K3GmX7N5prSCMVbt32tRr+ciddjVcQDxbd9rVLCic1W3YaRdl2GmXtmCnXZ1hp10UWORrAHfapbt3WisIY43unTb1Wh5yp10TFxDf1p12TQsKZy3hhfPPjrNWL/yDN8hkXxv44I2tu4QNyb420kZbWalvvXwb1+kOlNLDLQjUukyPWcKF1Xo4Qx1bE2o9Cyh6/e7KVzprQeVv0B0opcdaEKgNbaHojbof7dUbWUDRG9uSUJt0P8GmN7EgoTa1JaE2635QQ29mQUIVbEmoYvf9SF20IKFKtiRU0H3srgMLEqpsS0KFOEMLtiZUaEFCbW5LQm2BM7Roa0JtYUFCbWlLQm2FM7Rka0JtZUFCbW1LQm2DMzSwNaG2sSChtrUlobbDGVq2NaG2syChtu++paH0eAtuaexgS+XvCDNUK1sTakcLKn+n7spXeoIFlT/elsrfGVf51j5vsrMFlb+LLQm1Ky6hMrYm1K4WJNRutiTU7riEcm1NqN0tSKg9bEmoPXEJZe3zO3takFB72ZJQe+MSytrnd/a2IKH26VZPSj9ogXra15bK3w9X+dY+F7OfBZW/vy0JdQAuoax9LuYACxLqQFsS6iBcQln7XMxBFiTUwbYk1CG4hLL2uZhDLEioQ21JqMNwCWXtczGHWZBQh9uSUEfgEsra52KOsCChjrQloY7CJZS1z8UcZUFCHW1LQh2DS6jQ1oQ6xoKEOtaWhDoOZqhj7fM7x1mQUMfbklAn4BJK25pQJ1iQUCfaklAn4RLK2ueMTrIgoU7uvkem9MwW3CM7pTtQSt/WIN/GU22h6NNwFG3tczGnWUDRp9uSUGfgEsra52LOsCChzrQloc7CJZS132tzlgUJdbYtCXUOLqGsfX7nHAsS6lxbEuo8XEJZ+/zOeRYk1Pm2JNQFuISy9vmdCyxIqAttSaiLcAll7fM7F1mQUBd3n+8o3WrBQdwltlT+pbjKt/a5mEstqPzLbEmoy3EJZe1zMZdbkFBX2JJQE3AJZe1zMRMsSKgrbUmoq+z5hVdswbrKgoS62paEugaXUNY+F3ONBQl1rS0JdR0uoax9LuY6CxLqelsS6gZcQln7/Ts3WJBQN3af7yi9pgXnOzd1B8ocwVsQqJttoehbcBRt7XMxt1hA0bfaklC34RLK2udibrMgoW63JaHuwCWUtc/F3GFBQt1pS0LdhUsoa5+LucuChLrbloS6B5dQ1j4Xc48FCXWvLQl1Hy6hrH0u5j4LEup+WxLqAVxCWfu9Ng9YkFAP2pJQD+ESytrndx6yIKEetiWhHsEllLXP7zxiQUI9aktCPYZLKGuf33nMgoR63JaEegJmqGvt8ztPWJBQT9qSUE/hEsra53eesiChnrYloZ7BJZS1z+88Y0FCPWtLQj2HSyhrn995zoKEet6WhHoBl1DW/v6sFyxIqBdtSaiXcAll7fcEvWRBQr1sS0K9gksoa5+HesWChHrVloR6DZdQ1j4P9ZoFCfW6LQn1Bi6hrH0e6g0LEupNWxLqLVxCWfs81FsWJNTbtiTUO7iEsvZ5qHcsSKh3bUmo93AJZe3zUO9ZkFDv25JQH+ASytrnoT6wIKE+tCWhPsIllLXPQ31kQUJ9bEtCfYJLKGufh/rEgoT61JaE+gyXUNY+D/WZBQn1OdrGHuBEeqOhru5N3O+60LTeew1T2qnSDR23MS3mL8BBgX+JaH1d3UK98KSx/CgedusJxr9oLxzmL3Gx1kvj/KeRsaA8GRCLA/2ZvlZhUvSe8r39/Zex9yr6N+3/3Vfm77428xszv+01+Xr7QNf0a8Ca/g4YZ/JNfeQjWndY5KNe0fXKga7/r5j5Ka2vn234N6fQuL9g6r7gN8AYfjfUPwnW28yGOv4Eu72Bx9F1WDud9kLk9MU9Fvyir3stsPG+BjuK9wlL7PyuF2+Nwnfz74Bd20Sm3XxibDdvSQgeje97Rf9g1oq/4Ir0YOA3YMXt/aEXo8E/MOz/PwIziAv3j70mOxi0LouttxhbL2/A934rjJKN+1aD+0IG3Ctaop3vBWqqn4AsDMwbzRUL9Nkaks9+BsaCo+4oV35mOLP6pRd2c2zvBH6JOgGOuNM+gYwXl29/ZfLtr13osn6L4YEn489MvXM9OAC//w8QbNLh5CaxQ8hZYgeVfWPv+1UcTv5h/ps/zfyL/tvocJJma11tuvQ/wMXSPv7uFRnbXj1/R5VB4PpaCK7SRjht/c28FSLEK9lYDw7SxF48PkwttXrziHVad1i0LvqwgtZAbtGDImmIzqUZemMLk0sSo3H36M27Aw2P7TTk4/b3PWLvR1TsQPXm73qa2WBmr94d10P6dAiTT1cTLt2pHn9jwL26JdK9vjcOc28gJwPzRnPFAr3XzoI7k9U9gXHtw8yLvWP81yf2viH2vlfvjrzYaP7cZGazmS29J3fmtbqbOUs9T07Vge2sxd1MdL/AYSNyb0f3hbTvDqnH72ngXGK989jY2w47J4J1YNzGbtHKEKTptbEc/juQorUVl+ROXLS2xkRr+0CfLyP90Lc3vojq6vBHpafX49ZaCOi/fsA86hnlUC1O/JBNU2x/q+vf+9/Xtuh1QPQ6Y/Q6U/Q6c2/G8/+/wWe17cXdFhV3/BoB6hP9LHShtx8HI/3SHgigvzs9YekfUw9tUzlhmcX83axmzmbmwN5TPoCM3pwGAMlvFqDKm52pA5OskmcF+m8Qs0qePZbDg2LvZ4u9H1ihkgebPw8xcw4zh8ZUcq2eMpupN6wRK8ftHdab0WBaHEWq7cYPAxb9cGDScvlweG+cWmj34XDmAhsb2zxmjBXV4N7VP70ywvzdSDNHmTkn4/E8baJIn7bHfy7ht3ool+ZiyKW5mHMpG8ulmePNx1RyaW7zd/OYOdrMeaeSSwglN7w3/vYmUiHOJzwv208uJPtwfnCOt4uP+WOnDRw814+B59YSfhuSTkT69caLuTHAvgPtQ3Tt0D4N5A1Ne8TcDLm4ALAuLW3mw7i9Yzmb+bH4Zj4cC0wyZUEzr/ANWKj+S838AlNpwLT5O8fMjJkuczOvGIgla0Ezn2XIpSxzLlVr5vVUciln/i5vpmemz9zMK+HN/ILgDa9HXW02vP5Au1tjdi4UbXgLR6/jotdFotdFo9fFotfFo9clotclo9elotelo9dlotdle1t4m2Nc78n3odqvLZZwbcmEa8vErlUW75qx4l0oVrALx96vVVG8y5m/W97MFcxcsTf/LYFxwIZiOWBDsRJ4Q+Hy3yJA/y0P9N/KlvhvUaD/VgD6bxXmjX2lGAesHHu/Suz9ihW3VFY1f17NzNXNXKMG3LAYMDarAmOzpiW5vTjQf6sB/beWJf5bAui/1YH+W5uZG9aM9wex92vH3q9RwQ3rmD+va+Z6Zq5fA25YEhibdYCx2cCS3F4K6L91gf7b0BL/LQ3033pA/23EzA0bxDhgw9j7jWLv16/gho3Nnzcxc1MzN6sBNywDjM3GwNgUmGNTiMVgk9j7TWPvN6uITdH8uWRmYGY5ik3S2uNjWrIYW2/ZqRwEhebvNjdzCzO37D35EZz/fOC0YqD1egj0d4+YnVtFhw1b23LYwGXfVgwnuduAi6Q92Wjd/RljtTWDL7Zl8sW2U/EF4lSWIy/WZ76N3Yl9pU7sY8uBDYTfvifcIcMpPDDeGunD9k0sviFUjq7+rM5yKr4mOm5bgbmlfWxn4wl83OhptFl39nPI5u0YiGFDIR+zr+Wnp7bvLZNgkLGI5+X2sY16euPTmc+R8dkhFh+dyZjaCPI6DMJMNu87RZ3L5HKhG+ZznhuEWbcQ5MvaLWQcv5xXofbK5Xw2U8rnQj8o5cI4aesgk3EDv1jSWSdXKCovyBRU6OYzjioEmXwQZLxcrpDJBDkv9HzPcQphxlPZfN5XOSfjO1zx2SGKD73vU9fx4+ao3Jo09fWcUqgzWeM5lSu42SCXcQInrwI3G2oTNMd3TcjCkusFnpMJnbxT+s+Xf0Wc1L6R0futYmpu6+j9juZ1JzPH967rMNCfOETeydoRqNp37o1tHmr1zNrOTBv8Lr0ZDd6lN37dXYHJwIV711hxgdZl/SZF5G3TnYDx2c3SYt2NqVh3781o8O4MxbqH8GIl3HvUuFhVutFhN1TpBpRM9wQnfWMU7z1jXcxOsfftHQ/NRWLXF034N3uZ173N3Kc3T/1Q1z2e4dikLzA++zLFZ8cq8dk3Fp/O/s1+1HmbeQBTfHaN6hyt2g8E39/kyMsDGXAfxIwbcWx9YG/ZDxMfDPYhGitxJtBGTTV+EEMuHmJBDY5nwH2oBTXIgfswYE5y1A3hBubkPz3AXgx+PNyCulmMAfcRFtQNB+4jhdcN9fBATtPEE4cz+PEo4fs29drAHNeUN0cx+PFo4X6kOuzfG1vXRzOcNSQ931Xt80Hjeld/vusY83fHmnmcmcf35vug3+lMv5/7BDC/cexnJzDU0YnC93GnF0+8QyF3zDsZemGgZjwJmOOLAu+Yh8Ifa8ow5eDmluTgOGAOngzMwcWBObi58Bx0mXJwC0tycBFgDp4CzMElgTloSywWBcbiVGAslgbGYnnhfEB920kM/eBpwvtBwn0yA+7TLcB9CgPuM8D39Sq15GkxzXh67P0ZU9GSZ5q/O8vMs808p3fnnxFL64NjgBx0JlDzn2vpAyzngnOqfZzXm9Hg8xgeYDlf+AMshPt8hkMlSjb67VM96viT7ZjePE0Th0/axwWRzy+MXi+KXi+mHEQzPAX47172fP7iotiTH5W7yQWxXePC2PuLprKbXGL+7lIzLzPzcsaTSfLH+cKfGriC+dQcsRMDbdSXROvVYWPyTzHPVlcbgkP8lpv2b5tMMDft2v/5zFPcFxMin1/ZO3JIe3FPiBV3+zX6R8MqjEI/9tgv/U7stH8SbwJwV78SHFw0qVHxTGAoIA5b6XhsHYZfo7YOkICvApIb97E5Ih7rMsRjXWA8rgbGY3ML4rE+QzzWB8bjGmA8trAgHhswxGMDYDyuBcYDfaSKbrQpHsv0wsZ3Q4ZfjrEh0MbrhD/ORj7cmMGHGwN9eL0FPtyUwYebAn14gwU+LDD4sAD04Y0W+LDE4MMS0Ic3WeDDMoMPy0Af3myBDzdn8OHmQB/eYoEPt2Tw4ZZAH95qgQ+3ZvDh1kAf3maBD7dl8OG2QB/eboEPt2fw4fZAH95hgQ93YPDhDkAf3mmBD3di8OFOQB/eZYEPxzP4cDzQh3db4MNdGHy4C9CH91jgw90YfLgb0If3WuDDPRh8uAfQh/dZ4MO9GHy4F9CH91vgw30YfLgP0IcPWODDfRl8uC/Qhw9a4MP9GXy4P9CHD1ngwwMZfHgg0IcPW+DDgxl8eDDQh49Y4MNDGXx4KNCHj1rgw8MZfHg40IePWeDDIxl8eCTQh49b4MOjGXx4NNCHT1jgw2MZfHgs0IdPWuDD4xl8eDzQh09Z4MMTGXx4ItCHT1vgw5MZfHgy0IfPWODDUxh8eArQh89a4MNTGXx4KtCHz1ngw9MZfHg60IfPW+DDMxl8eCbQhy9Y4MOzGXx4NtCHL1rgw3MZfHgu0IcvWeDD8xl8eD7Qhy9b4MMLGXx4IdCHr1jgw4sZfHgx0IevWuDDSxh8eAnQh69Z4MPLGHx4GdCHr1vgwysYfHgF0IdvWODDKxl8eCXQh29a4MOrGXx4NdCHb1ngw2sZfHgt0IdvW+DD6xl8eD3Qh+9Y4MMbGXx4I9CH71rgw5sYfHgT0IfvWeDDmxl8eDPQh+9b4MNbGXx4K9CHH1jgw9sZfHg70IcfWuDDOxl8eCfQhx9Z4MO7GXx4N9CHH1vgw3sZfHgv0IefWODD+xl8eD/Qh59a4MMHGXz4INCHn1ngw4cZfPgw0IefW+DDRxl8+CjQh19Y4MPHGXz4ONCHX1rgwycZfPgk0IdfWeDDpxl8+DTQh19b4MNnGXz4LNCH31jgw+cZfPg80IffWuDDFxl8+CLQh99Z4MOXGXz4MtCHEy3w4asMPnwV6MPvLfDh6ww+fB3owx8s8OGbDD58E+jDHy3w4dsMPnwb6MOfLPDhuww+fBfow58t8OH7DD58H+jDXyzw4YcMPvwQ6MNfLfDhxww+/Bjow98s8OGnDD78FOjD3y3w4ecMPvwc6MM/gD6k39mwnZmrRevR73Wh3yVCv7+CfmcCfa8+fS88fa85fS83fa80fS8yfa8vfS8tfa8qfS8ofa8lfS8jfa8gfS8efa8bfS8Zfa8WfS8Ufa8RfS8Pfa8MfS8Kfa8HfS8Ffa8CfS8Afa6dPpdNnyumz8XS5zrpc4n0uTr6XBh9rok+l0OfK6HPRdBz/fRcOj1XTc8F03Ot9FwmPVdIz8XRc130XBI9V0PPhdBzDXRfnu4r031Ruq9H96XovgrdF6BzbTqXpXNFOhejcx06lyBdTbqQdA315dRXUl9E+zrtS7+aSbxAeU1xaR/gX56Vpd/7RL/DCJ3vfwJzqUeUS5UDtT6TbzXSB1w2/oW2EW3gBUwJuqPwX35DmCk46F9+Ew94Whsn4ZJHI+PBTBi6jqkYbSCMScIJ4z87GrrTugJYOH937476bwuSva6P8N3xQqbdcbwFuyMFB707xgOe1sYZcMmjx3fvjlYQxgzCCYNrd3SQu2OPPt27Y48+8m2sl747XsS0O+5iwe5Yz7A71gN3x57A3XGX7t3RCsLo+T+6O2aQu2ND9+6oGyxI9l7Sd8eLmXbH3SzYHXsx7I69gLtjb+DuuFv37mgFYfT+H90dXeTu2Kd7d9R9LEj2Ru5kR+wSjfBdIqOu6M3jxLR4m+wpHLZdwobCaZLeVtpw/60Z6ETyX33kR1p3WF3HUekHBDGh1mrpgy1KdC5N7FVX93cvPLnvCZYoPRhw9wXEuRz+O/6O1usJtvPvXrg7CH2Bed0KzOs9meWsSjf+icECDDK+bx/ZuLm4oV+3gtB96+Xb2B+Zn7YGargFgWrrDpTS6/WSb+OA7kApnbWgombsDpTSYy0I1EzdgVJ6Iwuob+buQCm9iQWBmqU7UEpvZkGgZu0OlNJFCwI1W3eglA4sCNTA7kApHVoQqNm7A6X0FhYEalB3oJTeyoJADe4OlNLbWBCoId2BUno7CwI1R3eglB5vwRHS0O5AKb2jBRU1rDtQSk+woKKGdwdK6Z0tqKgR3YFSelcLAjWyO1BK725BoEZ1B0rpPS0I1JzdgVJ6bwsCNVd3oJR+0IKub+7uQCm9nwUVNU93oJQ+wIJAje4OlNIHWRCoebsDpfQhFgRqvu5AKX2YBYGavztQSh9hQaDGdAdK6aMsCNQC3YFS+hgLAjW2O1BKH2dBoFR3oJQ+wYJA6e5AKX2SBYFyugOl9MwWnPVlugOl9G0N8m10uwOl9GkWUF+2O1BKn2FBoHLdgVL6LAsCle8OlNLnWBAorztQSp9nQaD87kApfYEFgVqwO1BKX2RBoBbqDpTSrRYI3oW7A6X0pRZU1LjuQCl9uQWBWqQ7UEpPsCBQi3YHSumrLAjUYt2BUvoaCwK1eHeglL7OgkAt0R0opW+wIFBLdgdK6TUt0FFLdQfKHCFZEKiluwOl9C0WUN8y3YEyt+ItCNSy3YFS+g4LArVcd6CUvsuCQC3fHSil77EgUCt0B0rp+ywI1IrdgVL6AQsCtVJ3oJR+yIJArdwdKKUfsSBQq3QHSunHLAjUqt2BUvoJCwK1WneglH7KgkCt3h0opZ+xIFBrdAdK6ecsCNSa3YFS+gULArVWd6CUfsmCQK3dHSilX7EgUOt0B0rp1ywI1LrdgVL6DQsCtV53oJR+y4JArd8dKKXfsSBQG3QHSun3LAjUht2BUvoDCwK1UXeglP7IgkBt3B0opT+xIFCbdAdK6c8sCNSmfcA2og3s27uuboyZPSrWzaic65bzTllndEE5ftHLKjdbzHna01kvGzheJlP2XC/vF/288rWbKesw62fCaOHNcMD1WqOwTkT7sNH4j/w4A9iHhT6ycU/s9S/uHgw5ifJhUbgP/+jFkzslS3IHjTsQjvtvg/t8Btxl4bhPNJhPZcAdgnGjuWwBg3nB3rj1smatHIMfNxeeP5TfFGt0n7IFsE/ZDdinkP8GmNkzWo/+TB8NmxS9p3i1v98i9l5F/6b9v9vS/N1WZm5t5jZ9Oq6HjA/xOXEbuH6cv3vhYr1tH2x86iM/0rrDIp/3iq5XDrS/txRer/P1/jdH67DrKk6fTsQJSl1pI0sjAVpLUeKaeNU11PEn7iz1PMkATjTdXuCcvpihN94XaBt7AG1EN1c/mhoYgssn/bNZ77de8FxiJa3G3v9z5OpU2iiaXLmcydBtZZDd1nZM3dZ2UbfF5dcrGNTV/sJPMFuMT1v7TN7wUOteATzJ2x6o1NDx4Dg1uKI3Nr59++DzegfhKoRw92M4NdjxfycX/9kTWnB4HTr1bemDtxPJNTsJP1Xsx8APm+FjAuX/8RZwTYmBY3e2AHfAgHsXS0640Lh3tSDeBQbcu1mAu8iAe3f0IyLRaADjv7w+PeZy+O9A6sz4Hf60a+0BXGtPYF9HB7SzxnI6PtB5vgdYt7ePPfswGrxnH/y6ewGTgQv3Xsy3WNAk8l2v//8ksnc3iei9mUhknz6MBu/DQCL7CicRwr0vE4lwPKu6O8NpDrL49+tjZ8Hux1Sw+/dhNHh/hoI9QHjBEu4DalSwafHvFZEL+rbCXn1kEvSBfWTHo/22YT1oXemd2EGWkvFBTGR8cB9Ggw9mIONDhJMx4T7EEjKmTeNABjI+AEjGBwLjfahwMqa8OZQhHocA43EoMB6HWRCPw4TH4zBgPA63IB6HC4/H4cB4HGFBPI4QHo8jgPE40oJ4HCk8HkcC43GUBfE4Sng8jgLG42gL4nG08HgcDYzHMRbE4xjh8TgGGI9jLYjHscLjcSwwHsdZEI/jhMfjOGA8jrcgHscLj8fxwHicYEE8ThAejxOA8TjRgnicyPDMMDIeJwLjQTcABtbV5tPddnxI1uFbW0++cUGvw6L3J5l4nmzmKWaeauZpZp5u5hlmnmnmWWaebeY5Zp5r5nlmnm/mBWZeaOZFZl5s5iVmXmrmZWZebuYVZk4w80ozrzLzajOvMfNaM68z83ozb+gTGdP+QTQypvLayQnXTkm4dmrCtdMSrp2ecO2MhGtnJlw7K+Ha2QnXzkm4dm7CtfMSrp2fcO2ChGsXJly7KOHaxQnXLkm4dmnCtcsSrl2ecO2KhGsTEq5dmXDtqoRrVydcuybh2rUJ165LuHZ9wrUbomvxMTx6XSx6VelGB9JJS5YnAYj337vLSp8MWoswngJZ619/nZp+LSfylz4t7Vruf3yvT0+3lorFUZ+RZi2nQ07oM6d/LVWRX/qs6VwrF06Rq/rs6VvLS8h7fc70rOUl1pA+d9rXylepR33etK6Vr1rb+vxpW8uZCk/oC6ZlrfxUOUdf2PW1Sp3wl76oq2vlO+VCfXHX1lJd4FV9SVfWUl3iaH1p52tlu8j3+rLO1nK7vHfoy6e6lhtOwz6kr5jaWvlp2tP0hOpredO4P+orq6zlh9O81+qrktdS07Fv66uT1lLT1QPoa6ZcS09nP6GvrVwrmO7eRF/Xca1Mij5HXx9bywlT9Uz6hj52Pq12A6zXC3Tc3hv7MBpMi1eeXKQ1/kZcAPVNAKdyPvlGPiQbUadK7T68CVwEs9VNjnOtikClGgHrqUrcFzdHBXZLpdq8OQps/NotCQoUfRSLYxKlbwYW0C3g4KKTj4rmZmAxtuO+2dId6XpYHvlB3N5b+zAafCt8R/KDW4E70m3CdyTy4W3wHckPbrN0R7oeZrdfSjCXZUe6PSqwOyp3pNsTdqQ7arAjXQ/ckW4HFtAdTMFFEVC7nUjMdwLJrK4Ov1veFBEQ+oYoUgrcBSSzJB+qdENTjO9i6GTusrSTuQ7GP8VM3N67+zAafDe8kylm7gYW/z3COxny4T3wTqaYuYe5+BEEepdwAr0X7MP2gd54kTl+H7D2atkBXwezu+gkmMvSAd8fEfMDlR3w/Qkd8AM16IBxO5DS9wOT8gGm4KILEYn5QeYOWKUbmsjxPobu7SHhXSvF5SELcHPl+EPAHH9YeI5Xa1IQzQ9qrUfAG3at1M61sL3GC+P2PtqH0eBH4WrHCx8FBvAx4WqHfPgYXO144WPC1Q4R3SN9ZJPx42Aybh9ozMgcf8JStXMtzG6vnGAui9p5MiLmpyrVzpMJauepGqgd3A6k9JPApHyKKbjoQkRiflp4J0jk+ARD1/+McLVDcXnGAtxcOf4MMMefFZ7j1ZoUlW5oZJPynKX3dq6B7TVOh2/5e74Po8HPw9WOo54HFsELwtUO+fAFuNpx1AvC1Q4R3XN9ZJPxi5aoHWSOv2Sp2rkGZrcOE8xlUTsvR8T8SqXaeTlB7bxSA7WD24GUfhmYlK8wBRddiEjMrwrvBIkcX2Lo+l8TrnYoLq9ZgJsrx18D5vjrwnO8WpOi0g2NbFLesFTtXA3ba4IOaufNPowGvwlXO4F6E1gEbwlXO+TDt+BqJ1BvCVc7RHRv9JFNxm9bonaQOf6OpWrnapjdpZqpnXcjYn6vUu28m6B23quB2sHtQEq/C0zK95iCiy5EJOb3hXeCRI7vMHT9HwhXOxSXDyzAzZXjHwBz/EPhOV6tSVHphkY2KR9Zqnaugu01uQ7fifFxH0aDP4arnZz+GFgEnwhXO+TDT+BqJ9cBt0o5knAjiO6jPrLJ+FNL1A4yxz+zVO1cBbM7V7PvUvk8IuYvKtXO5wlq54saqB3cDqT058Ck/IIpuOhCRGL+UngnSOT4GUPX/5VwtUNx+coC3Fw5/hUwx78WnuPVmhSVbmhkk/KNpWrnSty9HS9u77d9GA3+Fn9vx/sWWATfCVc75MPv8Pd2vO+Eqx0ium/6yCbjiZaoHWSOf2+p2rkSZneQTzCXRe38EBHzj5Vq54cEtfNjDdQObgdS+gdgUv7IFFx0ISIx/yS8EyRy/J6h6/9ZuNqhuPxsAW6uHP8ZmOO/CM/xak2KSjc0skn51VK1MwG217h+3N7f+jAa/Btc7bj+b8Ai+F242iEf/g5XO67/u3C1Q0T3ax/ZZPyHJWoHmeN/Wqp2JsDsdr0Ec1nUzl8RMU+qVDt/JaidSTVQO7gdSOm/gEk5iSm46EJEYv5beCdI5PgnQ9df1yhb7VBcyEbpuLlyPG5n2rVmaJSd49WaFJVuaGST0gOYN7VUO1fA9ppihyfZ6hsZDabFsWqnqOuBRdATWJxcPuzZiFY7xQ64VcqRhBtBdD0aZZNxA5iM2wcaMzLHeyFrr652aucKWHNYrNmTbL0jYu7TWNdR2fRunFLt0D/iVjtXANVOb2BS9mnkCS66EJGYG4V3gkSOvRi6/ibhaofi0mQBbq4cbwLmeLPwHK/WpKh0QyOblBZL1c7lOLVTitvb2shocCte7ZRagUXQV7jaIR/2xaudUl/haoeIrqVRNhn3s0TtIHO8v6Vq53Kc2ikmmMuidtoiYh5QqXbaEtTOgBqoncuBaqcNmJQDGnmCiy5EJOYZhXeCRI79Gbr+mYSrHYrLTBbg5srxmYA5PrPwHK/WpKh0QyOblFksVTuX4Z5kK8btnbWR0eBZ4WrHLc4KLILZhKsd8uFscLXjFmcTrnaI6GZplE3GAy1RO8gcn91StXMZ7mGnQoK5LGpnUETMgyvVzqAEtTO4BmrnMqDaGQRMysGNPMFFFyIS8xDhnSCR4+wMXf8cwtUOxWUOC3Bz5fgcwBwfKjzHqzUpKt3QyCZlmKVq51LYXuN1+Abq4Y2MBg+Hqx1PDQcWwQjhaod8OAKudjw1QrjaIaIb1iibjEdaonaQOT7KUrVzKUzt5Gv2DdRzRsQ8V6XamTNB7cxVA7VzKVDtzAlMyrkaeYKLLkQk5rmFd4JEjqMYuv55hKsdiss8FuDmyvF5gDk+WniOV2tSVLqhkU3KvJaqnUuY1M58jYwGz8egduYDFsH8wtUO+XB+BrUzv3C1Q0Q3b6NsMh5jidpB5vgClqqdSyxUO2MjYlaVamdsgtpRNVA7lwDVzlhgUipL1A4SsxbeCRI5LsDQ9TvC1Q7FxbEAN1eOO8AczwjP8WpNiko3NLJJcS1VOxfD9ppCh+9kyzYyGpyFq52CnwUWQU642iEf5uBqp+DnhKsdIjq3UTYZ5y1RO8gc9yxVOxfD1E6hZt/J5kfEvGCl2vET1M6CNVA7FwPVjg9MygUbeYKLLkQk5oWEd4JEjh5D17+wcLVDcVnYAtxcOb4wMMfHCc/xak2KSjc0sklZxFK1cxFO7bhxexdtZDR4UbzacRcFFsFiwtXOP0HHqx13MeFqh4hukUbZZLy4JWoHmeNLWKp2LsKpnUyCuSxqZ8mImJeqVDtLJqidpWqgdi4Cqp0lgUm5VCNPcNGFiMS8tPBOkMhxCYaufxnhaofisowFuLlyfBlgji8rPMerNSkq3dDIJmU5S9XOhbjfLtrh3s7yjYwGLw9XO4G/PLAIVhCudsiHK8DVTuCvIFztENEt1yibjFe0RO0gc3wlS9XOhbhfQFmzezsrR8S8SqXaWTlB7axSA7VzIVDtrAxMylUaeYKLLkQk5lWFd4JEjisxdP2rCVc7FJfVLMDNleOrAXN8deE5Xq1JUemGRjYpa1iqdi6A7TWlctzeNRsZDV4TrnZK5TWBRbCWcLVDPlwLrnZK5bWEqx0iujUaZZPx2paoHWSOr2Op2rkApnZKQYK5LGpn3YiY16tUO+smqJ31aqB2LgCqnXWBSbleI09w0YWIxLy+8E6QyHEdhq5/A+Fqh+KygQW4uXJ8A2CObyg8x6s1KSrd0MgmZSNL1c75sL1Gd7i3s3Ejo8Ebw9WO9jcGFsEmwtUO+XATuNrR/ibC1Q4R3UaNssl4U0vUDjLHN7NU7ZwPUzu6Zvd2ChExFyvVTiFB7RRroHbOB6qdAjApi408wUUXIhJzSXgnSOS4GUPXHwhXOxSXwALcXDkeAHO8LDzHqzUpKt3QyCYltFTtnIf77aId1M7mjYwGbw5XO0V/c2ARbCFc7ZAPt4CrnaK/hXC1Q0QXNsom4y0tUTvIHN/KUrVzHu63i9ZM7WwdEfM2lWpn6wS1s00N1M55QLWzNTApt2nkCS66EJGYtxXeCRI5bsXQ9W8nXO1QXLazADdXjm8HzPHthed4tSZFpRsa2aTsYKnaORf3DdRe3N4dGxkN3hGudjxvR2AR7CRc7ZAPd4KrHc/bSbjaIaLboVE2GY+3RO0gc3xnS9XOuTC14+UTzGVRO7tExLxrpdrZJUHt7FoDtXMuUO3sAkzKXRt5gosuRCTm3YR3gkSOOzN0/bsLVzsUl90twM2V47sDc3wP4TlerUlR6YZGNil7Wqp2zoHtNW4HtbNXI6PBe8HVjuvtBSyCvYWrHfLh3nC143p7C1c7RHR7Nsom430sUTvIHN/XUrVzDkztuDVTO/tFxLx/pdrZL0Ht7F8DtXMOUO3sB0zK/Rt5gosuRCTmA4R3gkSO+zJ0/QcKVzsUlwMtwM2V4wcCc/wg4TlerUlR6YZGNikHW6p2zobtNb6O23tII6PBh8DVjq8PARbBocLVDvnwULja8TvgVilHEm4E0R3cKJuMD7NE7SBz/HBL1c7ZMLXjqwRzWdTOERExH1mpdo5IUDtH1kDtnA1UO0cAk/LIRp7gogsRifko4Z0gkePhDF3/0cLVDsXlaAtwc+X40cAcP0Z4jldrUlS6oZFNyrGWqp2zYHtNXsXtPa6R0eDj4Gonr44DFsHxwtUO+fB4uNrJq+OFqx0iumMbZZPxCZaoHWSOn2ip2jkLpnZyYYK5LGrnpIiYT65UOyclqJ2Ta6B2zgKqnZOASXlyI09w0YWIxHyK8E6QyPFEhq7/VOFqh+JyqgW4uXL8VGCOnyY8x6s1KSrd0Mgm5XRL1c6ZuG8p6PAN1Gc0Mhp8BlztFMtnAIvgTOFqh3x4JlztFMtnClc7RHSnN8om47MsUTvIHD/bUrVzJu5bCmr2DdTnRMR8bqXaOSdB7ZxbA7VzJlDtnANMynMbeYKLLkQk5vOEd4JEjmczdP3nC1c7FJfzLcDNlePnA3P8AuE5Xq1JUemGRjYpF1qqds6A7TVOh3s7FzUyGnwRXO046iJgEVwsXO2QDy+Gqx1HXSxc7RDRXdgom4wvsUTtIHP8UkvVzhm4b6Cu2b2dyyJivrxS7VyWoHYur4HaOQOodi4DJuXljTzBRRciEvMVwjtBIsdLGbr+CcLVDsVlggW4uXJ8AjDHrxSe49WaFJVuaGSTcpWlaud03F5Titt7dSOjwVfD1Y4qXQ0sgmuEqx3y4TVwtaNK1whXO0R0VzXKJuNrLVE7yBy/zlK1czpM7ahigrksauf6iJhvqFQ71yeonRtqoHaAO5C+HpiUNzTyBBddiEjMNwrvBIkcr2Po+m8SrnYoLjdZgJsrx28C5vjNwnO8WpOi0g2NbFJusVTtnAbba3IdnmS7tZHR4FvhaidXvhVYBLcJVzvkw9vgaidXvk242iGiu6VRNhnfbonaQeb4HZaqndNwn9up2ZNsd0bEfFel2rkzQe3cVQO1cxpQ7dwJTMq7GnmCiy5EJOa7hXeCRI53MHT99whXOxSXeyzAzZXj9wBz/F7hOV6tSVHphkY2KfdZqnZOhe01usN3st3fyGjw/XC1o/X9wCJ4QLjaIR8+AFc7ugNulXIk4UYQ3X2Nssn4QUvUDjLHH7JU7ZyKe5KtZt/J9nBEzI9Uqp2HE9TOIzVQO6cC1c7DwKR8pJEnuOhCRGJ+VHgnSOT4EEPX/5hwtUNxecwC3Fw5/hgwxx8XnuPVmhSVbmhkk/KEpWrnFNzDGB0+t/NkI6PBTzbi131KuEIh3E81TnYwaF0WVUGE8kSjbNJ72hJVgczLZ5iJHhGTZxhyvJaEejIToT7byGjwswyE+pxwQiXcz9WIUFW6oakwnmvkKTgU7loW2Ul9cD6I2/t8I6PBzzPsiM8DGf0F4QVLPnyBoQheEH5GS0X6AoP8eRoY7xeFHxdQ7rzIRPbtA13bLwLj85JwiV9NMah0QyMVw8vCc5xi/DJDI4fMQ2oSBtZNPjKPD7TdM/TmqfM6qJ0O632OGWK+HRa9f8XE81UzXzPzdTPfMPNNM98y820z3zHzXTPfM/N9Mz8w80MzPzLzYzM/MfNTMz8z83MzvzDzSzO/MvNrM78x81szvzNzopnfm/mDmT+a+VPlPZZXovsp8WuvJlx7LeHa6wnX3ki49mbCtbcSrr2dcO2dhGvvJlx7L+Ha+wnXPki49mHCtY8Srn2ccO2ThGufJlz7LOHa5wnXvki49mXCta8Srn2dcO2bhGvfJlz7LuHaxIRr3ydc+yHh2o8J135qnPLe3fDodbHoVaUbHUgnLVm+AiDe9vuAr4LWIoyvQdb611+vp1/Lifyl30i7lvsf3+s3062lYnHUb6VZy+mQE/rt6V9LVeSXfmc618qFU+Sqfnf61vIS8l6/Nz1reYk1pN+f9rXyVepRfzCta+Wr1rb+cNrWcqbCE/qjaVkrP1XO0R93fa1SJ/ylP+nqWvlOuVB/2rW1VBd4VX/WlbVUlzhaf975Wtku8r3+orO13C7vHfrLqa7lhtOwD+mvprZWfpr2NP119bW8adwf9TdV1vLDad5r9bfJa6np2Lf1d0lrqenqAfTEKdfS09lP6O8r1wqmuzfRP3RcK5Oiz9E/xtZywlQ9k/7J0hPtn2C9XtDhqeOfGxkN/rkR/dRxoH/GBVD/AnAq54k2+fAX4Il2uw9/ARdBrZ4exRVvULOnR3+NCuy3ypONXxunfHr0t0b+p0dxTKL0r8AC+g0cXHTyUdH8CizGdty/Wroj/QjLIz+I2/t7I6PBv8N3JD/4Hbgj/SF8RyIf/gHfkfzgD0t3pB9hdvulBHNZdqQ/owL7q3JH+jNhR/qrBjvSj8Ad6U9gAf3FFFz0jWAk5klAMqurw++Wv0QEhL4RjJQCfwPJLMmHKt3QFOO/GTqZvy3tZH6A8U8x08HeJkaDaXFsJ1PM0JooG2dokt3JkA/JRmwnYxKgibf4EQT6t3AC7QH2YftAb7zIHK8H1l4tO+AfYKRfdBLMZemAe0bE3NBU17Hb7dk0ZQdM/4i7A/4B2AH3BCZlQxNPcNGFiMTcC1iIdXX4giNyrG/Cbwy9mTculW5oiktvC3Bz5XhvYI73EZ7j1ZoURPODWqsRvGHXSu18D9trvDBub1MTo8FNcLXjhU3AADYLVzvkw2a42vHCZuFqh4iusUk2GbeAybh9oDEjc7zVUrXzPUzteOUEc1nUTt+ImPtVqp2+CWqnXw3UzvdAtdMXmJT9mniCiy5EJOb+wjtBIsdWhq6/Tbjaobi0WYCbK8fbgDk+QHiOV2tSVLqhkU3KjMC8qaXamQjbazr+3vGZmhgNngmudhw1E7AIZhaudsiHM8PVjqNmFq52iOhmbJJNxrNYonaQOT6rpWpnIkzt1O73js8WEfPASrUzW4LaGVgDtTMRqHZmAyblwCae4KILEYl5duGdIJHjrAxd/yDhaofiMsgC3Fw5PgiY44OF53i1JkWlGxrZpAyxVO18h/uUWAe1M0cTo8FzwNVOoOYAFsFQ4WqHfDgUrnYCNVS42iGiG9Ikm4yHWaJ2kDk+3FK18x1M7ZRqpnZGRMQ8slLtjEhQOyNroHa+A6qdEcCkHNnEE1x0ISIxjxLeCRI5Dmfo+ucUrnYoLnNagJsrx+cE5vhcwnO8WpOi0g2NbFLmtlTtfAvba3IdvhNjniZGg+eBq52cngdYBKOFqx3y4Wi42sl1wK1SjiTcCKKbu0k2Gc9ridpB5vh8lqqdb2FqJ1ez71KZPyLmMZVqZ/4EtTOmBmrnW6DamR+YlGOaeIKLLkQk5gWEd4JEjvMxdP1jhasdistYC3Bz5fhYYI4r4TlerUlR6YZGNinaUrXzDe7ejhe312liNNjB39vxHGARZISrHfJhBn9vx8sIVztEdLpJNhm7lqgdZI5nLVU73+C+XDCfYC6L2slFxJyvVDu5BLWTr4Ha+QaodnLApMw38QQXXYhIzJ7wTpDIMcvQ9fvC1Q7FxbcAN1eO+8AcX1B4jldrUlS6oZFNykKWqp2vYXuN68ftXbiJ0eCF4WrH9RcGFsE44WqHfDgOrnZcf5xwtUNEt1CTbDJexBK1g8zxRS1VO1/D1I7rJZjLonYWi4h58Uq1s1iC2lm8Bmrna6DaWQyYlIs38QQXXYhIzEsI7wSJHBdl6PqXFK52KC5LWoCbK8eXBOb4UsJzvFqTotINjWxSlrZU7XyF+wbqDk+yLdPEaPAycLVT1MsAi2BZ4WqHfLgsXO0UO+BWKUcSbgTRLd0km4yXs0TtIHN8eUvVzle4b6Cu2ZNsK0TEvGKl2lkhQe2sWAO18xVQ7awATMoVm3iCiy5EJOaVhHeCRI7LM3T9KwtXOxSXlS3AzZXjKwNzfBXhOV6tSVHphkY2Kataqna+xKmdUtze1ZoYDV4Nr3ZKqwGLYHXhaod8uDpe7ZRWF652iOhWbZJNxmtYonaQOb6mpWrnS5zaKSaYy6J21oqIee1KtbNWgtpZuwZq50ug2lkLmJRrN/EEF12ISMzrCO8EiRzXZOj61xWudigu61qAmyvH1wXm+HrCc7xak6LSDY1sUta3VO18gXuSrRi3d4MmRoM3wD/JVtwAWAQbClc75MMN8U+yFTcUrnaI6NZvkk3GG1midpA5vrGlaucL3JNshQRzWdTOJhExb1qpdjZJUDub1kDtfAFUO5sAk3LTJp7gogsRiXkz4Z0gkePGDF1/QbjaobgULMDNleMFYI4Xhed4tSZFpRsa2aSULFU7n+N+u2iHb6AOmhgNDuBqx1MBsAjKwtUO+bAMVzueKgtXO0R0pSbZZBxaonaQOb65pWrnc5jaydfsG6i3iIh5y0q1s0WC2tmyBmrnc6Da2QKYlFs28QQXXYhIzFsJ7wSJHDdn6Pq3Fq52KC5bW4CbK8e3Bub4NsJzvFqTotINjWxStrVU7XzGpHa2a2I0eDsGtbMdsAi2F652yIfbM6id7YWrHSK6bZtkk/EOlqgdZI7vaKna+cxCtbNTRMzjK9XOTglqZ3wN1M5nQLWzEzApx1uidpCYdxbeCRI57sjQ9e8iXO1QXHaxADdXju8CzPFdhed4tSZFpRsa2aTsZqna+RS21xQ6fCfb7k2MBu8OVzsFf3dgEewhXO2QD/eAq52Cv4dwtUNEt1uTbDLe0xK1g8zxvSxVO5/C1E6hZt/JtndEzPtUqp29E9TOPjVQO58C1c7ewKTcp4knuOhCRGLeV3gnSOS4F0PXv59wtUNx2c8C3Fw5vh8wx/cXnuPVmhSVbmhkk3KApWrnE5zaceP2HtjEaPCBeLXjHggsgoOEqx3y4UF4teMeJFztENEd0CSbjA+2RO0gc/wQS9XOJzi1k0kwl0XtHBoR82GVaufQBLVzWA3UzidAtXMoMCkPa+IJLroQkZgPF94JEjkewtD1HyFc7VBcjrAAN1eOHwHM8SOF53i1JkWlGxrZpBxlqdr5GPfbRTvc2zm6idHgo+FqJ/CPBhbBMcLVDvnwGLjaCfxjhKsdIrqjmmST8bGWqB1kjh9nqdr5GPfbRWt2b+f4iJhPqFQ7xyeonRNqoHY+Bqqd44FJeUITT3DRhYjEfKLwTpDI8TiGrv8k4WqH4nKSBbi5cvwkYI6fLDzHqzUpKt3QyCblFEvVzkewvaZUjtt7ahOjwafC1U6pfCqwCE4TrnbIh6fB1U6pfJpwtUNEd0qTbDI+3RK1g8zxMyxVOx/B1E4pSDCXRe2cGRHzWZVq58wEtXNWDdTOR0C1cyYwKc9q4gkuuhCRmM8W3gkSOZ7B0PWfI1ztUFzOsQA3V46fA8zxc4XneLUmRaUbGtmknGep2vkQttfoDvd2zm9iNPh8uNrR/vnAIrhAuNohH14AVzvav0C42iGiO69JNhlfaInaQeb4RZaqnQ9hakfX7N7OxRExX1Kpdi5OUDuX1EDtfAhUOxcDk/KSJp7gogsRiflS4Z0gkeNFDF3/ZcLVDsXlMgtwc+X4ZcAcv1x4jldrUlS6oZFNyhWWqp0PcL9dtIPamdDEaPAEuNop+hOARXClcLVDPrwSrnaK/pXC1Q4R3RVNssn4KkvUDjLHr7ZU7XyA++2iNVM710TEfG2l2rkmQe1cWwO18wFQ7VwDTMprm3iCiy5EJObrhHeCRI5XM3T91wtXOxSX6y3AzZXj1wNz/AbhOV6tSVHphkY2KTdaqnbex30DtRe396YmRoNvgqsdz7sJWAQ3C1c75MOb4WrH824WrnaI6G5skk3Gt1iidpA5fqulaud9mNrx8gnmsqid2yJivr1S7dyWoHZur4HaeR+odm4DJuXtTTzBRRciEvMdwjtBIsdbGbr+O4WrHYrLnRbg5srxO4E5fpfwHK/WpKh0QyOblLstVTvvwfYat4PauaeJ0eB74GrH9e4BFsG9wtUO+fBeuNpxvXuFqx0iurubZJPxfZaoHWSO32+p2nkPpnbcmqmdByJifrBS7TyQoHYerIHaeQ+odh4AJuWDTTzBRRciEvNDwjtBIsf7Gbr+h4WrHYrLwxbg5srxh4E5/ojwHK/WpKh0QyOblEctVTvvwvYaX8ftfayJ0eDH4GrH148Bi+Bx4WqHfPg4XO34HXCrlCMJN4LoHm2STcZPWKJ2kDn+pKVq512Y2vFVgrksauepiJifrlQ7TyWonadroHbeBaqdp4BJ+XQTT3DRhYjE/IzwTpDI8UmGrv9Z4WqH4vKsBbi5cvxZYI4/JzzHqzUpKt3QyCbleUvVzjuwvSav4va+0MRo8AtwtZNXLwCL4EXhaod8+CJc7eTVi8LVDhHd802yyfglS9QOMsdftlTtvANTO7kwwVwWtfNKRMyvVqqdVxLUzqs1UDvvANXOK8CkfLWJJ7joQkRifk14J0jk+DJD1/+6cLVDcXndAtxcOf46MMffEJ7j1ZoUlW5oZJPypqVq523ctxR0+Abqt5oYDX4LrnaK5beARfC2cLVDPnwbrnaK5beFqx0iujebZJPxO5aoHWSOv2up2nkb9y0FNfsG6vciYn6/Uu28l6B23q+B2nkbqHbeAybl+008wUUXIhLzB8I7QSLHdxm6/g+Fqx2Ky4cW4ObK8Q+BOf6R8Byv1qSodEMjm5SPLVU7b8H2GqfDvZ1PmhgN/gSudhz1CbAIPhWudsiHn8LVjqM+Fa52iOg+bpJNxp9ZonaQOf65pWrnLdw3UNfs3s4XETF/Wal2vkhQO1/WQO28BVQ7XwCT8ssmnuCiCxGJ+SvhnSCR4+cMXf/XwtUOxeVrC3Bz5fjXwBz/RniOV2tSVLqhkU3Kt5aqnTdxe00pbu93TYwGfwdXO6r0HbAIJgpXO+TDiXC1o0oThasdIrpvm2ST8feWqB1kjv9gqdp5E6Z2VDHBXBa182NEzD9Vqp0fE9TOTzVQO8AdSP8ITMqfmniCiy5EJOafhXeCRI4/MHT9vwhXOxSXXyzAzZXjvwBz/FfhOV6tSVHphkY2Kb9ZqnbegO01uQ5Psv3exGjw73C1kyv/DiyCP4SrHfLhH3C1kyv/IVztENH91iSbjP+0RO0gc/wvS9XOG7jP7dTsSbZJETH/Xal2JiWonb9roHbeAKqdScCk/LuJJ7joQkRirmuW3QkSOf7F0PXP0My7cal0Q1NcyEbpuLlyPG5n2rV6CM/xak2KSjc0skmpB+ZNLdXO67C9Rnf4TraezYwG0+JYtaN1T2ARNACLk8uHDc1otaM74FYpRxJuBNHVN8sm415gMm4faMzIHO8NxFxLtfM67km2mn0nW5+ImBub6zoqmz7NU6od+kfcaud1oNrpA0zKxmae4KILEYm5SXgnSOTYm6HrbxaudiguzRbg5srxZmCOtwjP8WpNiko3NLJJabVU7byGexijw+d2+jYzGty3Gb9uP+EKhXD3a57sYNC6LKqCCKW1WTbp9bdEVSDzso2Z6BExaWPI8VoS6qtMhDqgmdHgAQyEOqNwQiXcM9aIUFW6oakwZmzmKTgU7loW2SuNOB/E7Z2pmdHgmRh2xJmAjD6z8IIlH87MUAQzCz+jpSKdmUH+9AfGexbhxwWUO7MwkX37QNf2LMD4zCpc4ldTDCrd0EjFMJvwHKcYz8bQyCHzkJqEgXWTj8zjA35s1Junzuugdjqs9zlmiPl2WPR+oInn7GYOMnOwmUPMnMPMoWYOM3O4mSPMHGnmKDPnNHMuM+c2cx4zR5s5r5nzmTm/mWPMXMDMsWYqM7WZjpkZM10zs2bmzMyb6VXeYxkY3U+JX5s94dqghGuDE64NSbg2R8K1oQnXhiVcG55wbUTCtZEJ10YlXJsz4dpcCdfmTrg2T8K10QnX5k24Nl/CtfkTro1JuLZAwrWxCddUwjWdcM1JuJZJuOYmXMsmXMslXMsnXPOap7x3Nzx6XSx6VelGB9JJS5YDAcTbfh9wdtBahHEQZK1//TU4/VpO5C89JO1a7n98r+dIt5aKxVEPTbOW0yEn9LDpX0tV5JcePp1r5cIpclWPmL61vIS81yOnZy0vsYb0qGlfK1+lHvWc07pWvmpt67mmbS1nKjyh556WtfJT5Rw9T9fXKnXCX3p0V9fKd8qFet6uraW6wKt6vq6spbrE0Xr+ztfKdpHv9ZjO1nK7vHfoBaa6lhtOwz6kx05trfw07WlaVV/Lm8b9Uesqa/nhNO+12kleS03Hvq0zSWup6eoBtDvlWno6+wmdrVwrmO7eROc6rpVJ0efofGwtJ0zVM2nP0hNtD9brBR2eOvabGQ32m9FPHQfaxwVQLwhwKueJNvlwQeCJdrsPFwQXQa2eHsUVb1Czp0cXigps4cqTjYWap3x6dOFm/qdHcUyi9ELAAloYHFx08lHRLAQsxnbcC1m6I+VheeQHcXvHNTMaPA6+I/nBOOCOtIjwHYl8uAh8R/KDRSzdkfIwu/1SgrksO9KiUYEtVrkjLZqwIy1Wgx0pD9yRFgUW0GJMwUXfCEZiXhxIZnV1+N1ywYiA0DeCkVJgCSCZJflQpRuaYrwEQyezhKWdTA7GP8VM3N4lmxkNXhLeyRQzSwKLfynhnQz5cCl4J1PMLMVc/AgCXUI4gS4N9mH7QG+8yBxfBlh7teyAczC7i06CuSwd8LIRMS9X2QEvm9ABL1eDDhi3Aym9LDApl2MKLroQkZiXZ+6AVbqhiRyXYejeVhDetVJcVrAAN1eOrwDM8RWF53i1JgXR/KDWWgm8YddK7WRhe40Xxu1duZnR4JXhascLVwYGcBXhaod8uApc7XjhKsLVDhHdSs2yyXhVMBm3DzRmZI6vZqnaycLs9soJ5rKondUjYl6jUu2snqB21qiB2sHtQEqvDkzKNZiCiy5EJOY1hXeCRI6rMXT9awlXOxSXtSzAzZXjawFzfG3hOV6tSVHphkY2KetYem/Hhe01HX/v+LrNjAavC1c7jloXWATrCVc75MP14GrHUesJVztEdOs0yybj9S1RO8gc38BStePC7K7d7x3fMCLmjSrVzoYJamejGqgd3A6k9IbApNyIKbjoQkRi3lh4J0jkuAFD17+JcLVDcdnEAtxcOb4JMMc3FZ7j1ZoUlW5oZJOymaVqJwPba4IOaqfQzGhwAa52AlUAFkFRuNohHxbhaidQReFqh4hus2bZZFyyRO0gczywVO1kYHaXaqZ2yhExh5Vqp5ygdsIaqB3cDqR0GZiUIVNw0YWIxLy58E6QyDFg6Pq3EK52KC5bWICbK8e3AOb4lsJzvFqTotINjWxStrJU7TiwvSbX4Tsxtm5mNHhruNrJ6a2BRbCNcLVDPtwGrnZyHXCrlCMJN4LotmqWTcbbWqJ2kDm+naVqx4HZnavZd6lsHxHzDpVqZ/sEtbNDDdQObgdSentgUu7AFFx0ISIx7yi8EyRy3I6h699JuNqhuOxkAW6uHN8JmOPjhed4tSZFpRsa2aTsbKna0bh7O17c3l2aGQ3eBX9vx9sFWAS7Clc75MNd8fd2vF2Fqx0iup2bZZPxbpaoHWSO726p2tEwu4N8grksamePiJj3rFQ7eySonT1roHZwO5DSewCTck+m4KILEYl5L+GdIJHj7gxd/97C1Q7FZW8LcHPl+N7AHN9HeI5Xa1JUuqGRTcq+lqodBdtrXD9u737NjAbvB1c7rr8fsAj2F652yIf7w9WO6+8vXO0Q0e3bLJuMD7BE7SBz/EBL1Y6C2e16CeayqJ2DImI+uFLtHJSgdg6ugdrB7UBKHwRMyoOZgosuRCTmQ4R3gkSOBzJ0/YcKVzsUl0MtwM2V44cCc/ww4TlerUlR6YZGNimHW6p2xsL2mmKHJ9mOaGY0+Ai42inqI4BFcKRwtUM+PBKudoodcKuUIwk3gugOb5ZNxkdZonaQOX60pWpnLMzuYs2eZDsmIuZjK9XOMQlq59gaqB3cDqT0McCkPJYpuOhCRGI+TngnSOR4NEPXf7xwtUNxOd4C3Fw5fjwwx08QnuPVmhSVbmhkk3KipWpnAZzaKcXtPamZ0eCT8GqndBKwCE4WrnbIhyfj1U7pZOFqh4juxGbZZHyKJWoHmeOnWqp2FsA1xMUEc1nUzmkRMZ9eqXZOS1A7p9dA7eB2IKVPAybl6UzBRRciEvMZwjtBIsdTGbr+M4WrHYrLmRbg5srxM4E5fpbwHK/WpKh0QyOblLMtVTtjcE+yFeP2ntPMaPA5+CfZiucAi+Bc4WqHfHgu/km24rnC1Q4R3dnNssn4PEvUDjLHz7dU7YzBPexUSDCXRe1cEBHzhZVq54IEtXNhDdQObgdS+gJgUl7IFFx0ISIxXyS8EyRyPJ+h679YuNqhuFxsAW6uHL8YmOOXCM/xak2KSjc0skm51FK1Mz9sr/E6fAP1Zc2MBl8GVzueugxYBJcLVzvkw8vhasdTlwtXO0R0lzbLJuMrLFE7yByfYKnamR9md75m30B9ZUTMV1WqnSsT1M5VNVA7uB1I6SuBSXkVU3DRhYjEfLXwTpDIcQJD13+NcLVDcbnGAtxcOX4NMMevFZ7j1ZoUlW5oZJNynaVqZz4mtXN9M6PB1zOoneuBRXCDcLVDPryBQe3cIFztENFd1yybjG+0RO0gc/wmS9XOfBaqnZsjYr6lUu3cnKB2bqmB2sHtQErfDEzKWyxRO0jMtwrvBIkcb2Lo+m8TrnYoLrdZgJsrx28D5vjtwnO8WpOi0g2NbFLusFTtzAvbawodvpPtzmZGg++Eq52CfyewCO4SrnbIh3fB1U7Bv0u42iGiu6NZNhnfbYnaQeb4PZaqnXlhdhdq9p1s90bEfF+l2rk3Qe3cVwO1g9uBlL4XmJT3MQUXXYhIzPcL7wSJHO9h6PofEK52KC4PWICbK8cfAOb4g8JzvFqTotINjWxSHrJU7YzGqR03bu/DzYwGP4xXO+7DwCJ4RLjaIR8+glc77iPC1Q4R3UPNssn4UUvUDjLHH7NU7YzGNcSZBHNZ1M7jETE/Ual2Hk9QO0/UQO3gdiClHwcm5RNMwUUXIhLzk8I7QSLHxxi6/qeEqx2Ky1MW4ObK8aeAOf608Byv1qSodEMjm5RnLFU788D2mqDDvZ1nmxkNfhaudgL/WWARPCdc7ZAPn4OrncB/TrjaIaJ7plk2GT9vidpB5vgLlqqdeWB2BzW7t/NiRMwvVaqdFxPUzks1UDu4HUjpF4FJ+RJTcNGFiMT8svBOkMjxBYau/xXhaofi8ooFuLly/BVgjr8qPMerNSkq3dDIJuU1S9XO3LC9plSO2/t6M6PBr8PVTqn8OrAI3hCudsiHb8DVTqn8hnC1Q0T3WrNsMn7TErWDzPG3LFU7c8PsLgUJ5rKonbcjYn6nUu28naB23qmB2sHtQEq/DUzKd5iCiy5EJOZ3hXeCRI5vMXT97wlXOxSX9yzAzZXj7wFz/H3hOV6tSVHphkY2KR9Yqnbmgu01usO9nQ+bGQ3+EK52tP8hsAg+Eq52yIcfwdWO9j8SrnaI6D5olk3GH1uidpA5/omlamcumN26Zvd2Po2I+bNKtfNpgtr5rAZqB7cDKf0pMCk/YwouuhCRmD8X3gkSOX7C0PV/IVztUFy+sAA3V45/AczxL4XneLUmRaUbGtmkfGWp2pkTttcUO6idr5sZDf4arnaK/tfAIvhGuNohH34DVztF/xvhaoeI7qtm2WT8rSVqB5nj31mqduaE2V2smdqZGBHz95VqZ2KC2vm+BmoHtwMpPRGYlN8zBRddiEjMPwjvBIkcv2Po+n8UrnYoLj9agJsrx38E5vhPwnO8WpOi0g2NbFJ+tlTtjILtNZ4Xt/eXZkaDf4GrHc/7BVgEvwpXO+TDX+Fqx/N+Fa52iOh+bpZNxr9ZonaQOf67pWpnFMxuL59gLova+SMi5j8r1c4fCWrnzxqoHdwOpPQfwKT8kym46EJEYv5LeCdI5Pg7Q9c/SbjaobhMsgA3V45PAub438JzvFqTotINjWxS6lrsVDsjYXuN20HtzNDCaDAtjlU7xnhcAHWPFtlqh3xINmLVjuv1aOHdNBBEV9cim4zrW7Bk3D7QmJE53hOIuZZqZyRs43RrpnYaImLu1VLXUdk0tEypdugfcaudkUC10wBMyl4tPMFFFyISc28w+aALjsixZwt+Y+jDvHGpdENTXPpYgJsrx/sAc7xReI5Xa1JUuqGRTUqTpWpnBGyv8XXc3uYWRoOb4WrH183AImgRrnbIhy1wteN3wK1SjiTcCKJrapFNxq2WqB1kjve1VO2MgKkdXyWYy6J2+kXE3L9S7fRLUDv9a6B2RgDVTj9gUvZv4QkuuhCRmNuEd4JEjn0Zuv4BwtUOxWWABbi5cnwAMMdnFJ7j1ZoUlW5oZJMyk6VqZzhsr8mruL0ztzAaPDNc7eTVzMAimEW42iEfzgJXO3k1i3C1Q0Q3U4tsMp7VErWDzPHZLFU7w2FqJxcmmMuidgZGxDx7pdoZmKB2Zq+B2hkOVDsDgUk5ewtPcNGFiMQ8SHgnSOQ4G0PXP1i42qG4DLYAN1eODwbm+BDhOV6tSVHphkY2KXNYqnaG4b6loMM3UA9tYTR4KFztFMtDgUUwTLjaIR8Og6udYnmYcLVDRDdHi2wyHm6J2kHm+AhL1c4w3AfZa/YN1CMjYh5VqXZGJqidUTVQO8OAamckMClHtfAEF12ISMxzCu8EiRxHMHT9cwlXOxSXuSzAzZXjcwFzfG7hOV6tSVHphkY2KfNYqnaGwvYap8O9ndEtjAaPhqsdR40GFsG8wtUO+XBeuNpx1LzC1Q4R3Twtssl4PkvUDjLH57dU7QzFfUlxze7tjImIeYFKtTMmQe0sUAO1MxSodsYAk3KBFp7gogsRiXms8E6QyHF+hq5fCVc7FBdlAW6uHFfAHNfCc7xak6LSDY1sUhxL1c4cuL2mFLc308JocAaudlQpAywCV7jaIR+6cLWjSq5wtUNE57TIJuOsJWoHmeM5S9XOHLiv9ykmmMuidvIRMXuVaiefoHa8Gqgd4A6k88Ck9Fp4gosuRCRmX3gnSOSYY+j6FxSudiguC1qAmyvHFwTm+ELCc7xak6LSDY1sUha2VO0Mge01uQ5Pso1rYTR4HFzt5MrjgEWwiHC1Qz5cBK52cuVFhKsdIrqFW2ST8aKWqB1kji9mqdoZgvvcTs2eZFs8IuYlKtXO4glqZ4kaqJ0hQLWzODApl2jhCS66EJGYlxTeCf5Djgxd/1LC1Q7FZSkLcHPl+FLAHF9aeI5Xa1JUuqGRTcoylqqdwbC9Rnf4TrZlWxgNXhaudrReFlgEywlXO+TD5eBqR3fArVKOJNwIolumRTYZL2+J2kHm+AqWqp3BuCfZavadbCtGxLxSpdpZMUHtrFQDtTMYqHZWBCblSi08wUUXIhLzysI7QSLHFRi6/lWEqx2KyyoW4ObK8VWAOb6q8Byv1qSodEMjm5TVLFU7g4C/Xypu7+otjAav3oJfdw3hCoVwr9Ey2cGgdVlUBRHKai2ySW9NS1QFMi/XYiZ6REzWYsjxWhLq7EyEunYLo8FrMxDqOsIJlXCvUyNCVemGpsJYp4Wn4FC4a1lkA4G/OyRu77otjAavy7Ajrgtk9PWEFyz5cD2GIlhP+BktFel6DPJnTWC81xd+XEC5sz4T2bcPdG2vD4zPBsIlfjXFoNINjVQMGwrPcYrxhgyNHDIPqUkYWDf5yDypblS6oX/sVVc3pB633s9mvd96TbYXtC7f/Q3lsN47ac8veh0Wvd/I5MjGZm5i5qZmbmZmwcyimSUzAzPLZoZmbm7mFmZuaeZWZm5t5jZmbmvmdmZub+YOZu5o5k5mjjdzZzN3MXNXM3czc3cz9zBzTzP3qrxvs1F0jyZ+beOEa5skXNs04dpmCdcKCdeKCddKCdeChGvlhGthwrXNE65tkXBty4RrWyVc2zrh2jYJ17ZNuLZdwrXtE67tkHBtx4RrOyVcG59wbeeEa7skXNs14dpuCdd2T7i2R8K1PROu7dUy5f3AEdHrYtFrWtLcCEDA7fcDNwatRVSwCWStf2ll0/RrOZG/9GZp13L/43tdSLeWisVRF9Os5XTICV2a/rVURX7pYDrXyoVT5KouT99aXkLe63B61vISa0hvPu1r5avUo95iWtfKV61tveW0reVMhSf0VtOyVn6qnKO37vpapU74S2/T1bXynXKh3rZra6ku8KreritrqS5xtN6+87WyXeR7vUNna7ld3jv0jlNdyw2nYR/SO01trfw07Wl6fPW1vGncH/XOVdbyw2nea/UuyWup6di39a5Ja6np6gH0blOupaezn9C7V64VTHdvovfouFYmRZ+j94yt5YSpeia9F/DAY7VRuLVWx61V0xP3vWA9aNDhqei9WxgN3rsF/VR0oPcGJtY+AKdynriTD/cBnri3+3CfFmwR1OrpVhypBDV7unXfqMD2qzwl2bdlyqdb92vhf7oVxyRK7wssoP3AwUUnHxXNvsBibMe9b4udO9KesDzyg7i9+7cwGrw/fEfyg/2BO9IBwnck8uEB8B3JDw6wdEfaE2a3X0owl2VHOjAqsIMqd6QDE3akg2qwI+0J3JEOBBbQQUzBRd+oRmI+GEhmdXX43XKfiIDQNy2RUuAQIJkl+VClG5pifAhDJ3OIpZ3MHjD+KWbi9h7awmjwofBOppg5FFj8hwnvZMiHh8E7mWLmMObiRxDoIcIJ9HCwD9sHeuNF5vgRwNqrZQe8B8zuopNgLksHfGREzEdVdsBHJnTAR9WgA8btQEofCUzKo5iCiy5EJOajmTtglW5oIscjGLq3Y4R3rRSXYyzAzZXjxwBz/FjhOV6tSUE0P6i1jgNv2LVSO7vD9hovjNt7fAujwcfD1Y4XHg8M4AnC1Q758AS42vHCE4SrHSK641pkk/GJYDJuH2jMyBw/yVK1szvMbq+cYC6L2jk5IuZTKtXOyQlq55QaqB3cDqT0ycCkPIUpuOhCRGI+VXgnSOR4EkPXf5pwtUNxOc0C3Fw5fhowx08XnuPVmhSVbmhkk3KGpfd2doPtNR1/L/qZLYwGnwlXO446E1gEZwlXO+TDs+Bqx1FnCVc7RHRntMgm47MtUTvIHD/HUrWzG8zu2v1e9HMjYj6vUu2cm6B2zquB2sHtQEqfC0zK85iCiy5EJObzhXeCRI7nMHT9FwhXOxSXCyzAzZXjFwBz/ELhOV6tSVHphkY2KRdZqnZ2he01QQe1c3ELo8EXw9VOoC4GFsElwtUO+fASuNoJ1CXC1Q4R3UUtssn4UkvUDjLHL7NU7ewKs7tUM7VzeUTMV1SqncsT1M4VNVA7uB1I6cuBSXkFU3DRhYjEPEF4J0jkeBlD13+lcLVDcbnSAtxcOX4lMMevEp7j1ZoUlW5oZJNytaVqZxfYXpPr8J0Y17QwGnwNXO3k9DXAIrhWuNohH14LVzu5DrhVypGEG0F0V7fIJuPrLFE7yBy/3lK1swvM7lzNvkvlhoiYb6xUOzckqJ0ba6B2cDuQ0jcAk/JGpuCiCxGJ+SbhnSCR4/UMXf/NwtUOxeVmC3Bz5fjNwBy/RXiOV2tSVLqhkU3KrZaqnZ1x93a8uL23tTAafBv+3o53G7AIbheudsiHt+Pv7Xi3C1c7RHS3tsgm4zssUTvIHL/TUrWzM8zuIJ9gLovauSsi5rsr1c5dCWrn7hqoHdwOpPRdwKS8mym46EJEYr5HeCdI5HgnQ9d/r3C1Q3G51wLcXDl+LzDH7xOe49WaFJVuaGSTcr+lamc8bK9x/bi9D7QwGvwAXO24/gPAInhQuNohHz4IVzuu/6BwtUNEd3+LbDJ+yBK1g8zxhy1VO+NhdrtegrksaueRiJgfrVQ7jySonUdroHZwO5DSjwCT8lGm4KILEYn5MeGdIJHjwwxd/+PC1Q7F5XELcHPl+OPAHH9CeI5Xa1JUuqGRTcqTlqqdnWB7TbHDk2xPtTAa/BRc7RT1U8AieFq42iEfPg1XO8UOuFXKkYQbQXRPtsgm42csUTvIHH/WUrWzE8zuYs2eZHsuIubnK9XOcwlq5/kaqB3cDqT0c8CkfJ4puOhCRGJ+QXgnSOT4LEPX/6JwtUNxedEC3Fw5/iIwx18SnuPVmhSVbmhkk/KypWpnR5zaKcXtfaWF0eBX8Gqn9AqwCF4VrnbIh6/i1U7pVeFqh4ju5RbZZPyaJWoHmeOvW6p2dsQ1xMUEc1nUzhsRMb9ZqXbeSFA7b9ZA7eB2IKXfACblm0zBRRciEvNbwjtBIsfXGbr+t4WrHYrL2xbg5srxt4E5/o7wHK/WpKh0QyOblHctVTs74J5kK8btfa+F0eD38E+yFd8DFsH7wtUO+fB9/JNsxfeFqx0iundbZJPxB5aoHWSOf2ip2tkB97BTIcFcFrXzUUTMH1eqnY8S1M7HNVA7uB1I6Y+ASfkxU3DRhYjE/InwTpDI8UOGrv9T4WqH4vKpBbi5cvxTYI5/JjzHqzUpKt3QyCblc0vVzvawvcbr8A3UX7QwGvwFXO146gtgEXwpXO2QD7+Eqx1PfSlc7RDRfd4im4y/skTtIHP8a0vVzvYwu/M1+wbqbyJi/rZS7XyToHa+rYHawe1ASn8DTMpvmYKLLkQk5u+Ed4JEjl8zdP0ThasdistEC3Bz5fhEYI5/LzzHqzUpKt3QyCblB0vVznZMaufHFkaDf2RQOz8Ci+An4WqHfPgTg9r5SbjaIaL7oUU2Gf9sidpB5vgvlqqd7SxUO79GxPxbpdr5NUHt/FYDtYPbgZT+FZiUv1midpCYfxfeCRI5/sLQ9f8hXO1QXP6wADdXjv8BzPE/hed4tSZFpRsa2aT8Zana2Ra21xQ6fCfbpBZGgyfB1U7BnwQsgr+Fqx3y4d9wtVPw/xaudojo/mqRTcZ1rXaoHWSOzwDEXEu1sy0s3ws1+062Hq3/vta31nVUNvQXlWqH/hG32sHtQEr3aMUlZX0rT3DRhYjE3BNMPuiCI3KcoRW/MTS08m5cKt3QFJcGC3Bz5XgDMMd7Cc/xak2KSjc0sknpDcybWqqdbXBqx43b26eV0WBaHKx23D7AImgEFieXDxtb4WrHbWTeNBBE17tVNhk3WaJ2kDnebKna2QandjIJ5rKonZaImFsr1U5LgtpprYHa2QaodlqASdnayhNcdCEiMfcV3gkSOTYzdP39hKsdiks/C3Bz5Xg/YI73F57j1ZoUlW5oZJPSZqna2Rq21wQd7u0MaGU0eABc7QT+AGARzChc7ZAPZ4SrncCfUbjaIaJra5VNxjNZonaQOT6zpWpna5jaCWp2b2eWiJhnrVQ7sySonVlroHa2BqqdWYBJOWsrT3DRhYjEPJvwTpDIcWaGrn+gcLVDcRloAW6uHB8IzPHZhed4tSZFpRsa2aQMslTtbAXba0rluL2DWxkNHgxXO6XyYGARDBGudsiHQ+Bqp1QeIlztENENapVNxnNYonaQOT7UUrWzFUztlIIEc1nUzrCImIdXqp1hCWpneA3UzlZAtTMMmJTDW3mCiy5EJOYRwjtBIsehDF3/SOFqh+Iy0gLcXDk+Epjjo4TneLUmRaUbGtmkzGmp2tkSttfoDvd25mplNHguuNrR/lzAIphbuNohH84NVzvan1u42iGim7NVNhnPY4naQeb4aEvVzpYwtaNrdm9n3oiY56tUO/MmqJ35aqB2tgSqnXmBSTlfK09w0YWIxDy/8E6QyHE0Q9c/RrjaobiMsQA3V46PAeb4AsJzvFqTotINjWxSxlqqdraA7TXFDmpHtTIarOBqp+grYBFo4WqHfKjhaqfoa+Fqh4hubKtsMnYsUTvIHM9Yqna2gKmdYs3UjhsRc7ZS7bgJaidbA7WzBVDtuMCkzLbyBBddiEjMOeGdIJFjhqHrzwtXOxSXvAW4uXI8D8xxT3iOV2tSVLqhkU2Kb6na2Rz3DdRe3N4FWxkNXhCudjxvQWARLCRc7ZAPF4KrHc9bSLjaIaLzW2WT8cKWqB1kjo+zVO1sDlM7Xj7BXBa1s0hEzItWqp1FEtTOojVQO5sD1c4iwKRctJUnuOhCRGJeTHgnSOQ4jqHrX1y42qG4LG4Bbq4cXxyY40sIz/FqTYpKNzSySVnSUrUTwvYat4PaWaqV0eCl4GrH9ZYCFsHSwtUO+XBpuNpxvaWFqx0iuiVbZZPxMpaoHWSOL2up2glhasetmdpZLiLm5SvVznIJamf5GqidEKh2lgMm5fKtPMFFFyIS8wrCO0Eix2UZuv4VhasdisuKFuDmyvEVgTm+kvAcr9akqHRDI5uUlS1VO2XYXuPruL2rtDIavApc7fh6FWARrCpc7ZAPV4WrHb8DbpVyJOFGEN3KrbLJeDVL1A4yx1e3VO2UYWrHVwnmsqidNSJiXrNS7ayRoHbWrIHaKQPVzhrApFyzlSe46EJEYl5LeCdI5Lg6Q9e/tnC1Q3FZ2wLcXDm+NjDH1xGe49WaFJVuaGSTsq6laieA7TV5Fbd3vVZGg9eDq528Wg9YBOsLVzvkw/Xhaiev1heudojo1m2VTcYbWKJ2kDm+oaVqJ4CpnVyYYC6L2tkoIuaNK9XORglqZ+MaqJ0AqHY2Aiblxq08wUUXIhLzJsI7QSLHDRm6/k2Fqx2Ky6YW4ObK8U2BOb6Z8Byv1qSodEMjm5SCpWqnhPuWgg7fQF1sZTS4CFc7xXIRWAQl4WqHfFiCq51iuSRc7RDRFVplk3FgidpB5njZUrVTwn1LQc2+gTqMiHnzSrUTJqidzWugdkpAtRMCk3LzVp7gogsRiXkL4Z0gkWOZoevfUrjaobhsaQFurhzfEpjjWwnP8WpNiko3NLJJ2dpStVOE7TVOh3s727QyGrwNXO04ahtgEWwrXO2QD7eFqx1HbStc7RDRbd0qm4y3s0TtIHN8e0vVThH3DdQ1u7ezQ0TMO1aqnR0S1M6ONVA7RaDa2QGYlDu28gQXXYhIzDsJ7wSJHLdn6PrHC1c7FJfxFuDmyvHxwBzfWXiOV2tSVLqhkU3KLpaqnQJurynF7d21ldHgXeFqR5V2BRbBbsLVDvlwN7jaUaXdhKsdIrpdWmWT8e6WqB1kju9hqdopwNSOKiaYy6J29oyIea9KtbNngtrZqwZqB7gD6T2BSblXK09w0YWIxLy38E6QyHEPhq5/H+Fqh+KyjwW4uXJ8H2CO7ys8x6s1KSrd0MgmZT9L1c5msL0m1+FJtv1bGQ3eH652cuX9gUVwgHC1Qz48AK52cuUDhKsdIrr9WmWT8YGWqB1kjh9kqdrZDPe5nZo9yXZwRMyHVKqdgxPUziE1UDubAdXOwcCkPKSVJ7joQkRiPlR4J0jkeBBD13+YcLVDcTnMAtxcOX4YMMcPF57j1ZoUlW5oZJNyhKVqZ1PYXqM7fCfbka2MBh8JVztaHwksgqOEqx3y4VFwtaM74FYpRxJuBNEd0SqbjI+2RO0gc/wYS9XOprgn2Wr2nWzHRsR8XKXaOTZB7RxXA7WzKVDtHAtMyuNaeYKLLkQk5uOFd4JEjscwdP0nCFc7FJcTLMDNleMnAHP8ROE5Xq1JUemGRjYpJ1mqdjbBPYzR4XM7J7cyGnxyK37dU4QrFMJ9SutkB4PWZVEVRCgntcomvVMtURXIvDyNmegRMTmNIcdrSagbMxHq6a2MBp/OQKhnCCdUwn1GjQhVpRuaCuOMVp6CQ+GuZZFt1ILzQdzeM1sZDT6TYUc8E8joZwkvWPLhWQxFcJbwM1oq0rMY5M+pwHifLfy4gHLnbCaybx/o2j4bGJ9zhEv8aopBpRsaqRjOFZ7jFONzGRo5ZB5Sk9BSN3nEN9/zqD7pH9TX1aaLOA8Y0B4xO8+PiOaCyhsK9Bf7V1y7ILoWH+gbCucBI3h+19cqdbKWvgDcftJMustVN43+7MzuOsakPB/ok3gRXViZjBe2TllllYmHTJZObNWdgbkQmMQXtcKSQcV9elEXijmt7RcA/YD06cXT4NPOflbcpxfHSLNPzJ9xn6p0Q0+a+npOKdSZbDmfVbmCmw1yGSdw8ipws6E2Bju+a1wTllwv8JxM6OSd0iSsff/kWDuxtW8kk+ombyD0/hLzeqmZl7X+S4S10uKXxuKuvYzj5DOUH16gtBuYLcBxgqKrSqpQcsq+q/3QddxMKSgVTS4VdKjCQskPvX/Xitt7eSujwZcn9Jppjb8c2GNfIVyLkw+vSOg10/rwCnBH0FRXm+deLmW6bVyH9W+HjmBCvAFAH1oAA6nju0Hc6Gm0udSV5JswHSK0M6dPABbzleD2sN2vV8Y6l2nNBU3fNaxVqHxHFVS+lMsX/cApeoUwE2YzQWZ6/dpZsiP9ehWTX6+K/FpLXYskozh5Xh3tyNdQDXIQxgSG04sJwk93p7c41DTgTmvjtcJPvigxr2W4M3AdEylcNxWyVemGvobJF9cz+eL6FBtPZzZz5cVjo/6rnNLpuRpXDjw+SjYPXBrhRnMpMN4a6cP/L2eeVzOded4wNYWj0g19LRMh3jAVhdPJMp2eoZLNNzAQwxNgYmgfPacxZtPSyKTFfGOrTIJBxiKelzcmnG1Pa3w68zkyPjfFzyUzGVMbQV6HQZjJ5n2nqHOZXC50w3zOc4Mw6xaCfFm7hYzjl/Mq1F7ZnPZmSvlc6AelXBgnbR1kMm7gF0s66+QKReUFmYIK3XzGiN8gkw+CjJfLFTKZIOeFnm8Eq5HBnsrm877KORnf4YrPTTGlidoUOjvZiK9py6Zws42bws3Mm8LNDJvCk0I2hapJnP/nM3IhknRuEbopPMlEOrcANoXOjvmQ8blV6KbAFZ9b/x8dP94WHT/ennT8qNKNqmf/yPsgadcCHmWyPMTX7kP0Ew9cPky71h3C40EFcwfDxn4nU5NzJ+Ox6O1MvriLyRd3MR6LcuXF08KPRbly4BkLjkXvYDgWBcZbP9N9LFo5/uFvlE/ijd/dnAr4DiZCvJtRAZPNdzMQw7OWHIveAWyK7mmVSTDPMimse2pwLIqMz71ABfwMUAFzxefehPigH/BCxuc+Jv68D+CHzk5qkH64n8kP93fhmFzyRp5gLiyP403CAzY2CQ8wNwkPMDQJz9WoSUj5dCyU5B4EroVsEp5j2oQe7EKTkPYpW2R8HmrFbezIJoErPg8xnjzVVVk3bYweFv5QJq3xMANfPgLI83+/HTNkwU32PcKA+1Hh8SbMj3I8bCkcN9n3GMfDlsJxk32PczxLJhw32fcEx+MSwnGTfU8y4H5KOG6y7ymOuyXCcZN9T3PcLbFgH3uG4zBYOG6y71kOfWtBvJ9jwP28cNxk3/MMuF8Qjpvse4EB94vCcZN9LzLgfsmC+n6JAffLwnGTfS8z4H5FOG6y7xUG3K8Kx032vcqA+zXhuMm+1xhwv24Br73OgPsN4bjJvjcYcL8pHDfZ9yYD7reE4yb73mLA/bYF9f02A+53hOMm+95hwP2uBfF+lwH3e8Jxk33vMeB+34J4v8+A+wPhuMm+DxhwfygcN9n3IQPuj4TjJvs+YsD9sQX1/TED7k+E4yb7PmHA/akF8f6UAfdnwnGTfZ8x4P7cgnh/zoD7C+G4yb4vGHB/KRw32fclA+6vhOMm+75iwP21BfX9NQPub4TjJvu+YcD9rXDcZN+3DLi/syDPv2PAPVE4brJvIgPu7y2I9/cMuH8Qjpvs+4EB948WxPtHBtw/CcdN9v3EgPtn4bjJvp8ZcP8iHDfZ9wsD7l+F4yb7fmXA/Ztw3GTfbwy4f7eAz39nwP2HcNxk3x8MuP8Ujpvs+5MB91/CcZN9fzHgnmRBfU9iwP23cNxk398MuOv6yo832YjGPYNw3GTfDAy4ewjHTfb1YMBdLxw32VfPgLuncNxkX08G3A0W8FoDA+5ewnGTfb0YcPe2IN69GXD3EY6b7OvDgLtROG6yr5EBd5MFed7EgLtZOG6yr5kBd4tw3GRfCwPuVuG4yb5WBtx9heMm+/oy4O4nHDfZ148Bd3/huMm+/gy424TjJvvaGHAPEI6b7BvAgHtGC/qWGRlwzyQcN9k3EwPumYXjJvtmZsA9iwV5PgsD7lmF4yb7ZmXAPZtw3GTfbAy4BwrHTfYNZMA9uwX1PTsD7kHCcZN9gxhwD7Yg3oMZcA8RjpvsG8KAew7huMm+ORhwD7Ugz4cy4B4mHDfZN4wB93AL4j2cAfcI4bjJvhEMuEdaEO+RDLhHCcdN9o1iwD2ncNxk35wMuOcSjpvsm4sB99zCcZN9czPgnkc4brJvHgbcoy3g89EMuOcVjpvsm5cB93zCcZN98zHgnt+CPJ+fAfcY4bjJvjEMuBcQjpvsW4AB91jhuMm+sQy4lXDcZJ9iwK2F4yb7NANuRzhuss9hwJ2xYB/LMOB2heMm+1wG3FnhuMm+LAPunHDcZF+OAXdeOG6yL8+A27OA1zwG3L5w3GSfz4B7QeG4yb4FGXAvZEGeL8SAe2HhuMm+hRlwj7Mg3uMYcC8iHDfZtwgD7kWF4yb7FmXAvZgFeb4YA+7FheMm+xZnwL2EBfFeggH3ksJxk31LMuBeSjhusm8pBtxLW5DnSzPgXkY4brJvGQbcy1oQ72UZcC8nHDfZtxwD7uWF4yb7lmfAvYIFeb4CA+4VheMm+1ZkwL2ScNxk30oMuFcWjpvsW5kB9yrCcZN9qzDgXlU4brJvVQbcqwnHTfatxoB7deG4yb7VGXCvYcH+vQYD7jWF4yb71mTAvZYF8V6LAffawnGTfWsz4F5HOG6ybx0G3OsKx032rcuAez3huMm+9Rhwry8cN9m3PgPuDYTjJvs2YMC9oXDcZN+GDLg3smD/3ogB98bCcZN9GzPg3kQ4brJvEwbcm1qQ55sy4N5MOG6ybzMG3AXhuMm+AgPuogV5XmTAXRKOm+wrMeAOLIh3wIC7LBw32VdmwB0Kx032hQy4NxeOm+zbnAH3FsJxk31bMODeUjhusm9LBtxbWcDnWzHg3lo4brJvawbc2wjHTfZtw4B7WwvyfFsG3NsJx032bceAe3sL4r09A+4dhOMm+3ZgwL2jBfHekQH3TsJxk307MeAeLxw32TeeAffOFuT5zgy4dxGOm+zbhQH3rsJxk327MuDeTThusm83Bty7W1DfuzPg3kM4brJvDwbcewrHTfbtyYB7LwvyfC8G3HsLx0327c2Aex/huMm+fRhw7yscN9m3LwPu/YTjJvv2Y8C9v3DcZN/+DLgPEI6b7DuAAfeBFuxjBzLgPkg4brLvIAbcB1sQ74MZcB8iHDfZdwgD7kOF4yb7DmXAfZhw3GTfYQy4D7egvg9nwH2EcNxk3xEMuI+0IN5HMuA+Sjhusu8oBtxHWxDvoxlwHyMcN9l3DAPuYy2I97EMuI8TjpvsO44B9/EWxPt4BtwnCMdN9p3AgPtE4bjJvhMZcJ9kQZ6fxID7ZOG4yb6TGXCfIhw32XcKA+5TheMm+05lwH2acNxk32kMuE8XjpvsO50B9xkW8PkZDLjPFI6b7DuTAfdZwnGTfWcx4D5bOG6y72wG3OdYUN/nMOA+Vzhusu9cBtznCcdN9p3HgPt84bjJvvMZcF8gHDfZdwED7guF4yb7LmTAfZEFfH4RA+6LheMm+y5mwH2JBfG+hAH3pcJxk32XMuC+zIJ4X8aA+3LhuMm+yxlwX2FBvK9gwD1BOG6ybwID7iuF4yb7rmTAfZVw3GTfVQy4r7agvq9mwH2NcNxk3zUMuK+1IN7XMuC+Tjhusu86BtzXC8dN9l3PgPsGC/L8BgbcNwrHTfbdyID7JgvifRMD7puF4yb7bmbAfYsF8b6FAfetwnGTfbcy4L5NOG6y7zYG3LcLx0323c6A+w4L6vsOBtx3CsdN9t3JgPsu4bjJvrsYcN9tQZ7fzYD7HuG4yb57GHDfa0G872XAfZ9w3GTffQy477cg3vcz4H5AOG6y7wEG3A8Kx032PciA+yHhuMm+hxhwPywcN9n3MAPuR6TzmrHvEQbcj1rA548y4H5MOG6y7zEG3I8Lx032Pc6A+wnhuMm+JxhwP2lBfT/JgPsp4bjJvqcYcD8tHDfZ9zQD7meE4yb7nmHA/axw3GTfswy4n7OA155jwP28cNxk3/MMuF8Qjpvse4EB94sW5PmLDLhfEo6b7HuJAffLwnGTfS8z4H5FOG6y7xUG3K8Kx032vcqA+zXhuMm+1xhwv24Bn7/OgPsN4bjJvjcYcL9pQbzfZMD9lnDcZN9bDLjftiDebzPgfkc4brLvHQbc71oQ73cZcL8nHDfZ9x4D7vctiPf7DLg/EI6b7PuAAfeHwnGTfR8y4P5IOG6y7yMG3B8Lx032fcyA+xPhuMm+Txhwf2oBn3/KgPsz4bjJvs8YcH9uQbw/Z8D9hXDcZN8XDLi/tCDeXzLg/ko4brLvKwbcX1sQ768ZcH8jHDfZ9w0D7m8tiPe3DLi/E46b7PuOAfdE4bjJvokMuL+3IM+/Z8D9g3DcZN8PDLh/FI6b7PuRAfdPFuT5Twy4fxaOm+z7mQH3LxbE+xcG3L8Kx032/cqA+zfhuMm+3xhw/y4cN9n3OwPuPyyo7z8YcP8pHDfZ9ycD7r+E4yb7/mLAPUk4brJvEgPuvy2o778ZcNf1k42b7KOJxj2DcNwU7xkYcPcQjpvs68GAu96CeNcz4O4pHDfZ15MBd4MF8W5gwN1LOG6yrxcD7t4WxLs3A+4+wnGTfX0YcDdaEO9GBtxNwnGTfU0MuJuF4yb7mhlwtwjHTfa1MOBuFY6b7GtlwN1XOG6yry8D7n7CcZN9/Rhw9xeOm+zrz4C7TThusq+NAfcA4bjJvgEMuGcUjpvsm5EB90zCcZN9MzHgnlk4brJvZgbcswjHTfbNwoB7VuG4yb5ZGXDPJhw32TcbA+6BwnGTfQMZcM8uHDfZNzsD7kHCcZN9gxhwDxaOm+wbzIB7iHDcZN8QBtxzCMdN9s3BgHuocNxk31AG3MOE4yb7hjHgHi4cN9k3nAH3COG4yb4RDLhHCsdN9o1kwD2qH/Beullj1hj2+ED7YxQwXnF75+zHaPCc/fDrzgUMIBfuufpNdjBoXbabkhw3Y+cGk0v76FGJP+d4rus5mWIh7+iCW8znQj8oFULHKzpBQZU9lQvyTiHjFTxXF0sFTxWDgpPNBwW3nNMOMpfmia1lfmJJ+aEqZL1CvmwWUmVl3hS9cphzCsWSq5xAa112zf855cD1i0FOF3Pmp2eL2vx3SbF2iiU/l8+b/7IUFF1XZ32nEBR1XhN4N/TymaIuZoypmXw2dMqhq3zjDAMzNC7IFMtNUV5O4UPXL5TNssVMLlMuGmNDJ5sr+Oa/KuXKmZxbJP9mM06YczPGb47KuIWw5GY95TteyXWbgD4cLXxTIvtGM9TLvMJxk33zMuCeTzhusm8+BtzzC8dN9s3PgHuMcNxk3xgG3AsIx032LcCAe6xw3GTfWAbcSjhusk8x4NbCcZN9mgG3Ixw32ecw4M4Ix032ZRhwu8Jxk30uA+6scNxkX5YBd044brIvx4A7Lxw32ZdnwO0Jx032eQy4feG4yT6fAfeCwnGTfQsy4F5IOG6ybyEG3AsLx032LcyAe5xw3GTfOAbciwjHTfYtwoB7UeG4yb5FGXAvJhz3P/Yx4F5cOG6yb3EG3EtYelN3Caabukv2YzR4SYabuksJv6lLuJfqN9nBoHVZbKWbr/MwFNnSNbqpm/ZGJzKXlumHu1GaFGsdhqUwH+TLYcZxSvl8MZ8pZbPFUsncsC4WtbkUeL5xgLmq8uanOPmcl/EypZIq6lwQ/nPDdKmEm7pa5fLZnF8IzQ8wPnHM0WemHIYGv1kvcAs5lS1mnWIuE+S80MDSJeOBIJt3QrfsO9oZDfThssI3JbJvWYZ6WU44brJvOQbcywvHTfYtz4B7BeG4yb4VGHCvKBw32bciA+6VhOMm+1ZiwL2ycNxk38oMuFcRjpvsW4UB96rCcZN9qzLgXk04brJvNQbcqwvHTfatzoB7DeG4yb41GHCvKRw32bcmA+61hOMm+9ZiwL22cNxk39oMuNcRjpvsW4cB97rCcZN96zLgXk84brJvPQbc6wvHTfatz4B7A+G4yb4NGHBvKBw32bchA+6NhOMm+zZiwL2xcNxk38YMuDcRjpvs24QB96aW3tzclOnm5mb9GA3ejOHmZkH4zU3CXeg32cGgdVlspZuQyzAUWbFGNzfT3vBD5lKpH+6GYWKss6EKw2K+UC6Vs+VMQeeKWdfJugUvV3aLnlcIVJAx/6JcDB2/7DjZvDY/KJvN5L18qVT2lo3ycoobxIV8xi0Xixknl3F1OSxov6gyOR34OqNKgZsvOrli3vU8c2M2cHLlcslcDM09Wy9vPKILywJ9GAjflMi+gKFeysJxk31lBtyhcNxkX8iAe3PhuMm+zRlwbyEcN9m3BQPuLYXjJvu2ZMC9lXDcZN9WDLi3Fo6b7NuaAfc2wnGTfdsw4N5WOG6yb1sG3NsJx032bceAe3vhuMm+7Rlw7yAcN9m3AwPuHYXjJvt2ZMC9k3DcZN9ODLjHC8dN9o1nwL2zcNxk384MuHcRjpvs24UB967CcZN9uzLg3k04brJvNwbcuwvHTfbtzoB7D+G4yb49GHDvKRw32bcnA+69LL3JtxfTTb69+zEavDfDTb59hN/kI9z79JvsYNC6LLbSzbgSQ5HtW6ObfGlvfCFzab9+uBtnSbE2dyrdglMoZs0/dcNsPmPua2rzI1RobmeSMZkgGxR85RYzOdcPi06+WFKZoqKfFxYL+SDKyyl8WPLDQrGU99xskFUGZtYpOwWVyeuScYgOtZstq6DoOWXPwPFzuuRkQ13OmFumRXJQAPTh/sI3JbJvf4Z6OUA4brLvAAbcBwrHTfYdyID7IOG4yb6DGHAfLBw32XcwA+5DhOMm+w5hwH2ocNxk36EMuA8TjpvsO4wB9+HCcZN9hzPgPkI4brLvCAbcRwrHTfYdyYD7KOG4yb6jGHAfLRw32Xc0A+5jhOMm+45hwH2scNxk37EMuI8TjpvsO44B9/HCcZN9xzPgPkE4brLvBAbcJwrHTfadyID7JOG4yb6TGHCfLBw32XcyA+5ThOMm+05hwH2qpTe7TmW62XVaP0aDT2O42XW68JtdhPv0fpMdDFqXxVa6KbUfQ5GdUaObXWlvACFz6cx+uBtISbF2ytlMVqnQy+VLgblL5tJNs5ybLWWzQTHvZAJt7q05ysvmgmKQz2uv7LtF5RnH5MOMucO3f5SXU9zscrQKy7lMtlB0S3k3MHfhiqUwr4olx9w9zPjZnKeM1cpxgsD3dWhuJwZuVuUKRXM96wf7A314lvBNiew7i6FezhaOm+w7mwH3OcJxk33nMOA+Vzhusu9cBtznCcdN9p3HgPt84bjJvvMZcF8gHDfZdwED7guF4yb7LmTAfZFw3GTfRQy4LxaOm+y7mAH3JcJxk32XMOC+VDhusu9SBtyXCcdN9l3GgPty4bjJvssZcF8hHDfZdwUD7gnCcZN9ExhwXykcN9l3JQPuq4TjJvuuYsB9tXDcZN/VDLivEY6b7LuGAfe1wnGTfdcy4L7O0ps+1zHd9Lm+H6PB1zPc9LlB+E0fwn1Dv8kOBq3LYivdnDmTochurNVNn5Q3QpC5dFM/3I2UpFgbI4o6dEpOmPFKxqpyoRDmc2EYZgsqyLn5TEn7Jd/NmJtKBc8Nsr75wTqfCdygnCsWPfesKC8rfagLge+Ebs4s7gV+wTiyoEplg7tYVp6js+WSLuhQGUf75XKxaG6V5YKgnM0VHO0bP5bPAvrwZuGbEtl3M0O93CIcN9l3CwPuW4XjJvtuZcB9m3DcZN9tDLhvF46b7LudAfcdwnGTfXcw4L5TOG6y704G3HcJx0323cWA+27huMm+uxlw3yMcN9l3DwPue4XjJvvuZcB9n3DcZN99DLjvF46b7LufAfcDwnGTfQ8w4H5QOG6y70EG3A8Jx032PcSA+2HhuMm+hxlwPyIcN9n3CAPuR4XjJvseZcD9mHDcZN9jDLgft/Tmx+NMNz+e6Mdo8BMMNz+eFH7zg3A/2W+yg0HrsthKNyluYiiyp2p08yPtDQFkLj3dD3dDISnW2snnSm7oZDIqW8oog9MpZ1QhHxbLXrYYqFKYKZedQBXCbKgzxgCt/XyggjBjLCkE4c1RXk7hw6AceL6nCmWnGAS64DqOsVCZRX0vLHmlrBdmVTafLxWyhWypnCk6JS/vedmwFKhi1sncDPThM8I3JbLvGYZ6eVY4brLvWQbczwnHTfY9x4D7eeG4yb7nGXC/IBw32fcCA+4XheMm+15kwP2ScNxk30sMuF8Wjpvse5kB9yvCcZN9rzDgflU4brLvVQbcrwnHTfa9xoD7deG4yb7XGXC/IRw32fcGA+43heMm+95kwP2WcNxk31sMuN8Wjpvse5sB9zvCcZN97zDgflc4brLvXQbc7wnHTfa9x4D7fUtvArzPdBPgg36MBn/AcBPgQ+E3AQj3h/0mOxi0LoutdFj/NEORfVSrmwApD8aRufRxP9zBemKsC1lz3yDQQd5xSmEp59NvtymEpTzd+Mhm/XzRmGh+ih+USpliaP6tb/6yXPBLJbN4ofhMlJeVPnRy2skGBa0KqhyoXMbJZ5VXKBZULtDGmZlCKadz5nJQLAcZ1w+zGYMmKPjZTCaT97L5Z4A+/ET4pkT2fcJQL58Kx032fcqA+zPhuMm+zxhwfy4cN9n3OQPuL4TjJvu+YMD9pXDcZN+XDLi/Eo6b7PuKAffXwnGTfV8z4P5GOG6y7xsG3N8Kx032fcuA+zvhuMm+7xhwTxSOm+ybyID7e+G4yb7vGXD/IBw32fcDA+4fheMm+35kwP2TcNxk308MuH8Wjpvs+5kB9y/CcZN9vzDg/tXSw/BfmQ7Df+vHaPBvDIfhvws/DCfcv/eb7GDQuiy20qH1xwxF9keNDsPTHhAjc+nPfrgD5sRYl1Uml3fL5vA8G2SDfC5XCoqOOf0vhOY2gJsP82XtK5ULcznH8bO5cr7k+iXteuWS8jNu9pMoL6c4DHdyysB2PdctmsN5J6s9x89kM37OK7u+zpr7DE7Wc7WXyebdfMYc3uvAeDbM6UyYKxWDT4A+/Ev4pkT2/cVQL5OE4yb7JjHg/ls4brLvbwbcdf1l4yb7aKJxzyAcN9k3AwPuHsJxk309GHDXC8dN9tUz4O4pHDfZ15MBd4Nw3GRfAwPuXsJxk329GHD3Fo6b7OvNgLuPcNxkXx8G3I3CcZN9jQy4m4TjJvuaGHA3C8dN9jUz4G4Rjpvsa2HA3SocN9nXyoC7b387D4X7AuMVt7dff0aD+/XHr9sfGEAu3P37T3YwaF0WW+nw9k+GQ482MLm0jykOhVMelCJzaUB/3EFrUqx1zsv5upQp5Apu1iyULbnlUrlYKBVL+bCgwpxTymRD18+Zv/DNWbM5Ay9msmVjRsbJhI5Dh5mEt9KH2g8CY2SYKXiBmyvpbEnpfC4sFrNFP1t2g1I2rzwvDI1pbqCLgeeWcsWwkM0HpaBkAvAX8FB4RuGbEtk3I8OmNJNw3GTfTAy4ZxaOm+ybmQH3LMJxk32zMOCeVThusm9WBtyzCcdN9s3GgHugcNxk30AG3LMLx032zc6Ae5Bw3GTfIAbcg4XjJvsGM+AeIhw32TeEAfccwnGTfXMw4B4qHDfZN5QB9zDhuMm+YQy4hwvHTfYNZ8A9Qjhusm8EA+6Rlh6OjmQ6HB3Vn9HgUQyHo3MKPxwl3HP2n+xg0LosttIh5gCGIpurRoejaQ8Mkbk0d3/cgWNSrLVZyFFePuNnzT90cua/DIteOfQLeccc/hYMJBUW/dDJGByhl9El808NZEfnVSGvgxmjvJzCh8XQcwLjtHyQd31lPGZsK5XMQbIq57Q5ZM5qp1wqmKPlbNbRquzkc2XjD69U9sKsV87OCPThPMI3JbJvHoZ6GS0cN9k3mgH3vMJxk33zMuCeTzhusm8+BtzzC8dN9s3PgHuMcNxk3xgG3AsIx032LcCAe6xw3GTfWAbcSjhusk8x4NbCcZN9mgG3Ixw32ecw4M4Ix032ZRhwu8Jxk30uA+6scNxkX5YBd044brIvx4A7b+khYZ7pkNDrz2iwx3BI6As/JCTcfv/JDgaty2IrHebNzVBkC9bqkDDlwRkylxbqjzt4S4q1E+azvlnRyxfColN2s5li1suFnjkLDfPFbFnrXNHzHLOo54aOzuSdfJjzQ62z5l+W3OI8UV72mCKHyuWiUypmfU+XAzebc/1CsVwMysrTQckcZOZKXk7poOxm3Hw5HwQ653jFghMUCiU3U8zPA/ThwsI3JbJvYYZ6GSccN9k3jgH3IsJxk32LMOBeVDhusm9RBtyLCcf9j30MuBcXjpvsW5wB9xLCcZN9SzDgXlI4brJvSQbcSwnHTfYtxYB7aeG4yb6lGXAvIxw32bcMA+5lheMm+5ZlwL2ccNxk33IMuJcXjpvsW54B9wqWHpatwHRYtmJ/RoNXZDgsW0n4YRnhXqn/ZAeD1mWxlQ61FmIospVrdFiW9gAJmUur9McdQCXGOuN6BU9lvHw5LGV8r5gL6BnBks77WafkBU5O+cWyLma8QiYwB4h+oRD4JT9XMGeCOqPyC0d5OYUPA10s5HIGimts87U57jX/Cws5v1xyioG5beoUzP8C13itoJRfoM9pe2Hglp1cuRQWFwb6cFXhmxLZtypDvawmHDfZtxoD7tWF4yb7VmfAvYZw3GTfGgy41xSOm+xbkwH3WsJxk31rMeBeWzhusm9tBtzrCMdN9q3DgHtd4bjJvnUZcK8nHDfZtx4D7vWF4yb71mfAvYFw3GTfBgy4NxSOm+zbkAH3RpYeGm3EdGi0cX9GgzdmODTaRPihEeHepP9kB4PWZbGVDndWYSiyTWt0aJT2IAWZS5v1xx3EJMbaKQWh52idyeaLxYLn+0qHmbCczxRcc2Tm5g3Igp/LK3NSVcrS20w+zATaK3sZX+eDVaO8nPLQyM9lc1ldCgK/7Hpah245q4ueCoJSwXi36BrrymWddx1VKJRzBXOypXTJyel8KVf2sqsCfVgQvimRfQWGeikKx032FRlwl4TjJvtKDLgD4bjJvoABd1k4brKvzIA7FI6b7AsZcG8uHDfZtzkD7i2E4yb7tmDAvaVw3GTflgy4txKOm+zbigH31sJxk31bM+DeRjhusm8bBtzbWnp4si3T4cl2/RkN3o7h8GR74YcnhHv7/pMdDFqXxVY65NiMoch2qNXhScoDBWQu7dgfdyCRFGsnDN1CxvEdr5QPdSlf9DJOtlAuK69UDnVZZ7M6H7q5bLloXgyE0M8E5mQml3Vd+pW4TiHKyyl8qHJhoegavDnfmOKQdioXSl7eKzq5XL4YZHQxzJQdr5wxxz35nFso0D8O/GIxMH/X4cAjrQ93Er4pkX07MdTLeOG4yb7xDLh3Fo6b7NuZAfcuwnGTfbsw4N5VOG6yb1cG3LsJx0327caAe3fhuMm+3Rlw7yEcN9m3BwPuPYXjJvv2ZMC9l3DcZN9eDLj3Fo6b7NubAfc+lh4i7MN0iLBvf0aD92U4RNhP+CEC4d6v/2QHg9ZlsZXE/o4MRbZ/jQ4R0gprZC4d0B8nzJNi7eQzTt4LSipjjhtCXSjm8k4+6zqe6+QM8kxRu06+7BlVX8wGbuA5eb/gKUeXw2LgFEveTlFeTnGI4GfoVxTmgrITBlqFxtQgUPlMaDzlq4Kfz4U655fMi8oY+3xdcvP5bN5gcp3AzRR2AvrwQOGbEtl3IEO9HCQcN9l3EAPug4XjJvsOZsB9iHDcZN8hDLgPFY6b7DuUAfdhwnGTfYcx4D5cOG6y73AG3EcIx032HcGA+0jhuMm+IxlwHyUcN9l3FAPuoy0V00czielj+jMafAyDmD5WuJgm3Mf2n+xg0LostpLoPYChyI6rlZhOKTCRuXR8f5xATYq1Y+S49splN58r+cWwrFz67VRBOSi5xbBQLubCvIFklHjWcfNhKZfPBHm/5Bfyfi4baOcfoXpskph28oVM1nN9v2QAO8Wia66EQb6QzWSzQV4XvZJ2Sjqfd303VKVCoFQh64UGg19wymXnQKAPTxC+KZF9JzDUy4nCcZN9JzLgPkk4brLvJAbcJwvHTfadzID7FOG4yb5TGHCfKhw32XcqA+7ThOMm+05jwH26cNxk3+kMuM8QjpvsO4MB95mWisozmUTlWf0ZDT6LQVSeLVxUEu6zLRGVJP6OZyiyc2olKlMKLWQundsfJ9SSYu34xny3qPNa+2GJfqmJrz3fM/9t6Jdzeb9cNqjKXj5Q5ZzvlXMZXfayYdHJZAJdMOr1hCgvpxCVOaN7fWOM0vmC66hysVgulozNysvndTmToW+u9Euq4AXmZnKhqHXo+9myNv+mnPW1cwLQh+cJ35TIvvMY6uV84bjJvvMZcF8gHDfZdwED7guF4yb7LmTAfZFw3GTfRQy4LxaOm+y7mAH3JcJxk32XMOC+VDhusu9SBtyXWSquLmMSV5f3ZzT4cgZxdYVwcUW4r7BEXJEIOpehyCbUSlylFBzIXLqyP06wJMXa0W4up7OZcsEt5FUpKHq+0kYnFjLlXFaX865SmWJZ5fKBa2zTxWKhYO4Chk7BC8sFL+OeF+XlFOIq1EaNmpuYOQM+zBZD40inpMpB4BfNatmyl1FOwdVhKe8ZY7Oenynkw4J2DbhsvlQ+D+jDq4RvSmTfVQz1crVw3GTf1Qy4rxGOm+y7hgH3tcJxk33XMuC+Tjhusu86BtzXC8dN9l3PgPsG4bjJvhsYcN9oqci4kUlk3NSf0eCbGETGzcJFBuG+2RKRQWLgSoYiu6VWIiNl443MpVv74xr3pFg7XjHj+VpnijrQJcct5UsFJ5srlh3X3P0plEo5gy4butrJeflyTuWLbtmnO0fFbIF+Rf1VUV5OITLyRVXK5ozo0q7nKnNHycs5yi34YSYXhsZcnfddJ+sas1XoZFTJGJvTvs6bH5sv5HNXAX14m/BNiey7jaFebheOm+y7nQH3HcJxk313MOC+Uzhusu9OBtx3CcdN9t3FgPtu4bjJvrsZcN9jabN9D1OzfW9/RoPvZWi27xPebBPu+yxptqkpvpWhyO6vVbOdsgFF5tID/XENbFKstZ8PtMpnM0ZB+DnzB88s5mrf9x3PdOmBKuQ83ylnSk4p77jmTkIuyBTM3YxMNueU8+E/jeJ9Cc22NoIgE4RBgb5Jw/d1EGZLZXM7wtz78A1GpYNSMZvNucVcSA72fXN7xIiCUrHgB8Y1+jagDx8UvimRfQ8y1MtDwnGTfQ8x4H5YOG6y72EG3I8Ix032PcKA+1HhuMm+RxlwP2Zp0/kYU9P5eH9Ggx9naDqfEN50Eu4nLGk6qTl8gKHInqxR05m2EUPm0lP9cY1cUqx1yS1lTEtt2lffV1lzeqwyuYKrMnlzuZArlLUX6MBxs05gFg5Mm+2WwoJXDsp5FQYl78EoL6fwoWt+ousG2aLyVFgqUO8eFPM51y8a+419uUKuVHRcJ1fOOG6xHBR91/TNWa29UDmZwoNAHz4tfFMi+55mqJdnhOMm+55hwP2scNxk37MMuJ8Tjpvse44B9/OWNl/PMzVfL/RnNPgFhubrReHNF+F+0ZLmi5qkpxiK7KVaNV8pGxJkLr3cH9fQJMXayfmhLhZK5iwxZ44T844OPCdb8DP0LHDWnHyWdFFnnFKYc8xpZp7OGc0Ro6uKrlsoBxnn6Sgvp7i97pey5j/LGfxFPxPQY9Geo1Tg5kuq6BR8v2ScSL/EJ+OVy+ZkNVMuB675TzLFYlY7QYeGKa0PXxG+KZF9rzDUy6vCcZN9rzLgfk04brLvNQbcr1vahLzO1IS80Z/R4DcYmpA3hTchhPtNS5oQahZeZiiyt2p12zHlxozMpbf74zb2xFibUySDT5UKuWxZmbalaH5+Lq/KJdN1mcMur1zKlku5fM7JFfJuaE6+SqVysWT+g9BYHOZfifJyCh9q5Tnmbq02bVExdMu6lCsbN5mjqiDIKq/k+7kgND/L3BMth0XfK2qdNfhM+2QcllPFV4A+fEf4pkT2vcNQL+8Kx032vcuA+z1LN+P3mDbj9/szGvw+w2b8gfDNmHB/YMlmTJvm2wxF9mGNNuO0GxQylz7qj9vgEmOdzajA/Fzt5c3RgaKV3ULey5ULgc75Ti7IBrScsbbg5HJerhBmXddzzd0o1yloz3knysspNuNiJpMPjImmc3FDxymXDMCyE/pmhbK5u5V1ck4+k8uFns6rgjK9jGdONdyC6XOCbNnrsIGm9eHHwjclsu9jhnr5xNJN6ROmTenT/owGf8qwKX0mfFMi3J9ZsinR5vERQ5F9XqtNKSVRI3Ppi/44ou9KrIuZkhvk/cDVBV/ns16p6PqlTFbnS2ZbcwtZx+y8oXYyOeWFJb9U+jjKyx6dxFq5XjFX1gZY4LnauKBULjhumAsDY3GxXHIy2lFu3qyaN/cEMrmPgT780lJy/pKJnL/qz2jwVwzk/LVwcibcX1tCzkSiXzCQ8ze1IueKMa2Ehcylb/vjCC8p1oiYfMsQ6+/i9069jGN2Hfp3XqC0G5Qcz3GCoqvMcWrJKfuu9kPXcTOloFQ0axZ0qMJCyQ+9f9eqJaF+x0SoE/szGjyRgVC/F06ohPt7BkKlZGuqm0wqSaP9Z6VNbA6/tBc02i/xZP4hlm9w5vgeV4GabKuPbGw3umfsWjUMKt1gC0I8KX+M1v+JcHEE4QcGVvmB+fAHhbuzlmIaRwfcaW38WfgBGiXmzwwtxS/grbmdBGjd/aN10b74ickXvzL54ldGX3C1mr8J5xSuenh+1H8Vd6kT+9hy/4VRsvmPMP/GsIcA462RPqSGimZXOubO1uosp+JrcuxbKJ/Em8vfp9Ytq3RD/8y0EcSNnkabdWc/h2z+nYEYXgITQ/voOY0xm5YGLi3mP/rLJBhkLOJ5+UesQZne+HTmc2R8/oyfg2UypjaCvA6DMJPN+05R5+hejBvmc54bmFtEhSBf1m4h4/j0cQb6RVH5bIZ+la8flHJhnLR1kMm4gV8saXNLp1BUXpApqNDNZxxVCMwtoCDj5XKFTCbIeaHnm1OJQpjxVDaf91XOyfgOV3z+TIjPtG6EnR2bIOPzFxN//gXwQ2fHS0g/TGLyw6TID1NrEiRv5AnmwvI43iT8bWOT8Ddzk/A3Q5Pwco2ahM7UUy1Jrq5NpOrULzNtQoR3/7qOYxrjE5gE1SWtQuWbHVXlS7l80Q+comf20TCbCTLI+MzQhtvYkU0CV3xmaJv+U6bO6qb9BLceW4/Tcj+s07WQp8E92rAbUnuMeqSIUWeNy3TGqNOanJZ7lp2thYxRfRvOd/EY1bdNbq4qb2nVTWfsOjMPedoabwZ7tv372tCWcDtLpRu62m0d5L3KtGsBb40lftWPSjf09Bbtf8uHadfq1SY7HlQwZCO6Qe7dxrPp927ju7XUwOSLPky+6DMVX6R+/JTJF68Kv93ElQOvCb/dRBsy4UbfbgLGW7/WfbupcvzD3yifxBu/xjbGk6ReTIQYNxp9kkQ2NzIQw+uW3G7qBTz9aWqTSTCvM51UNLXx325Cxqe5DXe76TXgSRJXfJrbOr+9UDeN8erKU7vtw5ZNocXGTaGFeVNoYdgU3hCyKVRN4nz4z0CSTqvQTeENJtJpBWwKnR3zIePTV+imwBWfvrFNoVafG/oN93knHbe3Xxujwf0SZGNa4/sByaA/sAi4fNg/YRNJ68P+bdhNhGPDJxvRR8FI0kPmThv4KLh9oG9H/AY8/h7AnIOIXEnKQZVuIJtZKH/NCI4H+riQcg9oo6aaG8DQoM8EFit96ibnYLutk6L39LMmYf38z8/sEft557dO/nkXRO9nNj93FjNnbW8eKuwD2aJnBfqSmrWBMV9y2j0zuJYqB2Zth29tPfl0gF6HRe9nM34ZaObsZg4yc7CZQ8ycw8yhZg4zc7iZI8wcaeYoM+c0cy4z5zZzHjNHmzmvmfOZOb+ZY8xcwMyxZioztZmOmRkzXTOzZubMzLdFxrR38WRMn4prAxOuzZ5wbVDCtcEJ14YkXJsj4drQhGvDEq4NT7g2IuHayIRroxKuzZlwba6Ea3MnXJsn4drohGvzJlybL+Ha/AnXxiRcWyDh2tiEayrhmk645iRcyyRccxOuZROu5RKu5aNr8TE8el0selXpRgfSSbuJzQZYq/zPOZDSA0FrEcbZIWv9669B6ddy2u/jDU67ljv5nuCQdGup+P3FOdKs5XS8Vzl0+tdSlfc9h03nWuaQaIp7qMOnby0v6X7siOlZy0u+tzty2tfKV7tPPGpa18pXv+c857St5Uzt/vVc07JWfur3wufu+lqdPqsxT1fXynfKhXp019ZSXeBVPW9X1lJd4mg9X+drZbvI93r+ztZyu7x36DFTXYu+wbbray0wtbXy07Sn6bHV1/KmcX/UqspafjjNe63WyWup6di3tZO0lpquHkBnplxLT2c/od3KtYLp7k10tuNamRR9js7F1nLCVD2TzgNFH/WNu9ZNFk75SMRkI1GTiUSOjkTP2EgEjYlE0XyRSBodiaa5IxE1ZySqRkYia3gkuoZGImxIJMoGRSKNejfqBWnU8m5HHtZ/Bh3udnhtjAbT4qgT13bjPVxSaR8oELh8SDaiTuTafegDC5OKYLa62nzMFEcoAetJT9wXC0YFtlDlacuCUWDj1xZKUMXo43Yckyi9ILCAFgIHF518VDQLAouxHfeC4GKs1Y6Ug+WRH8TtXbiN0eCF4TuSHywM3JHGCd+RyIfj4DuSH4yzdEfKwez2SwnmsuxIi0QFtmjljrRIwo60aA12pBxwR1oEWECLMgUX/RACEvNiQDKrq8Pvln5EQOib6UgpsDiQzJJ8qNINTTFenKGTWdzSTiYL459iJm7vEm2MBi8B72SKmSWAxb+k8E6GfLgkvJMpZpZkLn4EgS4unECXAvuwfaA3XmSOLw2svVp2wFmY3UUnwVyWDniZiJiXreyAl0nogJetQQeM24GUXgaYlMsyBRddiEjMyzF3wCrd0ESOSzN0b8sL71opLstbgJsrx5cH5vgKwnO8WpOCaH5Qa60I3rBrpXZc2F7jhXF7V2pjNHgluNrxwpWAAVxZuNohH64MVzteuLJwtUNEt2KbbDJeBUzG7QONGZnjq1qqdlyY3V45wVwWtbNaRMyrV6qd1RLUzuo1UDu4HUjp1YBJuTpTcNGFiMS8hvBOkMhxVYauf03haofisqYFuLlyfE1gjq8lPMerNSkq3dDIJmVtS+/tZGB7jdPh633WaWM0eB242nHUOsAiWFe42iEfrgtXO45aV7jaIaJbu002Ga9nidpB5vj6lqqdDMxuHSaYy6J2NoiIecNKtbNBgtrZsAZqB7cDKb0BMCk3ZAouuhCRmDcS3gkSOa7P0PVvLFztUFw2tgA3V45vDMzxTYTneLUmRaUbGtmkbGqp2nFge03QQe1s1sZo8GZwtROozYBFUBCudsiHBbjaCVRBuNohotu0TTYZFy1RO8gcL1mqdhyY3aWaqZ0gIuZypdoJEtROuQZqB7cDKR0Ak7LMFFx0ISIxh8I7QSLHEkPXv7lwtUNx2dwC3Fw5vjkwx7cQnuPVmhSVbmhkk7KlpWpHw/aaXIfvxNiqjdHgreBqJ6e3AhbB1sLVDvlwa7jayXXArVKOJNwIotuyTTYZb2OJ2kHm+LaWqh0NsztXs+9S2S4i5u0r1c52CWpn+xqoHdwOpPR2wKTcnim46EJEYt5BeCdI5LgtQ9e/o3C1Q3HZ0QLcXDm+IzDHdxKe49WaFJVuaGSTMt5StaNw93a8uL07tzEavDP+3o63M7AIdhGudsiHu+Dv7Xi7CFc7RHTj22ST8a6WqB1kju9mqdpRMLuDfIK5LGpn94iY96hUO7snqJ09aqB2cDuQ0rsDk3IPpuCiCxGJeU/hnSCR424MXf9ewtUOxWUvC3Bz5fhewBzfW3iOV2tSVLqhkU3KPpaqnbGwvcb14/bu28Zo8L5wteP6+wKLYD/haod8uB9c7bj+fsLVDhHdPm2yyXh/S9QOMscPsFTtjIXZ7XoJ5rKonQMjYj6oUu0cmKB2DqqB2sHtQEofCEzKg5iCiy5EJOaDhXeCRI4HMHT9hwhXOxSXQyzAzZXjhwBz/FDhOV6tSVHphkY2KYdZqnYWgO01xQ5Psh3exmjw4XC1U9SHA4vgCOFqh3x4BFztFDvgVilHEm4E0R3WJpuMj7RE7SBz/ChL1c4CMLuLNXuS7eiImI+pVDtHJ6idY2qgdnA7kNJHA5PyGKbgogsRiflY4Z0gkeNRDF3/ccLVDsXlOAtwc+X4ccAcP154jldrUlS6oZFNygmWqp0xOLVTitt7YhujwSfi1U7pRGARnCRc7ZAPT8KrndJJwtUOEd0JbbLJ+GRL1A4yx0+xVO2MwTXExQRzWdTOqRExn1apdk5NUDun1UDt4HYgpU8FJuVpTMFFFyIS8+nCO0Eix1MYuv4zhKsdissZFuDmyvEzgDl+pvAcr9akqHRDI5uUsyxVO/PjnmQrxu09u43R4LPxT7IVzwYWwTnC1Q758Bz8k2zFc4SrHSK6s9pkk/G5lqgdZI6fZ6namR/3sFMhwVwWtXN+RMwXVKqd8xPUzgU1UDu4HUjp84FJeQFTcNGFiMR8ofBOkMjxPIau/yLhaoficpEFuLly/CJgjl8sPMerNSkq3dDIJuUSS9XOfLC9xuvwDdSXtjEafClc7XjqUmARXCZc7ZAPL4OrHU9dJlztENFd0iabjC+3RO0gc/wKS9XOfDC78zX7BuoJETFfWal2JiSonStroHZwO5DSE4BJeSVTcNGFiMR8lfBOkMjxCoau/2rhaoficrUFuLly/Gpgjl8jPMerNSkq3dDIJuVaS9XOvExq57o2RoOvY1A71wGL4Hrhaod8eD2D2rleuNohoru2TTYZ32CJ2kHm+I2Wqp15LVQ7N0XEfHOl2rkpQe3cXAO1g9uBlL4JmJQ3W6J2kJhvEd4JEjneyND13ypc7VBcbrUAN1eO3wrM8duE53i1JkWlGxrZpNxuqdoZDdtrCh2+k+2ONkaD74CrnYJ/B7AI7hSudsiHd8LVTsG/U7jaIaK7vU02Gd9lidpB5vjdlqqd0TC7CzX7TrZ7ImK+t1Lt3JOgdu6tgdrB7UBK3wNMynuZgosuRCTm+4R3gkSOdzN0/fcLVzsUl/stwM2V4/cDc/wB4TlerUlR6YZGNikPWqp25sGpHTdu70NtjAY/hFc77kPAInhYuNohHz6MVzvuw8LVDhHdg22yyfgRS9QOMscftVTtzINriDMJ5rKoncciYn68Uu08lqB2Hq+B2sHtQEo/BkzKx5mCiy5EJOYnhHeCRI6PMnT9TwpXOxSXJy3AzZXjTwJz/CnhOV6tSVHphkY2KU9bqnbmhu01QYd7O8+0MRr8DFztBP4zwCJ4VrjaIR8+C1c7gf+scLVDRPd0m2wyfs4StYPM8ectVTtzw+wOanZv54WImF+sVDsvJKidF2ugdnA7kNIvAJPyRabgogsRifkl4Z0gkePzDF3/y8LVDsXlZQtwc+X4y8Acf0V4jldrUlS6oZFNyquWqp25YHtNqRy397U2RoNfg6udUvk1YBG8LlztkA9fh6udUvl14WqHiO7VNtlk/IYlageZ429aqnbmgtldChLMZVE7b0XE/Hal2nkrQe28XQO1g9uBlH4LmJRvMwUXXYhIzO8I7wSJHN9k6PrfFa52KC7vWoCbK8ffBeb4e8JzvFqTotINjWxS3rdU7cwJ22t0h3s7H7QxGvwBXO1o/wNgEXwoXO2QDz+Eqx3tfyhc7RDRvd8mm4w/skTtIHP8Y0vVzpwwu3XN7u18EhHzp5Vq55MEtfNpDdQObgdS+hNgUn7KFFx0ISIxfya8EyRy/Jih6/9cuNqhuHxuAW6uHP8cmONfCM/xak2KSjc0skn50lK1Mwq21xQ7qJ2v2hgN/gqudor+V8Ai+Fq42iEffg1XO0X/a+Fqh4juyzbZZPyNJWoHmePfWqp2RsHsLtZM7XwXEfPESrXzXYLamVgDtYPbgZT+DpiUE5mCiy5EJObvhXeCRI7fMnT9PwhXOxSXHyzAzZXjPwBz/EfhOV6tSVHphkY2KT9ZqnZGwvYaz4vb+3Mbo8E/w9WO5/0MLIJfhKsd8uEvcLXjeb8IVztEdD+1ySbjXy1RO8gc/81StTMSZreXTzCXRe38HhHzH5Vq5/cEtfNHDdQObgdS+ndgUv7BFFx0ISIx/ym8EyRy/I2h6/9LuNqhuPxlAW6uHP8LmOOThOd4tSZFpRsa2aT8banaGQHba9wOaqduAKPBtDhW7bgerYmycYYBstUO+ZBsxKodkwADeDcNBNH93SabjHsMwJJx+0BjRuZ4PRBzLdXOCBjpuzVTOz0jYm4YUNdR2fQcMKXaoX/ErXZGANVOT2BSNgzgCS66EJGYe4HJB11wRI71A/AbQ2/mjUulG5ri0tsC3Fw53huY432E53i1JkWlGxrZpDQC86aWamc4bK/xddzepgGMBjfB1Y6vm4BF0Cxc7ZAPm+Fqx++AW6UcSbgRRNc4QDYZt1iidpA53mqp2hkOUzu+SjCXRe30jYi5X6Xa6ZugdvrVQO0MB6qdvsCk7DeAJ7joQkRi7i+8EyRybGXo+tuEqx2KS5sFuLlyvA2Y4wOE53i1JkWlGxrZpMxoqdoZBttr8ipu70wDGA2eCa528momYBHMLFztkA9nhqudvJpZuNohoptxgGwynsUStYPM8VktVTvDYGonFyaYy6J2ZouIeWCl2pktQe0MrIHaGQZUO7MBk3LgAJ7gogsRiXl24Z0gkeOsDF3/IOFqh+IyyALcXDk+CJjjg4XneLUmRaUbGtmkDLFU7QzFfUtBh2+gnmMAo8FzwNVOsTwHsAiGClc75MOhcLVTLA8VrnaI6IYMkE3GwyxRO8gcH26p2hmK+yB7zb6BekREzCMr1c6IBLUzsgZqZyhQ7YwAJuXIATzBRRciEvMo4Z0gkeNwhq5/TuFqh+IypwW4uXJ8TmCOzyU8x6s1KSrd0MgmZW5L1c4csL3G6XBvZ54BjAbPA1c7jpoHWASjhasd8uFouNpx1GjhaoeIbu4Bssl4XkvUDjLH57NU7cwBUzu6Zvd25o+IeUyl2pk/Qe2MqYHamQOoduYHJuWYATzBRRciEvMCwjtBIsf5GLr+scLVDsVlrAW4uXJ8LDDHlfAcr9akqHRDI5sUbanaGYLba0pxe50BjAY7cLWjSg6wCDLC1Q75MANXO6qUEa52iOj0ANlk7FqidpA5nrVU7QzBfTVNMcFcFrWTi4g5X6l2cglqJ18DtQPcgXQOmJT5ATzBRRciErMnvBMkcswydP2+cLVDcfEtwM2V4z4wxxcUnuPVmhSVbmhkk7KQpWpnMGyvyXV4km3hAYwGLwxXO7nywsAiGCdc7ZAPx8HVTq48TrjaIaJbaIBsMl7EErWDzPFFLVU7g3Gf26nZk2yLRcS8eKXaWSxB7SxeA7UzGKh2FgMm5eIDeIKLLkQk5iWEd4JEjosydP1LClc7FJclLcDNleNLAnN8KeE5Xq1JUemGRjYpS1uqdgbB9hrd4TvZlhnAaPAycLWj9TLAIlhWuNohHy4LVzu6A26VciThRhDd0gNkk/FylqgdZI4vb6naGYR7kq1m38m2QkTMK1aqnRUS1M6KNVA7g4BqZwVgUq44gCe46EJEYl5JeCdI5Lg8Q9e/snC1Q3FZ2QLcXDm+MjDHVxGe49WaFJVuaGSTsqqlamd24O8Jitu72gBGg1cbgF93deEKhXCvPmCyg0HrsqgKIpRVB8gmvTUsURXIvFyTmegRMVmTIcdrSagDmQh1rQGMBq/FQKhrCydUwr12jQhVpRuaCmPtATwFh8JdyyKbDfi7Q+L2rjOA0eB1GHbEdYCMvq7wgiUfrstQBOsKP6OlIl2XQf6sAYz3esKPCyh31mMi+/aBru31gPFZX7jEr6YYVLqhkYphA+E5TjHegKGRQ+ZhLZuEWWJNgvYyjpPPkE1eoLQblBzPcYKiq0qqUHLKvqv90HXcTCkoFY39BR2qsFDyQ+/fteL2bjiA0eANE4ogrfEbAot/I+FNAvlwo4QiSOvDjcCdclNdbW7IzcL0++PrsP7t0IVvHIsfvJsCBlLHbwzGjZ5Gm0tdSb6Np2N37MzpGwOLeRNggcT9SuvuP525YG706pJWofIdVVD5Ui5f9AOn6BXCTJjNBJnp9WtnyY7066ZMft008mvP2LXKIZmM4uS5WbQjF6gGOQhjY4a2amPhsnN6i0NNA+60NhaFt+SUmEWGI4sSEymUpkK2Kt3QBSZfBEy+CFJsPJ3ZzJUXX4/6r3JKqRP72HLgm1GyeYA2viIDlwLjrZE+pKaCZpLCqZtGH3SWU/E1Ofgb5ZN4g1WemsJR6YYuMhFieSoKp5NldGc/h2wuMxDDt2BiaB89pzFm09LIpMUcDpBJMMhYxPMyjG3U0xufznyOjM/msbV0JmNqI8jrMAgz2bzvFHUuk8uFbpjPeW4QZt1CkC9rt5Bx/HJehdorl/PZTCmfC/2glAvjpK2DTMYN/GJJZ51coai8IFNQoZvPGPEbZPJBkPFyuUImE+S80PONYDUy2FPZfN5XOSfjO1zx2TymNFGbQmcnG/E1bdkUtrBxU9iCeVPYgmFT+E7IplA1ifPhv7/2B0g6WwrdFL5jIp0tAZtCZ8d8yPhsJXRT4IrPVv+Pjh+3jo4ft0k6flTpRtWzf+R9kLRrAY8yWZ4uaPdhvSU+TLvWtsLjQQWzLcPGvh1Tk7Md47HoNky+2J7JF9szHoty5cX3wo9FuXLgBwuORbdlOBYFxlv/0H0sWjn+4W+UT+KN3w6cCnhbJkLcgVEBk807MBDDj5Yci24LbIp2HCCTYH5kUlg71uBYFBmfnYAK+AegAuaKz04J8UE/4IWMz3gm/hwP8ENnJzVIP+zM5Iedu3BMLnkjTzAXlsfxJmEXG5uEXZibhF0YmoSfatQkpHw6FkpyuwLXQjYJPzFtQrt2oUlI+5QtMj67DcBt7MgmgSs+uzGetuQj9Y3++qo87OurPI3Mnd1h3O51iBGtS18JRhv2rnVTDpBf/8Oh6D2vb718G/dANyo9mIoJBZjW2uN/qDj3BBYncyHq/+VC3BNZiLYy5nALArVXd6CUXq+XfBv37g6U0lkLKmqf7kApPdaCQO3bHSilN7KA+vbrDpTSm1gQqP27A6X0ZhYE6oDuQCldtCBQB3YHSunAgkAd1B0opUMLAnVwd6CU3sKCQB3SHSilt7IgUId2B0rpbSwI1GHdgVJ6OwsCdXh3oJQeb8ER0hHdgVJ6Rwsq6sjuQCk9wYKKOqo7UErvbEFFHd0dKKV3tSBQx3QHSundLQjUsd2BUnpPCwJ1XHeglN7bgkAd3x0opR+0oOs7oTtQ5ja3BRV1YnegzN1TCwJ1UnegzE05CwJ1cnegzL0eCwJ1SnegzC0ECwJ1anegzMm0BYE6rTtQ5sDTgkCd3h0oc45mQaDOQAaKPuDbr27yZ8vI2OEVQesBBsD1uTOVangKjZNsywF/Oy2tt9cA2R8P4vBhFuzDvRl8uLdwH7pgH+7D4MN9hPswA/bhvgw+3Fe4Dx2wD/dj8OF+wn2owT7cn8GH+wv3oQL78AAGHx4g3IdjwT48kMGHBwr34QJgHx7E4MODhPtwDNiHBzP48GDhPpwf7MNDGHx4iHAfzgf24aEMPjxUuA//j72vgJPqeLbeQEKIJ8CyBuwQIcS7xyfu7u7JaNzd3d2FBAkhAQKBkATi7u5uxN1dv6ow+7gz9AaZU/dVv2/6/eptp3f/TZ2yrnPvnTtLgm14moANT1NuwyXANjxdwIanK7fhQLANzxCw4RnKbbg42IZnCtjwTOU2HAC24VkCNjxLuQ0XA9vwbAEbnq3chouCbXiOgA3PUW7DRcA2PFfAhucqt+HCYBueJ2DD85TbsD/YhucL2PB85TaMgG14gYANL1Buw3awDS8UsOGFym3YD2zDiwRseJFyG/YF2/BiARterNyGfcA2vETAhpcot2Eb2IaXCtjwUuU2bAXb8DIBG16m3IYtYBte3kP304oSNmwG2/CKHsofJKwamH1jyQbHwOwdtXJ7T40p9tmC5fmVZO9BJFeRXE0ymGQIyVCSYSTXkAwnuZZkBMl1JNeTjCQZ1WPKHqN7lDft+MYJ3jRStTbIsXaVY+1qx9pgx9oQx9pQx9owx9ro8hoPdKIlq75oAfWA5cx+Nd5/aznlCyFq1ZEfeE0b6LdSVTz4WavtbgDpxV/kFIyfGwLx0yARR7ZS91rtMAZYVIN2GCOYRwmBPOIHYtFfWAJ8yNaOAeIdK+TzsSHE/ligHW4UssONgrEfF4j9YwRiH/hwtL0RiHeckM/HScc+2eFKpXbgPWYHY40iv5SK6kYMlDdTPsgzpa85FpyHx6HzkHADH7CveNC8VrzjhfJwfAhn0HigHW4SssNNgmeQFTiDjhc4g4AP9dubgHgnCPl8QgixPwFoh5uF7HCzYOwbgdg/QSD2gR/GsDcD8d4i5PNbQui/Bim1A++B7r+WBfdfywn0XyeC8/Akgf4L+IGeig+21Ir3VqE8vDWEM+hWoB0mCtlhouAZtIzAGXSywBkE/BCRnQjEO0nI55NCiP1JQDvcJmSH2wRjf2mB2D9FIPaBH/6ytwHx3i7k89tD6L+uUmoH3gPdfy0J7r+WEui/TgXn4WkC/RfwA4QVH6SrFe8dQnl4Rwhn0B1AO9wpZIc7Bc+gJQTOoNMFziDghxbtnUC8dwn5/K4QYv8uoB3uFrLD3YKxP1Ag9s8QiH3gh03t3UC89wj5/J4Q+q+rldqB90D3XwPA/dfiAv3XmeA8PEug/wJ+YLnig7u14r1XKA/vDeEMuhdoh/uE7HCf4Bm0mMAZdLbAGQT8kLS9D4j3fiGf3x9C7N8PtMMDQnZ4QDD2FxWI/XMEYh/44Xb7ABDvg0I+fzCE/muwUjvwHuj+a2Fw/7WIQP91LjgPzxPov4AvSKh4UUCteB8SysOHQjiDHgLa4WEhOzwseAb1FziDzhc4g4AvZbAPA/E+IuTzR0KI/UeAdnhUyA6PCsZ+RCD2LxCIfeDLNOyjQLyPCfn8sRD6ryFK7cB7oPuvfuD+q12g/7oQnIcXCfRfwBeyVLyYpFa8jwvl4eMhnEGPA+3whJAdnhA8g/oKnEEXC5xBwJfA2CeAeJ8U8vmTIcT+k0A7PCVkh6cEY7+PQOxfIhD7wJf32KeAeJ8W8vnTIfRfQ5XagfdA91+t4P6rTaD/uhSch5cJ9F/AF0BVvAipVrzPCOXhMyGcQc8A7fCskB2eFTyDWgTOoMsFziDgS6fss0C8zwn5/LkQYv85oB2eF7LD84Kx3ywQ+1cIxD7wZWH2eSDeF4R8/kII/dcwpXYIYp4NjPkaAOZcdspeknoO98Se13qi5whP9LzOEz2v90TPkZ7oOQqoJ3NXfulj8Eu1F2yoHGj9rxSwM1rHQR7oeJUHOl7tgY6DPdBxiAc6DvVAx2FCNR6hYyyZFtlXSt/6vv+39sXtHY0K7m07akKwV3mR8volkpdJXiF5leQ1ktdJ3iB5k+QtkrdJ3iF5l+Q9kskk7/doqHwR9Is9pn059EuOtZcda6841l51rL3mWHvdsfaGY22yY+398ho3dM0NUy8ABAe6mL7ZQ30wWv5/QVt80GPKzw+rnc6/qO580Vem3gTdheG9PgBekfnQE+bji55veaLn257o+Y4ner7riZ7veaInol7mMv921RVXYKuvjtdaP4FXNOyLQr5BYwZeIbEveYIZeMXFvuwJZuAVHPuKJ5iBV4Tsq55gBl5hsq95ghl4xcq+7glm4BUw+0ZImM2sDdsxmQzkSh8J3cUP7gu2Q8ew7wN9/xHqicJiKRPEPBs43j8BYHZdmUXr+SlAz2TWZIrJZEpSz88AeuZyyVS2mE5I6vk5wu/5ZLEUS0Ul9fwCoGc2ES+VErGspJ5fAvRMWFNMRFMlST2/AuiZyZlEMp3OS+r5NUBPW0rHCplsTlLPbxB+zxVNvmAzrFvPhmm/DTL4LZDBb38Mfutj8Nseg9/yGPx2x+C3On4SmM/fddbnwYvt7wfmnwbmnwXmnwfmXwTmXwbmXwXmXwfm35Tn39LP70i+J/mB5EeSn0h+Jvmlx5SL/C0NU69P/5f/TW3Dfqv/Ij+PuNjedkqf1mHbjk97/Ep2+Y3kd5I/qm8m8C+7V6395lj73bH2R3ktOObAGqvCqbUWiF9RjWDJ2N+AN0h+h+w1xV5/gB+5Cit5v6snrzN5/yS7/EXyN8k/1cn7pyMp/3Ks/e1Y+yeE5P0OmLx/ApP3L2Dy/g1M3n88Td7v68nrTF5uIWcj6ULStaOd7EhA/mV1Us7mWOviWOvaUz55vwcmL2Otda+O5J2tJy55u/TEJW/Xnn4m7w/15HUm7+zkzzlIupHMWZ28szuScg7HWjfH2pwhJO8PwOSdHZi8cwCTtxsweef0NHl/rCevM3m7kz/nIpmbZJ7q5O3uSMq5HGtzO9bmCSF5fwQmb3dg8s4FTN65gck7j6fJ+1M9eZ3JOy/5cz6S+UkWqE7eeR1JOZ9jbX7H2gIhJO9PwOSdF5i88wGTd35g8i7gafL+XE9eZ/IuSP5ciKQHSc/q5F3QkZQLOdZ6ONZ6hpC8PwOTd0Fg8i4ETN4ewOTt6Wny/lJPXmfy9iJ/NpL0JmmqTt5ejqRsdKz1dqw1hZC8vwCTtxcweRuBydsbmLxNwOTtCKahDeBApdG9vl99v/p+9f3q+9X3q+9X36++n+b9bEfvP6H7VB5wU2A+PjAfF5jfGJiPDczHBOY3BOajA/NRgfnIwPz6wPy6wHxEYH5tYD48ML8mMB8WmA8NzIcE5oMD86sD86sC80GB+ZWB+RWB+eWB+WWB+aWB+SWB+cWB+UWB+U9zTZ3/GJj/EJh/H5h/F5h/G5h/E5h/HZh/FZh/GZh/EZh/Hph/Fph/Gph/Eph/HJh/FJh/GJh/EJi/H5hPDszfC8zfDczfCczfDszfCszfDMzfCMxfD8xfC8xfDcxfCczT80ydpwLzZGCeCMzjgXksMI8G5jYwN4H5coH5soH5MoH50oH5UoH5koH5EoH5wMB88cB8QGC+WGC+aGC+SGC+cGDePzCPBObtgXm/wLxvYN4nMG8LzFsD85bA/Kh5p86PDMyPCMwPD8wPC8wPDcwPCcwPDswPCswPDMwPCMz3D8z3C8z3Dcz3Ccz3Dsz3Csz3DMz3CMx3D8x3C8xLgXkxMC8E5vnAPBeYZwPzXQPzXQLznQPznQLzHQPzeQLXgYK3UoO3WoO3YhcIzIN3b4J3d4J3f3oG5sELxsELysELzk2BefAaVfAaVvAa1x+BpyaDjz8HH48OPj79T2AefOIy+ERmxRObgX8r+JBX8CGw4ENicwbmwedKgs+ddDyXMr5hymim/24haSVpI+lD0pekH0k7SYSkP8nCJIuQLEqyGMkAksVJBpIsQbIkyVIkS5MsQ7IsyXIkhsSSREliJHGSBEmSJEWSJsmQLE+yAsmKJCuRrEyyCl9/IlmNZHWSNUjWJFmLZG2SdUjWJVmPZH2SDUg2JNmIZGOSTUg2JdmMZHOSLUi2JNmKZGuSbUi2JdmOZHuSHUh2JNmJZGeSXUh2JcmS5EjyJAWSIkmJZDeS3Un2INmTZC+SvUn2IdmXZD+S/UkOIDmQ5CCSg0kOITmU5DCSw0mOIDmS5CiSo0mOITmW5DiS40lOIDmR5CSSk0lOITmV5DSS00nOIDmT5CySs0nOITmX5DyS80kuILmQ5CKSi0kuIbmU5DKSy0muILmSZBDJVSRXkwwmGUIylGQYyTUkw0muJRlBch3J9SQjSUaRjCa5gWQMyViSG0nGkYwnuYlkAsnNJLeQ3EoykWQSyW0kt5PcQXInyV0kd5PcQ3IvyX0k95M8QPIgyUMkD5M8QvJoz3IONFS+JGrV8k9T4+gO3S9n6nXvf7/udbwX6zH678dJniB5kuQpkqdJniF5luQ5kudJXiB5keQlkpdJXiF5teeUGyILBWJutsDP5vL8Nfq710neIHmT5C2St0neIXmX5D2SySTvk3xA8iHJRyQfk3xC8inJZySfk3xB8iXJVyRfk3zTs8NY5Z+vBcD+z1vYHGtvONbedKy95Vh727H2jmPtXcfae461yY619x1rHzjWPnSsfeRY+9ix9olj7VPH2meOtc8da1841r50rH3lWPvasfZNeY2DrEeDO8jay/Nv6W+/I/me5AeSH0l+IvmZ5BeSX0l+I/md5A+SP0n+Ivmb5B8Ool60H0kXkq4ks5PMQdKNZE6S7iRzkcxNMg/JvCTzkczfq0rpbx1AvnOsfe9Y+8Gx9qNj7SfH2s+OtV8ca7861n5zrP3uWPvDsfanY+0vx9rfjrV/HGvsiOq12RxrXRxrXR1rszvW5nCsdXOszelY6+5Ym8uxNrdjbR7H2ryOtfkca/P3mvFkWID+dkGShUh6kPQk6UXSSNKbpImkmaSFpJWkjaQPSV+SfiTtJBGS/iQLkyxCsijJYiQDSBYnGUiyBMmSJEuRLE2yTHUyLOAAsqBjbSHHWg/HWk/HWi/HWqNjrbdjrcmx1uxYa3GstTrW2hxrfRxrfR1r/Rxr7Y61iGOtv2NtYcfaIo61RR1riznWBjjWFnesDXSsLeFYW9KxtpRjbWnH2jIzkQzL0t8uR2JILEmUJEYSJ0mQJElSJGmSDMnyJCuQrEiyEsnKJKuQrEqyGsnqJGuQrEmyFsnaJOuQrEuyHsn6JBuQbFidDMs6gCznWDOONetYizrWYo61uGMt4VhLOtZSjrW0Yy3jWFvesbaCY21Fx9pKjrWVHWurONZWdayt5lhb3bG2hmNtTcfaWo61tR1r6zjW1nWsredYW9+xtoFjbcOZSIaN6G83JtmEZFOSzUg2J9mCZEuSrUi2JtmGZFuS7Ui2J9mBZEeSnUh2JtmFZFeSLEmOJE9SICmSlEh2I9mdZA+SPUn2qk6GjRxANnasbeJY29SxtpljbXPH2haOtS0da1s51rZ2rG3jWNvWsbadY217x9oOjrUdHWs7OdZ2dqzt4ljb1bGWdazlHGt5x1rBsVZ0rJUca7s51nZ3rO3hWNvTsbbXTCTD3vS3+5DsS7Ifyf4kB5AcSHIQycEkh5AcSnIYyeEkR5AcSXIUydEkx5AcS3IcyfEkJ5CcSHISyckkp5CcSnIayekkZ5CcWZ0MezuA7ONY29extp9jbX/H2gGOtQMdawc51g52rB3iWDvUsXaYY+1wx9oRjrUjHWtHOdaOdqwd41g71rF2nGPteMfaCY61Ex1rJznWTnasneJYO9Wxdppj7XTH2hmOtTNnIhnOor89m+QcknNJziM5n+QCkgtJLiK5mOQSkktJLiO5nOQKkitJBpFcRXI1yWCSISRDSYaRXEMynORakhEk15FcTzKSZFR1MpzlAHK2Y+0cx9q5jrXzHGvnO9YucKxd6Fi7yLF2sWPtEsfapY61yxxrlzvWrnCsXelYG+RYu8qxdrVjbbBjbYhjbahjbZhj7RrH2nDH2rWOtRGOtesca9c71kY61kbNRDKMpr+9gWQMyViSG0nGkYwnuYlkAsnNJLeQ3EoykWQSyW0kt5PcQXInyV0kd5PcQ3IvyX0k95M8QPIgyUMkD5M8QvIoyWPVyTDaAeQGx9oYx9pYx9qNjrVxjrXxjrWbHGsTHGs3O9Zucazd6lib6Fib5Fi7zbF2u2PtDsfanY61uxxrdzvW7nGs3etYu8+xdr9j7QHH2oOOtYccaw871h5xrD3qWHtsJpLhcfrbJ0ieJHmK5GmSZ0ieJXmO5HmSF0heJHmJ5GWSV0heJXmN5HWSN0jeJHmL5G2Sd0jeJXmPZDLJ+yQfkHxI8hHJxySfVCfD4w4gTzjWnnSsPeVYe9qx9oxj7VnH2nOOtecday841l50rL3kWHvZsfaKY+1Vx9prjrXXHWtvONbedKy95Vh727H2jmPtXcfae461yY619x1rHzjWPnSsfeRY+9ix9slMJMOn9LefkXxO8gXJlyRfkXxN8g3JtyTfkXxP8gPJjyQ/kfxM8gvJryS/kfxO8gfJnyR/kfxN8g8HfCP9eyRdSLqSzE4yB0m3xiqlP3UA+cyx9rlj7QvH2peOta8ca1871r5xrH3rWPvOsfa9Y+0Hx9qPjrWfHGs/O9Z+caz96lj7zbH2u2PtD8fan461vxxrfzvW/nGscSBUr83mWOviWOvqWJvdsTaHY61b49Rk4PtiwScKOkZHYqxa/mlqGxa4l+i3lyD1nC2g55yNZYP3qhs8FD3his4/J12J6T7tvrV+vnL7xWQMMDsWf+yfbjjM3RtxfjlyUdxeQF/YYMVlvJHyvEfAN/zfjfRHf5fnAxumzucPrC9Qnnf87+ai/eYmmYdk3sYp6yxNDVPjUzIX5mqUqZLzNQoq/D+bN+AC2eXQnbtNdRz/uzPi0Pnp7xYgWZBkoYBD52sIx6HzCzm0R3VPywuzlcHN7yG4ah3hx0GPRuzZitaPSxnr2BXspOCRgLRhrXv1bJQ5EnqWjwSJgP+ZKtDv3fC+7wWuEtWVs38nR2GvQBVduKpyNtLvepM0kTQ3Bl44Wx7oOP2+G26vRmCctggUOQn7AVsH2xtov1bh2G4JxHBrYN4UmDc3VsZ2G/13H5K+JP0CXQExkf95ZUxwaG7zHOrC66qkLQY2yDURKB17NerXEVg/Ra9LtDX6oSeSSlfrWG9uBZxU2zu0SiVkc9uO80c02Ny2l5vb2cv/7ds1iW4BPSPlywb9yz8XLv9cpPxz0fLPxRr/I3FMbcP2AHcnHY7qH7gw1bG2aPn2AI8uVTgg10sasXZZxHFdx9Q4psdOIoGurf9/sJMB9LvFSQaSLBECO1kYaNsBwEKz5P+H7GRxoP2WEmYnSwZieKnAfGBgvkQVO1ma/nsZkmVJlvtfuAi9KO5QLQb1NY2CCvPmqKLaobwBBq0FBq2UDW0jrvPrsKEVTrDlAofHIoGkWjowN1WHR5R+FyOJkyQaK/dD2rQH2KYd/k+Ci75ELCUFYikpHEuJQCwtFoif6H/EUop+lybJkCz/H7GEYHi2Ef8t6EjWs4LyuOxgoZptuKIQIVkxwBz57RIdNpCwMz/RcWB3+L4VT0qYWRxlsi9x2dR2TIK2Xanc9KxcfcN2pcapFL5jbeVGuXtXHU4Bd/aIx1ei5eC3KwETaeVGbLBIFPSVBBi2VOzs3x1fOOfvjrPnKsoPH7bhAQI2XABow1WBNuQ6c2nD1Hq2Ei30InmTbrCNop//+qtxytM7YUjHAPs12lFXwX5NIh8LXE15bnAtXE2AKK0OxN2lHM/VA2lXCduu3qhfxzXQOqKLLF9NALIby0w2JRDwa4INib5NwYkOdPa/hWNNAUa3BrARXcufImSlEtyHIrQWWsf/HzuNtYUfRDC1jX8LxtoChXedeqdh1/EgyddVnuT/c40SHaA58KehJC6HrCvwhNC6wJN8PWBxQ/rD167Ah4KxnvaCIdQVQD+WuL4HXcH6AkV3A6GbORuU7xP42inw9TjtOm6ITHxfHdXfA0dtVHeUsdt206/jxnVHGZvwIKM2qTvK2OU8cNSmdUcZu6MHpW+zuqOM3dkDR21ed5Sxu3rgqC3qjqKLSB44asu6o4wteOCoreqOMrbkgaO2rjvK2N09cNQ2dUcZu6cHjtq27ihj9/bAUdvVHWXsvh44avu6o4w9yINLSDvUHWXsAR5k1I51Rxk72oOM2qnuKGMP9iCjdq47ythDPXDULnVHGXu4B47ate4oY4/0wFHZuqOMPdoDR+XqjjL2QQ+6vnzdUcYe50FGFeqOMvYEDxxVrDvK2JM8cFSp7ihjT/HAUbvVHWXsaR44ave6o4w9wwNH7VF3lLFneeCoPeuOMvYcDxy1F9JRnr41txTUd2/Jt+bujX9rbmlv4If99gF+elfKhvvg33Ra2ud/6a25azZ2/qbTfel3+5HsT3KA8FtzkTbt8P+BHrw190CBWDpQOJY6e2vuvv8RSwfR7w4mOYTkUOG35u6j/I2vhwH9w3bs0hDOgRcB6j1fQM/DywfeEeWfR5Z/HlX+eXT55zHln8eWfx5X/nl8+ecJ5Z8nln+eVP55ciDHRIoXaK+KT3wf2Tjt22KPcawd71g7KbBWnbxbBJL38EDCHhGYb1mVvKfQ704lOY3k9Eb57944EthQnAJM3DPAB4qU/Y4C2u9UoP3O9MR+RwPtdxrQfmcJH+xnBGrAmYH5WYH56Y2VteFs+u9zSM4lOS+E2nAM0DdnA31zviexfSzQfucA7XeBJ/Y7Dmi/c4H2u1C4NpwfqAEXBOYXBubnVdWGi+i/Lya5hOTSEGrD8UDfXAT0zWWexPYJQPtdDLTf5Z7Y70Sg/S4B2u8K4dpwWaAGXB6YXxGYX1pVG66k/x5EchXJ1SHUhpOAvrkS6JvBwr4ZHPDBoMD8qsD86irfDKH/HkoyjOSaxqlfPlq990EBLjkksN/J/3EhaDj97lqSESTXNU79rrsO7lo90Hx9ONDeXQJ6Xl++2DDSl4sNUvpdL3Ald5TQRRbe93hBX40UsMVoIVuM/g9bIK7KSsRF8X/3Hbf56egnFgOlxfTXgeECV+GB/rZIG3YcYsEDoXrM6L81vZgK7on22/Xg2tIxbvDxCnxQ6ZnU2U7v32GdbxAoDLuBC0PHmH0mfTYjBwIK85hGnQUG6YtgXI4JHNSz6p/p2Rzpn7GBvWwsRrlRSNlSoRRLpDLRnE3GkslSvJRKpuOFUiKeLaSKNp6NRTPFlCnZdLGYSsTyqWQpU8gnS8GibQuxWLyQyeVtIprM5ky6EMuaUjwVi5psIZYqFGLpZDIbixWS6VI6k45Gs6VY2iRSqYxJRmOZqJR/xjr8g3rkRiJ/bgTmD+Pv3jCVvc9MTE5v77//e79ovmRjCYoWk8zGE4VkLFqIpkwhnihZMkQ0EyczlPLxdCEdjZWiqWi+g6HeWK7DHT7i+fUBBjuyPB9HP8eT3NRY6duuYN8i796NA8bJhEZswxTWc3oThJqamxsFFb65Eb/vLcBgkMJ9SyC5QPv+5yXfWu2AvFU8HuifWz1N1luFknVio6DCEwWSdZLyZGXck0JOVlPbqDgNTW0DWkxvAwf9XGV/3xboYsYH5h0dD8tRgfWjHX9zO/28g+TORpn86VHuqNCXim4E+ucuIf+M68Q/dwX8M72/uZt+3kNyr5B/binnOfpKxX0e3Mq4TwD3/cK4EczyvkbdD1A/ALYhGivXTKCOlnP8foFYfNCDHLxJAPdDHuSgBO6HgTEpkTeMGxiT//YAtwvY8REP8uYYAdyPepA3ErgfU5433MMDa5rlOvGIgB0fV35uc68NjHHLcfO4gB2fUG5HzsNIIzavnxC41uB6pq2zz0Qd2dj5M21P0u+eInma5JlGuQ/KXjBnQ8O8+G9+taPmxPnqWQ/OxmcFcvI55bgv6iR2asX9PLBeHrCobhteLGTDF4A2PEi5DS8RsuGLQBseotyGlwrZ8CWgDQ9TbkOu188LnAMvKz8HGPcLArhf8QD3iwK4XwXfG6juR18O9J2vBOav/kc/+hr97nWSN0jebJz+Z2tqtcGTwLrxGpA3vOXpTfC3wDHVMd5uFFT4bYGb4O8ovwnOuN8RIKYcbHM0uJ8nR2N4Ely4qwfSJh3j3bLN3yv/nFz++T7HILrCs4N7NMowUZRxgs+fTm5s6PTtL+8GTo33AvPJ/3GafEC/+5DkI5KPG2Vf3fSO8juPnwhfeUOcxEAd7Qfl/RqwPvk3mZsbKgsc2u//dGtoOKg7br/555yyH8oW5be1SRTN//n8SdC+n5b9+Bn/DBaMTwMFo2ON/yhS/h+iC1+HY9AF5HDln4rrCCA07iNC+tDPLOoZ7fjk2qfAQvwZsMgB48YifBEsDOhY4WL+qUBB5z0kbkssCCzgY8qXzdA2/Vz57Ti240JAO44VsuMXHtixB9CONwrZ8UsP7NgTaMdxQnb8ygM79gLacbyQHb/2wI6NQDveJGTHbzywY2+gHScI2fFbD+zYBLTjzUJ2/M4DOzYD7XiLkB2/98COLUA73ipkxx88sGMr0I4Thez4owd2bAPacZKQHX/ywI59gHa8TciOP3tgx75AO94uZMdfPLBjP6Ad7xCy468e2LEdaMc7hez4mwd2jADteJeQHX/3wI79gXa8W8iOf3hgx4WBdrxHyI5/emDHRYB2vFfIjn95YMdFgXa8T8iOf3tgx8WAdrxfyI7/eGDHAUA7PiBkx4be+u24ONCODwrZcTYP7DgQaMeHhOzYxQM7LgG048NCduzqgR2XBNrxESE7zu6BHZcC2vFRITvO4YEdlwba8TEhO3bzwI7LAO34uJAd5/TAjssC7fiEkB27e2DH5YB2fFLIjnN5YEcDtONTQnac2wM7WqAdnxay4zwe2DEKtOMzQnac1wM7xoB2fFbIjvN5YMc40I7PCdlxfg/smADa8XkhOy7ggR2TQDu+IGTHBT2wYwpoxxeF7LiQB3ZMA+34kpAde3hgxwzQji8L2bGnB3ZcHmjHV4Ts2MsDO64AtOOrQnZs9MCOKwLt+JqQHXt7YMeVgHZ8XciOTR7YcWWgHd8QsmOzB3ZcBWjHN4Xs2OKBHVcF2vEtITu2emDH1YB2fFvIjm0e2HF1oB3fEbJjHw/suAbQju8K2bGvB3ZcE2jH94Ts2M8DO64FtONkITu2e2DHtYF2fF/IjhEP7LgO0I4fCNmxvwd2XBdoxw+F7LiwB3ZcD2jHj4TsuIgHdlwfaMePhey4qAd23ABox0+E7LiYB3bcEGjHT4XsOMADO24EtONnQnZc3AM7bgy04+dCdhzogR03AdrxCyE7LuGBHTcF2vFLITsu6YEdNwPa8SshOy7lgR03B9rxayE7Lu2BHbcA2vEbITsu44EdtwTa8VshOy7rgR23AtrxOyE7LueBHbcG2vF7ITsaD+y4DdCOPwjZ0Xpgx22BdvxRyI5RD+y4HdCOPwnZMeaBHbcH2vFnITvGPbDjDkA7/iJkx4QHdtwRaMdfheyY9MCOOwHt+JuQHVMe2HFnoB1/F7Jj2gM77gK04x9CdswA7cjfWzWCZNPyfvydLPx9IvxdGPw9DvwdBPz+fH73O7+3nN+5ze+L5ncd83t6+R2z/H5Ufrcnv5eS36nI7wPkd9nxe9j4HWL8/it+dxO/d4jfmcPve+F3lfB7NvgdEfx+A/5sPn+unD8TzZ/n5c+i8uco+TOA/Pk1/uwVf26IP/PCn9fgzxrwc/L8jDc/n8zP1vJzofxMIz+Px8+S8XNQ/AwPP3/Cz07wfX++Z833W/leId/n4ns0fH+Br43zdV2+JsnX0/haEF/HYA7O/JG5D/ft3HNyv8RnPZ9TXGO5PnBss1+qB/orY5fH+T4B/P6mxBHKv0OMv7+JbYfOxRWAudilnIvVA2lXCdsibSCl44poHdGHz7tV30CJ+MIyBo3WM2jIWnVcyZ/ksVKB6UPyrCSg478DfTqu/H//dLQSDuZisbLA6bhK/XS0q3iQ4KtqPx3fEzgdVxU4HVcFno6r1U9HL5JnNV9Ox9X/75+OUQkHc7FYXeB0XKN+Oto1PEjwNbWfjpMFTsc1BU7HNYGn41r109GL5FnLl9Nx7f/7p2NMwsFcLNYWOB3XqZ+Odh0PEnxdtI5oBd8vn47wj+MOkL3lgTjF2TldBR1eq47r4YLHIv3ha0fgQ8FYz5eOYP3/+x1BXMLBXHjWF+gINqh3BHYDDxJ8Q+mOAHEybgg/GWPmk0YZI9aKd6M6V/YicTby5WTcGNi2AU9G68N91o0FTsZNgIEzWzle+CfvG2moHF3AuiMvXG7aW7X/oz0IKwuaknUH2LBY+ncUewD9sRnOHyJ3dhjrhgKXBhZRfmlgpa4yccj7onTcHJjL0v4wtY1/43AjgThcTHkc9hKKw17AONwCGIeLeRCHGwvE4eLK4/DNOWTikPdF6bglMA4X9yAONxGIwyWUx+EooXo4ClgPtwLG4RIexOGmAnG4lPI4ZNyrCMThKkBusTUwDpfyIA43E4jDZTyIw1UF4nBVYBxuA4zDZTyIw80F4nDb3vpxbyGAezsPcG8pgHt7D3BvJYB7Bw9wby2Ae0cPcG8jgHsnD3BvK4B7Zw9wbyeAexcPcG8vgHtXD3DvIIA76wHuHQVw5zzAvZMA7rwHuHcWwF3wAPcuAriLHuDeVQB3yQPcWQHcu3mAOyeAe3cPcOcFcO/hAe6CAO49PcBdFMC9lwe4SwK49/YA924CuPfxAPfuArj39QD3HgK49/MA954CuPf3APdeArgPqH8ixM7fVb+OByLj01dH9ffAUQfVHWXstt3063hw3VHGJjzIqEPqjjJ2OQ8cdWjdUcbu6EHpO6zuKGN39sBRh9cdZeyuHjjqiLqjjM154Kgj644ytuCBo46qO8rYkgeOOrruKGN398BRx9QdZeyeHjjq2LqjjN3bA0cdV3eUsft64Kjj646iK9MeXEI6oe4oYw/wIKNOrDvK2NEeZNRJdUfRvR4PMurkuqPoFoIHjjql7ii6Mu2Bo06tO4oueHrgqNPqjqLraB446vS6o4x90IOu74y6o+jyjAcZdWbdUcT6PXDUWXVHEZn0wFFn1x1FHMUDR51TdxS1vh446ty6o6ij8sBR59UdRQe1B446v+4oqv8eOOqCuqOorHjgqAvrjqJo9cBRF9UdRUbwwFEX1x1lbKMH1/ouqTvK2Nvm0K/jpXVHGXuZB6XvsrqjjL3CA0ddXneUsYM8cNQVdUcZe7UHjrqy7ihjh3jgqEF1Rxk7zANHXVV3lLHDPXDU1XVHGTufB4R3cN1Rxl7nQUYNqTvK2JEeOGpo3VHGjvbAUcPqjjJ2jAeOuqbuKGNv9MBRw+uOMna8B466tu4oYyd44KgRdUcZu4UHPOq6uqOoo/LAUdfXHWXsRA9K38i6o+hWvAeOGlV3lLF3eOCo0XVHGXuXB466oe4oY+/xwFFj6o4y9j4PHDW27ihjH/DAUTfWHWXsQx44alzdUcY+4oGjxtcdZexjHjjqprqjjH3CA0dNqDvK2Kc8cNTNdUcZ+4wHjrql7ihjn/PAUbfWHWXsCx44amLdUca+5IGjJtUdZewrHjjqtrqjjH3NA0fdXneUsW944Kg76o4y9i0PHHVn3VHGvuOBo+6qO8rY9zxw1N11Rxn7vgeOuqfuKGM/9MBR99YdZezHHjjqvrqjjP3UA0fd3xusY7WCMZOMx4upaNHGbNZEM7l0wsQTuWTapm0inShE07FYMR1PpzK5TMpkbDxWtKVEJlYqb9qjsaGhjaQLGDjvidLxAbAR0TbsTljZjl3BNuzeiPUzaq8Hcf6wEv6Yv+wPdEzPD7ThQ57ENNqGyJh+WNiGprZh2X7vNOJ984hy3M8R5pcEcD8Kxo2O7TUJ82GNuP0OpL0OErDjY8rjh+Obfd0FjPtx4LkVGYCzIduvB8ns5f34v/ljYH+X5+yvjvnjgbkp/03H/+4J+t2TJE+RPN27cj+kf4TOhiiyR3mmN9Y/Xct25H0jZZt3a5ja8wUH/Hku5fm6QuOUGG3A7mskbdodWKerdRRpJEB7GQ7cOUnmaJAP3LkaZYIBHGi2I8ElbTGwAW8LtI69GvXr+H03PwpMW+P/d4UwWq2j6kIoZUyBziiG7IyeFeqMni13Rjwkrhp8AjyxNyVdN+uN1/MToJ+eU852NxTwyea98Wz3eeV23EjAjlsI2PEF5XbcWMCOWwrY8UXldtxEwI5bCdjxJeV23FTAjlsL2PFl5XbcTMCO2wjY8RXldtxcwI7bCtjxVeV23ELAjtsJ2PE15XbcUsCO2wvY8XXldtxKwI47CNjxDeV23FrAjjsK2PFN5XbcRsCOOwnY8S3ldtxWwI47C9jxbeV23E7AjrsI2PEd5XbcXsCOuwrY8V3ldtxBwI5ZATu+p9yOOwrYMSdgx8nK7biTgB3zAnZ8X7kddxawY0HAjh8ot+MuAnYsCtjxQ+V23FXAjiUBO36k3I5ZATvuJmDHj5XbMSdgx90F7PiJcjvmBey4h4AdP1Vux4KAHfcUsONnyu1YFLDjXgJ2/Fy5HUsCdtxbwI5fKLfjbgJ23EfAjl8qt+PuAnbcV8COXym34x4CdtxPwI5fK7fjngJ23F/Ajt8ot+NeAnY8QMCO3yr/1AvjfkgA93ce4H5YAPf3nnzKCY37Bw/8/YAA7h89wP2gAO6fwLg7xhxg/CO71o65WJoypN4+UetePwP3yi2G8yt/SK8pENPBgY7zn8GfB+kYv/QWVPiX3vh9fwUGgxTuX3tPNTBoX9Ei8m23//tF5Ld6EbG/CRWR33sLKvy7QBH5Q3kRYdx/CBURtK7zz9nQcHh3fAd2yACZ4jknFn/0n/8PiuefuMJhj1xUZSG2yHgLs6j/KVTU/+otqPBfAkX9b+VFnXH/HVJRrxX/r+UDCP2yxF976zzE/1F+meNGOhj4kkQXsJ+RhwRXPJQNwyygSL2D+s7WJKgwb47et0uT7gLKuLs0TTUwaF+RAsqF/h+BAvo3sID+A0z+rk26/dHZ23//r3bss3tajGcXKsZzNAkqPIdAMe6mvBgz7m6eFGM+NLhAoYtxF1yw2q5Af8+pvBhz3Mwp4I9uQH/MCfRHdw/80V25P7oD/TGXB/6YS7k/5gL6Y24P/DG3cn/MDfTHPB74Yx7l/pgH6I95PfDHvMr9MS/QH/N54I/5lPtjPqA/5vfAH/Mr98f8QH8s4IE/FlDujwWA/ljQA38sqNwfCwL9sZAH/lhIuT8WAvqjhwf+YB27KPZHD6A/+IJzS0M4X9vix7dfROX2tlMvlPPPSHnek/zZi6SRpDdJE0kzSQtJK0kbSR+SviT9SNpJIiT9SRYmWYRkUZLFSAaQLE4ykGQJkiVJliJZmmQZkmVJliMxJJYk2nG3oeOt9axM96q1Xo61Rsdab8dak2Ot2bHW4lhrday1Odb6ONb6Otb6OdbaHWsRx1p/x9rCjrVFHGuLOtYWc6wNcKwt7lgb6FhbwrG2pGNtKcfa0o61ZRxryzrWlnOsGceadaxFy2vB0b/8c9XyT1PbqCg6tRbLnoDCO+VuprG9QHsxxkbIXlPs1bv2vaJle9mmWveK/4/tbXNte5mAH21LLXtFK2LCts76XqYqvmzbLO6VLE0Tq7bPrO2VdsS97Tsre6WdOWT7zfxeqU7y0bbP7F6pTnPbRmZur+h/1Anbf2b2Sv1nzbELz/he+enUL7vIjO6Vmm4ttIvO2F5mBuqqXWxG9jIzVKPtgOnvlZjBem8Xn95e8Rk+O+zA/9wrXpqJc8gu8V97pWbqTLNLdr5XeibPR7tUJ3tlSjN91tql3XuZWTi37TKuvcws9QB22Wn3srPYT9jlqvcqzHJvYk3lXrEa+hxrA3tFSzX1TDYKJPxhPh0VhfV6BRvUN9YkqHCsCffccofyMZwDbRxgVMknrdiGrCPqqlKHDePgJGhumOrnsJLA1DQKoldVgrZIlBMsWX1lI1F2bHAt6WCg6EuxuEpibAKYQEmwc9HBx0mTACZjB+6EpyeShcVRphDUN9UkqHAKfiJlCingiZRWfiKxDdPwEylTSHt6IlmY3pm8Q12REylTTrDlq0+kjONEWj6EE8kCT6QMMIGWF3IuqgB16InEvAKwmDU04E/LeLkAoW+IIqnAisBi5rKhqW1Y9vGKAp3Mip52MgZWf3KxoL4rNQkqvBK8k8nFVgIm/8rKOxm24crwTiYXW1k4+REFdEXlBXQVsA07BvrgRcb4qsDcC7MDNjC9c1GHuiId8Grlwrx6dQe8mqMDXj2EDhh3Ahm7GjAoVxdyLjoRkZjXEO6ATW3D/lscBbq3NZV3reyXNT3ALRXjawJjfC3lMd5Zk4JoflB7rQ0+sMNiO8vBzpp0KajvOk2CCq8DZzvp0jpAB66rnO2wDdeFs510aV3lbIcL3dpNuovxeuBi3DHQmJExvr6nbGc5mN7pokNdEbazQbkwb1jNdjZwsJ0NQ2A7uBPI2A2AQbmhkHPRiYjEvJHyTpCL4/oCXf/GytkO+2VjD3BLxfjGwBjfRHmMd9akmNqGRTYpm3p6b2dZ2FkTrXir3GZNggpvBmc7UbMZMAk2V8522Iabw9lO1GyunO1wodu0SXcx3sITtoOM8S09ZTvLwvS2JYe6Imxnq3Jh3rqa7WzlYDtbh8B2cCeQsVsBg3JrIeeiExGJeRvlnSAXxy0Fuv5tlbMd9su2HuCWivFtgTG+nfIY76xJMbUNi2xStveU7SwDO2sKFWxnhyZBhXeAs52C2QGYBDsqZztswx3hbKdgdlTOdrjQbd+kuxjv5AnbQcb4zp6ynWVgeudDYzu7lAvzrtVsZxcH29k1BLaDO4GM3QUYlLsKORediEjMWeWdIBfHnQW6/pxytsN+yXmAWyrGc8AYzyuP8c6aFFPbsMgmpeAp21kadtYkK96JUWwSVLgIZztJWwQmQUk522EbluBsJ1mB29Q4XLgRha7QpLsY7+YJ20HG+O6esp2lYXonQ3uXyh7lwrxnNdvZw8F29gyB7eBOIGP3AAblnkLORSciEvNeyjtBLo67C3T9eytnO+yXvT3ALRXjewNjfB/lMd5Zk2JqGxbZpOzrKdtZCndvJx3Ud78mQYX3w9/bSe8HTIL9lbMdtuH++Hs76f2Vsx0udPs26S7GB3jCdpAxfqCnbGcpmN6FlENdEbZzULkwH1zNdg5ysJ2DQ2A7uBPI2IOAQXmwkHPRiYjEfIjyTpCL44ECXf+hytkO++VQD3BLxfihwBg/THmMd9akmNqGRTYph3vKdpaEnTXxTFDfI5oEFT4CznbimSOASXCkcrbDNjwSznbimSOVsx0udIc36S7GR3nCdpAxfrSnbGdJmN7xtENdEbZzTLkwH1vNdo5xsJ1jQ2A7uBPI2GOAQXmskHPRiYjEfJzyTpCL49ECXf/xytkO++V4D3BLxfjxwBg/QXmMd9akmNqGRTYpJ3rKdpaAnTW5iifZTmoSVPgkONvJ2ZOASXCycrbDNjwZznZyFbhNjcOFG1HoTmzSXYxP8YTtIGP8VE/ZzhIwvXOhPcl2Wrkwn17Ndk5zsJ3TQ2A7uBPI2NOAQXm6kHPRiYjEfIbyTpCL46kCXf+ZytkO++VMD3BLxfiZwBg/S3mMd9akmNqGRTYpZ3vKdgbi2E4+qO85TYIKn4NnO/lzgElwrnK2wzY8F8928ucqZztc6M5u0l2Mz/OE7SBj/HxP2c5AXEOcc6grwnYuKBfmC6vZzgUOtnNhCGwHdwIZewEwKC8Uci46EZGYL1LeCXJxPF+g679YOdthv1zsAW6pGL8YGOOXKI/xzpoUU9uwyCblUk/ZzuK4J9lyQX0vaxJU+DL8k2y5y4BJcLlytsM2vBz/JFvucuVshwvdpU26i/EVnrAdZIxf6SnbWRz3sFPWoa4I2xlULsxXVbOdQQ62c1UIbAd3Ahk7CBiUVwk5F52ISMxXK+8EuTheKdD1D1bOdtgvgz3ALRXjg4ExPkR5jHfWpJjahkU2KUM9ZTsDYGdNuuIN1MOaBBUeBmc7aTMMmATXKGc7bMNr4Gwnba5Rzna40A1t0l2Mh3vCdpAxfq2nbGcATO9UaG+gHlEuzNdVs50RDrZzXQhsB3cCGTsCGJTXCTkXnYhIzNcr7wS5OF4r0PWPVM522C8jPcAtFeMjgTE+SnmMd9akmNqGRTYpoz1lO4sJsZ0bmgQVvkGA7dwATIIxytkO23CMANsZo5ztcKEb3aS7GI/1hO0gY/xGT9nOYh6ynXHlwjy+mu2Mc7Cd8SGwHdwJZOw4YFCO94TtIDHfpLwT5OJ4o0DXP0E522G/TPAAt1SMTwDG+M3KY7yzJsXUNiyySbnFU7azKOysyVa8k+3WJkGFb4WznWzmVmASTFTOdtiGE+FsJ5uZqJztcKG7pUl3MZ7kCdtBxvhtnrKdRWF6Z0N7J9vt5cJ8RzXbud3Bdu4Ige3gTiBjbwcG5R1CzkUnIhLznco7QS6Otwl0/XcpZzvsl7s8wC0V43cBY/xu5THeWZNiahsW2aTc4ynbWQTHduJBfe9tElT4Xjzbid8LTIL7lLMdtuF9eLYTv0852+FCd0+T7mJ8vydsBxnjD3jKdhbBNcQxh7oibOfBcmF+qJrtPOhgOw+FwHZwJ5CxDwKD8iEh56ITEYn5YeWdIBfHBwS6/keUsx32yyMe4JaK8UeAMf6o8hjvrEkxtQ2LbFIe85TtLAw7awoV93YebxJU+HE42ylkHgcmwRPK2Q7b8Ak42ylknlDOdrjQPdakuxg/6QnbQcb4U56ynYVhehdCu7fzdLkwP1PNdp52sJ1nQmA7uBPI2KeBQfmMkHPRiYjE/KzyTpCL41MCXf9zytkO++U5D3BLxfhzwBh/XnmMd9akmNqGRTYpL3jKdvrDzpp8Majvi02CCr8IZzv54ovAJHhJOdthG74EZzv54kvK2Q4XuheadBfjlz1hO8gYf8VTttMfpne+4FBXhO28Wi7Mr1WznVcdbOe1ENgO7gQy9lVgUL4m5Fx0IiIxv668E+Ti+IpA1/+GcrbDfnnDA9xSMf4GMMbfVB7jnTUpprZhkU3KW56ynQjsrLEV93bebhJU+G0427GZt4FJ8I5ytsM2fAfOdmzmHeVshwvdW026i/G7nrAdZIy/5ynbicD0tqHd25lcLszvV7OdyQ62834IbAd3Ahk7GRiU7ws5F52ISMwfKO8EuTi+J9D1f6ic7bBfPvQAt1SMfwiM8Y+Ux3hnTYqpbVhkk/Kxp2ynHXbW5CrYzidNggp/Amc7ucwnwCT4VDnbYRt+Cmc7ucynytkOF7qPm3QX4888YTvIGP/cU7bTDtM7Fxrb+aJcmL+sZjtfONjOlyGwHdwJZOwXwKD8Usi56EREYv5KeSfIxfFzga7/a+Vsh/3ytQe4pWL8a2CMf6M8xjtrUkxtwyKblG89ZTv9YGdNOh3U97smQYW/g7OddPo7YBJ8r5ztsA2/h7OddPp75WyHC923TbqL8Q+esB1kjP/oKdvpB9M7nXKoK8J2fioX5p+r2c5PDrbzcwhsB3cCGfsTMCh/FnIuOhGRmH9R3glycfxRoOv/VTnbYb/86gFuqRj/FRjjvymP8c6aFFPbsMgm5XdP2U5f2FkTr2A7fzQJKvwHnO3E038Ak+BP5WyHbfgnnO3E038qZztc6H5v0l2M//KE7SBj/G9P2U5fmN7x0NjOPx2Fubmhktn842A7/EfSbAd3Ahn7D7LwNss4F52ISMyzNWOLDzrhuDj+LdD1d2mWPbhMbcOyX1hH7bilYjyoZ617dVUe4501Kaa2YZFNyuzAuAmT7fSBnTUZG9R3jmZBhXlzLNvJ2DmASdANmJxSNuzWjGY7mQrcpsbhwo0odLM36y7Gc4KLccdAY0bGeHcg5jDZTh8Y28kYh7oibGeucmGeu5rtzNU8LduZOwS20wfIduYCBuXczTLORSciEvM8yjtBLo7dBbr+eZWzHfbLvB7glorxeYExPp/yGO+sSTG1DYtsUub3lO20wc6alAnqu0CzoMILwNlOyiwATIIFlbMdtuGCcLaTMgsqZztc6OZv1l2MF/KE7SBjvIenbKcNxnaSJYe6ImynZ7kw96pmOz0dbKdXCGynDch2egKDslezjHPRiYjE3Ki8E+Ti2EOg6++tnO2wX3p7gFsqxnsDY7xJeYx31qSY2oZFNinNnrKdVtxbCireQN3SLKhwC5zt5IotwCRoVc522IatcLaTK7YqZztc6JqbdRfjNk/YDjLG+3jKdlpxH2QP7Q3UfcuFuV812+nrYDv9QmA7rUC20xcYlP2aZZyLTkQk5nblnSAXxz4CXX9EOdthv0Q8wC0V4xFgjPdXHuOdNSmmtmGRTcrCnrKdFthZE624t7NIs6DCi8DZTtQsAkyCRZWzHbbhonC2EzWLKmc7XOgWbtZdjBfzhO0gY3yAp2ynBcZ2bGj3dhYvF+aB1WxncQfbGRgC22kBsp3FgUE5sFnGuehERGJeQnknyMVxgEDXv6RytsN+WdID3FIxviQwxpdSHuOdNSmmtmGRTcrSnrKdZtxZkw/qu0yzoMLLwNmOyS8DTIJllbMdtuGycLZj8ssqZztc6JZu1l2Ml/OE7SBj3HjKdppxb1fIOdQVYTu2XJij1WzHOthONAS2AzyBrAUGZbRZxrnoRERijinvBLk4GoGuP66c7bBf4h7glorxODDGE8pjvLMmxdQ2LLJJSXrKdppgZ02y4km2VLOgwik420kWU8AkSCtnO2zDNJztJItp5WyHC12yWXcxznjCdpAxvrynbKcJ97md0J5kW6FcmFesZjsrONjOiiGwnSYg21kBGJQrNss4F52ISMwrKe8EuTguL9D1r6yc7bBfVvYAt1SMrwyM8VWUx3hnTYqpbVhkk7Kqp2ynN+yssRXvZFutWVDh1eBsx9rVgEmwunK2wzZcHc52bAVuU+Nw4YYUumbdxXgNT9gOMsbX9JTt9MY9yRbaO9nWKhfmtavZzloOtrN2CGynN5DtrAUMyrWbZZyLTkQk5nWUd4JcHNcU6PrXVc522C/reoBbKsbXBcb4espjvLMmxdQ2LLJJWd9TttMI/IqUoL4bNAsqvEEzft8NlTMUxr1h81QDg/YVYRVcUNZv1l30NvKEVSDjcmPhQo/wycYCMR5mQe0lVFA3aRZUeBOBgrqp8oLKuDcNqaCa2oblxNi0WSbhULjDTLKeyO8YCui5WbOgwpsJnIibASv65soTlm24uUASbK78Gi0n6eYC9GcjoL+3UH65gGNnC6Fi3zHQub0F0D9bKqf4nTEGU9uwSMawlfIYZx9vJdDIIeOQm4SWhqmXzIMDrffABpk8b4DqGRW9zzFbwLaR8nxr8uc2JNuSbEeyPckOJDuS7ESyM8kuJLuSZElyJHmSAkmRpESyG8nuJHuQ7EmyF8neJPuQ7EuyH8n+JAeQHEhyEMnBJIdU32PZunw/Jbi2jWNtW8fado617R1rOzjWdnSs7eRY29mxtotjbVfHWtaxlnOs5R1rBcda0bFWcqzt5ljb3bG2h2NtT8faXo61vR1r+zjW9nWs7edY29+xdoBj7UDH2kGOtYMda4c0T3vvrn/556rln6a2UVF0ai2WWwMKb8d9wG1AezHGbSF7TbHXdrXvFS3by25f617x/7G93aG2vUzAj3bHWvaKVsSE3WnW9zJV8WV3nsW9kqVpYtXuMmt7pR1xb3edlb3Szhyy2ZnfK9VJPtrczO6V6jS3bX7m9or+R52whZnZK/WfNccWZ3yv/HTqly3N6F6p6dZCu9uM7WVmoK7a3WdkLzNDNdruMf29EjNY7+2e09srPsNnh93rP/eKl2biHLJ7/9deqZk60+w+ne+Vnsnz0e7byV6Z0kyftXY/915mFs5tu79rLzNLPYA9YNq97Cz2E/bA6r0Ks9yb2IMq94rV0OfYgwN7RUs19Uz2EE+vaB8C6/UKFU8dH9osqPChzeinjgv2UJwD7WEAo0pe0WYbHga8ot1hw8PAScAx1KUh3CQwNY1CaE+PHl5OsCOqr2wc3jzt06NHNMs/PYqrJMYeDkygI8DORQcfJ83hwGTswH24pyfSwbA4yhSC+h7ZLKjwkfATKVM4EngiHaX8RGIbHgU/kTKFozw9kQ6G6Z3JO9QVOZGOLifYMdUn0tGOE+mYEE6kg4En0tHABDpGyLnoG8FIzMcCi1lDA/60PKxcgNA3gpFU4DhgMXPZ0NQ2LPv4OIFO5jhPO5mDYPUnFwvqe3yzoMLHwzuZXOx4YPKfoLyTYRueAO9kcrEThJMfUUCPU15ATwTbsGOgD15kjJ8EzL0wO+CDYHrnog51RTrgk8uF+ZTqDvhkRwd8SggdMO4EMvZkYFCeIuRcdCIiMZ8q3AGb2obl4niSQPd2mvKulf1ymge4pWL8NGCMn648xjtrUhDND2qvM8AHdlhs50DYWZMuBfU9s1lQ4TPhbCddOhPowLOUsx224VlwtpMunaWc7XChO6NZdzE+G1yMOwYaMzLGz/GU7RwI0ztddKgrwnbOLRfm86rZzrkOtnNeCGwHdwIZey4wKM8Tci46EZGYz1feCXJxPEeg679AOdthv1zgAW6pGL8AGOMXKo/xzpoUU9uwyCblIk/v7RwAO2sqv3f84mZBhS+Gs52ouRiYBJcoZztsw0vgbCdqLlHOdrjQXdSsuxhf6gnbQcb4ZZ6ynQNgeof3veOXlwvzFdVs53IH27kiBLaDO4GMvRwYlFcIORediEjMVyrvBLk4XibQ9Q9SznbYL4M8wC0V44OAMX6V8hjvrEkxtQ2LbFKu9pTt7A87awoVbGdws6DCg+Fsp2AGA5NgiHK2wzYcAmc7BTNEOdvhQnd1s+5iPNQTtoOM8WGesp39YXrnQ2M715QL8/BqtnONg+0MD4Ht4E4gY68BBuVwIeeiExGJ+VrlnSAXx2ECXf8I5WyH/TLCA9xSMT4CGOPXKY/xzpoUU9uwyCblek/Zzn6wsyZZ8U6Mkc2CCo+Es52kHQlMglHK2Q7bcBSc7SQrcJsahws3otBd36y7GI/2hO0gY/wGT9nOfjC9k6G9S2VMuTCPrWY7YxxsZ2wIbAd3Ahk7BhiUY4Wci05EJOYblXeCXBxvEOj6xylnO+yXcR7glorxccAYH688xjtrUkxtwyKblJs8ZTv74u7tpIP6TmgWVHgC/t5OegIwCW5WznbYhjfj7+2kb1bOdrjQ3dSsuxjf4gnbQcb4rZ6ynX1hehdSDnVF2M7EcmGeVM12JjrYzqQQ2A7uBDJ2IjAoJwk5F52ISMy3Ke8EuTjeKtD1366c7bBfbvcAt1SM3w6M8TuUx3hnTYqpbVhkk3Knp2xnH9hZE88E9b2rWVDhu+BsJ565C5gEdytnO2zDu+FsJ565Wznb4UJ3Z7PuYnyPJ2wHGeP3esp29oHpHU871BVhO/eVC/P91WznPgfbuT8EtoM7gYy9DxiU9ws5F52ISMwPKO8EuTjeK9D1P6ic7bBfHvQAt1SMPwiM8YeUx3hnTYqpbVhkk/Kwp2xnb9hZk6t4ku2RZkGFH4GznZx9BJgEjypnO2zDR+FsJ1eB29Q4XLgRhe7hZt3F+DFP2A4yxh/3lO3sDdM7F9qTbE+UC/OT1WznCQfbeTIEtoM7gYx9AhiUTwo5F52ISMxPKe8EuTg+LtD1P62c7bBfnvYAt1SMPw2M8WeUx3hnTYqpbVhkk/Ksp2xnLxzbyQf1fa5ZUOHn8Gwn/xwwCZ5XznbYhs/j2U7+eeVshwvds826i/ELnrAdZIy/6Cnb2QvXEOcc6oqwnZfKhfnlarbzkoPtvBwC28GdQMa+BAzKl4Wci05EJOZXlHeCXBxfFOj6X1XOdtgvr3qAWyrGXwXG+GvKY7yzJsXUNiyySXndU7azJ+5JtlxQ3zeaBRV+A/8kW+4NYBK8qZztsA3fxD/JlntTOdvhQvd6s+5i/JYnbAcZ4297ynb2xD3slHWoK8J23ikX5ner2c47DrbzbghsB3cCGfsOMCjfFXIuOhGRmN9T3glycXxboOufrJztsF8me4BbKsYnA2P8feUx3lmTYmobFtmkfOAp29kDdtakK95A/WGzoMIfwtlO2nwITIKPlLMdtuFHcLaTNh8pZztc6D5o1l2MP/aE7SBj/BNP2c4eML1Tob2B+tNyYf6smu186mA7n4XAdnAnkLGfAoPyMyHnohMRiflz5Z0gF8dPBLr+L5SzHfbLFx7glorxL4Ax/qXyGO+sSTG1DYtsUr7ylO3sLsR2vm4WVPhrAbbzNTAJvlHOdtiG3wiwnW+Usx0udF816y7G33rCdpAx/p2nbGd3D9nO9+XC/EM12/newXZ+CIHt4E4gY78HBuUPnrAdJOYflXeCXBy/E+j6f1LOdtgvP3mAWyrGfwLG+M/KY7yzJsXUNiyySfnFU7azG+ysyVa8k+3XZkGFf4WznWzmV2AS/Kac7bANf4OznWzmN+VshwvdL826i/HvnrAdZIz/4Snb2Q2mdzbtUFeE7fxZLsx/VbOdPx1s568Q2A7uBDL2T2BQ/iXkXHQiIjH/rbwT5OL4h0DX/49ytsN++ccD3FIx/g+yoWrRHeOdNSmmtmGRTcpsOBuGynZKOLYTD+rbpUVQYd4czHbiXYBJ0LVFN9thG7KOYLYT79oie2ggCt1sLbqL8ezgYvw/CQnGjIzxOYCYw2Q7JVxDHHOoK8J2upUL85wtDZXMplvLtGyH/0ia7ZSAbKcbMCjnbJFxLjoRkZi7K+8EuTjO0YI/GOYSPrhMbcOyX+byALdUjM8FjPG5lcd4Z02KqW1YZJMyj6dspwg7awoV93bmbRFUeF442ylk5gUmwXzK2Q7bcD442ylk5lPOdrjQzdOiuxjP7wnbQcb4Ap6ynSKM7RRCu7ezYLkwL1TNdhZ0sJ2FQmA7RSDbWRAYlAu1yDgXnYhIzD2Ud4JcHBcQ6Pp7Kmc77JeeHuCWivGewBjvpTzGO2tSTG3DIpuURk/ZTgF21uSLQX17twgq3BvOdvLF3sAkaFLOdtiGTXC2ky82KWc7XOgaW3QX42ZP2A4yxls8ZTsFGNvJFxzqirCd1nJhbqtmO60OttMWAtspANlOKzAo21pknItORCTmPso7QS6OLQJdf1/lbIf90tcD3FIx3hcY4/2Ux3hnTYqpbVhkk9LuKdvJw84aW3FvJ9IiqHAEznZsJgJMgv7K2Q7bsD+c7dhMf+Vshwtde4vuYrywJ2wHGeOLeMp28jC2Y0O7t7NouTAvVs12FnWwncVCYDt5INtZFBiUi7XIOBediEjMA5R3glwcFxHo+hdXznbYL4t7gFsqxhcHxvhA5THeWZNiahsW2aQs4SnbycHOmlwF21myRVDhJeFsJ5dZEpgESylnO2zDpeBsJ5dZSjnb4UK3RIvuYry0J2wHGePLeMp2cjC2kwuN7SxbLszLVbOdZR1sZ7kQ2E4OyHaWBQblci0yzkUnIhKzUd4JcnFcRqDrt8rZDvvFeoBbKsYtMMajymO8sybF1DYsskmJecp2srg3UKeD+sZbBBWOw9lOOh0HJkFCOdthGybgbCedTihnO1zoYi26i3HSE7aDjPGUp2wnC2M76ZRDXRG2ky4X5kw120k72E4mBLaTBbKdNDAoMy0yzkUnIhLz8so7QS6OKYGufwXlbIf9soIHuKVifAVgjK+oPMY7a1JMbcMim5SVPGU7u8LOmngF21m5RVDhleFsJ55eGZgEqyhnO2zDVeBsJ55eRTnb4UK3UovuYryqJ2wHGeOrecp2doWxnXhobGf1cmFeo5rtrO5gO2uEwHZ2BbKd1YFBuUaLjHPRiYjEvKbyTpCL42oCXf9aytkO+2UtD3BLxfhawBhfW3mMd9akmNqGRTYp63jKdnaBnTUZG9R33RZBhdeFs52MXReYBOspZztsw/XgbCdTgdvUOFy4EYVunRbdxXh9T9gOMsY38JTt7AJjOxnjUFeE7WxYLswbVbOdDR1sZ6MQ2M4uQLazITAoN2qRcS46EZGYN1beCXJx3ECg699EOdthv2ziAW6pGN8EGOObKo/xzpoUU9uwyCZlM0/Zzs6wsyZlgvpu3iKo8OZwtpMymwOTYAvlbIdtuAWc7aTMFsrZDhe6zVp0F+MtPWE7yBjfylO2szOM7SRLDnVF2M7W5cK8TTXb2drBdrYJge3sDGQ7WwODcpsWGeeiExGJeVvlnSAXx60Euv7tlLMd9st2HuCWivHtgDG+vfIY76xJMbUNi2xSdvCU7eyEe0tBxRuod2wRVHhHONvJFXcEJsFOytkO23AnONvJFXdSzna40O3QorsY7+wJ20HG+C6esp2dcG8pCO0N1LuWC3O2mu3s6mA72RDYzk5AtrMrMCizLTLORSciEnNOeSfIxXEXga4/r5ztsF/yHuCWivE8MMYLymO8sybF1DYsskkpesp2doSdNdGKezulFkGFS3C2EzUlYBLsppztsA13g7OdqNlNOdvhQlds0V2Md/eE7SBjfA9P2c6OuDdQh3ZvZ89yYd6rmu3s6WA7e4XAdnYEsp09gUG5V4uMc9GJiMS8t/JOkIvjHgJd/z7K2Q77ZR8PcEvF+D7AGN9XeYx31qSY2oZFNin7ecp2dsCdNfmgvvu3CCq8P5ztmPz+wCQ4QDnbYRseAGc7Jn+AcrbDhW6/Ft3F+EBP2A4yxg/ylO3sAGM7JudQV4TtHFwuzIdUs52DHWznkBDYDvAEsgcDg/KQFhnnohMRiflQ5Z0gF8eDBLr+w5SzHfbLYR7glorxw4AxfrjyGO+sSTG1DYtsUo7wlO1sDztrkhVPsh3ZIqjwkXC2kyweCUyCo5SzHbbhUXC2kywepZztcKE7okV3MT7aE7aDjPFjPGU72+M+txPak2zHlgvzcdVs51gH2zkuBLazPZDtHAsMyuNaZJyLTkQk5uOVd4JcHI8R6PpPUM522C8neIBbKsZPAMb4icpjvLMmxdQ2LLJJOclTtrMd7KyxFe9kO7lFUOGT4WzH2pOBSXCKcrbDNjwFznZsBW5T43DhRhS6k1p0F+NTPWE7yBg/zVO2sx3uSbbQ3sl2erkwn1HNdk53sJ0zQmA72wHZzunAoDyjRca56EREYj5TeSfIxfE0ga7/LOVsh/1ylge4pWL8LGCMn608xjtrUkxtwyKblHM8ZTvb4h7GqPjczrktggqf24Lf9zzlDIVxn9cy1cCgfUVYBReUc1p0F73zPWEVyLi8QLjQI3xygUCMh1lQtxEqqBe2CCp8oUBBvUh5QWXcF4VUUE1tw3JiXNQik3Ao3GEm2dbNOBsE9b24RVDhiwVOxIuBFf0S5QnLNrxEIAkuUX6NlpP0EgH6cz7Q35cqv1zAsXOpULHvGOjcvhTon8uUU/zOGIOpbVgkY7hceYyzjy8XaOSQcchNAqdhxyXz4EDr3atRJs8boHpGRe9zzBawbaQ8v4IccCXJIJKrSK4mGUwyhGQoyTCSa0iGk1xLMoLkOpLrSUaSjCIZTXIDyRiSsSQ3kowjGU9yE8kEkptJbiG5lWQiySSS26rvsVxRvp8SXLvSsTbIsXaVY+1qx9pgx9oQx9pQx9owx9o1jrXhjrVrHWsjHGvXOdaud6yNdKyNcqyNdqzd4Fgb41gb61i70bE2zrE23rF2k2NtgmPtZsfaLY61Wx1rEx1rkxxrt7VMe++uf/nnquWfprZRUXRqLZZXAApvx33AK0F7McZBkL2m2Ouq2veKlu1lr651r/j/2N4Orm0vE/CjHVLLXtGKmLBDZ30vUxVfdtgs7pUsTROr9ppZ2yvtiHs7fFb2SjtzyF4783ulOslHO2Jm90p1mtv2upnbK/ofdcJePzN7pf6z5tiRM75Xfjr1y46a0b1S062FdvSM7WVmoK7aG2ZkLzNDNdqOmf5eiRms93bs9PaKz/DZYW/8z73ipZk4h+y4/9orNVNnmh3f+V7pmTwf7U2d7JUpzfRZaye49zKzcG7bm117mVnqAewt0+5lZ7GfsLdW71WY5d7ETqzcK1ZDn2MnBfaKlmrqmextnl7Rvg3W6xUqnjq+vUVQ4dtb0E8dF+ztOAfaOwBGlbyizTa8A3hFu8OGd4CTIKynR3HJWwjt6dE7ywl2V/WVjTtbpn169K4W+adHcZXE2DuBCXQX2Lno4OOkuROYjB247/T0RJoEi6NMIajv3S2CCt8NP5EyhbuBJ9I9yk8ktuE98BMpU7jH0xNpEkzvTN6hrsiJdG85we6rPpHudZxI94VwIk0Cnkj3AhPoPiHnom8EIzHfDyxmDQ340/KOcgFC3whGUoEHgMXMZUNT27Ds4wcEOpkHPO1kJsLqTy4W1PfBFkGFH4R3MrnYg8Dkf0h5J8M2fAjeyeRiDwknP6KAPqC8gD4MtmHHQB+8yBh/BJh7YXbAE2F656IOdUU64EfLhfmx6g74UUcH/FgIHTDuBDL2UWBQPibkXHQiIjE/LtwBm9qG5eL4iED39oTyrpX98oQHuKVi/AlgjD+pPMY7a1IQzQ9qr6fAB3ZYbOdW2FmTLgX1fbpFUOGn4WwnXXoa6MBnlLMdtuEzcLaTLj2jnO1woXuqRXcxfhZcjDsGGjMyxp/zlO3cCtM7XXSoK8J2ni8X5heq2c7zDrbzQghsB3cCGfs8MChfEHIuOhGRmF9U3glycXxOoOt/STnbYb+85AFuqRh/CRjjLyuP8c6aFFPbsMgm5RVP7+3cAjtrKr93/NUWQYVfhbOdqHkVmASvKWc7bMPX4Gwnal5Tzna40L3SorsYv+4J20HG+Buesp1bYHqH973jb5YL81vVbOdNB9t5KwS2gzuBjH0TGJRvCTkXnYhIzG8r7wS5OL4h0PW/o5ztsF/e8QC3VIy/A4zxd5XHeGdNiqltWGST8p6nbOdm2FlTqGA7k1sEFZ4MZzsFMxmYBO8rZztsw/fhbKdg3lfOdrjQvdeiuxh/4AnbQcb4h56ynZtheudDYzsflQvzx9Vs5yMH2/k4BLaDO4GM/QgYlB8LORediEjMnyjvBLk4fijQ9X+qnO2wXz71ALdUjH8KjPHPlMd4Z02KqW1YZJPyuadsZwLsrElWvBPjixZBhb+As52k/QKYBF8qZztswy/hbCdZgdvUOFy4EYXu8xbdxfgrT9gOMsa/9pTtTIDpnQztXSrflAvzt9Vs5xsH2/k2BLaDO4GM/QYYlN8KORediEjM3ynvBLk4fi3Q9X+vnO2wX773ALdUjH8PjPEflMd4Z02KqW1YZJPyo6ds5ybcvZ10UN+fWgQV/gl/byf9EzAJflbOdtiGP+Pv7aR/Vs52uND92KK7GP/iCdtBxvivnrKdm2B6F1IOdUXYzm/lwvx7Ndv5zcF2fg+B7eBOIGN/Awbl70LORSciEvMfyjtBLo6/CnT9fypnO+yXPz3ALRXjfwJj/C/lMd5Zk2JqGxbZpPztKdsZDztr4pmgvv+0CCr8D5ztxDP/IJOgVTfbYRuyjli2E88EcZsahws3otD93aK7GM/Wii3GHQONGRnjXYCYw2Q742E1I552qCvCdrq2Tvk5e2tDJbPp2jot2+E/kmY744FspyswKGdvlXEuOhGRmOcAFx90wnFx7NKKPxi6CR9cprZh2S/dPMAtFePdgDE+p/IY76xJMbUNi2xSugPjJky2Mw521uQqnmSbq1VQYd4cy3Zydi5gEsytnO2wDeeGs51cBW5T43DhRhS67q26i/E8nrAdZIzP6ynbGQdjO7nQnmSbr1yY569mO/M52M78IbCdcUC2Mx8wKOdvlXEuOhGRmBdQ3glycZxXoOtfUDnbYb8s6AFuqRhfEBjjCymP8c6aFFPbsMgmpYenbOdGHNvJB/Xt2SqocE8828n3BCZBL+Vsh23YC8928r2Usx0udD1adRfjRk/YDjLGe3vKdm7EsZ2cQ10RttNULszN1WynycF2mkNgOzcC2U4TMCibW2Wci05EJOYW5Z0gF8feAl1/q3K2w35p9QC3VIy3AmO8TXmMd9akmNqGRTYpfTxlO2NxT7Llgvr2bRVUuC+c7cRzfYFJ0E8522Eb9sM/yZbrp5ztcKHr06q7GLd7wnaQMR7xlO2MxT3JlnWoK8J2+pcL88LVbKe/g+0sHALbGQtkO/2BQblwq4xz0YmIxLyI8k6Qi2NEoOtfVDnbYb8s6gFuqRhfFBjjiymP8c6aFFPbsMgmZYCnbGcM7KxJV7yBevFWQYUXh7OdtFkcmAQDlbMdtuFAONtJm4HK2Q4XugGtuovxEp6wHWSML+kp2xkDYzup0N5AvVS5MC9dzXaWcrCdpUNgO2OAbGcpYFAu3SrjXHQiIjEvo7wT5OK4pEDXv6xytsN+WdYD3FIxviwwxpdTHuOdNSmmtmGRTYrxlO3cIMR2bKugwlaA7VhgEkSVsx22YVSA7USVsx0udKZVdzGOecJ2kDEe95Tt3OAh20mUC3Oymu0kHGwnGQLbuQHIdhLAoEx6wnaQmFPKO0EujnGBrj+tnO2wX9Ie4JaK8TQwxjPKY7yzJsXUNiyySVneU7YzGnbWZCveybZCq6DCK8DZTjazAjAJVlTOdtiGK8LZTjazonK2w4Vu+VbdxXglT9gOMsZX9pTtjIaxnWxo72RbpVyYV61mO6s42M6qIbCd0UC2swowKFdtlXEuOhGRmFdT3glycVxZoOtfXTnbYb+s7gFuqRhfHRjjayiP8c6aFFPbsMgmZU1P2c4oHNuJB/Vdq1VQ4bXwbCe+FjAJ1lbOdtiGa+PZTnxt5WyHC92arbqL8TqesB1kjK/rKdsZhWM7MYe6ImxnvXJhXr+a7aznYDvrh8B2RgHZznrAoFy/Vca56EREYt5AeSfIxXFdga5/Q+Vsh/2yoQe4pWJ8Q2CMb6Q8xjtrUkxtwyKblI09ZTsjcd8uWnFvZ5NWQYU3gbOdQmYTYBJsqpztsA03hbOdQmZT5WyHC93GrbqL8WaesB1kjG/uKdsZifsCytDu7WxRLsxbVrOdLRxsZ8sQ2M5IINvZAhiUW7bKOBediEjMWynvBLk4bi7Q9W+tnO2wX7b2ALdUjG8NjPFtlMd4Z02KqW1YZJOyrads53rYWZMvBvXdrlVQ4e3gbCdf3A6YBNsrZztsw+3hbCdf3F452+FCt22r7mK8gydsBxnjO3rKdq6HsZ18waGuCNvZqVyYd65mOzs52M7OIbCd64FsZydgUO7cKuNcdCIiMe+ivBPk4rijQNe/q3K2w37Z1QPcUjG+KzDGs8pjvLMmxdQ2LLJJyXnKdq6DnTW24t5OvlVQ4Tyc7dhMHpgEBeVsh21YgLMdmykoZztc6HKtuotx0RO2g4zxkqds5zoY27Gh3dvZrVyYd69mO7s52M7uIbCd64BsZzdgUO7eKuNcdCIiMe+hvBPk4lgS6Pr3VM522C97eoBbKsb3BMb4XspjvLMmxdQ2LLJJ2dtTtjMC9+2iFWxnn1ZBhfeBs51cZh9gEuyrnO2wDfeFs51cZl/lbIcL3d6tuovxfp6wHWSM7+8p2xmB+3bR0NjOAeXCfGA12znAwXYODIHtjACynQOAQXlgq4xz0YmIxHyQ8k6Qi+P+Al3/wcrZDvvlYA9wS8X4wcAYP0R5jHfWpJjahkU2KYd6ynauxb2BOh3U97BWQYUPg7OddPowYBIcrpztsA0Ph7OddPpw5WyHC92hrbqL8RGesB1kjB/pKdu5FsZ20imHuiJs56hyYT66mu0c5WA7R4fAdq4Fsp2jgEF5dKuMc9GJiMR8jPJOkIvjkQJd/7HK2Q775VgPcEvF+LHAGD9OeYx31qSY2oZFNinHe8p2hsPOmngF2zmhVVDhE+BsJ54+AZgEJypnO2zDE+FsJ54+UTnb4UJ3fKvuYnySJ2wHGeMne8p2hsPYTjw0tnNKuTCfWs12TnGwnVNDYDvDgWznFGBQntoq41x0IiIxn6a8E+TieLJA13+6crbDfjndA9xSMX46MMbPUB7jnTUpprZhkU3KmZ6ynWtgZ03GBvU9q1VQ4bPgbCdjzwImwdnK2Q7b8Gw428lU4DY1DhduRKE7s1V3MT7HE7aDjPFzPWU718DYTsY41BVhO+eVC/P51WznPAfbOT8EtnMNkO2cBwzK81tlnItORCTmC5R3glwczxXo+i9UznbYLxd6gFsqxi8ExvhFymO8sybF1DYsskm52FO2Mwx21qRMUN9LWgUVvgTOdlLmEmASXKqc7bANL4WznZS5VDnb4UJ3cavuYnyZJ2wHGeOXe8p2hsHYTrLkUFeE7VxRLsxXVrOdKxxs58oQ2M4wINu5AhiUV7bKOBediEjMg5R3glwcLxfo+q9SznbYL1d5gLtjdBHUs9a9rlYe4501Kaa2YZFNymBP2c5Q3FsKKt5APaRVUOEhcLaTKw4BJsFQ5WyHbTgUznZyxaHK2Q4XusGtuovxME/YDjLGr/GU7QzFvaUgtDdQDy8X5mur2c5wB9u5NgS2MxTIdoYDg/LaVhnnohMRiXmE8k6Qi+M1Al3/dcrZDvvlOg9wS8X4dcAYv155jHfWpJjahkU2KSM9ZTtDYGdNtOLezqhWQYVHwdlO1IwCJsFo5WyHbTgaznaiZrRytsOFbmSr7mJ8gydsBxnjYzxlO0Nwb6AO7d7O2HJhvrGa7Yx1sJ0bQ2A7Q4BsZywwKG9slXEuOhGRmMcp7wS5OI4R6PrHK2c77JfxHuCWivHxwBi/SXmMd9akmNqGRTYpEzxlO4NxZ00+qO/NrYIK3wxnOyZ/MzAJblHOdtiGt8DZjsnfopztcKGb0Kq7GN/qCdtBxvhET9nOYBjbMTmHuiJsZ1K5MN9WzXYmOdjObSGwHeAJZCcBg/K2VhnnohMRifl25Z0gF8eJAl3/HcrZDvvlDg9wS8X4HcAYv1N5jHfWpJjahkU2KXd5ynauhp01yYon2e5uFVT4bjjbSRbvBibBPcrZDtvwHjjbSRbvUc52uNDd1aq7GN/rCdtBxvh9nrKdq3Gf2wntSbb7y4X5gWq2c7+D7TwQAtu5Gsh27gcG5QOtMs5FJyIS84PKO0EujvcJdP0PKWc77JeHPMAtFeMPAWP8YeUx3lmTYmobFtmkPOIp27kKdtbYineyPdoqqPCjcLZj7aPAJHhMOdthGz4GZzu2ArepcbhwIwrdI626i/HjnrAdZIw/4SnbuQr3JFto72R7slyYn6pmO0862M5TIbCdq4Bs50lgUD7VKuNcdCIiMT+tvBPk4viEQNf/jHK2w355xgPcUjH+DDDGn1Ue4501Kaa2YZFNynOesp1BuIcxKj6383yroMLPt+L3fUE5Q2HcL7RONTBoXxFWwQXluVbdRe9FT1gFMi5fEi70CJ+8JBDjYRbUK4UK6sutggq/LFBQX1FeUBn3KyEVVFPbsJwYr7TKJBwKd5hJdkULzgZBfV9tFVT4VYET8VVgRX9NecKyDV8TSILXlF+j5SR9TYD+vAj09+vKLxdw7LwuVOw7Bjq3Xwf65w3lFL8zxmBqGxbJGN5UHuPs4zcFGjlkHHKTQKn4P5fMgwOt9/fdZPK8AapnVPQ+x2wB20bK87fIn2+TvEPyLsl7JJNJ3if5gORDko9IPib5hORTks9IPif5guRLkq9Ivib5huRbku9Ivif5geRHkp9Ifib5heRXkt9Ifif5o/oey1vl+ynBtbcda+841t51rL3nWJvsWHvfsfaBY+1Dx9pHjrWPHWufONY+dax95lj73LH2hWPtS8faV461rx1r3zjWvnWsfedY+96x9oNj7UfH2k+OtZ8da7841n51rP3mWPvdsfZH67T37vqXf65a/mlqGxVFp9Zi+Rag8HbcB3wbtBdjfAey1xR7vVv7XtGyvex7te4V/x/b28m17WUCfrTv17JXtCIm7Aezvpepii/74SzulSxNE6v2o1nbK+2Ie/vxrOyVduaQ/WTm90p1ko/205ndK9VpbtvPZm6v6H/UCfv5zOyV+s+aY7+Y8b3y06lf9ssZ3Ss13Vpov5qxvcwM1FX79YzsZWaoRttvpr9XYgbrvf12envFZ/jssN/9517x0kycQ/b7/9orNVNnmv2h873SM3k+2h872StTmumz1v7k3svMwrltf3btZWapB7C/TLuXncV+wv5avVdhlnsT+1vlXrEa+hz7e2CvaKmmnsn+4ekV7T9gvV6h4qnjP1sFFf6zFf3UccH+iXOg/QtgVMkr2mzDv4BXtDts+Bc4CcJ6ehSXvIXQnh79u5xg/1Rf2fi7ddqnR/9plX96FFdJjP0bmED/gJ2LDj5Omr+BydiB+29PT6TfYXGUKVTo2yaoMG+OPZEyBd4TpeNsbbpPJLYh64g9kSgA2vw8kX6HJW8m71BX5ETqUk6wrm0NladPl7ZpTyT+I+kT6XfgidQFmEBd22Sci74RjMQ8O7CYNTTgT8u/ygUIfSMYSQXmABYzlw1NbcOyj+dow/tmjjY/O5nfYPUnFwvq261NUOFu8E4mF+sGTP45lXcybMM54Z1MLjancPIjCugcygtod7ANOwb64EXG+FzA3AuzA/4N1gHnog51RTrgucuFeZ7qDnhuRwc8Twgd8G/ADnhuYFDO0ybjXHQiIjHPK9wBm9qG5eI4l0D3Np/yrpX9Mp8HuKVifD5gjM+vPMY7a1IQzQ9qrwXAB3ZYbOdX2FmTLgX1XbBNUOEF4WwnXVoQ6MCFlLMdtuFCcLaTLi2knO1woVugTXcx7gEuxh0DjRkZ4z09ZTu/wthOuuhQV4Tt9CoX5sZqttPLwXYaQ2A7vwLZTi9gUDa2yTgXnYhIzL2Vd4JcHHsKdP1NytkO+6XJA9xSMd4EjPFm5THeWZNiahsW2aS0eHpv5xfYWVP5veOtbYIKt8LZTtS0ApOgTTnbYRu2wdlO1LQpZztc6FradBfjPp6wHWSM9/WU7fwCYzvhfe94v3Jhbq9mO/0cbKc9BLbzC5Dt9AMGZXubjHPRiYjEHFHeCXJx7CvQ9fdXznbYL/09wC0V4/2BMb6w8hjvrEkxtQ2LbFIW8ZTt/Iz7lFgF21m0TVDhReFsp2AWBSbBYsrZDttwMTjbKZjFlLMdLnSLtOkuxgM8YTvIGF/cU7bzM4zt5ENjOwPLhXmJarYz0MF2lgiB7fwMZDsDgUG5RJuMc9GJiMS8pPJOkIvj4gJd/1LK2Q77ZSkPcEvF+FLAGF9aeYx31qSY2oZFNinLeMp2foKdNcmKd2Is2yao8LJwtpO0ywKTYDnlbIdtuByc7SQrcJsahws3otAt06a7GBtP2A4yxq2nbOcnGNtJhvYulWi5MMeq2U7UwXZiIbCdn4BsJwoMylibjHPRiYjEHFfeCXJxtAJdf0I522G/JDzALRXjCWCMJ5XHeGdNiqltWGSTkvKU7fyIu7eTDuqbbhNUOI2/t5NOA5Mgo5ztsA0z+Hs76YxytsOFLtWmuxgv7wnbQcb4Cp6ynR9xLxdMOdQVYTsrlgvzStVsZ0UH21kpBLbzI5DtrAgMypXaZJyLTkQk5pWVd4JcHFcQ6PpXUc522C+reIBbKsZXAcb4qspjvLMmxdQ2LLJJWc1TtvMD7KyJZ4L6rt4mqPDqcLYTz6wOTII1lLMdtuEacLYTz6yhnO1woVutTXcxXtMTtoOM8bU8ZTs/wNhOPO1QV4TtrF0uzOtUs521HWxnnRDYzg9AtrM2MCjXaZNxLjoRkZjXVd4JcnFcS6DrX08522G/rOcBbqkYXw8Y4+srj/HOmhRT27DIJmUDT9nO97g3UFc8ybZhm6DCG8LZTs5uCEyCjZSzHbbhRnC2k6vAbWocLtyIQrdBm+5ivLEnbAcZ45t4yna+x72BOrQn2TYtF+bNqtnOpg62s1kIbOd7INvZFBiUm7XJOBediEjMmyvvBLk4biLQ9W+hnO2wX7bwALdUjG8BjPEtlcd4Z02KqW1YZJOylads5zsc28kH9d26TVDhrfFsJ781MAm2Uc522Ibb4NlOfhvlbIcL3VZtuovxtp6wHWSMb+cp2/kOx3ZyDnVF2M725cK8QzXb2d7BdnYIge18B2Q72wODcoc2GeeiExGJeUflnSAXx+0Euv6dlLMd9stOHuCWivGdgDG+s/IY76xJMbUNi2xSdvGU7XyLe5ItF9R31zZBhXfFP8mW2xWYBFnlbIdtmMU/yZbLKmc7XOh2adNdjHOesB1kjOc9ZTvf4p5kyzrUFWE7hXJhLlaznYKD7RRDYDvfAtlOARiUxTYZ56ITEYm5pLwT5OKYF+j6d1POdtgvu3mAWyrGdwPG+O7KY7yzJsXUNiyySdnDU7bzDe7bRSveQL1nm6DCe8LZTtrsCUyCvZSzHbbhXnC2kzZ7KWc7XOj2aNNdjPf2hO0gY3wfT9nONzC2kwrtDdT7lgvzftVsZ18H29kvBLbzDZDt7AsMyv3aZJyLTkQk5v2Vd4JcHPcR6PoPUM522C8HeIBbKsYPAMb4gcpjvLMmxdQ2LLJJOchTtvO1ENs5uE1Q4YMF2M7BwCQ4RDnbYRseIsB2DlHOdrjQHdSmuxgf6gnbQcb4YZ6yna89ZDuHlwvzEdVs53AH2zkiBLbzNZDtHA4MyiM8YTtIzEcq7wS5OB4m0PUfpZztsF+O8gC3VIwfBYzxo5XHeGdNiqltWGSTcoynbOcr2FmTrXgn27FtggofC2c72cyxwCQ4TjnbYRseB2c72cxxytkOF7pj2nQX4+M9YTvIGD/BU7bzFYztZEN7J9uJ5cJ8UjXbOdHBdk4Kge18BWQ7JwKD8qQ2GeeiExGJ+WTlnSAXxxMEuv5TlLMd9sspHuCWivFTgDF+qvIY76xJMbUNi2xSTvOU7XyJYzvxoL6ntwkqfDqe7cRPBybBGcrZDtvwDDzbiZ+hnO1woTutTXcxPtMTtoOM8bM8ZTtf4thOzKGuCNs5u1yYz6lmO2c72M45IbCdL4Fs52xgUJ7TJuNcdCIiMZ+rvBPk4niWQNd/nnK2w345zwPcUjF+HjDGz1ce4501Kaa2YZFNygWesp0vcN8uWnFv58I2QYUvhLOdQuZCYBJcpJztsA0vgrOdQuYi5WyHC90FbbqL8cWesB1kjF/iKdv5AvftoqHd27m0XJgvq2Y7lzrYzmUhsJ0vgGznUmBQXtYm41x0IiIxX668E+TieIlA13+FcrbDfrnCA9xSMX4FMMavVB7jnTUpprZhkU3KIE/ZzuewsyZfDOp7VZugwlfB2U6+eBUwCa5WznbYhlfD2U6+eLVytsOFblCb7mI82BO2g4zxIZ6ync9hbCdfcKgrwnaGlgvzsGq2M9TBdoaFwHY+B7KdocCgHNYm41x0IiIxX6O8E+TiOESg6x+unO2wX4Z7gFsqxocDY/xa5THeWZNiahsW2aSM8JTtfAY7a2zFvZ3r2gQVvg7OdmzmOmASXK+c7bANr4ezHZu5Xjnb4UI3ok13MR7pCdtBxvgoT9nOZzC2Y0O7tzO6XJhvqGY7ox1s54YQ2M5nQLYzGhiUN7TJOBediEjMY5R3glwcRwl0/WOVsx32y1gPcEvF+FhgjN+oPMY7a1JMbcMim5RxnrKdT3HfLlrBdsa3CSo8Hs52cpnxwCS4STnbYRveBGc7ucxNytkOF7pxbbqL8QRP2A4yxm/2lO18ivt20dDYzi3lwnxrNdu5xcF2bg2B7XwKZDu3AIPy1jYZ56ITEYl5ovJOkIvjzQJd/yTlbIf9MskD3FIxPgkY47cpj/HOmhRT27DIJuV2T9nOJ7g3UKeD+t7RJqjwHXC2k07fAUyCO5WzHbbhnXC2k07fqZztcKG7vU13Mb7LE7aDjPG7PWU7n8DYTjrlUFeE7dxTLsz3VrOdexxs594Q2M4nQLZzDzAo722TcS46EZGY71PeCXJxvFug679fOdthv9zvAW6pGL8fGOMPKI/xzpoUU9uwyCblQU/ZzsewsyZewXYeahNU+CE424mnHwImwcPK2Q7b8GE424mnH1bOdrjQPdimuxg/4gnbQcb4o56ynY9hbCceGtt5rFyYH69mO4852M7jIbCdj4Fs5zFgUD7eJuNcdCIiMT+hvBPk4vioQNf/pHK2w3550gPcUjH+JDDGn1Ie4501Kaa2YZFNytOesp2PYGdNxgb1faZNUOFn4GwnY58BJsGzytkO2/BZONvJVOA2NQ4XbkShe7pNdzF+zhO2g4zx5z1lOx/B2E7GONQVYTsvlAvzi9Vs5wUH23kxBLbzEZDtvAAMyhfbZJyLTkQk5peUd4JcHJ8X6PpfVs522C8ve4BbKsZfBsb4K8pjvLMmxdQ2LLJJedVTtvMh7KxJmaC+r7UJKvwanO2kzGvAJHhdOdthG74OZzsp87pytsOF7tU23cX4DU/YDjLG3/SU7XwIYzvJkkNdEbbzVrkwv13Ndt5ysJ23Q2A7HwLZzlvAoHy7Tca56EREYn5HeSfIxfFNga7/XeVsh/3yrge4pWL8XWCMv6c8xjtrUkxtwyKblMmesp0PcG8pqHgD9fttggq/D2c7ueL7wCT4QDnbYRt+AGc7ueIHytkOF7rJbbqL8YeesB1kjH/kKdv5APeWgtDeQP1xuTB/Us12PnawnU9CYDsfANnOx8Cg/KRNxrnoRERi/lR5J8jF8SOBrv8z5WyH/fKZB7ilYvwzYIx/rjzGO2tSTG3DIpuULzxlO+/Dzppoxb2dL9sEFf4Sznai5ktgEnylnO2wDb+Cs52o+Uo52+FC90Wb7mL8tSdsBxnj33jKdt7HvYE6tHs735YL83fVbOdbB9v5LgS28z6Q7XwLDMrv2mSci05EJObvlXeCXBy/Eej6f1DOdtgvP3iAWyrGfwDG+I/KY7yzJsXUNiyySfnJU7YzGXfW5IP6/twmqPDPcLZj8j8Dk+AX5WyHbfgLnO2Y/C/K2Q4Xup/adBfjXz1hO8gY/81TtjMZxnZMzqGuCNv5vVyY/6hmO7872M4fIbAd4AlkfwcG5R9tMs5FJyIS85/KO0Eujr8JdP1/KWc77Je/PMAtFeN/AWP8b+Ux3lmTYmobFtmk/OMp23kPdtYkK55ka+gjqDBvjmU7ySLvidJxtj662Q7bkHXEsh0KgD6yhwai0P3TprsYd+mDLcYdA40ZGeNdgZjDZDvv4T63E9qTbLOXC/McfRoqmc3sfaZlO/xH0mznPSDbmR0YlHP0kXEuOhGRmLuBiw864bg4du2DPxjmFD64TG3Dsl/m9AC3VIzPCYzx7spjvLMmxdQ2LLJJmQsYN2GynXdhZ42teCfb3H0EFZ4bznasnRuYBPMoZztsw3ngbMdW4DY1DhduRKGbq4/uYjyvJ2wHGePzecp23sU9yRbaO9nmLxfmBarZzvwOtrNACGznXSDbmR8YlAv0kXEuOhGRmBdU3glycZxPoOtfSDnbYb8s5AFuqRhfCBjjPZTHeGdNiqltWGST0tNTtvMO7mGMis/t9OojqHCvPvh9G5UzFMbd2GeqgUH7irAKLig9++guer09YRXIuGwSLvQInzQJxHiYBfVtoYLa3EdQ4WaBgtqivKAy7paQCqqpbVhOjJY+MgmHwh1mkr3VirNBUN/WPoIKtwqciK3Ait6mPGHZhm0CSdCm/BotJ2mbAP3pDfR3H+WXCzh2+ggV+46Bzu0+QP/0VU7xO2MMprZhkYyhn/IYZx/3E2jkkHHITcK8DVNH8PBt5/zkP+jaEE4X0Q50aJeAnpFyoelffUOBf3F81Vr/8lpwoG8otAM9GJnxvfLT2cv2B7efLK67XA0zac/p6d0gGJQRoE2CSbRwdTAu3GfaLKsOPGSwTEdXOz0wCwODeJE+sGAwQZsuMgPJXKvu/YF2QNp00Zmw6fT+raBNFw0Uze4BewZtamob9u//3i+aL9lYophKmGQ2nigkY9FCNGUK8UTJksLRTJxMU8rH04V0NFaKpqL5v7H6/RtjHYWt4yD5u2HqAcLzxejnAJLF+0wphGFx8QEBv9t0LBpNxTg+0gVj4wU6AqLRQi5u8iabjxYzcZspxaPxWL6Qz1EsZW3JlLL5TCk9Za+gvgP7CCo80NFr1qr8QGCPvYRyLs42XMLRa9ZqwyXAHcHcDeE89zJA6LZxA9a+FR3BksEGAH3RAuhIGzwNgkrPpM75GQm+JWeBhE7P6EsCk3kpcHvYYdelAp3LzMYCtW42b03JZKIma1L5ZCqXKURz6WwpVkrECrFZtev0gh1p16WF7Lp02a5h8lpkMQoWz2XKJ/KynIMSBWNJgasXSyq/ujuryWFmAnetOi6n/MoXB+ZyAncGjFBRMP9RbE1twy4rZAsrZAtbw8EzPZ2l4uLWAf+rNWW619WkYmDiAN11YEAZN7qWAv1tkTb8v3LNcxmha57R/2I4prZhlxMqiNH/YDjT2Wa611BZ56hAYZgELgwdY/aZ9NnMNDK1Yo710VlgkL4IxmXMcW17Zv0zPZsj/RMPXpeMxSg3CilbKpRiiVQmmrPJWDJZipdSyXS8UErEs4VU0cazsWimmDIlmy7S1d5YPpUsZQr5ZClYtG0hFosXMrm8TUST2ZxJF2JZU4qnYkR+C7FUoRBLJ5PZWKyQTJfSGSKsRIPTJpFKZUwyGstEpfwTDzBN1KEwvSsbwT19ORQSPh4KCeFDISFwKNym5FDoNIhT/35GroQsOkmlh8JtQkUnCTgUpneZD+mflNJDQco/qf9Dlx/T5cuPGdflR1Pb6PTaP/I+SK17AS9lijzE12FD9BMPUjasda/llfuDE2Z5gYN9BaEmZwXBy6IZIVusKGSLFQUvi0rFxR3KL4tKxcCdHlwWXV7gsijQ3/bO+mXR6vFv/UbZJNj4rSTJgJcXKogrCTJg1nklgcJwlyeXRZcHNkUr99FZYO4SYlgrh3BZFOmfVYAM+E4gA5byzyoO/6Af8EL6Z1Wh+rkqwA7Tu1KDtMNqQnZYbQYuk2s+yB3qwuI42CSs7mOTsLpwk7C6QJNwd0hNQo1Px0KL3BrAvZBNwt1Ch9AaM9Ak1PqULdI/a/bBHezIJkHKP2sKXnkaSHsMbMDXjbWUP5TJmNcSqJdrA+J8ytsxSyK4Wb+1BXCvo9zfjHkdAdzrKsfN+q0rgHs95bhZv/UEcK+vHDfrt74A7g2U42b9NhDAvaFy3KzfhgK4N1KOm/XbSAD3xh6cYxsL4N5EOW7WbxMB3Jt64O9NBXBvphw367eZAO7NleNm/TYXwL2Fctys3xYCuLf0IL+3FMC9lXLcrN9WAri3Vo6b9dtaAPc2ynGzftsI4N5WOW7Wb1sB3Nt5UNe2E8C9vXLcrN/2Arh3UI6b9dtBAPeOynGzfjsK4N7Jg/zeSQD3zspxs347C+DexQN/7yKAe1fluFm/XQVwZz3wd1YAd045btYvJ4A7rxw365cXwF1Qjpv1KwjgLnqQ30UB3CXluFm/kgDu3Tzw924CuHdXjpv1210A9x4e+HsPAdx7KsfN+u0pgHsv5bhZv70EcO+tHDfrt7cA7n08yO99BHDvqxw367evAO79lONm/fYTwL2/B3G+vwDuA5TjZv0OEMB9oAf+PlAA90HKcbN+BwngPtgDfx8sgPsQ5bhZv0MEcB+qHDfrd6gA7sOU42b9DhPAfbhy3Kzf4QK4j1COm/U7QgD3kR7U8yMFcB+lHDfrd5QA7qOV42b9jhbAfYxy3KzfMQK4j/Ugv48VwH2cctys33ECuI/3wN/HC+A+QTlu1u8EAdwnKsfN+p0ogPsk5bhZv5MEcJ+sHDfrd7IA7lM8qGunCOA+VTlu1u9UAdyneeDv0wRwn64cN+t3ugDuM5TjZv3OEMB9pgdxfqYA7rOU42b9zhLAfbZy3Kzf2QK4z1GOm/U7RwD3ucpxs37nCuA+Tzlu1u88AdznK8fN+p0vgPsC5bhZvwsEcF+oHDfrd6EA7os86FsuEsB9sXLcrN/FArgvUY6b9btEAPelHsT5pQK4L1OOm/W7TAD35cpxs36XC+C+Qjlu1u8KAdxXepDfVwrgHqQcN+s3SAD3VR74+yoB3Fcrx836XS2Ae7By3KzfYAHcQzyI8yECuIcqx836DRXAPcwDfw8TwH2Nctys3zUCuId74O/hArivVY6b9btWAPcI5bhZvxECuK9Tjpv1u04A9/XKcbN+1wvgHqkcN+s3UgD3KA/q+SgB3KOV42b9RgvgvkE5btbvBgHcYzyI8zECuMcqx836jRXAfaNy3KzfjQK4xynHzfqNE8A9Xjlu1m+8AO6blONm/W4SwD1BOW7Wb4IA7ps9OMduFsB9i3LcrN8tArhvVY6b9btVAPdE5bhZv4kCuCcpx836TRLAfZsHde02Ady3K8fN+t0ugPsO5bhZvzsEcN/pQZzfKYD7LuW4Wb+7BHDf7YG/7xbAfY9y3KzfPQK471WOm/W7VwD3fR7E+X0CuO9Xjpv1u18A9wMe+PsBAdwPKsfN+j0ogPsh5bhZv4cEcD/sQZw/LID7EeW4Wb9HBHA/6oG/HxXA/Zhy3KzfYwK4H1eOm/V7XAD3Ex7E+RMCuJ9Ujpv1e1IA91PKcbN+Twngflo5btbvaQHczyjHzfo9I4D7WeW4Wb9nBXA/pxw36/ecAO7nleNm/Z4XwP2CB+f3CwK4X1SOm/V7UQD3Sx74+yUB3C8rx836vSyA+xXluFm/VwRwv6ocN+v3qgDu15TjZv1eE8D9unLcrN/rArjfUI6b9XtDAPebynGzfm8K4H7Lg/P7LQHcbyvHzfq9LYD7HeW4Wb93BHC/60GcvyuA+z3luFm/9wRwT1aOm/WbLID7fQ/i/H0B3B8ox836fSCA+0MP/P2hAO6PlONm/T4SwP2xctys38cCuD9Rjpv1+0QA96fKcbN+nwrg/kw5btbvMwHcn3tQzz8XwP2Fctys3xcCuL9Ujpv1+1IA91cexPlXAri/Vo6b9ftaAPc3Hvj7GwHc3yrHzfp9K4D7Ow/8/Z0A7u+V42b9vhfA/YNy3KzfDwK4f/Qgzn8UwP2Tctys308CuH9Wjpv1+1kA9y/KcbN+vwjg/tWD/P5VAPdvynGzfr8J4P5dOW7W73cB3H94EOd/COD+Uzlu1u9PAdx/KcfN+v0lgPtv5bhZv78FcP+jHDfr948A7oa+unGzfixo3LMpx836zSaAu4ty3HyOdRHA3VU5btavqwDu2T3w9+wCuOdQjpv1m0MAdzfluFm/bgK451SOm/WbUwB3dw/yu7sA7rmU42b95hLAPbcH/p5bAPc8ynGzfvMI4J7XA3/PK4B7PuW4Wb/5BHDP74G/5xfAvYBy3KzfAgK4F/TA3wsK4F5IOW7WbyEB3D2U42b9egjg7ulBnPcUwN1LOW7Wr5cA7kbluFm/RgHcvZXjZv16C+BuUo6b9WsSwN2sHDfr1yyAu8WDet4igLtVOW7Wr1UAd5ty3KxfmwDuPspxs359BHD39SC/+wrg7qccN+vXTwB3u3LcrF+7AO6IctysX0QAd3/luFm//gK4F1aOm/VbWAD3Ih7U80UEcC+qHDfrt6gA7sU88PdiArgHKMfN+g0QwL24B/5eXAD3QOW4Wb+BAriX8MDfSwjgXlI5btZvSQHcSynHzfotJYB7aeW4Wb+lBXAv40F+LyOAe1nluFm/ZQVwL+eBv5cTwG2U42b9jABuqxw362cFcEc9iPOoAO6YctysX0wAd9wDf8cFcCeU42b9EgK4kx74OymAO6UcN+uXEsCdVo6b9UsL4M4ox836ZQRwL+9Bfi8vgHsF5bhZvxUEcK+oHDfrt6IA7pU8iPOVBHCvrBw367eyAO5VPPD3KgK4V1WO+1/9BHCv5oG/VxPAvbpy3Kzf6gK411COm/VbQwD3mspxs35rCuBeSzlu1m8tAdxra69rpN/aArjX8aCeryOAe13luFm/dQVwr6ccN+u3ngDu9ZXjZv3WF8C9gQf5vYEA7g2V42b9NhTAvZFy3KzfRgK4N1aOm/XbWAD3Jspxs36bCODe1IO6tqkA7s2U42b9NhPAvbly3Kzf5gK4t/AgzrcQwL2lctys35YCuLdSjpv120oA99bKcbN+Wwvg3kY5btZvGwHc2yrHzfptK4B7Ow/q+XYCuLdXjpv1214A9w4e+HsHAdw7KsfN+u0ogHsnD/y9kwDunZXjZv12FsC9iwf+3kUA967KcbN+uwrgznrg76wA7pxy3KxfTgB3Xjlu1i8vgLugHDfrVxDAXVSOm/UrCuAuKcfN+pUEcO/mQT3fTQD37spxs367C+DewwN/7yGAe0/luFm/PQVw7+WBv/cSwL23ctys394CuPfxwN/7CODeVzlu1m9fAdz7eeDv/QRw768cN+u3vwDuA5TjZv0OEMB9oAdxfqAA7oOU42b9DhLAfbBy3KzfwQK4D/Egzg8RwH2octys36ECuA/zwN+HCeA+XDlu1u9wAdxHKMfN+h0hgPtI5bhZvyMFcB/lQX4fJYD7aOW4Wb+jBXAfoxw363eMAO5jleNm/Y4VwH2cB/l9nADu45XjZv2OF8B9ggf+PkEA94nKcbN+JwrgPskDf58kgPtk5bhZv5MFcJ/igb9PEcB9qnLcrN+pArhP88DfpwngPl05btbvdAHcZ3jg7zMEcJ+pHDfrd6YA7rOU42b9zhLAfbZy3Kzf2QK4z1GOm/U7RwD3ucpxs37nCuA+Tzlu1u88AdznK8fN+p0vgPsC5bhZvwsEcF+oHDfrd6EA7ouU42b9LhLAfbFy3KzfxQK4L1GOm/W7RAD3pcpxs36XCuC+TDlu1u8yAdyXK8fN+l0ugPsK5bhZvysEcF+pHDfrd6UA7kHKcbN+gwRwX6UcN+t3lQDuq5XjZv2uFsA9WDlu1m+wAO4hynGzfkMEcA9Vjpv1GyqAe5hy3KzfMAHc1yjHzfpdI4B7uHLcrN9wAdzX9sXtNTvt0RTAHhxoe1wL9FdQ3xF9BRUe0Re/73VAB0rhvq7vVAOD9hW7KSlxM/Z6cHHpGF2q8Sej6Xg8HY3lsqmozcZzqWQpU8hnS9F0LlrImmLaJAupaDaWzqbjNpfPpk2ukI0mUoVsvJi0UWQsjQzsRf9i3mRKJptIZ1NF2sgUDU1y6WIpGc3m8nETLVhri3H6f9FiIZ7JFZI2l6R/PZGz9L9z+Tqay2eSqRT9L/OFXDxuE5lotpCzKcvg46V0KpazuRipGkslStFiKW4yZAyCWSITxHLFM8txOY0N45lskbbNxZKxYo6ULUUTyWyG/lf5ZDGWjOfYvolYtJSMx8huUROLZ0v5eCJtMtF0Ph4/E2jDUcoPJdZvlEC+jFaOm/UbLYD7BuW4Wb8bBHCPUY6b9RsjgHusctys31gB3Dcqx8363SiAe5xy3KzfOAHc45XjZv3GC+C+STlu1u8mAdwTlONm/SYI4L5ZOW7W72YB3Lcox8363SKA+1bluFm/WwVwT1SOm/WbKIB7knLcrN8kAdy3KcfN+t0mgPt25bhZv9sFcN+hHDfrd4cA7juV42b97hTAfZdy3KzfXQK471aOm/W7WwD3Pcpxs373COC+Vzlu1u9eAdz3KcfN+t0ngPt+5bhZv/sFcD/g6U3dB4Ru6j7YV1DhBwVu6j6k/KYu436o71QDg/YV0ZVvvo4USLKHQ7qpW+uNTmQsPdIXd6PU5WtbKuVLqUKqWIpFo/lUKpeK5ROJXD5PN6xzOUtLhXSGDECrJkX/SjSVTMfSsXze5GyyUPr3hulDjpu61iRTiWQmW6J/gGwSNdbGiqUS4af9CvFs0iRyiWguGSsk0yWCZfNkgUIiFS3Fi5mojY4C2vBR5YcS6/eoQL48phw36/eYAO7HleNm/R4XwP2Ectys3xMCuJ9Ujpv1e1IA91PKcbN+Twngflo5btbvaQHczyjHzfo9I4D7WeW4Wb9nBXA/pxw36/ecAO7nleNm/Z4XwP2Cctys3wsCuF9Ujpv1e1EA90vKcbN+Lwngflk5btbvZQHcryjHzfq9IoD7VeW4Wb9XBXC/phw36/eaAO7XleNm/V4XwP2Gctys3xsCuN9Ujpv1e1MA91vKcbN+bwngfls5btbvbQHc7yjHzfq9I4D7XU9vbr4rdHPzvb6CCr8ncHNzsvKbm4x7ct+pBgbtK6Ir34R8RCDJ3g/p5matN/yQsfRBX9wNQ6evEyVTKuVS2WK+mCjGsjaZS8SjiXg2nSzGc+l0tmAKMfqLYq4UzRSj0UTK0j+USMRS6VQ+X0w/Wo7LaW4QZ1OxeDGXi0WTsbgtlrI2kzOxpC1kbMzkC/FULprMpeLpNN2YLUSTxWKeFkt0zzadIovY7KNAG36o/FBi/T4UyJePlONm/T4SwP2xctys38cCuD9Rjpv1+0QA96fKcbN+nwrg/kw5btbvMwHcnyvHzfp9LoD7C+W4Wb8vBHB/qRw36/elAO6vlONm/b4SwP21ctys39cCuL9Rjpv1+0YA97fKcbN+3wrg/k45btbvOwHc3yvHzfp9L4D7B+W4Wb8fBHD/qBw36/ejAO6flONm/X4SwP2zctys388CuH9Rjpv1+0UA96/KcbN+vwrg/k05btbvNwHcvyvHzfr9LoD7D09v8v0hdJPvz76CCv8pcJPvL+U3+Rj3X32nGhi0r4iufDPuA4Ek+zukm3y13vhCxtI/fXE3zly+pjuV8Ww0m0vQn8ZLiVSM7mta+idMiW5nsjKxQqKQzZh4LpaMZ0q5aCqXN7Gc4X+vlMumPizH5TQ2zGdK2Vw+lY4nCglDMBPRYjRrYimbJ4PYko0niqaQS0eLaYKTSdp8NFGyxRjdMs2xgT5E5mM/3fnC+rGg82U25bhZv9kEcHdRjpv16yKAu6ty3KxfVwHcsyvHzfrNLoB7DuW4Wb85BHB3U46b9esmgHtO5bhZvzkFcHdXjpv16y6Aey7luFm/uQRwz60cN+s3twDueZTjZv3mEcA9r3LcrN+8ArjnU46b9ZtPAPf8ynGzfvML4F5AOW7WbwEB3Asqx836LSiAeyHluFm/hQRw91COm/XrIYC7p3LcrF9PAdy9lONm/XoJ4G5Ujpv1axTA3bufnze7egP9FdS3qZ+gwk398Ps2Ax0ohbu531QDg/YV0ZVvSv0jcLOrBVxcOkb1jZpabwAhY6m1H+4GksvX0WIiljCmlE6m8gW6Sxbnm2bJeCKfSBRyqWisYOneWtSkE8lCrpBK2XQxE8+ZNBkmVYrRHb6GclxOc7Mrak2pmIwlsrl4PhUv0F24XL6UMrl8lO4exjKJZNqQ1iYaLRQyGVui24mFeMIkszlaT2QKDUAbtik/lFi/NoFDqY9y3KxfHwHcfZXjZv36CuDupxw369dPAHe7ctysX7sA7ohy3KxfRAB3f+W4Wb/+ArgXVo6b9VtYAPciynGzfosI4F5UOW7Wb1EB3Ispx836LSaAe4By3KzfAAHciyvHzfotLoB7oHLcrN9AAdxLKMfN+i0hgHtJ5bhZvyUFcC+lHDfrt5QA7qWV42b9lhbAvYxy3KzfMgK4l1WOm/VbVgD3cspxs37LCeA2nt70MUI3fWw/QYWtwE2fqPKbPow72m+qgUH7iujKN2daBZIsFtZNnxpvhCBjKd4PeCPF4WtSImdL0Xy0FEvnSatiNltKJUulUiJrCsl4Kpa3mXwmHqObStl0vJDI0D9sU7FCvFBM5nLpeFs5LqttaLOFTLQUT9Lm6UImS4bMmnyRcOeKJh21iWLeZm3JkKEzxWIuR7fKkoVCMZHMRm2G7FhsA9owofxQYv0SAvmSVI6b9UsK4E4px836pQRwp5XjZv3SArgzynGzfhkB3Msrx836LS+AewXluFm/FQRwr6gcN+u3ogDulZTjZv1WEsC9snLcrN/KArhXUY6b9VtFAPeqynH/q58A7tWU42b9VhPAvbpy3Kzf6gK411COm/VbQwD3mspxs35rCuBeSzlu1m8tAdxrK8fN+q0tgHsd5bhZv3UEcK+rHDfrt64A7vU8vfmxntDNj/X7CSq8vsDNjw2U3/xg3Bv0m2pg0L4iuvJNirhAkm0Y0s2PWm8IIGNpo364GwouX9toKpmPl6KxmEnkY4ZwRosxk02VcsV0Ilcw+VKsWIwWTLaUKNkYKWBtJlUwhVKMNMkWSolyXE5jw0KxkM6kTbYYzRUKNhuPRklDQ5tm0qV8Op9IlxImkUrls4lsIl+M5aL5dCqdTpTyBZNLRGMJoA03Vn4osX4bC+TLJspxs36bCODeVDlu1m9TAdybKcfN+m0mgHtz5bhZv80FcG+hHDfrt4UA7i2V42b9thTAvZVy3KzfVgK4t1aOm/XbWgD3Nspxs37bCODeVjlu1m9bAdzbKcfN+m0ngHt75bhZv+0FcO+gHDfrt4MA7h2V42b9dhTAvZNy3KzfTgK4d1aOm/XbWQD3Lspxs367CODeVTlu1m9XAdxZT28CZIVuAuT6CSqcE7gJkFd+E4Bx5/tNNTBoXxFd+WL9RgJJVgjrJkCNF8aRsVTsh7uw7vR1NkH3DQq2kIpG86V8MsPfbpMt5VN84yORyKRypCL9K5lCPh/LlehvM/TLYjaTz9Pm2dzG5bistmE0aaOJQtaarCkWTDIWTSVMOpvLmmTBkjFj2XzSJmm5kCsWYvFMKREjNIVsJhGLxVLpRGpjoA1Lyg8l1q8kkC+7KcfN+u0mgHt35bhZv90FcO+hHDfrt4cA7j2V42b99hTAvZdy3KzfXgK491aOm/XbWwD3Pspxs377CODeVzlu1m9fAdz7KcfN+u0ngHt/5bhZv/0FcB+gHDfrd4AA7gOV42b9DhTAfZBy3KzfQQK4D1aOm/U7WAD3Icpxs36HCOA+VDlu1u9QAdyHKcfN+h0mgPtwTy+GHy50MfyIfoIKHyFwMfxI5RfDGfeR/aYaGLSviK580bookGRHhXQxvNYLxMhYOrof7gKz09dFE0um4kW6eJ4oJAqpZDJfyEXp6n+2RLcB4qlSqmgzxiRLyWQ0mkkki6l8PJO38XQxbzKxeKJUjstpLoZHk4Zgx9PxeI4uzkcTNh3NxBKxTDJdjGdsgu4zRBPpuE3HEql4KkYX722BLFtK2lgpmc8VSkAbHqP8UGL9jhHIl2OV42b9jhXAfZxy3KzfcQK4j1eOm/U7XgD3Ccpxs34nCOA+UTlu1u9EAdwnKcfN+p0kgPtk5bhZv5MFcJ+iHDfrd4oA7lOV42b9ThXAfZpy3KzfaQK4T1eOm/U7XQD3Gcpxs35nCOA+Uzlu1u9MAdxnKcfN+p0lgPts5bhZv7MFcJ+jHDfrd44A7nM9vSh8rtBF4fP6CSp8nsBF4fOVXxRm3Of3m2pg0L4iuvLF26MFkuyCsC4K13ihFBlLF/bDXWh1+dom08mMzceyyWw8QRsl8vFivpjL5nP5VClrSsloPpYoxTNJ+kWGrjXTNfBcLFEkNWLRWCkaPaYcl9U2tJlCgZQsxbLpQjyZt4m8salkKZdL5DKJYryQT6RMOl0qkWrxgs0V0vF8MlfKJlKFfCFPDjgGaMOLlB9KrN9FAvlysXLcrN/FArgvUY6b9btEAPelynGzfpcK4L5MOW7W7zIB3Jcrx836XS6A+wrluFm/KwRwX6kcN+t3pQDuQcpxs36DBHBfpRw363eVAO6rleNm/a4WwD1YOW7Wb7AA7iHKcbN+QwRwD1WOm/UbKoB7mHLcrN8wAdzXKMfN+l0jgHu4pxdHhwtdHL22n6DC1wpcHB2h/OIo4x7hycVRvoh5oUCSXRfSxdFaLxgiY+n6frgLji5fW9ooatKpWCZBfxhN0v+ylEsXS5lsKkoXf7MEyZRymVI0RjhK6ZjN058S5KhNmWzKFi4qx+U0NsyV0tECGS1VSMUzhixGuuXzdCHZFJOWLjInbLSYz9Kl5UQiak0xmkoWyR7pfDFdSqSLiYuANhyp/FBi/UYK5Mso5bhZv1ECuEcrx836jRbAfYNy3KzfDQK4xyjHzfqNEcA9Vjlu1m+sAO4bleNm/W4UwD1OOW7Wb5wA7vHKcbN+4wVw36QcN+t3kwDuCcpxs34TBHDfrBw363ezAO5blONm/W4RwH2rctys360CuCcqx836TRTAPcnTi4SThC4S3tZPUOHbBC4S3q78IiHjvt2Ti4R8Me96gSS7I6yLhDVeOEPG0p39cBfeXL6OllKJDO2YTmVLuWgxnojlEulkKU3XQkupXKJobTKXTkdp03S8FLWxVDRVSmZK1iboL/Px3MhyXHaZJoaKxVw0n0tk0rZYiCeS8Uw2V8wViiZtC3m6kJnMp5PGForxWDxVTBUKNhlN57LRQjabj8dyqZFAG96l/FBi/e4SyJe7leNm/e4WwH2Pctys3z0CuO9Vjpv1u1cA933KcbN+9wngvl85btbvfgHcDyjHzfo9IID7QeW4Wb8HBXA/pBw36/eQAO6HleNm/R4WwP2Ictys3yMCuB9Vjpv1e1QA92PKcbN+jwngflw5btbvcQHcT3h6sewJoYtlT/YTVPhJgYtlTym/WMa4n/LkYhlf1LpTIMmeDuliWa0XkJCx9Ew/3AUop69j8XQ2bWLpVLGUj2XSuWSBnxHM21QmEc2nC9GkyeSKNhdLZ2MFuoCYyWYLmXwmmbWFjI2Z1F3luJzGhgWbyyaTBCVOumWssSn6v1I2mSnmo7mCMdFolv6vECerZY3JZPlz2ulSIV6MJov5Uu4uoA2fVX4osX7PCuTLc8pxs37PCeB+Xjlu1u95AdwvKMfN+r0ggPtF5bhZvxcFcL+kHDfr95IA7peV42b9XhbA/Ypy3KzfKwK4X1WOm/V7VQD3a8pxs36vCeB+XTlu1u91AdxvKMfN+r0hgPtN5bhZvzcFcL/l6UWjt4QuGr3dT1DhtwUuGr2j/KIR437Hk4tGfHHnGYEkezeki0a1XkhBxtJ7/XAXYpy+juYLpXTU2lgilctl05mMsaVYqZiKZeN0ySyeIpDZTDJl6EpVPsHTWKoUK9h0MR3L2FTh2XJcTnvRKJNMJBM2XyhkivG0taV4MWFzaVMo5LNk3VyctCsWbSoeNdlsMZmlK1vG5qNJm8oni+nEs0AbTlZ+KLF+kwXy5X3luFm/9wVwf6AcN+v3gQDuD5XjZv0+FMD9kXLcrN9HArg/Vo6b9ftYAPcnynGzfp8I4P5UOW7W71MB3J8px836fSaA+3PluFm/zwVwf6EcN+v3hQDuL5XjZv2+FMD9lacXT74SunjydT9Bhb8WuHjyjfKLJ4z7G08unvBFjvcEkuzbsC6e1HhBARlL3/XDXZBw+TpaKsWzsWgmms6nSjafyqVj0US2WDTpfLFkizaRsKlSPJko5ugHQShlYgW6MpNMxOP8lbjRyeW4nMaGJlnK5uKEN5khVaL8ZcDFbD6dSueiyWQqV4jZXClWjKaLMbrck0rGs1n+40ImlyvQ7youeNRqw++VH0qs3/cC+fKDctys3w8CuH9Ujpv1+1EA90/KcbN+Pwng/lk5btbvZwHcvyjHzfr9IoD7V+W4Wb9fBXD/phw36/ebAO7fleNm/X4XwP2Hctys3x8CuP9Ujpv1+1MA91+eXkT4S+giwt/9BBX+W+Aiwj/KLyIw7n88uYjAZP87gSRraA/nIkKtxBoZS7O144i5y9fRVCyaShfyJkaXG0o2m0umoqlEPJqOR5OEPJaz8WiqmLYmm0sU4oV0NJXJpk3UFku5QjSXT39fjstpLiJkYvwVhclCMVoqWFMiVQsFk4qVyFIZk82kkiWbzOTph4mRfhmbj6dSiRRhikcL8Vj2e6ANu7TrzhfWjwWdL12V42b9ugrgnl05btZvdgHccyjHzfrNIYC7m3LcrF83AdxzKsfN+s0pgLu7ctysX3cB3HMpx836zSWAe27luFm/uQVwz6McN+s3jwDuedv9JNPzAv0V1He+dkGF52vH7zs/0IFSuOdvn2pg0L4iujLpnU0gyRYIi0zXSDCRsbRgO46gunwdJTpu08ViPJXMZ3Kloonzt1MVioV8PFfKFnPJUoogERNPROOpUj6ZihVSmXwmm8okEwUb/ZeoMt5pn2pIZWOJdDyTyRPgaC4Xp5VSIZVNxBKJQsrm0nkbzdtUKp6Jl0w+WzAmm0iXCEMmGy0Wo12ANlxI+aHE+i0kkC89lONm/XoI4O6pHDfr11MAdy/luFm/XgK4G5XjZv0aBXD3Vo6b9estgLtJOW7Wr0kAd7Ny3KxfswDuFuW4Wb8WAdytnpLKViFS2dYuqHCbAKnso5xUMu4+npBKJn8LCiRZ37BIZY1ECxlL/dpxRM3l62iG1I/nbMraTCnPX2qSselMmv63pUwxmcoUi4SqmE4VTDGZSReTMVtMJ0q5aCxWsFlirwuV43IaUpkk3pshZYxNZeNRU8zlirk86WzSqZQtxmL85spM3mTTBbqZnM1ZW8pkEkVLf1NMZGx0IaAN25UfSqxfu0C+RJTjZv0iArj7K8fN+vUXwL2wctys38ICuBdRjpv1W0QA96LKcbN+iwrgXkw5btZvMQHcA5TjZv0GCOBe3FNytbgQuRrYLqjwQAFytYRycsW4l/CEXDEJ6ieQZEuGRa5qJBzIWFqqHUdYXL6O2ngyaROxYjaeTZl8IZfOGEs8MRsrJhO2mIobE8sVTTJViJNuNpfLZukuYCmaTZeK2XQs3l6Oy2nIVckSG6WbmEkCX0rkSmTIaN4UC4VMjnZLFNMxE83GbSmfSpOyiXQmlk2VsjZO4BKpfLEdaMOllR9KrN/SAvmyjHLcrN8yAriXVY6b9VtWAPdyynGzfssJ4DbKcbN+RgC3VY6b9bMCuKPKcbN+UQHcMU9JRkyIZMTbBRWOC5CMhHKSwbgTnpAMJgNLCSRZMiySUWPjjYylVDuucXf5OprOxdIZa2M5W7D5aDyfymejiWSuGI3T3Z9sPp8kdIlS3EaT6VQxaVK5eDHDd45yiSx/Rf3S5bichmSkciafSBLpsvF03NAdpXQyauLZTCmWLJVIXZvKxKOJOKltStGYyZOySZuxKfpnU9lUcmmgDdPKDyXWLy2QLxnluFm/jADu5ZXjZv2WF8C9gnLcrN8KArhXVI6b9VtRAPdKynGzfisJ4F7Z02Z7ZaFme5V2QYVXEWi2V1XebP/rKE+abW6KUwJJtlpYzXaNDSgyllZvxzWwLl/bTKpgTSoRIwaRSdJ/pGmzuM1kMtE0dekFk02mM9FiLB/Np6JxupOQLMSydDcjlkhGi6nSv43iqo5m2xIhiBVKhSy/SSOTsYVSIl+k2xF07yNDGI0t5HOJRDKeS5bYwJkM3R4hUpDPZTMFMo1NA224hvJDifVbQyBf1lSOm/VbUwD3Wspxs35rCeBeWzlu1m9tAdzrKMfN+q0jgHtdT5vOdYWazvXaBRVeT6DpXF9508m41/ek6eTmcHWBJNsgpKaz1kYMGUsbtuMaOZevbT6ej1FLTe1rJmMSdPXYxJLZuImlaDmbzBZtumAL0XgiWqCNC9Rmx/OlbLpYKKZMqZBPr1GOy2lsGKd/MR4vJHImbUr5LPfuhVwqGc/kSH/SL5lN5nPReDRZjEXjuWIhl4lT35ygdrNkorHsGkAbbqT8UGL9NhLIl42V42b9NhbAvYly3KzfJgK4N1WOm/XbVAD3Zp42X5sJNV+btwsqvLlA87WF8uaLcW/hSfPFTdKGAkm2ZVjNV40NCTKWtmrHNTQuX0eTmZLNZfN0LTFJlxNTUVtIRxPZTIyfBU7Qlc+8zdlYNF9KRulqZoqvM9IlxrjJxePZYiEW3agcl9PcXs/kE/Q/SxL+XCZW4Mei01FjCvFU3uSi2UwmT0bkL/GJpYtFurIaKxYLcfqfxHK5hI0WKhqmWm24tfJDifXbWiBftlGOm/XbRgD3tspxs37bCuDeztMmZDuhJmT7dkGFtxdoQnZQ3oQw7h08aUK4WdhKIMl2DOu2Y40HMzKWdmrHHexOX9NVJMJn8tlkomiobcnRv59MmWKeui662JUu5hPFfDKVjCazqXiJrnzl88Vcnv4HJdK4lNq6HJfT2NCadJTu1lpqi3KleNHmk0UyE12qKhQSJp3PZJKFEv1bdE+0WMpl0jlrE4SP2icyWNLktgbacGflhxLrt7NAvuyiHDfrt4sA7l09PYx3FTqMs+2CCmcFDuOc8sOYcec8OYz50NxJIMnyIR3GtR5QyFgqtOMOOKevEzFToH/XplN06cDwzvFsKp0sZgs2mYkmC4kCb0faZqPJZDqZLSXi8XSc7kbFo1mbju5cjstpDuNcLJYqkIrUucRL0WgxTwCL0VKGdijS3a1ENBlNxZLJUtqmTNZQL5OmqxrxLPU5hUQxXXGA1mrDovJDifUrCuRLydNDqSR0KO3WLqjwbgKH0u7KDyXGvbsnhxIfHgWBJNsjrEOpxkKNjKU923GFfkZ8nYvl44VUphC32YxNJdL5XDyTjyVsKk/HWjybiNLJW7LRWNKkS/kMHcbluOwyHV+beDqXLFoCVkjHLZkgX8xG46VkqUAa54r5aMxGTTxFu6bonkAsWQTacC9Pi/NeQsV573ZBhfcWKM77KC/OjHsfT4ozF9E9BYrzvmEV56oxswULGUv7teMKnsvXCJ/sJ+Dr/YP3TtOxKJ06/HfpgrHxQj6ajkYLubihy6n5aDETt5lSPBqP5Qv5HO2ZtSVTyuYzpfSUvcIsqPsLFdQD2gUVPkCgoB6ovKAy7gMFCioH29wNU4uKa3T8W7UGtoRdOhIabZdgMB8UiDd45TgQl4GWdeta1rFD6dkDa51hMLUNMScEg/Lg8v6HMC4JJxwkUFUOEr74g8I9vZZiJkcF7lp1PFT5BTQOzEMFWorDwEdzRxHgfY8v74u2xSFCtjhcyBaHC9pCqtU8QnlNkcqHewb8r+LOT0c/sdi/d4Du+seYjxA4Q4D+tkgbckPFMiMd8/T2ml5MBfeUOLdQNgk2l0f+V7dsahv2UKGDIKj0TOpsp/fvsM5HChSG+8GFoWPMPpM+m5kGrlbMR7XrLDBIXwTj8qhAgzKr/pmezZH+OTp4HSwWo9wopGypUIolUplozib5Xky8lEqm4wW6RZQtpIo2no1FM/xxBv6iqFQixl/lmynkk6Vg0baFWCxeyOTylm7pZHMmXYhlTSmeikVNtkC3gAqxdDKZjcUKyXQpnaGrEtlSLG0SqVTGJKOxTFTKP0c7/DOzB+H0Lpsg/XOMUP08BmCH6V1eQtrhWCE7HFu2w381CZoPcoe6sDgONgnH+dgkHCfcJBwn0CQ8EFKTMD32FGaROx64F7JJeEDoEDp+BpqE6dnB8lMq1pRMhk5Uk8onU7lMIZpL0zlaSsQKMaR/TmjHHezIJkHKPyfUcJVpennTcQW3KzYfZ+Z+2HT3Ql4NPrEdeyB1+OjEGnw0vcZlFn003ZycmXuW09sL6aOT2nG2C/ropEBzVX1Lq2EWfTc99ZBXW4PN4Mnl21mnuG5nmdqG7ey2DvJeZa17AW+NOV/1Y2obdlaT9n/LhrXudapyf3DCnCrQIJ8mRBZOE7y1dIqQLU4XssXp/2GLWnWWiouHlN9ukoqBh5XfbjqijBt9uwnob/tw/XZT9fi3fqNsEmz8zpC8knSqUEE8Q/BKEut8hkBheMST202nApuiM9t1FphHhK5UnBnC7Sakf84C3m56GHglSco/Z83A7YWGmfTXjDy12zF8ORTO9vFQOFv4UDhb4FB4VMmh0GkQp0r/DmTROUfpofCoUNE5B3AoTO8yH9I/5yo9FKT8c27gUAjrc0PBy6I1fizEBvU9r11Q4fMctLFW5c8DFoPzgUkgZcPzHYdIrTY8X/iJZlPb+PfAP1/gUjCy6CFj5wLwpeCOgb4dcQQQ84XKn6rvLAZNbQPZzELr10Vgf6AvF3LsAXW0nHMXCjToF4PJSveGqTHI/z2Q5O/ynP+tv7F2/vff7BL49yJ9pv57/cvzS+jfvZTkso7mIfD3SJ9fBrQlN2stAVtK6n2JkgcE/3tE5fa2U68O/BtD5fnlZJcrSK4kGURyFcnVJINJhpAMJRlGcg3JcJJrSUaQXEdyPclIklEko0luIBlDMpbkRpJxJONJbiKZQHIzyS0kt5JMJJnUXlamo4tnZbpXrV3hWLvSsTbIsXaVY+1qx9pgx9oQx9pQx9owx9o1jrXhjrVrHWsjHGvXOdaud6yNdKyNcqyNdqzd4Fgb41gb61i70bE2zrE23rF2k2NtgmPtZsfaLY61Wx1rEx1rk8prwdG//HPV8k9T26goOrUeYpcD9ir+ex3I2CtAezHGKyF7TbHXoNr3inbcx7uq1r3iU+8JXl3bXiZ4f3FwLXtFK+9VDpn1vUz1fc+hs7gXXSSa5h7qsFnbK+26H3vNrOyVdt/bHT7ze6U6u0987czuler8nvOImdsr+l/3r6+bmb1S/30v/PoZ32u6z2qMnNG9UtOthXbUjO1lZqCu2tEzspeZoRptb5j+XokZrPd2zPT2is/w2WHH/ude/AbbGd/rxv/aKzVTZ5od1/le6Zk8H+34TvbKlGb6rLU3ufcys3Bu2wmuvcws9QD25mn3srPYT9hbqvcqzHJvYm+t3CtWQ59jJwb2ipZq6pnsJCDp475xbMNU4jSpTGJuLZOam8sk56Yy6RlXJkFjy6TohjJJGlUmTdeXSdSIMqkaXiZZw8qka0iZhF1dJmWDyiSNezfuBXmEebdjEqz/LFTc7bitXVBh3hx1xbVD+dtwQWVvBxIEKRuyjqgrch02vB2YmJwEzQ3hfMwUV1AKold6gra4o5xgd1Zfbbmj7Njg2p0OVoy+3I6rJMbeAUygO8HORQcfJ80dwGTswH0HOBnDOpEmwuIoUwjqe1e7oMJ3wU+kTOEu4Il0t/ITiW14N/xEyhTu9vREmgjTO5N3qCtyIt1TTrB7q0+kexwn0r0hnEgTgSfSPcAEulfIueiHEJCY7wMWs4YG/Gl5e7kAoW+mI6nA/cBi5rKhqW1Y9vH9Ap3M/Z52MrfC6k8uFtT3gXZBhR+AdzK52APA5H9QeSfDNnwQ3snkYg8KJz+igN6vvIA+BLZhx0AfvMgYfxiYe2F2wLfC9M5FHeqKdMCPlAvzo9Ud8COODvjREDpg3Alk7CPAoHxUyLnoRERifky4Aza1DcvF8WGB7u1x5V0r++VxD3BLxfjjwBh/QnmMd9akIJof1F5Pgg/ssNjOLbCzJl0K6vtUu6DCT8HZTrr0FNCBTytnO2zDp+FsJ116Wjnb4UL3ZLvuYvwMuBh3DDRmZIw/6ynbuQWmd7roUFeE7TxXLszPV7Od5xxs5/kQ2A7uBDL2OWBQPi/kXHQiIjG/oLwT5OL4rEDX/6JytsN+edED3FIx/iIwxl9SHuOdNSmmtmGRTcrLnt7buRl21kQrXu/zSrugwq/A2U7UvAJMgleVsx224atwthM1rypnO1zoXm7XXYxf84TtIGP8dU/Zzs0wvW3Joa4I23mjXJjfrGY7bzjYzpshsB3cCWTsG8CgfFPIuehERGJ+S3knyMXxdYGu/23lbIf98rYHuKVi/G1gjL+jPMY7a1JMbcMim5R3PWU7E2BnTaGC7bzXLqjwe3C2UzDvAZNgsnK2wzacDGc7BTNZOdvhQvduu+5i/L4nbAcZ4x94ynYmwPTOh8Z2PiwX5o+q2c6HDrbzUQhsB3cCGfshMCg/EnIuOhGRmD9W3glycfxAoOv/RDnbYb984gFuqRj/BBjjnyqP8c6aFFPbsMgm5TNP2c5NsLMmWfFOjM/bBRX+HM52kvZzYBJ8oZztsA2/gLOdZAVuU+Nw4UYUus/adRfjLz1hO8gY/8pTtnMTTO9kaO9S+bpcmL+pZjtfO9jONyGwHdwJZOzXwKD8Rsi56EREYv5WeSfIxfErga7/O+Vsh/3ynQe4pWL8O2CMf688xjtrUkxtwyKblB88ZTvjcfd20kF9f2wXVPhH/L2d9I/AJPhJOdthG/6Ev7eT/kk52+FC90O77mL8sydsBxnjv3jKdsbD9C6kHOqKsJ1fy4X5t2q286uD7fwWAtvBnUDG/goMyt+EnItORCTm35V3glwcfxHo+v9QznbYL394gFsqxv8AxvifymO8sybF1DYsskn5y1O2Mw521sQzQX3/bhdU+G8424ln/gYmwT/K2Q7b8B8424ln/lHOdrjQ/dWuuxg3RPxgO8gYnw2IOUy2Mw4W7/G0Q10RttMlMuVn10hDJbPhX1SzHf4jabaDO4GM7RLBBWXXiIxz0YmIxDx7BFt80AnHxXG2CP5gmCMie3CZ2oZlv8zhAW6pGJ8DGOPdlMd4Z02KqW1YZJMyJ86GobKdG2FnTa7iSbbuEUGFeXMs28nZ7sAkmCuim+2wDVlHLNvJVeA2NQ4XbkShmzOiuxjPHcEW446BxoyM8XmAmMNkOzfC2E4utCfZ5o1M+TlfpKGS2fAvqtkO/5E027kRyHYYQ617dQTlfBEZ56ITEYl5/gi2+KATjovjPBH8wbBARPbgMrUNy35ZwAPcUjG+ADDGF1Qe4501Kaa2YZFNykLAuAmT7YzFsZ18UN8eEUGFe0TgbCffA5gEPYGBJWVD1hHMdvI9I7KHBqLQLRTRXYx7RbDFuGOgMSNjvBGIOUy2MxbHdnIOdUXYTu/IlJ9NkYZKZsO/qGY7/EfSbGcskO30juCCsiki41x0IiIxN0ewxQedcFwcGyP4g6ElIntwmdqGZb+0eIBbKsZbgDHeqjzGO2tSTG3DIpuUNmDchMl2xuCeZMsF9e0TEVS4TwT+JFuuDzAJ+gIDS8qGrCP4SbZc34jsoYEodG0R3cW4XwRbjDsGGjMyxtuBmMNkO2NwT7JlHeqKsJ1IZMrP/pGGSmbDv6hmO/xH0mxnDJDtRCK4oOwfkXEuOhGRmBeOYIsPOuG4OLZH8AfDIhHZg8vUNiz7ZREPcEvF+CLAGF9UeYx31qSY2oZFNimLAeMmTLZzA+ysSVe8gXpARFDhARH4t4uaAcAkWBwYWFI2ZB2xbCdtFo/IHhqIQrdYRHcxHhjBFuOOgcaMjPElgJjDZDs3wNhOKrQ3UC8ZmfJzqUhDJbPhX1SzHf4jabZzA5DtLBnBBeVSERnnohMRiXnpCLb4oBOOi+MSEfzBsExE9uAytQ3LflnGA9xSMb4MMMaXVR7jnTUpprZhkU3KcsC4CZPtjBZiOyYiqLCJ4NmOASaBBQaWlA1ZRzTbsRHZQwNR6JaL6C7G0Qi2GHcMNGZkjMeAmMNkO6M9ZDvxyJSfiUhDJbPhX1SzHf4jabYzGsh24hFcUCYifrAdJOZkBFt80AnHxTEWwR8MqYjswWVqG5b9kvIAt1SMp4AxnlYe4501Kaa2YZFNSgYYN2GynVGwsyZb8U625SOCCi8fQbOdbGZ5YBKsAAwsKRuyjli2k82sEJE9NBCFLhPRXYxXjGCLccdAY0bG+EpAzGGynVEwtpMN7Z1sK0em/Fwl0lDJbPgX1WyH/0ia7YwCsp2VI7igXCUi41x0IiIxrxrBFh90wnFxXCmCPxhWi8geXKa2Ydkvq3mAWyrGVwPG+OrKY7yzJsXUNiyySVkDGDdhsp2ROLYTD+q7ZkRQ4TUjcLYTXxOYBGsBA0vKhqwjmO3E14rIHhqIQrdGRHcxXjuCLcYdA40ZGePrADGHyXZG4thOzKGuCNtZNzLl53qRhkpmw7+oZjv8R9JsZySQ7awbwQXlehEZ56ITEYl5/Qi2+KATjovjOhH8wbBBRPbgMrUNy37ZwAPcUjG+ATDGN1Qe4501Kaa2YVcD2nAjYNyEyXaux327aMW9nY0jggpvHIF/u2hmY2ASbAIMLCkbso5YtlPIbBKRPTQQhW6jiO5ivGkEW4w7BhozMsY3A2IOk+1cj/sCytDu7WwemfJzi0hDJbPhX1SzHf4jabZzPZDtbB7BBeUWERnnohMRiXnLCLb4oBOOi+NmEfzBsFVE9uAytQ3LftnKA9xSMb4VMMa3Vh7jnTUpprZhkU3KNsC4CZPtXAc7a/LFoL7bRgQV3jaCZjv54rbAJNgOGFhSNmQdsWwnX9wuIntoIArdNhHdxXj7CLYYdww0ZmSM7wDEHCbbuQ7GdvIFh7oibGfHyJSfO0UaKpkN/6Ka7fAfSbOd64BsZ8cILih3isg4F52ISMw7R7DFB51wXBx3iOAPhl0isgeXqW1Y9ssuHuCWivFdgDG+q/IY76xJMbUNi2xSssC4CZPtjICdNbbi3k4uIqhwLoJmOzaTAyZBHhhYUjZkHbFsx2byEdlDA1HoshHdxbgQwRbjjoHGjIzxIhBzmGxnBIzt2NDu7ZQiU37uFmmoZDb8i2q2w38kzXZGANlOKYILyt0iMs5FJyIS8+4RbPFBJxwXx2IEfzDsEZE9uExtw7Jf9vAAt1SM7wGM8T2Vx3hnTYqpbVhkk7IXMG7CZDvX4r5dtILt7B0RVHjvCPzbRTN7A5NgH2BgSdmQdcSynVxmn4jsoYEodHtFdBfjfSPYYtwx0JiRMb4fEHOYbOda3LeLhsZ29o9M+XlApKGS2fAvqtkO/5E027kWyHb2j+CC8oCIjHPRiYjEfGAEW3zQCcfFcb8I/mA4KCJ7cJnahmW/HOQBbqkYPwgY4wcrj/HOmhRT27DIJuUQYNyEyXaG495AnQ7qe2hEUOFDI/A3UKcPBSbBYcDAkrIh64hlO+n0YRHZQwNR6A6J6C7Gh0ewxbhjoDEjY/wIIOYw2c5wGNtJpxzqirCdIyNTfh4VaahkNvyLarbDfyTNdoYD2c6REVxQHhWRcS46EZGYj45giw864bg4HhHBHwzHRGQPLlPbsOyXYzzALRXjxwBj/FjlMd5Zk2JqGxbZpBwHjJsw2c41sLMmXsF2jo8IKnx8BM124unjgUlwAjCwpGzIOmLZTjx9QkT20EAUuuMiuovxiRFsMe4YaMzIGD8JiDlMtnMNjO3EQ2M7J0em/Dwl0lDJbPgX1WyH/0ia7VwDZDsnR3BBeUpExrnoRERiPjWCLT7ohOPieFIEfzCcFpE9uExtw7JfTvMAt1SMnwaM8dOVx3hnTYqpbVhkk3IGMG7CZDvDYGdNxgb1PTMiqPCZETTbydgzgUlwFjCwpGzIOmLZTqYCt6lxuHAjCt0ZEd3F+OwIthh3DDRmZIyfA8QcJtsZBmM7GeNQV4TtnBuZ8vO8SEMls+FfVLMd/iNptjMMyHbOjeCC8ryIjHPRiYjEfH4EW3zQCcfF8ZwI/mC4ICJ7cJnahmW/XOABbqkYvwAY4xcqj/HOmhRT27DIJuUiYNyEyXaGws6alAnqe3FEUOGLI2i2kzIXA5PgEmBgSdmQdcSynZS5JCJ7aCAK3UUR3cX40gi2GHcMNGZkjF8GxBwm2xkKYzvJkkNdEbZzeWTKzysiDZXMhn9RzXb4j6TZzlAg27k8ggvKKyIyzkUnIhLzlRFs8UEnHBfHyyL4g2FQRPbgMrUNy34Z5AFuqRgfBIzxq5THeGdNiqltWGSTcjUwbsJkO0NwbymoeAP14IigwoMj8LcUFAcDk2AIMLCkbMg6gt9SUBwSkT00EIXu6ojuYjw0gi3GHQONGRnjw4CYw2Q7Q3BvKQjtDdTXRKb8HB5pqGQ2/ItqtsN/JM12hgDZzjURXFAOj8g4F52ISMzXRrDFB355gfQbFsEfDCMisgeXqW1Y9ssID3BLxfgIYIxfpzzGO2tSTG3DIpuU64FxEybbGQw7a6IV93ZGRgQVHhlBs52oGQlMglHAwJKyIeuIZTtRMyoie2ggCt31Ed3FeHQEW4w7BhozMsZvAGIOk+0Mxr2BOrR7O2MiU36OjTRUMhv+RTXb4T+SZjuDgWxnTAQXlGMjMs5FJyIS840RbPFBJxwXxxsi+INhXET24DK1Dct+GecBbqkYHweM8fHKY7yzJsXUNiyySbkJGDdhsp2rcWdNPqjvhIigwhMiaLZj8hOASXAzMLCkbMg6YtmOyd8ckT00EIXupojuYnxLBFuMOwYaMzLGbwViDpPtXA1jOybnUFeE7UyMTPk5KdJQyWz4F9Vsh/9Imu0ATyA7MYILykkRGeeiExGJ+bYItvigE46L460R/MFwe0T24DK1Dct+ud0D3FIxfjswxu9QHuOdNSmmtmGRTcqdwLgJk+1cBTtrkhVPst0VEVT4rgia7SSLdwGT4G5gYEnZkHXEsp1k8e6I7KGBKHR3RnQX43si2GLcMdCYkTF+LxBzmGznKtzndkJ7ku2+yJSf90caKpkN/6Ka7fAfSbOdq4Bs574ILijvj8g4F52ISMwPRLDFB51wXBzvjeAPhgcjsgeXqW1Y9suDHuCWivEHgTH+kPIY76xJMbUNi2xSHgbGTZhsZxDsrLEV72R7JCKo8CMRNNux9hFgEjwKDCwpG7KOWLZjK3CbGocLN6LQPRzRXYwfi2CLccdAY0bG+ONAzGGynUG4J9lCeyfbE5EpP5+MNFQyG/5FNdvhP5JmO4OAbOeJCC4on4zIOBediEjMT0WwxQedcFwcH4/gD4anI7IHl6ltWPbL0x7glorxp4Ex/ozyGO+sSTG1DYtsUp4Fxk2YbOdK3MMYFZ/beS4iqDBvjt73eWAwSOF+PjLVwKB9RVgFFxROCM1F74WIH6wCGZcvRmQLPcInrCM6xsMsqFcIFdSXIoIK8+bofV+O6C6ojPvlSAM82CR05cR4OSKTcCjcYSbZ5e04GwT1fSUiqDBvjj4dXsE50L4a0Z2wbMNXBZLg1YjuboqT9NUInv68APT3axHdBZRjh3VswO4rSvFfA/rn9Yhs52dqG7YzxmBqGxbJGN6I6I5x9jHriN4XGYdhNgmXBpoEm45Fo6kY65QuGBsv5KPpaLSQi5u8yeajxUzcZkrxaDyWL+RzpH/Wlkwpm8+U0lP2Cur7ZkRQ4TcdSVCr8m/iAte+BQwGKRu+5UiCWm34Fs6G/ybB3A3h3JC7tF3msGvA2reiC387EigQ6G4K6EgbvDEYVHomdc7PSPDx/jN7Ok7P6G9HcHZ9B2dXE7Qr73v8LMYC3ei1eWtKJhM1WZPKJ1O5TCGaS2dLsVIiVojNql2nF+xIu74rZNd3y3adPbBWPTQXo2DxfC8y5edk+jmbRMEIJjfKGMEgMTWOhgaZQjkryWFmAnetOr4vbENT27AcmO9H8L75ICJTFHjf48v7om0xWcgWHwrZ4sPIrB8809NZKi7eGPC/WlPy09FPLAbeHKC7DvDBx7jRtRTob4u0ITcVLC6G0zCTNpheTAX3lKjfKJsEG6yPIv/BcExtwyIPxWBBDCo9kzrb6f07rHNw/459a25iwIWhY8w+kz6bmUamVswfR3QWGKQvgnHJeI9vqBwz65/p2Rzpn08Ce9lYjHKjkLKlQimWSGWiOZuMJZOleCmVTMcLpUQ8W0gVbTwbi2aKKVOy6WIxlYjlU8lSppBPloJF2xZisXghk8vbRDSZzZl0IZY1pXgqRuS3EEsVCrF0MpmNxQrJdCmdIcJKNDhtEqlUxiSjsUxUyj+fRKYyTdShML0rG8E9fTkUPo14eCgElZY4FIL7d+xbawK+reRQ6DSIU/8+vF9CFp3PIjoPhbeFig7jPb6hcsysf6Z3mQ/pn88jOg8FKf98Hvm/c/nxi8iUn19GHJcfTW2j02v/yPsgNRfUiO6nCzps2NUTG9a611fK/cEJwzqiD/avIzLFivc9vrwv2hZfCtniGyFbfBORuywqFRfvKr8sKhUD73lwWZRxoy+LAv1t36tfFq0e/9ZvlE2Cjd+3EUEGDDwUKwpiUGk0A2adg/t37FtrYZjsyWXRoM9qxfxdRGeBmSzEsBjv8Q2VA31ZFOmf7yM4BvwekAFL+ed7h39m9iCc3mVQpH9+iMjY4QeAHaZ3pQZphx+F7PBjZPqXyTUf5A51YXEcbBJ+injYJASVlmgSgvt37Fvzw1UhNQk1Ph0LLXI/A/dCNgnvCx1CjPf4hsoxk/6Z7lO2SP/8EsEd7MgmQco/v0TkrrZMKrNv9OurJsFeX5W2yNj5NYLCmK7wEe/LrwTjA3tsw7QDZNf/qaHoM2/+rvp1/C0C1rGLUDKhAPNeDPr/l+T8PYJLTuFEtP8/JyLOT6SjrxWzvweO+iNSd5Tdtpt+Hf+M1B1lEx5k1F+RuqPsch446u9I3VF2Rw9K3z+RuqPszh44qqF/3VF2Vw8cNVvdUcbmPHBUl7qjjC144KiudUcZW/LAUbPXHWXs7h44ao66o4zd0wNHdas7yti9PXDUnHVHGbuvB47qXneUsQd5cAlprrqjjD3Ag4yau+4oY0d7kFHz1B1l7MEeZNS8dUcZe6gHjpqv7ihjD/fAUfPXHWXskR44aoG6o4w92gNHLVh3lLEPetD1LVR3lLHHeZBRPeqOMvYEDxzVs+4oY0/ywFG96o4y9hQPHNVYd5Sxp3ngqN51Rxl7hgeOaqo7ytizPHBUc91Rxp7jgaNakI7iD/gu0DD1s2WsbP8qp3UBA5D63JmpaaQNGifrNhH47bS8H3+UR/PHgyRseCvYhn8K2BD5yR0JG94CtuFfAjZEfqhGwoY3g234t4ANkZ93kbDhBLAN/xGwIfKjKBI2vAlsQz7wNX9KRMKG48E2nE3AhrMpt+E4sA27CNiwi3Ib3gi2YVcBG3ZVbsOxYBvOLmDD2ZXbcAzYhnMI2HAO5Ta8AWzDbgI27KbchqPBNpxTwIZzKrfhKLANuwvYsLtyG44E23AuARvOpdyG14NtOLeADedWbsPrwDacR8CG8yi34QiwDecVsOG8ym14LdiG8wnYcD7lNhwOtuH8AjacX7kNrwHbcAEBGy6g3IbDwDZcUMCGCyq34VCwDRcSsOFCym04BGzDHgI27KHchoPBNuwpYMOeym14NdiGvQRs2Eu5Da8C27BRwIaNym04CGzD3gI27K3chleCbdgkYMMm5Ta8AmzDZgEbNiu34eVgG7YI2BD6IGHVwOwbSzY4BmbvqJXbe2pMsc8WLM9byd5tJH1I+pL0I2kniZD0J1mYZBGSRUkWIxlAsjjJQJIlyg9lLtm/vGnHN07wppGqtTbHWh/HWl/HWj/HWrtjLeJY6+9YW7K8xgOdaBOrvmgB9YDlzH413n9rOeULIWrVkR94TRvot1JVPPhZq+2WAhUT/iKnYPwsFYifBok4spW612qHpYFFNWiHpQXz6FaBPOIHYtFfWAJ8yNYuDfT5MkI+XyaE2F8GaIdlheywrGDs3yIQ+38JxD7w4Wi7LNDnywn5fDnp2Cc7tCq1A+8xOxjrBOSXUlHduBmUN1M+yDOlr/kbnIf/oPOQcAMfsK940LxWvEYoD00IZ5AB5qEVsoMVPINuEjiD+AF89BkEfKjfWqDPo0I+j4YQ+1GgHWJCdogJxv54gdifTSD2gR/GsDGgz+NCPo+H0H+1KbUD74Huv24E91/jBPqvLv2xedi1P77/An6gp+KDLbXiTQjlYSKEMygBtENSyA5JwTNorMAZNLvAGQT8EJFNAn2eEvJ5KoTYTwHtkBayQ1ow9scIxP4cArEP/PCXTQN9nhHyeSaE/quPUjvwHuj+azS4/7pBoP/qBu6/5hTov4AfIKz4IF2teJcXysPlQziDlgfaYQUhO6wgeAaNEjiDugucQcAPLdoVgD5fUcjnK4YQ+ysC7bCSkB1WEoz9kQKxP5dA7AM/bGpXAvp8ZSGfrxxC/9VXqR14D3T/dR24/7peoP+aG9x/zSPQfwE/sFzxwd1a8a4ilIerhHAGrQK0w6pCdlhV8AwaIXAGzStwBgE/JG1XBfp8NSGfrxZC7K8GtMPqQnZYXTD2rxWI/fkEYh/44Xa7OtDnawj5fI0Q+q9+Su3Ae6D7r2vA/ddwgf5rfnD/tYBA/wV8QULFiwJqxbumUB6uGcIZtCbQDmsJ2WEtwTNomMAZtKDAGQR8KYNdC+jztYV8vnYIsb820A7rCNlhHcHYHyoQ+wsJxD7wZRp2HaDP1xXy+boh9F/tSu3Ae6D7r8Hg/muIQP/VA9x/9RTov4AvZKl4MUmteNcTysP1QjiD1gPaYX0hO6wveAZdLXAG9RI4g4AvgbHrA32+gZDPNwgh9jcA2mFDITtsKBj7VwnEfqNA7ANf3mM3BPp8IyGfbxRC/xVRagfeA91/XQnuvwYJ9F+9wf1Xk0D/BXwBVMWLkGrFu7FQHm4cwhm0MdAOmwjZYRPBM+gKgTOoWeAMAr50ym4C9PmmQj7fNITY3xRoh82E7LCZYOxfLhD7LQKxD3xZmN0M6PPNhXy+eQj9V3+ldghing2MeWEA5lx2yl6Sei7iiT0X9UTPxTzRc4Anei7uiZ4DPdFzCaCezF35pY/BL9VesKFyoPVvFbAzWsc2D3Ts44GOfT3QsZ8HOrZ7oGPEAx37C9V4hI6xZFpkXyl96/v+39oXt3c0Kri37agJwV5lC8rrLUm2ItmaZBuSbUm2I9meZAeSHUl2ItmZZBeSXUmyJLn+DZUvgt6i/7Qvh97SsbaVY21rx9o2jrVtHWvbOda2d6xlHWu58ho3dM0NUy8ABAe6mO7QX30w8iv7TNAW+f5Tfhaqnc6/qO580VemdgBcUeC7MLxXHnhFpuAJ8/FFzx090XMnT/Tc2RM9d/FEz1090RNRL3OZf7vqiiuw1VfHa62fwCsadgsh36AxA6+Q2C09wQy84mK38gQz8AqO3doTzMArQnYbTzADrzDZbT3BDLxiZbfzBDPwCpjdPiTMZtaG7ZhkgVypCMQc5J/BfcF26Bg2B/R9EcRlS8VShvH3LNsh+C1hwW8HC34rWPDbwILfAhb89q/gt371D8w/6TF1Pn/XWZ8HL8LkAvNPA/t/Fph/Hph/EZh/GZh/FZh/HZh/U57vRv/O7iR7kOxJshfJ3iT7kOzbf8rFn5aGqdctggPdm+8mlPsNWD3jYnvbKfnbYduOp4D3I7vsT3IAyYH9GyovMvEvu1et7e9YO8CxdmB5LTjmwBqrwqm1Fsr9UAWiZOz+oL0Y4wGQvabY60BgEoSZvLvXk9eZvAeRXQ4mOYTk0OrkPciRlAc71g5xrB0aQvLuDkzeg4DJezAweQ8BJu+hnibvHvXkdSbvYWSXw0mOIDmyOnkPcyTl4Y61IxxrR4aQvHsAk/cwYPIeDkzeI4DJe6SnybtnPXmdyXsU2eVokmNIjq1O3qMcSXm0Y+0Yx9qxISTvnsDkPQqYvEcDk/cYYPIe62ny7lVPXmfyHkd2OZ7kBJITq5P3OEdSHu9YO8GxdmIIybsXMHmPAybv8cDkPQGYvCd6mrx715PXmbwnkV1OJjmF5NTq5D3JkZQnO9ZOcaydGkLy7g1M3pOAyXsyMHlPASbvqZ4m7z715HUm72lkl9NJziA5szp5T3Mk5emOtTMca2eGkLz7AJP3NGDyng5M3jOAyXump8m7bz15ncl7FtnlbJJzSM6tTt6zHEl5tmPtHMfauSEk777A5D0LmLxnA5P3HGDyngtMgo5gGtoADlQa3ev71fer71ffr75ffb/6fvX96vtp3s929P7Rpqk8wAbmJjBfLjBfNjBfJjBfOjBfKjBfMjBfIjAfGJgvHpgPCMwXC8wXDcwXCcwXDsz7B+aRwLw9MO8XmPcNzPsE5m2BeWtg3hKYNwfmTYF578C8MTDvFZj3DMwPaZ46PzgwPygwPzAwPyAw3z8w3y8w3zcw3ycw3zsw3ysw3zMw3yMw3z0w3y0wLwXmxcC8EJjnA/NcYJ4NzHcNzHcJzHcOzHcKzHcMzHcIzLcPzLcLzLcNzLcJzLcOzG9rmTqfFJhPDMxvDcxvCcxvDswnBOY3BebjA/NxgfmNgfnYwHxMYH5DYD46MB8VmI8MzK8PzK8LzEcE5tcG5sMD82sC82GB+dDAfEhgPjgwvzowvyowHxSYXxmYXxGY/9E6df57YP5bYP5rYP5LYP5zYP5TYP5jYP5DYP59YP5dYP5tYP5NYP51YP5VYP5lYP5FYP55YP5ZYP5pYP5JYP5xYP5RYP5hYP5BYP5+YD45MH8vMH83MH8nMH87MH8rMO+4VcrzEwLz4K3W4K3YUwPz4N2b4N2d4N2fMwPz4AXj4AXl4AXncwPz4DWq4DWs4DWuAwPz4OPPwcejg49PHxqYB5+4DD6RGXxi88jAPPiQV/AhsOBDYscG5sHnSoLPnXQ8lzK+Yco4j/77fJILSC4kuYjkYpJLSC4luYzkcpIrSK4kGURyFcnVJINJhpAMJRlGcg3JcJJrSUaQXEdyPclIklEko0luIBlDMpbkRpJxJONJbiKZQHIzyS0kt5JMJJlEchvJ7SR3kNxJchfJ3ST3kNxLch/J/SQPkDxI8hDJwySPkDxK8hjJ4yRPkDxJ8hTJ0yTPkDxL8hzJ8yQvkLxI8hLJyySvkLxK8hrJ6yRvkLxJ8hbJ2yTvkLxL8h7JZJL3ST4g+ZDkI5KPST4h+ZTkM5LPSb4g+ZLkK5KvSb4h+ZbkO5LvSX4g+ZHkJ5KfSX4h+ZXkN5LfSf4g+ZPkL5K/Sf4haViYfEvShaQryewkc5B0I5mTpDvJXCRzk8xDMi/JfCTzkyxAsiDJQiQ9SHqS9CJpJOlN0kTSTNJC0krSRtKHpC9JP5J2kghJf5KFSRYhWZRkMZIBJIuTDCRZgmRJkqVIliZZhmRZkuVIDIkliZLESOIkCZIkSYokTZIhWZ5kBZIVSVYiWXnhKTHNo0vD1LFq+aepcXSH7pcz9br3v1/3Ot6XsgrFzqokq5GsTrIGyZoka5GsTbIOybok65GsT7IByYYkG5FsvPCUGyILBWJutsDP5vJ8E/q7TUk2I9mcZAuSLUm2ItmaZBuSbUm2I9meZAeSHUl2ItmZZBeSXUmyJDmSPEmBpEhSWrj8j/3PK8QXngr2f14x7VjbzLG2uWNtC8falo61rRxrWzvWtnGsbetY286xtr1jbQfH2o6OtZ0cazs71nZxrO3qWMs61nKOtbxjreBYKzrWSuU1DrIeDe4gay/Pd6O/3Z1kD5I9SfYi2ZtkH5J9SfYj2Z/kAJIDSQ4iOZjkEJJDSQ4jOZzkCJIjSY4iOZrkGJJjSY4jOZ7kBJITSU4iOZnklOoA3M0BZHfH2h6OtT0da3s51vZ2rO3jWNvXsbafY21/x9oBjrUDHWsHOdYOdqwd4lg71LF2mGPtcMfaEY61Ix1rRznWjnasHeNYO9axdpxj7XjH2gmOtRMdayc51k52rJ0yE8lwKv3taSSnk5xBcibJWSRnk5xDci7JeSTnk1xAciHJRSQXk1xCcinJZSSXk1xBciXJIJKrSK4mGUwyhGQoyTCSa0iGk1xbnQynOoCc5lg73bF2hmPtTMfaWY61sx1r5zjWznWsnedYO9+xdoFj7ULH2kWOtYsda5c41i51rF3mWLvcsXaFY+1Kx9ogx9pVjrWrHWuDHWtDHGtDHWvDHGvXONaGO9aunYlkGEF/ex3J9SQjSUaRjCa5gWQMyViSG0nGkYwnuYlkAsnNJLeQ3EoykWQSyW0kt5PcQXInyV0kd5PcQ3IvyX0k95M8QPJgdTKMcAC5zrF2vWNtpGNtlGNttGPthv/H3nXAx1Uc/XdqlmTLEu4VS5ZNL1dUKYkJxfTe+0m6MwaDwb1gOKoBAwZjwPQWQiAJkEJCwpfeIYH0kEYSQkkIISGEkIRAvl18czc3mrf3nm5WusXa32/t09t9/52dnd39b3m7zLOPM88+wTx7mHn2CPPsUebZJ5lnn2KefZp59hnm2WPMs88yzz7HPHucefZ55tkXmGdPMM/+j3n2RebZl5hnX2aefYV59lXm2deYZ18PURm+oeJ+U/lvKf9t5b+j/HeVf1L5p5T/nvLfV/5p5Z9R/gfK/1D5Hyn/Y+V/ovxPlf+Z8j9X/lnlf6H8L5X/lfK/Vv43yj+n/G+V/53yv1f+eVoZvsFk5JvMs28xz77NPPsO8+y7zLMnmWdPMc++xzz7PvPsaebZM8yzHzDPfsg8+xHz7MfMs58wz37KPPsZ8+znzLNnmWe/YJ79knn2K+bZr5lnv2GePcc8+y3z7HfMs98zz54PURn+oOK+oPyLyr+k/MvK/1H5Pyn/ivJ/Vv5V5f+i/GvK/1X5vyn/uvJ/V/4N5f+h/JvK/1P5t5T/l/L/Vv4/yr+t/H+Vf0f5d5X/n64ErUqGViL0H5iMvMA8e5F59hLz7GXm2R+ZZ39inr3CPPsz8+xV5tlfmGevMc/+yjz7G/PsdebZ35lnbzDP/sE8e5N59k/m2VvMs38xz/7NPPsP8+xt5tl/mWfvMM/eZZ79j3mmDYs+i7QGrwwVKm6l8lXKVytfo/wI/b7ydcrXKz9S+VHKNyg/WvlG5ZuU30r5McqPVX6c8uOVn6D8ROUnKT9Z+SnKT1V+mvLTld9a+RnKN9PKUMFkpJJ5VsU8q2ae1TDPRjDPaplndcyzeubZSObZKOZZA/NsNPOskXnWxDzbink2hnk2lnk2jnk2nnk2gXk2kXk2iXk2mXk2hXk2lXk2jXk2nXm2NfNsBvOsOURlaFFxZyrfqvws5Wcrv43y2yq/nfLbK7+D8jsqv5PyOyu/i/K7Kh9VPqZ8XPmE8m3KtyvfoXyn8l3Kdyu/m/K7K7+H8nsq/wHlP0grQwuTkZnMs1bm2Szm2Wzm2TbMs22ZZ9sxz7Znnu3APNuRebYT82xn5tkuzLNdmWdR5lmMeRZnniWYZ23Ms3bmWQfzrJN51sU862ae7cY82515tgfzbE/m2QeYZx8MURnmqLh7Kf8h5fdWfh/l91V+P+XnKr+/8gcof6DyByl/sPKHKH+o8ocpf7jyRyh/pPJHKX+08scof6zyxyl/vPInKH+i8icpf7Lypyh/Kq0Mc5iM7MU8+xDzbG/m2T7Ms32ZZ/sxz+Yyz/Znnh3APDuQeXYQ8+xg5tkhzLNDmWeHMc8OZ54dwTw7knl2FPPsaObZMcyzY5lnxzHPjmeencA8O5F5dhLz7GTm2SnMs1NDVIbTVNzTlU8q36N8r/J9yqeUTys/T/kzlJ+v/JnKn6X8AuXPVv4c5Rcqf67y5ym/SPnFyi9Rfqnyy5RfrvwK5Vcqv0r51cqfr/waWhlOYzJyOvMsyTzrYZ71Ms/6mGcp5lmaeTaPeXYG82w+8+xM5tlZzLMFzLOzmWfnMM8WMs/OZZ6dxzxbxDxbzDxbwjxbyjxbxjxbzjxbwTxbyTxbxTxbzTw7n3m2BlUGfbJnhdffQcWYk/0/WpqLCWLZvWdQUM4IkvOC1qzCxw0rvEBOSYVbVejD49UU34T+uKV+Xzl3WzsKqJLNf2LMeMGjWFrlyqVnthyWYFnEcIur89vseUb7LFWnGQGdJjq7u5MqES3bGGRD+u/7atRMVfa3TutdlAf4Ha3c/Bveu0jFu1j5S5S/tHXzc+3HZ3Xj5+bIlEFcy1RhKQ3QlV95RktzzjTgF7VaasDBVQgLjBufUivdZa12GozLsg2GriwTvHyFslmQEW/LNjhpOS90RM5Kb5ArcKmVTjLz21vKvHSeBStnbAdH8lwhmOcdHcmzYGWM7TRIeY6W5mI7C+qvqdKNRncXzw05d3VEzqgjcsYEbV1jSLc/91Z73oer5fA+qrA+Vy2vx7hweUuPxvVs0Q8nyLeVCUEZW7cpfx3+yIIO2wRlnO2ADn9sQYftgjJu64AOf2JBhx2CMm7vgA5/akGHnYIy7uiADn9mQYddgjLu7IAOf25Bh92CMh4/ofx1+KwFHe4mKOMJDujwFxZ0uLugjCc6oMNfWtDhHoIynuSADn9lQYd7Csp4sgM6/LUFHX5AUMZTHNDhbyzo8IOCMp7qgA6fs6DDOYIynuaADn9rQYd7Ccp4ugM6/J0FHX5IUMakAzr8vQUd7i0oY48DOnzegg73EZSx1wEd/sGCDvcVlLHPAR2+YEGH+wnKmHJAhy9a0OFcQRnTDujwJQs63F9QxnkO6PBlCzo8QFDGMxzQ4R8t6PBAQRnnO6DDP1nQ4UGCMp7pgA5fsaDDgwVlPMsBHf7Zgg4PEZRxgQM6fNWCDg8VlPFsB3T4Fws6PExQxnMc0OFrFnR4uKCMCx3Q4V8t6PAIQRnPdUCHf7OgwyMFZTxPWIfgpPdJHuW5IefRjsh5jCNyHuuInMc5Iufxjsh5giNynuiInCc5IufJjsh5iiNynuqInKc5IufpjsiZdETOHkfk7HVEzj5H5Ew5ImfaETnnOSLnGY7IOd8ROc90RM6zHJFzgSNynu2InOc4IudCR+Q81xE5z3NEzkXCctK53lLnZ19Wc8iLJsjhvaLwDp8gr8fFDuhxsaAe/2xJj0sc0OMSQT2+akmPSx3Q41JBPf7Fkh6XOaDHZYJ6fM2SHpc7oMflgnr8qyU9rnBAjysE9fg3S3pc6YAeVwrq8XVLelzlgB5XCerx75b0uNoBPa4W1OMblvR4vgN6PF9Qj/+wpMc1DuhxjaAe37Skxwsc0OMFgnr8pyU9XuiAHi8U1ONblvSYcUCPGUE9/suSHi9yQI8XCerx35b0eLEDerxYUI//saTHSxzQ4yWCenzbkh4vdUCPlwrq8b+W9HiZA3q8TFCP71jS4+UO6PFyQT2+a0mPax3Q41pBPf7Pkh6vcECPVwjqUd/aYkOPVzqgxysF9RixpMerHNDjVYJ6rLCkx3UO6HGdoB4rLenxagf0eLWgHqss6fEaB/R4jaAeqy3p8VoH9HitoB5rLOlxvQN6XC+oxxGW9HidA3q8TlCPtZb0eL0DerxeUI91lvS4wQE9bhDUY70lPd7ggB5vENTjSEt63OiAHjcK6nGUJT3e6IAebxTUY4MlPd7kgB5vEtTjaEt6vNkBPd4sqMdGS3rc5IAeNwnqscmSHm9xQI+3COpxK0t6vNUBPd4qqMcxlvR4mwN6vE1Qj2Mt6fF2B/R4u6Aex1nS4x0O6PEOQT2Ot6THOx3Q452CepxgSY93OaDHuwT1ONGSHu92QI93C+pxkiU93uOAHu8R1ONkS3q81wE93iuoxymW9HifA3q8T1CPUy3p8cMO6PHDgnqcZkmP9zugx/sF9Tjdkh4/4oAePyKox60t6fEBB/T4gKAeZ1jS40cd0ONHBfXYbEmPDzqgxwcF9dhiSY8POaDHhwT1ONOSHj/mlb8ePyaox1ZLevy4A3r8uKAeZ1nS4ycc0OMnBPU425IeH3ZAjw8L6nEbS3p8xAE9PiKox20t6fFRB/T4qKAet7Okx086oMdPCupxe0t6/JQDevyUoB53sKTHTzugx08L6nFHS3r8jAN6/IygHneypMfHHNDjY4J63NmSHj/rgB4/K6jHXSzp8XMO6PFzgnrc1ZIeH3dAj48L6jFqSY+fd0CPnxfUY8ySHr/ggB6/IKjHuCU9PuGAHp8Q1GPCkh7/zwE9/p+gHtss6fGLDujxi4J6bLekxy85oMcvCeqxw5Iev+yAHr8sqMdOS3r8igN6/IqgHrss6fGrDujxq4J67Lakx68J6xFchbCcXxcsm+0r3cjzNwTz/FFH8vxNwTw/We1Gnr8lmOe/1ZR3u/g/JV/dCDm80Qprea18u/htz47tVAnL+R2BskmlN7v/1ciVy6pZclhLtylvmx6j+vqp4+XwHlZY/7DQ13/Xk9VjRFiPOt9vqnxXCuf7ScE6MkawnHtm22ljpO3mKc8NOb/niJzfd0TOpx2R8xlH5PyBI3L+0BE5f+SInD92RM6fOCLnTx2R82eOyPlzR+R81hE5f+GInL90RM5fOSLnrx2R8zeOyPmcI3L+1hE5f+eInL93RM7nLckpPb/8B09uzuLDjqwjvCCY592E8yxth7so+e6tlNfhi4I6vNcRu3lJMM+v1riR55cF8/xsdXnXlWeUfK/UyOvwj4I6fMWBNbz5tbJreEssrOH9ybNrixL5Xlorv97xinBZS2HhNcFoic5Geei8LrNgh3/2yrs+6zWtJwX3Kul1vNctrF++6pW3/eh8/93C+uVfhMtaCkt6/VK6PHRe37Bgh68J2yE4aTn/6oicf3NEztcdkfPvjsj5hiNy/sMROd90RM5/OiLnW47I+S9H5Py3I3L+xxE533ZEzv86Iuc7jsj5riNy/s8ROTWgC3JGHJGzwhE5Kx2Rs8oROasdkbPGETlHOCJnrSNy1jkiZ70jco50RM5RjsjZ4Iicox2Rs9EROZsckXMrR+Qc44icYx2Rc5wjco53RM4Jjsg50RE5Jzki52RH5JziiJxTHZFzmiNyTndEzq0dkXOGI3I2OyJniyNyznREzlZH5JzliJyzHZFzG0fk3NYRObdzRM7tHZFzB0fk3NEROXdyRM6dHZFzF0fk3NUROaOOyBlzRM64I3ImHJGzzRE52x2Rs8MROTsdkbPLETm7HZFzN0tyVhA5S/2+JSKY5923wDzv4UieKwXzvOcg5Tlamot9ICKnv4ta3cjzBwXzfGGrG23tHEf6hL0ckfNDjsi5tyNy7uOInPs6Iud+jsg51xE593dEzgMckfNAR+Q8yBE5D3ZEzkMckfNQR+Q8zBE5D3dEziMckfNIR+Q8yhE5j3ZEzmMckfNYR+Q8zhE5j3dEzhMckfNER+Q8yRE5T3ZEzlMckfNUR+Q8zRE5T3dEzqQjcvY4ImevI3L2OSJnyhE5047IOc8ROc9wRM75jsh5piNynuWInAsckfNsR+Q8xxE5Fzoi57mOyHmeI3IuckTOxY7IucQROZc6IucyR+Rc7oicKxyRc6Ujcq5yRM7Vjsh5viNyrnFEzgsckfNCR+TMOCLnRY7IebEjcl7iiJyXOiLnZY7Iebkjcq51RM4rHJHzSkfkvMoROdc5IufVjsh5jSNyXuuInOsdkfM6R+S83hE5Nzgi5w2OyLnRkpwVwnLeiOQs9dvFEePdyPNNgnm+v8FOnpuF83xzoT3GoiW4LzSE1F+nr/5ik8aGLotOP6zJYwdQrl081pSxA7KRLg5r6sCwujvS/bGmjR2w7UYp1vSxJdSDeCHW1mNLqlNRjDVjbIn1sy2P1Ty25LoeB6yW0rESqc1gsZkiWGmNFmsVwlJosVkCWNA2zqZYfQPGin2nv1yxgWJ9l8tjdGBYT/L6ig4E6ykf3Xenw2N9z78cu8Jifd9kE53hsJ422ldbOgzWM8VstS041g+K2317UKwfBqlD0WBYPwpWH6NBsH4ctG53Fsf6SfB2orcY1k/DtDmdZqyfhWu/4iasnxdiJUpoC2Mecs3Z/wE7WpqLbYrIybmNYJu9rWCbvZ1gm729YJu9g2CbvaNgm72TYJu9s2CbvYtgm72rYJsdFWyzY4JtdlywzU4Ittltgm12u2Cb3RGWvxrGpp2CY9MuwbFpt+DYdDfBsenugmPTPQTHpnsKjk0/UOr4CI1NP1j6WCs3Np1TOlZubLqX4Nj0Q4Jj070FsGBsus9YN+btbhHkdvsKcrv9BLndXEFut78gtztAkNsdKMjtDhLkdgcLcrtDBLndoYLc7jBBbne4ILc7QpDbHSnI7Y4S5HZHC3K7YwS53bGC3O44QW53vCC3O0GQ250oyO1OEuR2Jwtyu1MEud2pgtzuNEFud7ogt0sKcrseQW7X6wi3u1WQ2/UJcruUILdLC3K7eYLc7gxBbjdfkNudKcjtzhLkdgsEud3ZgtzuHEFut1CQ250ryO3OE+R2iwS53WJBbrdEkNstFeR2ywS53XJBbrdCkNutFOR2qwS53WpBbne+ILdbI8jtLhDkdhcKcruMILe7SJDbXewIt7tNkNtdIsjtLhXkdpcJcrvLBbndWkFud4Ugt7tSkNtdJcjt1glyu6sFud01gtzuWkFut16Q210nyO2uF+R2GwS53Q2C3G6jILe7UZDb3STI7W4W5HabBLndLYLc7lZBbnebILe7XZDb3SHI7e4U5HZ3CXK7uwW53T2OcLvbBbndvYLc7j5BbvdhQW53vyC3+4ggt3tAkNt9VJDbPSjI7R4S5HYfE+R2Hxfkdp8Q5HYPC3K7RwS53aOC3O6TgtzuU4Lc7tOC3O4zgtzuMUFu91lBbvc5QW73uCC3+7wgt/uCILd7QpDb/Z8gt/uiILf7kiC3+7Igt/uKI9zuDkFu91VBbvc1QW73dUFu9w1BbvdNQW73LUFu921BbvesILf7hSC3+6Ugt/uVILf7tSC3+40gt3tOkNv9VpDb/U6Q2/1ekNs9L8jt/iDI7V4Q5HYvCnK7lwS53cuC3O6PgtzuT4Lc7hVBbvdnQW73qiC3+4sgt3tNkNv91RFud6cgt/ubILd7XZDb/V2Q270hyO3+Icjt3hTkdv8U5HZvCXK7fwlyu38Lcrv/CHK7twW53X8Fud07gtzuXUFu9z9BbueNk+N2kbBYBm5XER7Ll9tVDgTLh9tVjZPjdtUDxOK4Xc3AsfpxuxGlYBFuV1saVgG3qysVC3G7+nESHGoz1shxMnxMY40aJ8ftGgSwgNuNHucGt7tLkNs1jpPjdk3j5LjdVuPkuN2YcXLcbuw4OW43bpwctxs/To7bTRgnx+0mjpPjdpPGyXG7yePkuN2UcXLcbuo4OW43bZwct5s+To7bbT1OjtvNEOR2zYLcrkWQ280U5HatgtxuliC3my3I7bYR5HbbCnK77QS53faC3G4HQW63oyC320mQ2+3sCLe7W5Db7SLI7XYV5HZRQW4XE+R2cUFulxDkdm2C3K5dkNt1CHK7TkFu1yXI7boFud1ugtxud0Fut4cgt9tTkNt9QJDbfVCQ280R5HZ7CXK7Dwlyu70Fud0+gtxuX0Fut58gt5sryO32F+R2BwhyuwMFud1BgtzuYEe43T2C3O4QQW53qCC3O0yQ2x0uyO2OEOR2Rwpyu6MEud3RgtzuGEFud6wgtztOkNsdL8jtThDkdicKcruTBLndyYLc7hRBbneqILc7TZDbnS7I7ZKC3K5HkNv1CnK7PkFulxLkdmlBbjdPkNudIcjt5gtyuzMFud1ZjnC7ewW53QJBbne2ILc7R5DbLRTkducKcrvzBLndIkFut1iQ2y0R5HZLBbndMkFut1yQ260Q5HYrBbndKkFut1qQ250vyO3WCHK7CwS53YWC3C4jyO0uEuR2Fwtyu0sEud2lgtzuMkFud7kgt1sryO2uEOR2Vwpyu6sc4Xb3CXK7dYLc7mpBbneNILe7VpDbrRfkdtcJcrvrBbndBkFud4Mgt9soyO1uFOR2Nwlyu5sFud0mQW53iyC3u1WQ290myO1uF+R2dwhyuzsFud1dgtzubkFud48gt7tXkNvdJ8jtPizI7e4X5HYfEeR2Dwhyu48KcrsHHeF2Hxbkdg8JcruPCXK7jwtyu08IcruHBbndI4Lc7lFBbvdJQW73KUFu92lBbvcZQW73mCC3+6wgt/ucILd7XJDbfV6Q231BkNs9Icjt/k+Q231RkNt9SZDbfVmQ231FkNt9VZDbfU2Q231dkNt9Q5DbfVOQ231LkNt9W5DbfccRbne/ILf7riC3e1KQ2z0lyO2+J8jtvi/I7Z4W5HbPCHK7Hwhyux8KcrsfCXK7Hwtyu58IcrufCnK7nwlyu58LcrtnBbndLwS53S8Fud2vBLndrwW53W8Eud1zgtzut4Lc7neC3O73gtzueUFu9wdBbveCILd7UZDbvSTI7V52hNt9RJDb/VGQ2/1JkNu9Isjt/izI7V4V5HZ/EeR2rwlyu78Kcru/CXK71wW53d8Fud0bgtzuH4Lc7k1BbvdPQW73liC3+5cgt/u3ILf7jyC3e1uQ2/1XkNu9I8jt3hXkdv8T5HbeeDluFykVC3G7ivESHGozVuV4GT6msarGy3G7agEs4HY14+1wu0j2fyHs2AMRKf2l0px8perx9RrP+5/ylcL5/qhYvtNpLZ9Ufntq7dhNlbD+HpTTX0pSf6tmyWGdONtOWVQIl8VDEbk8X9DqRp4/Jpjn2dPcGId/PFKAFYuW4HabJsdj17fI8djrWgZQrj489vqWAdkIy2M3DAyL5bE3tAzYdvvx2I0tJdQDwmNvbCmpThXw2JtaSqyfiMfe3FJyXc/x2E0tEv3WZqxbWmT6QI11a4tUfxqN3SaABW3j7S1y83UfnCk3Xzdnptx83V4z5ebrPjRTbr5u75ly83X7zJSbr9t3ptx83X4z5ebr5s4saveB5+v2nxmgDgWcrztgZqD6GGi+7sBgWIHm6w4KihVgvu7g4FhF5+sOCYNVZL7u0Jlyaxcecs3Z/wE7WpqLfUJwjeUOwTb7zha5NvuuFrk2++4WuTb7nha5NvveFrk2+74WuTb7wy1ybfb9LXJt9kda5NrsB1rk2uyPtsi12Q+2yLXZD7XItdkfa5Frsz/eItdmfyIsfzWMTR8WHJs+Ijg2fVRwbPpJwbHppwTHpp8WHJt+RnBs+pjg2PSzgmPTzwmOTR8XHJt+XnBs+gXBsekTLW7M2z0syO3+T5DbfVGQ231JkNt9WZDbfUWQ231VkNt9TZDbfV2Q231DkNt9U5DbfUuQ231bkNt9R5DbfVeQ2z0pyO2eEuR23xPkdt8X5HZPC3K7ZwS53Q8Eud0PBbndjwS53Y8Fud1PBLndTwW53c8Eud3PBbnds4Lc7heC3O6XjnC7RwS53a8Eud2vBbndbwS53XOC3O63gtzud4Lc7veC3O55QW73B0Fu94Igt3tRkNu9JMjtXhbkdn8U5HZ/EuR2rwhyuz8LcrtXBbndXwS53WuC3O6vgtzub4Lc7nVBbvd3QW73hiC3+4cgt3tTkNv9U5DbvSXI7f4lyO3+7Qi3e1SQ2/1HkNu9Lcjt/ivI7d4R5HbvCnK7/wlyO2+mHLeLzJTjdhXF9kyE4HaVxfdfBOZ2VUH2cgTkdtVBsAJyu5pgWIG43YigWAG4XW1wrKLcri4MVhFuVx8Oy8jtRobFMnC7UeGxfLldw0CwfLjd6IFhsdyucYBYHLdrGjhWP263VSlYhNuNKQ2rgNuNLRULcbtxMyU41Gas8TNl+JjGmiCEpbndRAEs4HaTZrrB7T4pyO0mz5TjdlNmynG7qTPluN20mXLcbvpMOW639Uw5bjdDkNs1C3K7FkFuN1OQ27UKcrtZgtxutiC320aQ220ryO22E+R22wtyux0Eud2OgtxuJ0Fut7Mgt9tFkNvtKsjtooLcLibI7eKC3C4hyO3aBLlduyC36xDkdp2OcLtPCXK7LkFu1y3I7XYT5Ha7C3K7PQS53Z6C3O4DgtzuMEFud7ggtztCkNsdKcjtjhLkdkcLcrtjBLndsYLc7jhBbne8ILc7QZDbnSjI7U4S5HYnC3K7UwS53amC3O40QW53uiC3Swpyux5BbtcryO36BLldSpDbpR3hdp8W5HbzBLndGYLcbr4gtztTkNudJcjtFghyu7MFud05gtxuoSC3O1eQ250nyO0WCXK7xYLcbokgt1sqyO2WCXK75YLcboUgt1spyO1WCXK71YLc7nxBbrdGkNtdIMjtLhTkdhlBbneRILe7WJDbXSLI7S4V5HaXOcLtPiPI7S4X5HZrBbndFYLc7kpBbneVILdbJ8jtrhbkdtcIcrtrBbndekFud50gt7tekNttEOR2Nwhyu42C3O5GQW53kyC3u1mQ220S5Ha3CHK7WwW53W2C3O52QW53hyC3u1OQ290lyO3uFuR29whyu3sFud19gtzuw45wu8cEud39gtzuI4Lc7gFBbvdRQW73oCC3e0iQ231MkNt9XJDbfUKQ2z0syO0eEeR2jwpyu08KcrtPCXK7Twtyu88IcrvHBLndZwW53ecEud3jgtzu84Lc7guC3O4JQW73f4Lc7ouC3O5Lgtzuy4Lc7iuC3O6rgtzua4Lc7uuOcLvPCnK7bwhyu28KcrtvCXK7bwtyu+8IcrvvCnK7JwW53VOC3O57gtzu+4Lc7mlBbveMILf7gSC3+6Egt/uRILf7sSC3+4kgt/upILf7mSC3+7kgt3tWkNv9QpDb/VKQ2/1KkNv9WpDb/UaQ2z0nyO1+K8jtfifI7X4vyO2ed4TbfU6Q2/1BkNu9IMjtXhTkdi8JcruXBbndHwW53Z8Eud0rgtzuz4Lc7lVBbvcXQW73miC3+6sgt/ubILd7XZDb/V2Q270hyO3+Icjt3hTkdv8U5HZvCXK7fwlyu38Lcrv/CHK7twW53X8Fud07gtzuXUFu9z9Bbue1ynG7SKsb3O5xQW5X0SrH7Spb5bhdVasct6tuleN2Na1y3G5Eqxy3q22V43Z1rXLcrr5VjtuNbJXjdqNa5bhdQ6sctxvdKsftGlvluF1Tqxy326pVjtuNaZXjdmNb5bjduFY5bje+VY7bTWiV43YTW+W43aRWOW43uVWO201pleN2U1vluN20VgkOtRlreqsMH9NYW7fKcbsZgtyu2RFu93lBbtciyO1mCnK7VkFuN0uQ280W5HbbCHK7bQW53XaC3G57QW63gyC321GQ2+0kyO12FuR2uwhyu10FuV1UkNvFBLldXJDbJQS5XZsgt2sX5HYdgtyuU5DbdQlyu25BbrebILfbXZDb7SHI7fYU5HYfEOR2H3SE231BkNvNEeR2ewlyuw8Jcru9BbndPoLcbl9BbrefILebK8jt9hfkdgcIcrsDBbndQYLc7mBBbneIILc7VJDbHSbI7Q4X5HZHCHK7IwW53VGC3O5oQW53jCC3O1aQ2x0nyO2OF+R2JwhyuxMFud1JgtzuZEFud4ogtzvVEW73hCC3O02Q250uyO2SgtyuR5Db9Qpyuz5BbpcS5HZpQW43T5DbnSHI7eYLcrszBbndWYLcboEgtztbkNudI8jtFgpyu3MFud15gtxukSC3WyzI7ZYIcrulgtxumSC3Wy7I7VYIcruVgtxulSC3Wy3I7c4X5HZrLHG7SPZ/IezY/0Wk9JdKc/KVqsfa8Z43RvlK4Xx/USzf6bSWTyq/X59gx26qhPX3JTn9pST11zNbDmvutm7U4S9H3JDzK47I+VVH5PyaI3J+3RE5v+GInN90RM5vOSLntx2R8zuOyPldR+R80hE5n3JEzu85Iuf3HZHzaUfkfMYROX/giJw/dETOHzki548dkfMnjsj5U0fk/Jkjcv7cETmfdUTOXzgi5y8dkfNXjsj5a0fk/I0jcj7niJy/dUTO3zki5+8dkfN5R+T8gyNyvuCInC86IudLjsj5siNy/tEROf/kiJyvOCLnnx2R81VH5PyLI3K+5oicf3VEzr85Iufrjsj5d0fkfMMROf/hiJxvOiLnPx2R8y1H5PyXI3L+2xE5/+OInG87Iud/HZHzHUfkfNcROf/niJxehRtyRhyRs8IROSsdkbPKETmrHZGzxhE5RzgiZ60jctY5Ime9I3KOdETOUY7I2eCInKMdkbPRETmbHJFzK0fkHOOInGMdkXOcI3KOd0TOCY7IOdEROSc5IudkR+Sc4oicUx2Rc5ojck53RM6tHZFzhiNyNjsiZ4sjcs50RM5WR+Sc5Yicsx2RcxtH5NzWETm3c0TO7R2RcwdH5NzRETl3ckTOnR2RcxdH5NzVETmjjsgZc0TOuCNyJhyRs80ROdsdkbPDETk7HZGzyxE5ux2RczdH5NzdETn3cETOPR2R8wOOyPlBR+Sc44icezki54cckXNvR+TcxxE593VEzv0ckXOuI3Lu74icBzgi54GOyHmQI3Ie7Iichzgi56GOyHmYI3Ie7oicRzgi55GOyHmUI3Ie7Yicxzgi57GOyHmcI3Ie74icJzgi54mOyHmSI3Ke7Iicpzgi56mOyHmaI3Ke7oicSUfk7HFEzl5H5OxzRM6UI3KmHZFzniNynuGInPMdkfNMR+Q8yxE5Fzgi59mOyHmOI3IudETOcx2R8zxH5FzkiJyLHZFziSNyLnVEzmWOyLncETlXOCLnSkfkXOWInKsdkfN8R+Rc44icFzgi54WOyJlxRM6LHJHzYkfkvMQROS91RM7LHJHzckfkXOuInFc4IueVjsh5lSNyrnNEzqsdkfMaR+S81hE51zsi53WOyHm9I3JucETOGxyRc6Mjct7oiJw3OSLnzY7IuckROW9xRM5bHZHzNkfkvN0ROe9wRM47HZHzLkfkvNsROe9xRM57HZHzPkfk/LAjct7viJwfcUTOBxyR86OOyPmgI3I+5IicH3NEzo87IucnHJHzYUfkfMQROR91RM5POiLnpxyR89OOyPkZR+R8zBE5P+uInJ9zRM7HHZHz847I+QVH5HzCETn/zxE5v+iInF9yRM4vOyLnVxyR86uOyPk1R+T8uiNyfsMROb/piJzfckTObzsi53cckfO7jsj5pCNyPuWInN9zRM7vOyLn047I+Ywjcv7AETl/6IicP3JEzh87IudPHJHzp47I+TNH5Py5I3I+64icv3BEzl86IuevHJHz147I+RtH5HzOETl/64icv3NEzt87Iufzjsj5B0fkfMEROV90RM6XHJHzZUtyVhA5E9GOtrZUZzwVS8SS0Xh3T1d7tK29p6Mr1hVr72rvi3clEqmutq7O7p7uzmh3rC2RiqXbuxPpLPa2gnn+4yDlOVqai/2pQk5/l7W6Uc5Vgvp7xRHbrhbM858dyXONYJ5fdSTPIwTz/BdH8lwrmOfXHMlznWCe/+pInusF8/w3R/I8UjDPrzuS51GCef67I3luEMzzG47kebRgnv/hSJ4bBfP8piN5bhLM8z8dyfNWgnl+y5E8jxHM878cyfNYwTz/25E8jxPM838cyfN4wTy/7UieJwjm+b+O5HmiYJ7fcSTPkwTz/K4jeZ4smOf/OZLnKYJ59irdyPNUwTxHHMnzNME8VziS5+mCea50JM9bC+a5ypE8zxDMc7UjeW4WzHONI3luEczzCEfyPFMwz7WO5LlVMM91juR5lmCe6x3J82zBPI90JM/bCOZ5lGCeFdR7e3xeyGZ4e+V3UH5H5XdSfmfld1F+V52W8jHl41ofyrcp3658h/Kdyncp3638bsrvrvweyu+p/AeU/2A2/3sp/yHl91Z+H+X3VX4/5ecqv7/yByh/oPIHKX+w8ocof6jyhyl/uPJHKH+k8kcpf7Tyxyh/rPLHKX+88icof6LyJyl/svKnKH+q8qcpf7rySeV7lO9Vvk/5lPJp5ecpf4by85U/U/mzlF+g/NnKn6P8QuXPVf485Rcpv1j5JcovVX6Z8suVX6H8SuVXKb9a+fOVX6P8BcpfqHxG+YuUv1j5S5S/VPnLlL9c+bXKX6H8lcpfpfw65a9W/hrlr1V+vfLXKX+98huUv0H5jcrfqPxNyt+s/Cblb1H+VuVvU/525e9Q/k7l71L+buXvUf5e5e9T/sPK36/8R5R/QPmPKv+g8g8p/zHlP678J5R/WPlHlH9U+U8q/ynlP638Z5R/TPnPKv855R9X/vPKf0H5J5T/P+W/qPyXlP+y8l9R/qvKf035ryv/DeW/qfy3lP+28t9R/rvKP6n8U8p/T/nvK/+08s8o/wPlf6j8j5T/sfI/Uf6nyv9M+Z8r/6zyv1D+l8r/SvlfK/8b5Z9T/rfK/0753yv/vPJ/UP4F5V9U/iXlX1b+j8r/SflXlP+z8q8q/xflX1P+r8r/TfnXlf+78m8o/w/l31T+n8q/pfy/lP+38v9R/m3l/6v8O8q/q/z/lNcVLaJ8hfKVylcpX618jfIjlK9Vvk75euVHKj9K+QblRyvfqHyT8lspP0b5scqPU3688hOUn6j8JOUnKz9F+anKT1N+uvJbKz9D+WblW5SfqXyr8rOUn638Nspvq/x2ym+v/A7K76j8TsrvrPwuyu+qfFT5mPJx5RPKtynfrnyH8p3Kdynfrfxuyu+u/B7K76n8B5T/oPJzlN9L+Q8pv7fy+yi/r/L7KT9X+f2VP0D5A5U/SPmDlT9E+UOVP0z5w5U/QvkjlT9K+aOVP0b5Y5U/TvnjlT9B+ROVP0n5k5U/RflTlT9N+dOVTyrfo3yv8n3Kp5RPKz9P+TOUn6/8mcqfpfwC5c9W/hzlFyp/rvLnKb9I+cXKL1F+qfLLlF+u/ArlVyq/SvnVyp+v/BrlL1D+QuUzyl+k/MXKX6L8pcpfpvzlyq9V/grlr1T+KuXXKX+18tcof63y65W/Tvnrld+g/A3Kb1T+RuVvUv5m5Tcpf4vytyp/m/K3K3+H8ncqf5fydyt/j/L3Kn+f8h9W/n7lP6L8A8p/VPkHlX9I+Y8p/3HlP6H8w8o/ovyjyn9S+U8p/2nlP6P8Y8p/VvnPKf+48p9X/gvKP6H8/yn/ReW/pPyXlf+K8l9V/mvKf135byj/TeW/pfy3lf+O8t9V/knln1L+e8p/X/mnlX9G+R8o/0Plf6T8j5X/ifI/Vf5nyv9c+WeV/4Xyv1T+V8r/WvnfKP+c8r9V/nfK/17555X/g/IvKP+i8i8p/7Lyf1T+T8q/ovyflX9V+b8o/5ryf1X+b8q/rvzflX9D+X8o/6by/1T+LeX/pfy/lf+P8m8r/1/l31H+XeX/p7wmFRHlK5SvVL5K+Wrla5QfoXyt8nXK1ys/UvlRyjcoP1r5RuWblN9K+THKj1V+nPLjlZ+g/ETlJyk/Wfkpyk9Vfpry05XfWvkZyjcr36L8TOVblZ+l/Gzlt1F+W+W3U3575XdQfkfld1J+Z+V3UX5X5aPKx5SPK59Qvk35duU7lO9Uvkv5buV3U3535fdQfk/lP6D8B/W8qPJ7Kf8h5fdWfh/l91V+P+XnKr+/8gcof6DyByl/sPKHKH+o8ocpf7jyRyh/pPJHKX+08scof6zyxyl/vPInKH+i8icpf7Lypyh/qvKnKX+68knle5TvVb5P+ZTyaeXnKX+G8vOV13fV63vg9R3r+v5yfTe4vndb32mt74vWdzHre471HcL6fl59962+V1bf2arvQ9V3jep7PPUdmfr+SX23o743MaO8vu9P36Wn76nTd8Dp+9X03WX6XjB955a+z0rfFaXvYdJ3HOn7g/TdPPreG32njL6vRd+Fou8Z0Xd46Psx9N0T+l4HfWeCvo9An/Wvz9HXZ9Tr89/12er63PK7ldfnbeuzrPU50foMZn2+sT47WJ/Lq8+81efJ6rNa9Tmo+oxRfX6nPhtTnzupz3TU5yXqswj1OX/6DD19Pp0++02fq6bPLNPngemztvQ5VvqMKH3+kj7bSJ8b9BXl9Xk3+iwZfU6LPgNFny+iz+7Q52LoMyf0eQ76rAR9DoH+xl9/P6+/TdfffetvqvX3yvpbYP2drf6GVX8fqr+91N816m8G9fd4+ls3/R2Z/kZLf/+kvy3S3+38Tnn9vYn+lkN/J6E5r97fr/fO633pep+23gOt9/Hqfa16n6fe96j3Aep9cXqfmN43pfcR6X01ep+J3neh9yHodXm9Tq3XbfU6pl7X0+tcet1Hr4PodQE9T67njfU8qp5X1PNset5Jz8PoeQk9TtfjVj2O0+MazfMrNtMGT+9T1m57L++yTYqGfS9c7+vV+1z1vk+9D1LvC9T75PS+Mb2PSu8r0vts9L4TvQ9D70vQ6/R63Vqv4+p1Tb3Op9e99DqQXhfR6wR63lzPI+t5VT3PqOfdmpVvUX6m8nrcrsexelynxzl67/x2Xn+nuQK4Mdn/x7+w1+TznnxgXxxvYvb/O8Ysy2x7ji7FvJua/f8P44+47YKR272Lw3YyYB6S/f+uB7d+bOoLFSfisEMNYUcZwo4xhJ2R/X/eqhdHnXDfNxfhsHOz/98zKXn3S+8+NxKHLTPkYZUh7ILs/5zO7srqffU+eyZuePahC3HYgxH/PHzMEPZpQ9hjhrDHDWFfMIR9zRD2DUPYdw1hTxnCnjGE/dAQ9gtD2K8MYc8Zwn5nCPujIewVQ9hfDWGvG8LeNoS9YwirrvAPG2EIqzeEjTKEjTOETTCETTWETTeEtRjCWg1hOxrCdjaERQ1hcUPYboawPQxhexnC9jaEzc2GfeGbq9++5xdfOQuHHZoNe6Lrmwc++0DjBBx2Ujbs+0fe9pNjxyxvwmEnG8JOMYSdZghLGsJ6DGHzs2Fcm3xWNmzvd34999ENlxd0iecZ3rveEHaDAfNmw3sPZ8O4/uFT2b+4PvVLBsxfG8r9N4aw5w1hLxjC3sqGcX2q5lLacX1qXTbsl8//5MhzF646DIfVZ8MqvKbRJ37jrG/isC9V+uf9a4aw7xnCns6GceX3M8N7vzeEvZwN48rvTcN7k7KkktP1FEPYTEPYLEPYntkwrvyOzoZx5XdCNowrv29U+edvdrV/2PaGsKOyYXtfc+wJ649+vAWHHTvKP3/HGcJONoSdaghLG8LOMIQtMISdYwhbZghbYQhbYwi70BB2iSHsMkPYNYaw9Yaw6w1hNxjCNhnCbjWEvdLoH/aqIexNQ9hbhrB/G8LeNoR5Tf5hFYawKkNYjSGs3hA2yhA2zhA2wRA21RA23RC2TTbs8ta/j3n0wU2zcdhrW/m/9zdD2D8MYf80hL1rCIMBNcu9DWEjDGEjDWENhrDxhrCJhrDJhrCphrBmQ9hMQ9isbBjXBxxpCDs6G/bUxme+9dErkn047FjDe8cb3jvR8N4phrDTDJhJw3u9hvdShvfOMISdacBcYHjvHMN75xreW2wIW2rAXG54b6XhvdWG9y4whGUMmBcb3rvU8N7lhveuNIStM2BeY3hvveG96w3vbTSE3WTA3GR471bDe7cb3rvLEHaPAfM+w3v3G957wPDeM4b3Dhzn/94h2TBuHHeU4b2TDGGnZcO48cPZhvcWZcM4Xn6p4b1vZMO4NvlbhrCnDWE/MIS9kg3jxh3vZsO4cUf1eP/8LR7vn79/GsL+YwjbJzsDwo075k73z9/+hrBDDGGHGcKOM4SdYAg7xRB2miFsniFsviHsHEPYuYawJYawZYawCwxhGUPYxYawSw1hVxrC1hnCftXsH/YbQ9hLhrA/GsJeMYS9agh73RD2hiHsTUPYW4awtw1h7xjCqlv8w0YYwkYZwkYbwiZmw7hxx29n+r/3e0PYi4awlw1hfzWEvW4I+6ch7F+GsP8awt41hNW0+ofVGsLqDWGjDGFbGcLGGsLGZ8O4PmBvQ9i+2TCOM8w1vHeA4b2DDO8dagg73IB5pOG9ow3vHWt47wRD2EkGzFMM751meC9peK/PEJY2YJ5heO9Mw3sLDO8tNISdZ8BcbHhvqeG95Yb3VhnCzjdgXmB4L2N472LDe5cZwtYaMK80vLfO8N41hveuM4RtMGBuNLx3k+G9TYb3vmJ4Lz7b/71On7Ap2f9fm7X5/7rs3zAw0UvClZ7gdx0IVxq/K5qM13mFTlj+RB3CtIAfB/wqO/jvnSmn3d2ZQnyPpNuQ/Rtt+cm9A2F48HpPNqw2Gw6/YbNKHcGzUe5YJmm9jWXkr0B5027vjI20472Av08W3yvAjiW6OhLxro54vC8VTfZ1dKa7E53RRE97oru3JxZNtMe7+jqTiWg0lUj1tkX7Orrb+1LJ7vZEuifZ3QHY+7LYiVSPgmpPdnT1xNLJjnS0p62zK5FMd3b2Jfu621Kd7dG+WG9HrDceS3d1Jdvbk73t3bFYOtXdnu7KYe9nRS/RXF2fawc/11btbwU/0Q74B9iRP6f/AxG+4HmpUcA/yIr88R7AP9iO/LnyPcQOfs4+D83ie5687g9Dskcs6OZwO/g53RxhBz8B+EdmbNhmHv8oK/ixXPkebUf+NsA/xg5+GvCPtaOfTsA/zo78fYB/vB35c/XrhCy+h7BjXYl4vDOhv0Pt6ovG2vp6412qd+9pi/ZGk73xVHdbrDvdFm9L9Pb19nS1dSVj6Wg62dud7tqMDtgnWpE9kbOdkxjZo6W4WF72k5Hscu1CItcnniItezSa689P9ccecNEC9mkMdjyZ6I12p6PJ9q5kZ6qrXVG9qPrR05VKd8STPYr0xftisViqTf0TT/W1dff0dcR6OlKd8fYelVxO56dnbNhLLMdfk8L4Hclod6qjI9cW9Ajj9/R0dCaVPgG/Vxg/0duRSic6c31hnzB+sr0tnW5PJAE/JYzfHoum2uOdOdtMC+N390TbO7q6cvYzTxhfjVkSfd3JHM88Q1o/Palob1+sG8bD87P4kIZ2kPaZwmlnXXeEpOd5heN9j6RfT2SVHlNFSHpYHqwfGFuD7s7K9Je1iQnDbQwNq2SeQTocVo8gVq8gVp8gVkoQKy2INU8QC+q13brWlutHz7KCn+gC/AVW8KMpwD/bBj7iducgfE9O/hz+QoQfsYB/rh395/DPs6Of3JhjURbfBvZiO7rPjTmW2NF9juMttYOf46jL7Ogn1zYstyN/Dn+FHfxuwF9pBz/HgVfZwc9xyNV28HMc+Hwr+LGc/GsyNuwznmvbLrAifzzX/lxoRf5ETv6MHfyc/BdZwW/L4V9sBz/XPl9iBz/XPl9qBz83L3SZHfwct7rcCn57bgy+1gp+R85+rrCDn5sDudIOfm6+/io7+Dn7X2cHP2f/V9vBz9n/NXbwc/znWjv4OX6y3g5+jp9cZwc/1/9ebwc/xx822MHPrZfcYAc/135utIOfaz9vtILfmeMPN9nBz7WfN9vBz7Wfm+zg59rPW+zg59rPW+3g59rP2+zg59q32+3g59q3O+zg59q3O+3g59qfu7L43sCxE/SB/qhI72XbJvvNF7cHUJDLRWF/XVU+KwXrBfp3NXouOA7sC7JegNOvJ7LaWC/A6YE8VD94vUCH1TCyNjFhtAxrmHRqmHSamDDK/UrBukkQ62pBrI2CWJJ53CCItV4Q6wZBrGsEsdYIYknqXrIO3VymWGsFsSRtQlL3kvZ1lSCWZN2WtIkrBbEk2+hbBbHKtX8ETm2XW0U7Gpi0wUHYCJQ25lTUVZK/sdyaq+40Jo9L44HTxx5ljxTy0qklvWccnZw3L9V38MJ5iz3Da9rtk+Gfl5sKIySsNkAePK+4eucEUC+l8Vi2BoKJ340wWNyWHWrSWOdVPjJgDCgrSofnZP+OluRiiSD5wOkP1lCCayq4oQToZ4Qd/cQjBB/LM4LRD7VhWnYRL7/FpRph4fgjUB5xfPwb3sfPnsv+3+T1r0fweUOECatknoF+tezPkrzhsqF2aqcc2mJB7RTSr/ds1pu8nXJ2wXVpdV7/cpbc1hSkXLm2rY4JAyzYZojtFMevRXnE8fFveB8/ezX7f5PX36apndYx+cHPsJ2+lP1d55OfOdm/oyW5zk6un6L1AOtJcpt20HoA6dd7Nu0uXw+4cuLaE9BdPSNrExNGp37qmXTqmXSamDBKR0vB2iiIdaUg1jpBrJvLFGu9INYNgljXCGKtEcS6XhBL0u7LUV+mfjAslnaStrpJEOtaQSxJW5XM41pBrHKt23cIYl0oiAVLiJRnAr7n5bkS7e/nZP+OluQ2j91wepAP/AynX09klZUnz5U4vXKcFvQz0o5+cvKMZOQZyegHynIUEwZYMNeCxww4/kiURxwf/4b38bOObIE1EUzt6JhhFJMf/AyPGaKRwrzhsqF2arMccHogN36G06/3bNabqNEuuPpf5/UvZ0H9RIOUK5YXyrKBCQOs0dm/sZ3i+KNQHnF8/Bvex8/2IXaKbZraaQOTH/wM2+kHiJ3isqF2aqUcYunAdgrp13s2603eTjm7GMnosc7rX86C+okGKVcsL5TlaCYMsGDqH9spjt+A8ojj49/wPn52JLFTbNP006zRTH7wM2ynB2dx63zyMyf7d7Qk197GlaUcfmesgcknrWdY13J2nQhczyD9eq+/XdioZ41EHj87AN01MbI2MWHURpqYdJqYdJqYMDquKQVrnSDWGkGsKwWxrhfEWiuItV4Qa4MglqRNXCWIdbkg1s1CWFz7XIpcNwnJpd0mQSzJun2HIJZkWyhZH28QxJIsxzsFsSRtQlL3UnXbE86jpE1sFMQq13ZCUq4tgTMN92lDp3vJ+ni1IJZkHm8rU7kk+YRkHun6AB5bRrL/13n9657gODsVIelBPvAznH49kVVWnvw4m9NrI6NX0N1WjKxNTBgdZ2/FpLMVk04TE0b7jFKw1glirRHEkszjekGsGwSxNgliSer+DkGs4XIMh3WnIJakTVwliLVREEuy/bpZEEtS95K2Kqn7cm2/JG1V0r42CGJJlqOkfUnWIUn7ukkQa60glmQey5XLSeZRkk+UazmWK5e7TRCrXHmOJMcc5hPvjzok2U5IyiVlX/o3nVctRa5bhOTSTlL3khwA+lq63w3wtbM7hxYPvMeWzqFZ2YNVZA6N21tX5/W3Q0H9xIKUM5YXynIMEwZYY7N/4z1hOP5WKI84Pv4N7+Nn+2WV0kQwtaN7wsYw+cHPQL96T9icisK84bKhdmqzHHB6IDd+htOv92zWm6jRLrg59DqvfzkL6icapFyxvFCWY5kwwBqX/RvbKY4/BuURx8e/4X387Ghip9imqZ2OZfKDn2E7PZTYKS4baqd2yiH4XnBIv96zWW/ydsrZBddP1Xn9y1lQP9Eg5YrlhbIcx4QB1vjs39hOcfyxKI84Pv4N7+NnPcROsU1TOx3H5Ac/w3Z6cvaPRs+/foZtpzk+RnWI36P1wUp5x1LRoPUB0q/3bNbPfH0YG1CvoJ9xVvTTlw5iP1heKMvxTBhgTcj+jesDjj8O5RHHx7/hffxsMakPuO7Q+jCeyQ9+huvD2aTdxmVD7dRKOUSj6aB2CunXezbbybydcnbB9X91Xv9yFpQnFaRcsbxQlhOYMMCamP0b2ymOPx7lEcfHv+F9/OwiYqfYpuk3PBOY/OBn2E5XZ/+o88nPnOzf0ZJcKsaVpRx+MlrH6FoOP95dx5SXHH5PF+BPsoPfAfiTreB35cp3ihX89px+ptrB7wP8aXbsJyf/dCv4iQTgb20FP5WTf4YV/LYcfrMV/J5c/W2xgt+ds/+ZdvSTK99WK/jpdsCfZUc/Ofln25E/1/5vi/Al5yIAf3sr+NEE6GM7L+8qmTxB+sBFtkHxIz7/AxYNg7TqCZYt3sflDctPx33bIXmwDvywtguJVceE2SjTbQ35xuk3GGSl+dCOno0xUJ1od5Ug1mWCWDcJYXHcthS5MoJyjReSi+O/pWBNFMSqFMLSjl4VVopck4Tk0r8nlynWFEGsqYJY0wSxpgtibS2INUMISzt6hUspcjULynVjRk6uFiG59O+ZglhSfYf+3SqINUsQa7YQlnZ07rRcsA7LYtmd72rrtjvflUjane9q67M739WesDvf1dZpd76rrRe4OvSHkAa2Ldy/yY0r2gJ/Iwbp1xNZZeXJj++mEXmofqBegu6mM7I2MWG0jk5n0pnOpNPEhNE9fqVg3SqItVYQ63pBrPWCWFcJYq0RxNogiLVOEOvmMsWStNVrBLGkdM/12+Viq5L1cZMgVrnWx1sEsSTrULnq/lpBLMl2QrKvlWyjJXUvqa9ytS9JbiJZjpK63xLaiTuEsPRvOoYtRa5LBOWaKCSXJJZ2F2Xk5JokKJeU7rW7XBBL0iboXHopWJVCWNpJ2YR2lwliXSyIJWlfknJJ2Wo5t4WjBOWStFXJcpRsV8tVX5K2SudWy6VuS7ZfdwpiSfKvqwWxJOcUJDm55FhBcu4R+D3MY09BYZHs/3bXAKIDXgOYYkce4xrAFEav3H5YQXn6gpQzlhfKcmsmDLBgLR/v7cfxp6M84vj4N7yPn23IFlwTwdSO7u3fmskPfgb61Xv7r64szBsuG2qndsoh+N2QkH69Z7XexEx2MY3RI2cX8G4TE0Y5fdDy4sqe7n0rBWujINaVgljrBLFuLlOs9YJYNwhiXSOItUYQ60ZBLMk6JFmOtwpirRXE2iSIJVm3Je1Lsg5Jtqtbgu43CGJJttHQFnLfUQnyjyj3nZMgfu6bgxkGXeD06V4cCOf+BywaBmnVEyzhvMVMeTON3TAPp3t7OawZIbG4b+NslOnWhnzj9O1+C9get/stYHuH3W8B29Jg8y1InxGiu1YrZdkV+CwVSL+eyGqrTrUSeah+6HhoFiNrExNG9+7NYtKZxaTTxITRfrsUrFsFsdYKYl0viLVeEOsqQaw1glg3CmLdJIglqftytdVNgljrBLEk7UuyzdkoiLUl6H6DIJZkHm8uUyzJun2NIJaU7vVvui+3XGy1XDmAJNZwvz3cb7vSdwz328P99nC//f7Ufbna6i2CWJL6kmxzJHV/rSCWZB2S7LfLtY0uVz4hmUdJ7itZjpK63xLaiTuEsCJe//05pWBtLYglNU+uf88QwtKO7j0uRa5RgnJdIiSXdpcLYl0mhKV/N3tyWO933evf9NuJUrAmCmJNEsLSTlJfM4XkkrRV7STrULnafbnm8f3eFkrKpd1w3+F+36HdpUJY+rfkngcpfenfkwXlulhQLqm+VjvJ/lFSX+XYd2h3pyCW5JjvakEsyTUdyXkAyfkJyf059Pu2VhQWyf7PnRev05mT/TtamuuLkPQgH/gZTr+eyCosT8yk11ZGr9x594Ly9EYIPpZnNqMfKMttmTDAgnMy8fdtOP5slEccH/+G9/Gzv1Zt/r+JYGpHv2/jzkrHz0C/+vu2P1UV5g2XDbVTO+UQD/x9G6Rf71mtNzGTXXD1n7MLeJcrL9rvBy0vDmu9INbNglhXCmJtFMS6VRBrnSDWTWUq11WCWGsEse4QxLpQEOtOQSxJfd0giCVZHzcJYknavWRbKFmOVwtiSbY5kjaxQRBLUvdry1SuGwWxJG1CkptI9tuS5Viu7ZekfUnWx3JtoyWxJO3rGkEs0D2MV/D4JpL93/IdcG0Rkh7kAz/D6dcTWWXlyY/1OL3OZvQa5n4xkBV+4zCczmDf46XdRkGsKwWx1gli3VymWOsFsW4QxLpGEGuNIJbU3UjarRXEkqyPmwSxJO1LUl/XC2JJ2pdkHZJsVyVtQrJdLde6LVkfJevQrYJYkvVxS7CvDYJYkhwA+trGbBjm2/g8EhyG0zFxfvw+xGtg3otk/7d7h2934PM6IP16Ric2OP92AfUKutuekbWJCaN7V7Zn0tmeSaeJCaN9UylYtwpirRXEul4Qa70g1lWCWGsEsW4UxLpJEEtS9+Vqq5sEsdYJYknal2Sbs1EQa0vQ/QZBLMk83lymWJJ1+xpBLCnd69/0vI5ysdVy5QCSWOXab0vqXpIDSLbRknyiXG11uN8euj5tmJOHwxrm5ENnX8O8cOjsqxx5oXaS+ipXW71FEEtSX5JtjqTurxXEkqxDkn1HubbR5dqnSeZRkvtKlqOk7reEduIOIayI13+PUylyXSQo19ZCcunfowSxJNeHJPU1WVCuyzNyWJcJYenfzZ4clpRNaHdJRg5LSveSdVu6PkrVIf17hhCWdpL1cUuwL3reUClYEwWxJglhaSepr5lCckm2hdpJttHlavflmsf3e18rKZd2w9zE/b5Du0uFsPRvSU4upS/9W5KTXywol1Rfq51k/yipr3LsO7S7UxBLck7hakEsyXUryXkmyfkvyf2F9LyhUSgskv2/zuvf1ul05mT/jpbmAp/jAunXe/37KkF5cvt8x3n99TqK0SvoZ7wdeXoiBB/LM57RD5TlBCYMsKAdxucN4fjjUR5puz0RyVFNnj1Vs/n/JoKpHT1vaAKTH/wM9Kshv1lTmDdcNtRO7ZRDLPC5WJB+vWe13sRMdjGO0SNnF/BuExNG53CClhdX9nRvQilYGwWxrhTEWieIdXOZYq0XxLpBEOsaQaw1glg3CmJJ1iHJcrxVEGutINYmQSzJui1pX5JySZajpFyS7YSkTUiW4wZBLMn2HtpV4FaUE8zJ/h0tybW3AzfBXAY4VZ3HcxOZtGNdEZKe5/G8DtKvJ7LKypPndVy5Yf1QXjeRkbWJCaNlOJFJZyKTThMTRutmKVjXCWJJyrVRCEv/HuHJYEnncY0g1gZBrJsFsa4RxJLU1yZBrNsFsW4UxFoniCWp+/WCWFcJYknm8Q5BrAsFsWA+mnIL7eZk/1fdYaKrIxHv6ojH+1LRZF9HZ7o70RlN9LQnunt7YtFEe7yrrzOZiEZTiVRvW7Svo7u9L5Xsbk+ke5LdnXa5Q3t3ncf3rzL4sTjgT7KDnwD8yXbw2wB/azv47YA/ww5+B+A328HvAnw7Z2jEcva5vR38JODvYAe/D/B3tIOfAvyd7OCnAX9nK/jxKODvYgc/1/7sagc/1/5E7eDn2p+YHfxc+xO3g59rfxJ28HP9Y5sd/Fz71m4HP9e+ddjBz7VvnXbwc+1blx38XPvWbQc/177tZgU/kWvfdreDHwP8Pezg59rPPe3g59rPD9jBz7U/H7SDn2t/5tjBz7UPe9nBz7UPH7KD3wP4e9vB7wX8fezg59q3fe3g59q3/ezg59q3uVbw23Ltz/528HPtzwF28HPtz4F28HP87SA7+Dn+drAd/Fz7eYgd/Fz7eagd/Bx/O8wOfq59PtwOfq59PsIOfq59PtIOfq59PsoOfq59PtoOfq59PsYOfq59PtYKfnuOfx5nBz/X/h9vBz/X/p9gBz/X/p9oBz/X/p9kBz/X/p9sBz/X/p9iBz/X/p9qBz/X/p/m5V0eO5HqUVPx7cmOrp5YOtmRjva0dXYlkunOzr5kX3dbqrM92hfr7Yj1xmPprq5ke3uyt707FkunutvTXTnZT2exS3GxXL1K2tBLLJ1rF3oQfkRM/q4cfq+Vcs3j91nRT1+uXU4xZRtv6+voSUY7053JZFdadaLxPvVfh7KadHs82Z3oTSor6utJJXsSvd3x3r54XyLVpdqaVKK7I5Vq69NbgS/JLqTDOdhplI9qUibzsn/DXmftzs3k46RROI7/+frN/+v01mbTa0C68lA62kGeq2zoVM3lR0h6nsfvU4H064mssvLk96lUEXmofug+lWpG1iYSph1dt6xm0qlm0uGw7hTEWiOIdaMg1jpBrBsEsa4SxFoviCWZx2sEscrVvtYKYt0kiLVJEEvSviT1db0glqR9SdahjYJYkjYh2a7CfrY6r39fKNc3d0Shrz3d6+8gLOkV5guH9aD4+2by8airJH/jPNUqf/iYPC6NR+XBvCmJ8P04g3agxxoULslxAL/ODn4CdF/rFeqU5qnOR1cQzv0PWDQM0qr3+uvdBj/k8oblp/WlFsmDdeCHVRsSq44Js1GmNYZ84/QbDLJy+aDjG6494vg3xK8zyIXjNzJpw7ugw3oUJqjDuEmHuC5C+qOQnH2pnqXzDl44zyOukugB9DaJxJubyeuB2mCtD5ZH/p5EnlUiPOzsjhmHth+APIXtB7BukyRsoO2edrRtoDrXTpf1i2RuoZLJE7Uhv7mFShSO478yIp/en7K/R6I0GwxpjiZy4/jazc0Uxm9Eeatk4jQQGSH+X7Ny6fI7PVt+nO5Anjry/vvJliFPYW0ZlyOVDTDxN/i4bP3K5W1ULr1j8jLT9EZ7/vmAv09j0gPZtyJxtYMyHoOeC85xBb7zDdKvJ7IK90M5DjOGyEP1A22L7odGZn8vWJjs2zt57uKlC1IVRJVN6DeGbyJwEAfHxa4JieT5xKPFrt1Rmf7vUQeqrCYyN2X7QN2cVGd/N3r9qz49SgrLUMk8o83zKEZ+bvr1nExhGKZDh5KwGkNYrSGsjskXhNWj984l741kMLUMx9bm8bBuPY83L2iuOT372ZIf1n4EC78/hmCNLYJ1JMHC748lWOOKYB1NsPD79PiS8UWwlhAs/D69FmlCEawDCBZ+nx5DObEI1lKChd+nR2NNKoK1nGDh9+kxlJOLYK0gWPh9ejTWlCJYKwkWfn8KwZpaBGsVwcLvTyVY04pgrSZY+P1pBGt6EazjCBZ+n17DunURrAUEC78P7zYwWLRLtvMJTPDjmSD9eiKrrS55htdfr1g/dNmpmZG1iQmj7VYzk04zkw6HNU4Qa7wg1gRBrImCWJMEsSYLYk0RxJoqiDVNEIu2W8X662Mym/839dfwHrZdHK8SxeH6aIzhxwcqveC84CgiM5cmxzHPyxSG4Sk4yk3xdFETCcNTaWNIGOaYtN3H02xjSdhIFAb5wRyzmuTnhOxzu8P1aBRzQT9d0XEL97/nBZvO4abkGki6EulgfdE+pkkwHcrrcTpbCaaDsfbNFKYzlknH8nGQ6SD5wOnXe3y7MkdGnhg9No/ThZ3Pv9sCT4dMJLqw87l7nntx4wlsK3TJgRszcEcQ4emTeaklahL/QyuPTs4bgaLippOKM5rEo6dEjvcRaw6JN5H8DbSEyoGxsKNymKZnuPS5ZhF+VzPPteOGW5TKcsWGn9GmAb8/2ZDOhBLTmcCkA1ULUy8bK7vT7ODnVgG5IS7OE6TfwOgpTNOO06r3+peRjWaAy5upnDH1DTIVMDUkVh0TZqNMpxjyjdNvMMjK5QOvJuF27r9oyvXy2kJsrq2wu7sk0RHUHiH9wdqJGnQlnKPq8G4TCdPu0kw+Hg2rZJ5VGLA2CmLdIoh1gyDWVYJYawSxJPMoWY6SebxSEEsyjxsEsW4UxLpeEGudINYmQaz1gliSNiFZHyXrkKRNSOrrGkGsmwWxJHV/tSCWpO5vEsSS1JdkW7hWEEtSX+XaFkrqS7LN2RI4k6RNSPbbUrrXv+lpweVi95K6v1YQS9LuJfMo2U5IcgBJfd0hiBXka01uXA/xuR3u3LzUlrLDvZ3Em5vJ64G2OUF3uLeTZ5Uev8NdY79Ivp6eSt7Vzu58bCIeIenRPHok/Xoiq3D55+asuG1L3Lwn6G46I2sTEzYT/cZhOJ3pTDpNTBjtt0vB2iCIdaMg1vWCWOsEsTYJYq0XxJK0iRsEsdYIYknahKS+rhHEktTX1YJYkvq6RRBL0lavEsTaEsrxJkEsSX1J9kNrBbEk9VWu/ZCkviTbe0n7kmxzJOujpE1IciYp3evfdA6mXOxeUvfXCmJJ2r1kHiXbiXLlX3cIYsEcDPeJC91az41hpxnSwe9PC4DFjYchPvcZiGmuB3+WAu/aveUlP9fDlQf+bAfSH8hcD+gtRuLRuR7ctm3tg+WRv2Pkmd9cD923tDA7kWX3liF+qzndr2j6NJH7ZBI/o/aL3x/jg+V3IsA4j9fV0qyudLmnxxRiFttuC2XM5ZXuJ5zskz4u+2oSdxWSbf4Y/7Rs6JVLZ1SJ6Yxi0mlg3ov4/A/p0Gc0HU5mSAfvIQT70HOll9Xl36HlVcm8C59I0jL7CDq98oosJvcZpZ/9RlB6eB/1fpnC+NA213h5neA41N4h/jXIpk4n9j6O5Bnnk5MZMPGpFFhm+EScyrCBtE+W9gKz7ROkxX2KVOfx+vA8vkyo3dUxeuDSaS0xnVYmnQbmvVLrESezaS1hoOlgLKiTdm0j/KkmVM89KIzuO+5FYfQEMXzyL17joq6S/I11oevuggCnodhdSxs8HU4hYViHtI5jx+kQdBFUh41efx3Suj2GyQdX7+n3GmHr/QSDDDidRhJGPzXEYbh+1hP5Khn5Kg3y1TPp2P02ILwNTiBh2AYnkjBsg5NIGLZBatcpFEY/vUyjsBoSNg+F0VPqzkBh9SRsPgoLWx+gXHR6dwudFoZ5Tg8Jq2Vw7X7amEgE6Zdw+vVEVll58mvQXP3nTlXkbpqHd5tImHYXZ/LxaFgl86zCgCV5U7PkreJXCmJtFMS6VRBL8vbum8pUruHbu8Nh3SmIJamvGwSxJOvjJkEsSbuXbAsly/FqQSzJcpRsvyT1daMg1lpBLEl9SdYhST4hqa/rBbGG29Wha1eldK9/0zXocrF7Sd1fK4glafeSeZRsJ64RxCpXvpoRxAK+Sue39G+8ngJzAPgoOsm14KE8dwTniZ47gnUV8fkfsGgYPXdkop28Gc8dMdkBnvOjRwyWcu4IYA3WuSOTDPnG6TcYZOXyMU5QJ0Fup+DmlsKWLXdULbxruY7l9nOMM+gJp1/KtztxEg/WViu8/mU3yQfLI3/HyTO//RzcmUR4rfrgel5mvFbNHf9Lb0O4FK1VH5b9za0LNHmFYdjW4Bg7u7e7hJ/nryRhPSjM7ywvz+PnyCFPYW8hwN93Ydkwpt8tBDUoHMc/uT4vy6kzeMwIwsTfucF+FYgPa5N4DwGOQ2WA+KcjGegeAohT5ZOvWh/MZcgWe+t5TI/B5PJVT/JFZagjMkD8eShfSbTBDceBv3H7uihTKNtIJi3P5xnGxu/SMFO6xd7Vv/ENFTSM2grVF37fT6fUViD+uQZbqWFkwPml5UploHHqfWRYwsiAjzzsXXjuyuyNER5x9OKbSvI3LUpaBDUMjp8DfP3OsnoeB/42mR/ehlLLpFHrIyN+V6sH1NeXWpBakvJRUAWTAS6xCo933BUR0JZavjEs8Lep9Oa2GjvyGG9u477h5o4phne5NXm6vyloOqO8/D66xUsWLvKzBVr29O9qn/QjzPseeTfCPPO8wu+cOX5C8xz2Fsk6Rn4unfoS06kPmM7YEtMZGzCdCSWmM4FJh2JxfFW7MzP5cBz/BtSO983gMSt8MOHKFIjPjSG4vS0Qn5sDGcfkkTvbYKJXPG2sS9rvTQopa7E5CLp3iBvLBpV1v0GWtTqkrPVM2rjvV53b/GWpRYcuXJLCTQwVwyO/ab9PTzqn3Vmtj6ijSDy6DZpOD1WTv8eTv0cy8nEO5MCOylLpFXdQRUFX96EqOs+ninoeX0XB7OnwF7/LDX+5bfp4atFv67Rf8wM3w9Btyw8Zmh/u8xnTydzcJyncpz7crTnTSRjWE95W/x52pj9mboiGwgRpTK/Wz5kz8nJQ/VRngutCO6o77mYf/HkNPeoXf3o0lYTh7XL0k6hidkXtFW97g3fxpwVQXueieLRrPA/9XUni4zQh/iKUDjckgnerSfwvMUOiJkYmkKeOvC9rM50J0OFir7+DsCVeYd5x2FIUf59MPh513PQO5EnrYk6I6R1cjlQ2wMRtDC5bv3J5EpULvWQSp3ee558P+LuSSY/qEsK1gzJeSjDmZP+OluTakxGSnufxwy1Iv97rr1sbw62lRB6qH442GC6ZXIx+Y/gTCBzEwXGxOwGJ5PnE44p9AvMedaDKaiLzi2gW7idkRhhXfXo3LpahknlGRwdVjPxcOjUlplPDpEN3YmtHL7Ocx+SV7sTWjl48OR+F0cssz/T65wvCzjJgLjBgnm0IO8cQtpAJ0zIdOyovI22OuaoBXQ1Xdn71wA9rP4KF319KsJYVwaIXZOL3lxGs5UWwjiZY+P3lBGtFEawlBAu/v4JgrSyCRS/IxO+vJFirimDRCzLx+6sI1uoiWPSCTPz+aoJ1fhEsekEmfv98grWmCNZKgoXfX0OwLiiCRS/IxO9fQLAuLIJFL8jE719IsDJFsOgFmfj9DMG6qAgWvSATv38Rwbq4CBa9tA6/fzHBuqQI1lEEC79/CcG6tAjW8QQLv38pwbrMgKV/w1C9kXkf3m1gsCLZ/4F+XY6ey9GdWOCvYCD9eiKrrDx5+nW511+vWD90tnstI2sTE4b7IhyG01nLpMNhLRbEWiqItUwQa7kg1gpBrJWCWKsEsVYLYp0viLVGEOsCQawLBbEyglgXCWJdLIh1iSAW7ctMvF7/hulcE6+H93B7RqeHKsk7OD7G8Bs3VCKZlxaRmU6ZDnT8oH9vTbAGOn7Qv2cQrFLGD8dmCrEGOn7Qv5uJXAMdP+jf2xGsgY4f9O/tCVYp44fzM4VYpYwfTidYAx0/6N87eIVYAx0/6N87EqyBjh/0750I1kDHD/r3zgQLv0/b3GLjhwsyhVj4/TDjB/17FyLXQMcP+veuBAu/T9vcy4tgRQkWfv9ygrW2CFaMYOH31xKsK4pgxQkWfv8KgnVlEawEwcLvX0mwriqC1Uaw8PtXEax1RbDaCRZ+fx3BuroIVgfBwu9fTbCuMWBpd1CmEAu/fw3BurYI1t4EC79/LcFa75nz2OkVYuH31xOs64pgdREs/P51BOv6IljdBAu/fz3B2lAEazeChd/fQLBuKIK1O8HC799AsDYWwdqDYOH3NxKsG4tg7Umw8Ps3EqybDFjanZgpxMLv30Swbi6CtT/Bwu/fTLA2eeY8fsArxMLvbyJYtxTB+iDBwu/fQrBuNWBpd1amEAu/fyvBuq2IXHOIXPj92wjW7UWw9iJY+P3bCdYdRbA+RLDw+3cQrDuLYO1NsPD7dxKsu4pg7UOw8Pt3Eay7i2DtS7Dw+3cTrHuKYO1HsPD79xCsew1Y2sEuukbm/XsJ1n1F5JpL5MLv30ewPlwEa3+Chd//MMG6vwjWAQQLv38/wfpIEawDCRZ+/yME64EiWAcRLPz+AwTro0WwDiZY+P2PEqwHi2AdQrDw+w8SrIeKYB1KsPD7DxGsjxXBOoxg4fc/RrA+XgTrcIKF3/84wfpEEawjCBZ+/xME6+EiWEcSLPz+wwTrkSJYRxEs/P4jBOvRIlhHEyz8/qME65NFsI4hWPj9TxKsTxXBOpZg4fc/RbA+XQTrOIKF3/80wfpMEazjCRZ+/zME67EiWCcQLPz+YwTrs0WwTiRY+H14t4HBimT/h/Wnz6HnOp052b+jJbm2WISkB/nAz3D69URWWXny60+f8/rrFeuHrj89zsjaxITROcfHmXQeZ9LhsJYJYi0XxFohiLVSEGuVINZqQazzBbHWCGJdIIh1oSBWRhDrIkGsiwWxLhHEulQQ63JBrLWCWFcIYl0piHWVINY6QayrBbGuEcS6VhBrvSDWdYJY1wtibRDEukEQa6Mg1o2CWDcJYt0siLVJEOsWQaxbBbFuE8S6XRDrDkGsOwWx7hLEulsQ6x5BrHsFse4TxPqwINb9glgfEcR6QBDro4JYDwpiPSSI9TFBrI8LYn1CEOthQaxHBLEeFcT6pCDWpwSxPi2I9RlBLDrnWGyf3EnZ36Z9cvAenneinxhWkndwfIzhtw+vEslcbD/eyUTmge7H079PIVil7Mc7lWDh98Pux5tAsLj9eNx3cOdlCsPmoffoNwz4RhL6bR2+kWQxCcPfwdF56bNQ2FIStgCFLSNhZ6Ow5STsHBS2goQtRGGgI/wdHHwfCTo6Ifu8juQNbHBO9u9oiY67uYzqEZdbxOd/z+s/x64dbQPwrTQRks5iwXQw1j6Zzf+DjWL7pcdlLCHp0Gc0Hfz+Eh8sv5siz0DhOH4qW/bcTZHc3mR81OTcjOebV3gXbIq2a3Oyf0dLczHAX2EHP2Fqf3GeaB3EugtjXzites9j+5U5Qroz5Q3LT+0Q9wdB9o0vD4lVx4TZKNNlhnxzbS4nK5cPv7qJ0zGdWrvCIBeOb+qfQYe4jxTUYdykQ66PH8iptaC3qSQetDsVnufLdSiWR/6mNz1WevyptVzbVucjJ6RbrB3H70M80xEWQdoNLh1OZkgHny8A/YTmCJeQb+XB7vCRH/hd+Na0msQfNyaPeXkWk/vuxq+uRFB6+GwCKHsqn99RMbTfg/jrUL9HT/A8g+QZ55OTGTDx+Q9YZnpjLMS/jvAuS30ky7sgrUYiLy0fmheuTKjdLWL0YNIt5imYx+D4N4XkKdhGKU/BMsG73FiP6oFLx9RPLgqYTn2J6dQz6ZTKQ7h0OJnpmEo73J7cR9oTsDvcnuB34Tv4ahK/ArUnHzG0J3R/CuVOtI2l7Qmk59eeUPuE+B8ztCccNz8q4y8zYOL2BMtM2xOI/yhpTyzxJ7Y9gbS4/nKkx+vD84L1lyMZPdjuL0eSdJYJpoOxoK5wXI62P2G5NX6fclm/+vqlUXyaXH2l/ADHf3KrPOZXSX3F9g465+yG9lHLmHRpnfG8/uMz7Uxt2TIfrKB9FMT/rqGPMo01tDONpU1zjjgejmOa/6s0pIHttqD99fr3nWeQuMtJ3GWGuH7jRv379Oxvu2P7zm6oC3gOExyErWJkhjD8ze8JmXw86irJ3zhP2lYy6FhJGo/Kg/W0ygeTay/oqfqQ5woGdwXBxW0A1Recs0Xr/5+ydUHX/+dG8XjUTrQ7JYtnd/zamaTlix0tX6of6rjyBbl1+T4SonxxGa4mYbjNpme74bYeMLTu3yCcoNzq0kDqyyMl1hdOn3SNgOs7sT6rCcaEhnycN4m9QxzaX2gH9QfqLOivinlfO8r9IP6/Ud/z9gw+fVN98zy+XcB6oGcyrvJ4Wbg8Q9yxWT2BPeI6JmePbTEox/OJzDjtNZbSjpD0PI+f54X0Gxh5QO56JqyqBFnbY52d8Y62vvZ0T0dXe3sqQvBBVvqMzlFyZ0E0MvFB1xda0XWijzsS+gKkV+2qUNgaElaNwkBGXYfenVEo/wWW5A+if5x+ExN/v0w+XpiybGLSoWOOUrCWDRBrjFdYB7i+EHMb2hdi/oLPAY2jDoNrF01tHbRttN3H+aTt4K6krcP9n6ANtXF8lLZ151tKO2hbB+k3eP5lW8+EldLW9bW3xdrS3e09felEqq8zHfH69wmVzDPa1nF2O5qJb7mtiHJtHW3PqlDY+SQMt3UgI9fW2ekXE9Eg+sfpNzHxaVsXtCybmHRoW1cK1rIBYkFbh3kQ5am4raM8dQWTH9zW0XFZO2mT7Bx9z88R0jYVy6sdHkOvQHqi+qU4+BnmzfgdOmcD8fdEvH23Bl4+yMOhjHzcniKcrw82+MdbwcTTNB541LzUkqPOSC5K9R2V6l2UWlLp8eLRLNLs0+GUR+JpR2+EO5v8Tadv6NotdMFBb4SD/zEWV3QYm3a9e2dVppuwuubNv+uIvJDWnOz/0RIdN3SkXa2dZbx44GEFpF/v9Tc5G9tHuKlNrB/aPdpZlohH9YwznfrW7uxMf91QOcBeuOPwIz7/Q37pM9pNYFukdmNqAv2arNNRk3VEQz4+bQOCbNkKshSPn+H4PSQML51FDPh0GuQ4VI+TZGoHUx3Ih92bfuIx7qYfbE+YRvnZP3d9A8Q3bSXTDpYaTFuLONvCtgQ2wpUzvMMthzcQWcMu/Tcw6diuUw0kP9iOKcULu/TI2W+xJbQFPnXSbwltZxSO4z+BltAWBihPrs5APMt1Js7VGazXIHWGK4cgdQbrsImJf3KmMAzbDl1+5MIGWhfw+351Trv5mYGnQ9+HeHa5SGcnNzQBxw1NaN3BywRwDCq3JIOXXanjlgkgv9oeRzXncWk8Kisud0rtcV0Dubm2hm51CtvWmGxvCcLh+pijM4XxuW02OG2/bTbrUV9MbwPk6iBnlxCf28bK9WXc8j7dxmppe3cbyLoSyUn1S9PHNlqB4q80xKecl+Kv8tEdxNcOlzFd0sefeXBbQ+BdOkV5Kyrv08nNbKsM+eHyTKc3TduBI8TTZSftlmX6p88tG2k/J/t3tERHy7cKpbGa0Qdd3rqf9P0wlVXJ5JXT6/lMunj6EXRSTeLfj8pxXXMhJsg20uP7TlomdDqb1uXFmcLw3BY4NC550GfaQzvMlT7ZwKdd7/F2SGVdwciK+5Y1mcJwiP8I0te1zbysWB5OVq6O4guZw9bRI4msEP8xQx012RLX5tLtFFwdpXLTNiyoXUD8LyK7eILYBTfu0fGeIrqmW0a0M7UPtD2dk/07WqKjZYnrKdde0rL8JskX1N9KJq9cma5m0sXTyrR9WE3S5doHSAPXuV6Urp8dVzMya0frHMT/rqHOcX0/Zwfc56ZcfaVlUuMTn+YF4j8TcE4C823tqlCYHE+JsXMSuE2tzhTmO+icHNUTjs9Nnzd5xdtkusVfP8NcFY6Iplv8X0btxC/IeJebQ6PpYdlN4zL8fpA5CstLJd0Rkh7kAz/D6dczOrExr8tdS2qyoSWM/DA25eJzNsqVm54GofMeTQgL0q1Fz5aRZ9x2MFr2uC/DfdFrpA3i7I373ITqpcbjub/fp7l/9mmDaHsLOubG3Wd4/fPBzSHRNj7slbTctnUunXklpsMts0H9pJ+Ozcn+HS3Jhd/aOI+EceMGbnsazINEmHS4uQ5s99c353FpPCorN+40rWsFaZ+0o5+l4vLA9ZVrK+gzWu5cfbf9CUgTyY9pS33Yzw+4T4lNn5pYngcJ3Adhrkh1YqMP4uaQTGsrHD9cbohv4j04Pu6DQCZsk3i7t0ewa1F82obRsueu4dZt99jRhXKDDjDHwu/CdcV07XA9WlOYkMU0zX1zbfhWHi+L5wVrw/H79IgVuqeB+x/Soc9MazdbkfwsMeQnbNuE3x+stmkrko7f/MpsYjcD/fzyXGQ32xnsxtT3mz71sjF3bjqWZKDpBP107f1sU11CNnUqsqndiU1xY8/3q56XC6aDseinpZg70HkSrp9dYUjHdPSNn90cOJpPM6jdQPz9kN0cEsBuuDLwO74FpztY+wmGai0RY3GcB+Jz634mDsbZEjeu58ZVYNt2t8zHAu+lg/Triayy8uT5LneN7EpGd6O8/FgvmVoci3ftk+pdtPLcJbQwALDJK1TyKgII8T3yN31PC1VF4ixh0tAOn3GADYkOBimhpvhBZCoWt1g4VwlX+uTT84JVQvy+XyX0+8acflsH8VPZBi/oN+bYeOjmP9M35st8ZK9k8lDv8Q0JXqDBYTjPcw15hvgLDHleXiTP+5E8+50Vhf+m8SqZPNR6/W0AY3A6HuMVyh7WnvD7g0VWxpB0/Dr3FaRzL3ZuRB8Kx/ETqHNfTTp3jnzbzr/feTI4X30ojt+5BlUMpnZ0czvEvzSbd8sTP+x3GqZvG/CC+OWji+vGVOYQfzYq8ysDlLmp/nDnJJnaCqeJTCwVDWLjOH3nicxvI4VKDkpk6HsmIkPj+lXqUokMJ5Nf3LBEBo8A/FZoPS/Yiil+n+4wtbMqGo/SMsG7VXBl8jukDe/MM43g6CoqxacdAP7QjNMddIp05vUORGL2bdn8myursT7yeV6wssLvD9YO/LEkHRuzuNrRGY3BJut+Nrhz9ncxkvTxkB0mHiTg+D9tymM+QjrMILvOsV6DfAkUdobfVN+C1h+qoyoGUzu/wzWfIgTKzkpVe9Q0i2eXvLUH7vwpoeN2+9UzYSUdNNKZjkU7OjoT6XiyK9XeQftIkJU+C7KiN5WJb3fGqI09aGQl0qt2VShsBQmrRmF4ZZB+fG+HmLX1BdE/Tr+JiU93toSdNZbAgg/mucH6ULVlQQ/dh/g/NExocIe/4n6LTuJwh5/SwRDNI20TtZuT/b+YJaWLOEgPymcEIwvdYQ5xn0V62b+lMC/cAQDQRlUa0vCYZxHPX3c0De4AgpRXKNvyALJxE08YY5GPnBqDOxyU2nXYw0FNk1Y4nSklpjOFScfmyhdOsxgfeyXkitRxmXw4jv91xMf+QvgY5nN01xA3sWo67BwfRMdNoNL2BuL/HdWrIIedH4cw/ews6GHnEP+tMpjQonmu8vI76XH7eGCmMA8Q/6XsyRxa//8ZHQ7zYB/MbRHmOyExD/HBnIQw4TQRzh7He4XpYVvn7J/WOfw+/jofyyJcvrkLX860g5+7HGQ+owucJ0i/1J2TOK3BOrGDy5upnPHFV3RlmsOaHxKrjgmzUaZnGPKN028wyMrlg/IKLp3xjE4g/lkGuXB8qMPY9uFd0CG+UExQh3FTeeMLziD9gVz4AnqbSOJBH1fh9df9mT5YHvl7InlW6fEXvug2szfbn3PzJuN8ZAYZ6DNq//h9av922szODm5nMTjuywgsI3WV5G8sty7vncbkcWk8jEHt2O/yRK7N9cPg5nKL1Xvt8GIE5H3xkoWLUocvmr8suSS177LUOUsY+631CvNH7e5s8veZJC49uQPC6GLmfPL3OeTvhYw81FGdYNfAxPNzXP3A9XE2+j2Q/gG/D/G4dKaXmM50Jh0T1mwGC+IvYOJPZ+JDPrj2EtoAfLGjjfabq0O4z4D0B9J+g95aSTwYc1V4/v1Xsfa7lTzza785W5nnIyekW8xWOI5AsfD4CTad4LpcTeIfnOXldvlsdwLad8wxQGd2OUN3IkLSA33jZzj9BkYekLueCStlfjrelYjFutQSeiraFk32RU11GT+jdf8cJv62THzQ9UI7umYPhz0H6VW7KhS2gIRVozDcn9D5aTvtU3cg/eP0m5j4dL4kaFlyWPsNEAvmp3EbD3V7sNomu21KeD5Jv4gMejIUnkunjuOhkF9ttwe15HFpPCorLg86F3omkw9TX4qfmcoK4kFZYXtxsaxw3aOOKyvIb9iywuVBy+osJh8REgby0GemsjrLkM6oEtMZxaRj6rOD9KlcOpzMxb46XNiYfwe3d35fHa7K5MNx/B+j+chFhvlILCPGjnj8Whhto+F9PD9u4mIQf3lWJm5+/CySZ5xPKiPOcxWTL+3o/DjEP5/wQUvjAHZ+HNKyywfDt0UREobXg/fN5ONRx7U3kCddxocHmKOgdRDLxvGSsxgsOk4/jZEH8rnQK5Qf1w3t6Lovfn8hwSp2cgfdFI/fD/KFE8Y6kmCZ1t6LnUpzNMHiPlAArOVFsJYQLNPX+yuKYB1AsEwnNK0sgrWUYJlOx1tVBGs5wfI7jU/71UWwVhAs/D49be/8IlgrCRZ+/3yCtaYI1iqCxV0Uwc3l434pyOk+di69iIW+DGqwTvfh9G7a3H4BI2sTE0bnOLmLoi5g0uGw5gtiLRXEWiCItVAQa5Eg1hJBrGWCWMsFsVYIYq0UxFoliLVaEOt8Qax5glhnEyxuHwPXto3y8mOh99Z79k6eu3jpgpRHHOaTkAb++xyf9JuY9z0DFn7HlBfMNemcFz7xi1ufpRczQvzvoDEQnDbGrcFheUx7Hyyv6ceD9qvlureCm8+Ad5uYMDrODLOmWaqNa7dvhk8/wrzvFcGCv/FaIsTj5llxXumYH+oenpPAGHTPHsT/ObJ3etJ5sbEYXQPgxlu4Xwd5Gr3+7QX9DoMbU3Jz+3jdULsqFCZo173cyaNYP9WZ4LrQjurOdHsKLnvu5BG6FoDbOcqritkVtKN0rIDfxXNiXFlOI2lya0P4Ge3TpjF549KZXmI605l0TFjTGCxT+ZnWvrl9znZvhsqvfXP1mpsXGMjaN+htKolH1765uRaK5ZG/p5Jnxda+cZme6SMnpFvMVvD7JpucV2I685h0/Np47TDvofO6EH90tm+xu/balTB992j3+7OuwGvsfqdMYrm5Ux1LWWNPd8WjvYl0Ktqe6OnpjfaZ2oywJxC1MPHt7i3vYtfY8TcN2lWhsGUkDPeV+EJ7usZupx3sigbRP06/iYlPxxthTz6VwII1dtyXQN0erLbJbptSvmvseG9ImHVbXB503XYhkw9Tn83xSa6sFhrSaS0xnVYmHY4fR3z+h3ToM5oOJ3OxddvZZExV7LTY1Zl8OI7/SfRd03aGPdGUa9M6gW1QO1rv8c2FQfp3iL9zViZu3Zb7NnN1xl9mSCPod+YQP044hqUTkdl1W9N3r3S+IOx3r9xZAeV2qxz9BgfPwdK9FHhOle43xHOkdH6GznniMLxmdA4J49YeIOxCFEbP6MigMGyj1HFtMz6c7O4Qa9zcTWf0YC2sX25v1Cz0G4eBrPQZtTf8/pk+79F2xPI3LzHLdTr3XRL3zTfOE+XuA90XhNOqJ1jSujPlzbQfCq/T0XU2DmtpSKw6JsxGmS4w5JtrEzhZuXzQ8TxXz2YxOoH4ywxy4fjcAWyDPV/D6VBqvgb0tiOJB7yjwutvg0t9sDzy947kmd98TbHv009r4mUOel4QxN+EeFwP+k2/48FYaa8wLI3CFmd/213j6Yxz8ypUd4tR2nQMtITJT9C+FPKk7WpOiL4U8yYsG8bE5XceikO/34f45yKee+oMHjPimee1qQ0FPUMA4i8xcG2IU+WTr/k+mFchW1zuY+seg8nli+79pDKcSWSA+KtRvmDd0/M8tp9No78XZQplW8Ck5fk8o33BAp8wU7rF3tW/z0W/ub6e2ut5JD6sq/vplNoKxL/UYCvcnl7TejaVgcY5y0eGKxgZdD8xMhveu/DclT5LoVXoN22euaKkRXAGg+PnQA06e1c18Tjwt8n8uGVkz+cZLQZ4F5/F2ZdakFrit1ZcQcDm+SRW4fEuyH68cts3YHs/num8CaxLbl8y3TfAfXsUNp2B7hugtpD2ST/CvO+RdyPMM+10ZblkxObf3FiUzn2EHYtylYNi+Z0RdGYmH47j34naI7rf4EwkB4cJe6whPseLTQcZFxtf0u/TuHGKKW2syyBz+iZZubUezPnpXgos3/KQsu43yLKeGVJWv3oJfZhqpOcvSy06dOGSFK4qVAyP/K4jz2gc+tnCWT6ijiLx6LQ3PVKN9pu0TzqbkY9zXNNAZan0ijt6z8DDqIrO86minsdXUbp9hPvUjxvScdOyJvrOXbaEMeh2J4j/mKH5KfYpBTV77nMJ0wWg3GVB3KcUeBnlPexMPgziWd7u1Mdtd8L5rc4U6oL73MN0nCn3SQd3vHYTiY/1yC0N0WlbbvqeWxoq9unLXJ/8Vvvkd0EmH47jf9tgf5xOuKOaIT73KQt3+Tr3WcxqEobfo0v52P4gnmX7S3H2h/NL7Y/7FAfHp7rjPvvASxx46zKOj/XIHbkIaXLtH77QHY5c5Ja3Iz7/g6z0mWlrwaGZwnRsXbIGy4K0PnFUTv/e2SuMfz5Kl9YnLj7oGU+1cOVXTeL/DtW/dc2bf9OpZ+3w9OPzTXzauO4vZWSlab+LpnleJFOOHH2jR3n/Ecl+XIv/+3Q5FPc79Ch0vyNbsf5xPnGZ0zYO4r+G5DwxKyfXluBpdO2qUJhgW5IO25dx7aqpLzO1PVhnTV5/O/W7VwdjYZ378aAaj+cg+Gh9HP/fzHQfN+xbQWRfFFL2oNxwKcrHx8nRsViX9PMirqy4dp+73mB1AKwVhvyej2Tm4uN2Asevzt7zg3VPMas93pZW+WDWIkx6lHYxzD4fzJEIk3IVrv/k7rWB+NxnTbhPpXwE15ELSBiWnfaba1D6tExPyhSmz32O6zHpegZ5ue34Jnlp2w5hM/GF1NnfdQRPuF1MmMpyGyY/QctyqSH/FAveq/L62ytXh9Yw+pq+FY9ZHRKzGdk79K8c1zkvk097Jkmba0Nwu0jbwKWMXJhzmI48p/xgO6a+DtkYMpaKcv0u1gXtd7kxmOkeM9OYE/cvTUz8hZnCsCB33eF0BtKvXe5zN6Af7vGZwvgmPqZ/J1E4jt9paMc5HZp0XmzcTre04vJYRcI4my43e8X6ofZq0oV2Ycfr1F5xu0l5mOnKp2J2ZbJXfLT+CsLDuK3U3NwCndItZjN0qzNuB7n4lANB/IMD8Cosg+lTi6DzA1wft8bj08b1FuuEXvAN8Y8M2J5DudgdR8ViXP3AeqX1w6RD7cJyRNCZ6fN+rn6cT8KwfdK6E3QesNj8Dr3kvdiRP3Rcx90bizlmEoXj+D2Gtl66f6XzDJxeTW1HudlyubT1dL6Aa+s5+8NzAV0BuMYZBvmLrW3Q9i/o2sYiJP972BmvX76HouwHc22Dlr1pbYPbkh60TTmK5KNYm0LnLSF+JmSbYrIryTaFu5t96OYZy9uuTG1KWLsy9YG4DZpN+OMyRlaTHZn4WTE7Ms1zr/RJB8fTjvuMVrs52f+jJTrTmozdaxCj7RGSHugDP8Pp1zN6tLH9iytX7lo1u9dcRtt0k8etp52d6a8bKodffYK1MO2ORjj00yfuql9dn+4ic03cfAB+F9Kg8wH3o7mzewlm0H0YxdbXx/pcKYdx/a4yxLqt8YmP847jP2gYA3LtJ2dbEL8Yh6P7O4Kury/xSYfbS8D1yxD/0YDjw8FZs4/HhnrNns6RmNbscRnQdSDOVnG9oHWA42hcfZXeVkc5uOkqS24NeOi4UjzO2QrOL7UV03hEO6m5YaxHbj3U7+pKnE5QrgTvaltZkC2MRkYev7YRp8mNRbkxBN63hPPzjGH9kBs3cOMMivmjkPPOproQlPs2ev3LaZXhPY7v4bTmZP8vfuFvsOuAoa0Z4flzCNrO/xLpEa4D5vhPobylOW5OJEL0hNtNwbYh8HXukH49o0sb3JTjA1y9A/2cb0WeWBpzU2y/mJv6HTUN9sKNTzHXfIH0XVwbgNvTnVA4jv8K4pov+2B6XmnrFF8aVYgrPVdnms8KwvMavf5lQo8CLrZHI4nCcfy/o7bBtNdqUDhgLD3kawR0HcB0ZDJnf9gW6Jw86LDGM+/zqibx32HGJEHWKZaFlH0FIzut57TuvBCAow50nUI7WMOm7UJNlmMEnVM0cQNb6xT4aIL3sDP5sOF1iv5zinjfRNB1ivtI283tteDGXtRe/fbiTkThOP4kg/1JfwdC90MFXSsZ8j0R0Vh8qOe0oeyDrJVwc9rcGB3vybkka3829djZFc1xWihDfBwXdlUoHMffMWuv9Sgf8H9JR1N2JmPpRDKdbE/29bX1JunxWtpBmenP7bQ9bDMmrzPQk7TOtAP8ajv4uf2P+Pv0SiZPkD7YEv3sm/vf8/gxC6RVT7CE8xYz5Q3LT+cKqog88NsPqyokVp1P2ByZfOfKtNKQb5q+X3yuDsDzGgM+jg/tOrbhGqKLEXZ0ETeVWw1KE9IfyPFB8Pc0Eo8e94z1Xe2D5ZG/p5FnlR5/fBBtlxq8/vmGdyy3KYGPVYD06z2r9SHXDlQTefzqLv6sesHCZF/2tAPa5NGiw+rEcDTbtOhy3SJ5Rs2BnqABNJDrQqmcEQaDUwFgNnqFMuB3uaak0iddz8ubK20+imHB70qDLH4YEYLRYMAYrjrDVYdxw1UnWNWRZuPxrq6O7nhPtK2zrzfd15Yoxsal0+/t6ehpS/X0dsTaOhJt0b7BTj/V09bd2dPd2x7ti3bHugc9/53JLpV6d1uyrSPaG+3sCDMaAtvHzIrWdY411jDYTcz7EI9Lh9rwCEM6tMmMeHnWV+OZGWI1ib8UzaLQ3RY16B3IBz54eoSPDFVMnrWjB09D/JVIhlNaNv+Geoubbry6sXqMWVbaLld5hWlD/IvH5DEvIHbAsdsmj29ncBguS9DRSC9YuYNOPI8vx2oSH2Y9/Mq9luQb4q9lyr2RxOF0UMfIh5+Z7L/OB4srM+3oJdwQ/xrDzF89I18lIx/EH8nEx20SyMPpZiQJqyfYXDo4r7is6cH1EH8jk1duNhHSHopTZbAOqzOF+canGVUy8Wl5NDDx8cXyoLMmEh+XDVdHR5IwnG4NkYFr47Fd0pUZbmYAt1EcPcc6ADnrmPzKlV1v4At8If16IquwLcXC2gjop8GOfqImG2xg9APyjLYiTzR3GVMTkzbIml38K2hXcPwGpEMcH/+G9/Gzx4i9NqL3AL+JhGkHp9VEmLBK5lnFEGE1MVhYb1Cmuh4/RHRBT2jj/gdc+ozKiMsTbN7URgw0HYwFPIqrT9rPyf4dLcklcodej2byAWlju5KrO+2dQds6SL/es1qXYyYbxvqBcuPqPrzb5PW34Ysy+XjF7Bunw2FtKlOsdYJYGwSxbhTEktTXekGsGwSxrhHEWiOIJZnHjYJYknJdKYglWR8ly/EqQSzJOnSzIJZkOUra6q2CWJL2dZMg1u2CWJJ2X65tjmQe7xDEulAQ605BLEl9SXITSfsqV14oafflyuXWCmJdL4i1JXC5crV7SW4y3KeFwypXLleubaEkl5NsCyXLUVJf5cq/MoJY5cq/rhbEkqzbknVIUl+S/ZBkHSpX3Uu2X5LzcuU6NyRpX5LcV9K+3u99h/5N16wk+o5GH2z827Q2zKUTYWTm1pQrEEad1z+/kuvKgD/GEj7keytGVzhPkD5dY4Zw7n/AomGQVj3BEs5bzJQ301o0XnfHOvDD2iokVh0TZqNMmwz5xuk3GGTl8tEgqJNqQSy6N4ir/9z6LcQfw8Tn7KSRSRvehbIdi8IEyzZuKlvcRkD6A/nKCPR2LIkHF0JWeP3rxlY+WB75+1jyrBLhYTdY7Tv9G/bW4D299Fanwd8j0ZGIkPQgzx7J1/tlj8QlmXy8UjnDbYJYknP0kry7XOczJPMouVZcrus25TrHdZ0g1pZgE8NrGkOne0l9Sc4JSuZRcj6jXNdkJee4JO3+WkGscp3vl7SJYf71/mijJfvaywWxtoS2sFzXzK4QxLpFEKtc59Ul+zRJnrMlrGFvCfsHJOuQpL4k2+jhvuP90XcM77cYOpso176jXOcUJPMo+U1CuY6HJHUvuZ+6XOcLJXnOcDsxdHxiuJ0YOt2XazsB/Mu0d8byPqLAx/1B+oO1N4fTK7fnIuweFdP5XThPOAzLYDonrJFJp455b44noqs4zS/do8DJsZW4HIl2KAO8T4bar819Lzg9z+PtF9KvJ7Last+xRB6qH2q/4xhZm5gwv71ZEO5Z13miZ6A6t7Svzahzbo9YGJ1rd2kmH4+GVTLPKgxYawWx1gtiXS+ItU4Q6ypBrDWCWJsEsTYKYknm8UpBLMk8bhDEulEQ6xZBLEn7kqyPkvYl2RZKynWDIJak3W8JNnGtIJakfd0siCWZR0ndXy2IJWn3NwliDbcT7492QjKPtwtiSfKJctX9HYJYw3UoHNblgljDdWjodC85dpccI9PvaPEcEp0f5eZbxhrSwe/jePhv7jurRZlCmcah98YQmcLmHb8P8bh0GktMpzFgOjbyU8e8Nyf7f7Q0l/sOeXzp2O30AWBPkJe7DeYA8V0D52Y2/6/nzN8cV1gO+O6JSvJuBJVDNYl/0vg85r+ymPQ+Gw/9riN4EU9yrjT4re6Qfj2RVVae/NxtBZGH6ofO3VYysjaRMO0uzuTj0bBK5pkJa70g1s2CWFcKYm0UxLpVEGudINZNZSrXVYJYawSx1papXJsEsSTtXlIuSd1fL4glWY6Sur9aEEsyj3cIYl0oiHWnIJakvm4QxCrXui3ZdwCfgDEF5o9wPwl3Jxq9/wrf+4YxcBiWz3TzNH6/yuc9mg+6XwbC52T/jpbmYoBfawc/d8ZOsbv/IH3ujryIz/+ARcMgrXqCJa07U96w/NQOuP1IJqwRIbEs3+CdK1PTnWI4/QaDrFw+6D2QXD2LMDqB57UGuXD8RiZteBd0SO8NnJP9O1qai5t0iOsipD+Q84lAbzNIvLmZvB6oDY7wwfLI3zPIs0qEh10jweDaUVqf/cq3yed97Ux34jYw70H+8B2WE1F4LUljIiPjRIOM+H2Ix6UTKTGdCJMOxeLmaLQ7M5MPx/H7snM03F2Ukxj5THVxMhN/EooD8nC6mRzgPe0amLRAJqjHU9Bz6bYQpwfy4mc4/Xoiq60+aQqRh+qH1o2pjKxNTBhtF6Yy6Uxl0uGwJhEZsG0NUvnFB1p+k+zIYyy/SYxew5Yf5QhTreQj1gtyTfP6OwibjtKmtrA1CsN1hbpK8jfOk26/Tm/J49J4VB5sYyBbHSOroJ5SNL8eIxfua+/K9JffM+hiOtLFkhC6wPY9g4Th8mgmYdieWkjYNBQ2k4RNZ+QJUje1o22Mya4mCaaDdTSZpDNZMB2s76kknamC6eCyg7Jq9PqXHa4ntI5XMs9oOlOYdCA/mOvj9afbxvNpYm6D34UzOKtJ/INm5DHvzGJCHZ+B5JKr4/Eo5K3Z6+8grAWlPZ2EzURh1J5bURi1wVkoDJctdVy7AbrQ7caGEO0Gbrdp/Tf175b4UOD+HdIfrP7dxIu1M/Xv8C5Xb2FtuJHRK86TnwwcRxxoe2eXYwQvW0h/sLj31IB65XjQVKJzHEb3SXBc2iSDiZdPYmTg0plcYjqTA6bjcn6gz4H28tZsgO5zvj2+ME5TNs6nJ+XjfJfEgb1Az6C9E09lf3N9yzmZwrAWFEbPaJ7JhGn8UVl5QGe4L6FzI7MQRiXzzDQ3MssHqwph1SEs2q9D/FdJXz4b4crV8Y5O0Ns2SCba3m1rKe2g7R2k38DIA3LXM2FVJcia7u2KJqIdHX2pjrae9rZ0hOCDrPQZnS/ajonPnZMNut7es6LreO5ei0wefzukV+2qUNi2JKwahYGM2u7fnVEo/3aW5A+if5x+ExP/SJSHMGVpEwu3BxJYIwaINcYrrE+4zbHbBsU7uDYIHFfn6doarmMwxoowWNy4APKkMT/Wksel8ag8uJ3HstF8cP0HrFc0ev31ug3B2rYI1n4EaxtGrgYGi7bxduptcE4L6XPtuA1Oy7XLXL0A3W3PyNrEhG0zKHqNd1O5sIOwHVDaWJ/UcfUC5Nb14rch6gW2P5y+n86xLUOb2uj5t+v0PVrfgvAZS7beNlBb38aOPEZbx/oZqK3jdovaYiXzrMKANUsQC+yG4/p0n39Yrt/IyGyXJ8e7uH4OHFdm25CwHXzyTx3XDkCedDvwcksel8aj8mCdb0/ChqAf6tiS+iHt4JuaUuvTlobF1bWIz/+QDn1G08E2TTlZK3oPrw8kJuTfwe/h9QH87tGZfDiOfw+ah+nIYnLtIsgI9XBHFCbYluXWUXfy+jsI2xmlPR79po5rr0DusOuDuJ7vTMJw+e1CwnB93JWE4XY3SsJ2ZOQZqH3hsgrC+QeaDsfHbNcX2ndsL5gOLjsoq0avf9lRbrIDSYc+o+nMYtIpVv+PnMCn6Vf/l2Ty4Tj+9aj+H5PFrGPyOJR1fEcStgsKo/a8KwqjNhhFYbhsqePaDdBF2PVBXLaQJ7tzefEkbV88Ri7cvtD5852QXHh9kzpOT3ju738DbF9peeP6DrI1ev11SOdGwvb32zD54NJpLDGdRiYdy3Wuhyt3cFy50zHCzj75p65Y3QkzRsA634mEmcbvdnQYfIwA6Q/W+J3rb0zj9x0ZWSlX0I7y5x2ZdHZk0tnSsbj2N+LzP6RDn9F0sE3TuunHEa4iHAHeCzpGgPgXIo5wDRkjcPN5UA9xmyHYlqUoD8CO4wFhxwggd9gxQqlcX/+OkTDcJsdJ2M6MPAO1L1xWg82pbdcXyidsja0oN+H60wgJg3ToMxM3oX2hX/1/cAKfZtAxAsRfiOr/x8kYAedxKOs4HZNzXB/CYiiM2mAcheGypY5rN0AXYccIuGxxnrDsVegZHrMfkdn8fzWJ/0S2nHSZfX5CYXqtKA1I+705pYmF8bj6aHf+J/j3JZB+vde/vtvgWBwv4Mb0XLsN7zYxYfj7wYG0C1wbU25zdHQPLx6/43Kjrtj8XZhvHXAdo+NwLI+gntK0nfIYuaLoWdhvHXZBugjDU2xyEf07QcJ2YeQJUs+1o/bO2c77jT9w9avUdHDZQVk1ev3LjvKUnUk69JmJp9A+GfNIzFNensCniXkKfpfuiYT4JyOe8grhKZbGIqHqOLbfgXIRCEugMFy21BUb34ThKZi74zxh2YPyFIj/L1JOlnhFdAzJF6fTYb5jn+/guVzaxoXlO3TutFz4Dv1WZCj4Dq6rw3wnHzbMd/h0tlS+g+sJDoN0ivEdrp5xaxSY78yayKeJ+Q5+14/vHID4zrZZTMtri07yHbwmOdB5GdpuFJtDiZC0/XjR4ZnN/9P5m66JecyOif5ytaK0Hx2ev6HOqfkbKMvh+Zv+8uD6Nsxn8mHDfIZPZ0vlM7ie4DBIpxif4epZsfmbvgB8Jsj8TQfiM/MInxmev8nHGYr5G8pTIP5SUk5DOX9j+m7AEr8IzHfoniDb3w1we4JM3w0E2ROkf9P5m4Hul8H2WE77IfVvOn+D62fY7+Tw2CMM38F6Btksr7n3US7gMXJhLhCW7+D18YHuvZfeX4/bcNv99mDtvX+/7t9p9OTbI66e0TGHdpjv3DORT9NvXw3lOxC/FfGdD5N+1NJ3waHqOLZfypM4ew675yZou4G/NQ7DdzCXpe1GsTkUKAfM0+TKIZG7f6jN6+8grB2ljb+lpY7TGcitdfbkzDwujUfTxO1IOwnDNtlBwnC70EnCcHl3kTBcl7tJGG47dyNheDywOwnD9rsHCcP2uycJw/b7ARKG7feDJAzz/DnZ3+VmP7SudqAw+p1MJwoL+50MtrvJs/K4NB6VFds3yD3Ky5+PPC+15KDUymOTC+b3JZfMX3jOkanzlqYWL6kisLRLpZ+dbe8jLsbxDOJqV0HCZpNwOFaqwuNdA/MepAFm04aeD8VwBdKv9/oXj43hShuRh+qHDlfaGVmbmDC6naWdSaedSYfDAlvhtr7Ta/u4I162MaQzhpG53JqQMSQMNyGldE8D3cYHstUx8gjqqZM2ix4jVxd6FnZY1IF0EWZYhHVOu1VsM7RbxW0L7VZxedNutYORJ0h7oh21d852TO3iQNPBOqLT2gnBdLC+20g6bYLp4LKDsmr05Ns9rp4VGxa9TYZFxY4koMMiiN+EhkXvEjpu51O6cHUc2y+EdaMwas+7oTBqg7ujMFy21HHtBuiilGERbTeaUfzzMoVhLei9WeS9mSgMD6fgWE2Ih48ibSYY+OjXFhKGj6qeifDfyJ6tTW1oDLKh5kn5d7UPetwRxOc+792OyS93LBWd4rQzrC8v+4WwPVBYKceL9QYYRnDlzB2Nh9ufuZlCeVsZeXG7RqdvZiMbS5C0d2bSxnZHbWwXJj63rMdNgcG75fbZJZ06wsNrOhzFw2s6dYSH13TKEfe7YT/XwstoQW2MljM33RjUxnZEuPcQGwPZupCN7UfS3rVI2tTGokx8XF70yANsR/BuHfOeYDsWbWBkBcfZCp3WC2srHCemdot5FdYJdZyNgZ7C2Nh+AdoS3CdRG+O2JOJlempjByEbOyGAjXFHWwS1Mehnh22sMGywbeyEADaGORG1Me4zH7y1ldrYqcjGFgSwMRMfG27H8mHlbGMLLLVj9HMxjjuZ7IezN7xkQLkWXoaAd8tp6yHWjw0+ZbKtoPaDtzoGsZ8ISQdwcfloZ+JX8C53FMI2AXFNcpj6Qc7Wua2+HJ/fmYTh93bwScfv0wF6pAPEX5utm/jKSygPfAUApF2X/b8KhQmuA3RoOc5EclAdVmcK820aL2kXts6Dzpq8/v0C3f6Ny4DWu1YGkzuKh7OnWQb5w9oTJ2M5bR/i2pegWwvocmXYti5om4W3K4Vps7itd0HbLHiXO+Ix6HyGSQ6TjZk+keBsDPfPdIsOfs9viw5us3DeaJsF8R8M2GbhY6i0q0JhttssrEPaZnF1ntuaFLTO5+bLSXxcNmG2OWFMfMQwlGkLildLZG3x+svawuSNuxKpxQcr6JVIEP8HWfuAdg7PScuVe/5KJFz3oB2AtGdZSjtC0gN942c4/QZGHpC7ngmzcSVS0CP0If5sJr7pSiQ7a0L8lUh4bly7KhQ2i4Th+o/XauiVSJau7ooH0T9Ov4mJT68xCnsdgg0s3B5IYI0YIBZciYTbT2hzBqvNtNvWxRNcWweOa1vo1Uu4Loe9egnyFPbqJaxzejR3K0mT6hw4VKPXX6+tBGtWEaz9CFYrI1cDg0X7Ekt7rwJfvQTpc/2FoDwxU/vP1T9uLpK2Zdw2X7t6DX9dGdYndVy9wFeShbl6ieN5Jp1jW6ZXL3H9B32P1rcgvMmSrQe+eonaeqsdeYy2zq3hhbV13G5RWzTNkXJYLYJYYDdc/0iPVW9h0jH1j42MzHb5eLyd6+fAcWXWSsK29ck/dVw7AHkKe6w61jk9SnoI+qHAx6q/H/oh7eiR4wOtT1saFlfXIj7/Qzr0mWl/KOVkzeg9vM9xyuT8O/g9PJ+F36XHqkP8K9A12dOzmFy7SK9ZLZcrI8Meq473dIXZ52y6HgeXH53XMh2ZHeQ6JyzPQO0Ll1UQzj/QdDg+Zru+0L5jG8F0cNnR6xpx2bWg3zgM0qHPaDotTDrF6n/3ZD5Nv/pP57Mh/gpU//fIYtZ5/fM4lHWcrrXgdUpqz3humtognpvGZUsd127gKybD7HPGZUuvprAzZxjvpO2Lx8iF2xd69RJeUwl79RKeYwxz9RJ3zR/XvtJ9NRyvHWh/z62bcuk0lphOI5OO5ToX+npWOkYYiutZsc7pmqpp/G7pWJPAYwRIf7DG78XWZOkYgbvqk3IF7Sh/5r5Z4PaTb+lYXPsb8fkf0qHPTEdr0LrZjN7DHOE8whHgvaBjBIifRhxhCRkjcPN55XaNXNgxAr4qLswYoVSur38P5GgZLM9A7ct0tZdtTm27vgz2NbDc3hTKTcJe19jKpFOs/l83mU8z6BgB4h+L6v8NZIxg6bis0HWcjsk5rs/t/wpydWvQdmOgR/zissV5wrJXoWd4zE6vNID492bLSZfZ3ZML02tGaUDa780pTSmMZzrKzs78T/CzISD9wTrKjuMFpqPstmdk5Y6vqka/B9IucG1Muc3R0aN7uavAg9YxPH830KN76Ti8HI441i7smQ3D18jz+ZJIZ0u9Rp7ylLDXyHP1jOORmKc8PZlPM+hVBBB/b8RTfkh4yvA18vk4A71GnvveLkJkD8pTIP5vSTlZ4hXs0b1Up8N8xz7fwXO5tI0Ly3fo3Gm58B16dO9Q8B1cV4f5Tj5smO/w6WypfAfXExwG6RTjO1w949YoMN8ZOYVPM+gZVRA/ivjO6Cym5bVFJ/mOxBlVtN1oRmHcHEqEpO3Hi+iVBhB/xpQ85vQp/nI1o7RvHp6/oc6p+Zvm7O/h+Zv+8jSjsGE+kw8b5jN8Olsqn2lGv3EYpFOMzzQz6RSbvzkoAJ8JMn8zHfGZQwmfGZ6/yccZivkbylMg/smknIZy/sb03YAlfhGY79A9Qba/G+D2BJm+GwiyJ0j/pvM3A90vg+2xnPZD6t90/gbXz7DfyeGxRxi+g/UMsllecw91RZV2YfkOXh8f6N576f31uA233W8P1t779+v+nUZPvj3i6hkdc2iH+c4VU/g0/fbVUL6TG/sivrOO9KOWvgsOfQ0d5bR4fwq1Z8wpguy5Cdpu4G+Nw/CdZhRmOm8G4uE5FCgHzNPkyiERAzliXn8HYfjcqJnoN3WczkBurbMwVy/hdoRez2u6xwC3C/QM7i3xOqdysx9aV/EZi/Q7GXzGYtjvZLDdhbl6Cds3yD2Aq5dol0o/O9vGR9xSrl6aScKDXr00k0kDzAYfJzcUwxVIv97rXzw2hisxIg/VDx2uxBlZm5gwup0lzqQTZ9LhsMBWuK3v9OqlViadVkM6YxiZy60JoVcv4SaklO5poNv4QLZyuqJKu7DDInwNVZhhEdY57VaxzdBuFbcttFvF5e13nROWJ0h7oh21d852TO3iQNPBOqLT2lHBdLC+6U2+McF0cNlBWTV68u0eV8+KDYueJ8OiYkcS0GERxH8LLX2+SOg4lmuo6ji2XwjDV4lRe8Y3WVIbxNfh4LKljms3QBelDItouzEVxadXLwW9Gqk5+1uX3xtkSboKxZtKMKagsOkkbBoKm4Hwn8pGpDb0b2RDI6bm39U+6HFHEJ/7vHc2k1/uWCo6xWlnWF9e9gth+DqnUo4XC3rUPy1n7mi8ZvRsbqZQ3mZGXtyu0embUWj6ZgpJm1t2464ShfjFjj1uzv7mpsDg3XL77JJOHe2MwuhwlDsGnRteBzmSO6iN4WW0oDZGy5mbbmxGz0w2th3CvYLYGMg2A9nYziTtnYqkTW1sZyY+Li965MHw8e2F/IfqhDrOxsIe386VM9eW4D6J2hi3JREv01MbiyMbmxPAxrijLYLaGPSzwzZWGDbYNjYngI1hTkRtjPvMB29tpTa2L7KxowLYmImPDbdj+bBytrGjLLVj9HOxYtcfUvsxXYHAcS28DIGvoqHvDeW2JLpVS5JPmWwrqP3grY5hrjHhttM2o2cmfgXvckchtAbENclh6gc5W+e2+nJ8nm7vw+9t65OO36cD9EgHiH9Otm7q8jBdYwJp12X/r0JhgusA7DUmWIfVmcJ8m8ZL2oWt86CzJq9/v0C3f+MyoPWumcHkjuLh7KnFIH9Ye+JkLKftQ1z7EnRrAV2uDNvWBW2z8HalMG0Wt/WuGT0ztVn46ptunyNei+Ga5DDZmOkTCc7GcP9Mt+jg9/y26OA2C+eNtlkQ/7qAbRY+hkq7KhRmu83COqRtFlfnua1JQes86Mx0hFOYbU4YEx8xDGWK539riazTvf6yTmfyxl0jMt0HK+jVSxD/c1n7gHYOz0nLlXv+6qVmJBO0A5B2i6W0IyQ90Dd+htNvYORpzv6uZ8JsXL3UQmQt1g7NZOKbrl6ysybEX72E58a1q0JhLSQM13+8VkOvXrKztyJ/9ZJJ/zj9JiY+vS4paFnaxMLtgQTWiAFiwdVLzeh9aHMGq82029bFo1xbB45rW2pJGK7LYa9egjxpzDBXL3HrlBEmH5zOgUM1ev312kywWopg7Uewmg1yzSyCRa++4epvA/Me7Zcs7eMKfLUNpF/v9S8rG/vKiumV7itrZWTl9kRgu8BhOB3Tfi+M1SyIBXbB2S89tnoGk84MQzr4fYhnl+/E41w7Ao4rM7pvYJZP/qnj2h/Ik25/whxbjXXeSsJamHct183Ax1bTummnTM11k+tnw9RN7eiRzgOtT1salu39d1C23F4jvI/s72TdAN7D8wX4XXpsNcTvnpHHfDP7AtcugoyWP70JfSVf2GOr8Z6ZMPtIcT2n6wG4/Oi8Aa6PdK0pyHU5WJ6B2hcuqxaffEmkg3U0WPtVad/RKpgOLjt6HR4uO8pzwl5xO4NJp1j932oan6Zf/afzhRB/e1T/x2Ux65g8DmUdp3PZeB2I2jOe+6M26HeEJ3Vcu4Gv8AuzjxSXLT36386cTLyNti8eIxduX+jVNnjOOuzVNngOJ8zVNrjtoOWN6zvdt8Dx2oH299OZfHDpNJaYTiOTjuU6F/r6SzpGGIrrL7HO6ZqVafxu6diIwGMESH+wxu9cf2Mav3NXKVKuoB3lz9yecG6/7paOxbW/EZ//IR36jKaDbZrWTT+OcADhCPBe0DECxJ+IOMLBWUxu7hZktHucTPhrusKOEfBVXGHGCKVyff17IEd3YHkGal+mq5Nsc2rb9WWwr9nk1v4pNwl7Hd50Jp1i9f+MaXyaQccIEH8Eqv9nkTGCpeOIQtdxOibnuD63vybI1ZhB242BHqGKyxbnCcuOjxxrQRj0yHiIvypbTrrMVkwrTG8qSgPSfm9OicQbgivGA397/364Ylz/rka/B9IucG1Muc3R0aNR8fi9lG/eTh9gHaPj8HI4Qla7sN/E42Nih6/pHr6m25QOdyQZtw+R8pSw13Rz9YzjkZinfGQan2bQo94h/j+2zmM+SHjK8DXd+TgDvaYbc3ecJyx7UJ4C8T9HyskSr2CPRqU6HeY79vkOnsulbVxYvkPnTsuF79CjUYeC7+C6Osx38mHDfIdPZ0vlO7ie4DBIpxjf4eoZt0aB+c4fAvAdbl8j5Tu/R3znJdKPWlpbdJLv4DXJgc7L0Haj2BxKhKTtx4vokfEQ/y00f/PmNH+5pqK0F04vjDfMZ9yav4GyHJ6/6S8Prm/DfCYfNsxn+HS2VD6D6wkOg3SK8RmunhWbv2mdzqcZdv7macRntsliDs/fFDqsi8Gcv6E8BeK3kXIayvmbFib/lvcEBeY7dE9Qix15jHuCsH4GsidI/6bzNwPdL4PtsZz2Q+rfdP4G109cbtQVG3uE4TtYzyBbOV0BpF1YvoPXxwe69156fz1uw2332y0++ZJIB+vo/bp/p9GTb4+4ekbHHNphvnP6dD5Nv301lO9A/CcQ3+kl/aid79zCX/NFOS3en0LtOeyem6DtBugiLN/BXJa2G8XmUKAcME8TLIcUyLGL199BGD6Xpxn9po7TGcgd9mob3I7Q60+xTUZJGG4X6BnHW+J1OeVmP7Su4jPs6Hcy+Aw7XK7UFbO7MFfbNKMwkHsAV9u0kL9nkr9bfcQt5WqbZhIe9GqbZiYNMBt8XNdQDFcg/Xqvf/HYGK7sQuSh+qHDlV0ZWZuYMLqdZVcmnV2ZdDgssBVu6zu92ibssSVjGJnLrQmhV9vgJqQZ/aauWDMx0G18IFs5XQGkXdhhEb7mJ8ywqBmF0W4V2wztVnHbQrtVXN5+1+VgeYK0J9pRe+dsx9QuDjSdZhSHTmvvLJgO1je9KXUXwXRw2UFZNXry7R5Xz4oNi75AhkUt2ThBh0UQ/6NoWPRFQsftfEoX/povSn/xVU3NJAzfFEhtEF83gsuWOq7dAF2UMiyi7QbmQfRqG3z1zAzyHr56Bg+n6NUzgP+7wSnX3BHjMxidQNrNltIOUsdN7R+Wm+NhpRxDGE/19HYkk+lEbzram0ynIl7/ttfEw2gdx/G3YuLbndZIJMHu8TGELUiv2lWhsGYSVo3C8HQDPYawxZL8QfSP029i4s/N5OOFKUuurxzhDQwLjvvDxx7Qz1XpmE07u+1A8HEPpF9PZBWWJzfu4cYJVYxeGwx65Y4RodtSwh5jhrGg3efGPZNIOmHHPZOY/JTbcY10+wtuw7B9UMf12fi4xoGOe0C2cjpWTruw454WpIsw4x6sczrNjO2JLk9ge6JT/c0ojE55tzDyBGlPtDMt01T55EsiHawjar+TBNPB+qaccIZgOtwRo9yRoXTc00zSKdYHTmfSKTbuadyaTzPouAfi34jGPWOyv+1y1PBHR7aQMDy1T+0ZT+1TG8RT+7hsqePajebs71K289J2w8RJsI0PBSeB9AeLk0wi8lD9mDgJvMvVW3yUFG0fwnISKMtGr38ZTSbpcPmZZEhnMpMfu/w0lubaTHBcH0W3qLSgsLCcBM8jhOEkWOfN2d+W26sY1ydTuXBbFpaTNHt5XQyUk9DlNGxPtN3hjs8Jw1ewPEHaE+1M477B4iTUficLpoP1Tcee0wXTwWVHj7Tn2sSBtnsmjuXHSQ7amk8zKCeB+BcjTnIo4SR4HnGo6ji2X46vUHvGfIXaIOYruGyp49oN0EVYToLLlq5Vg+zVTNyJJAzinoTK68Ls70avf/0b5RWGTURhI9FvnC62nYle3p2Z4eU8PZu+1smJLTxmhQ8m2CM3rwf5sHt1UW+Mu7oIt1PVmcI84fpUycSnc6fcXAmuU5RLYZukXKqKwcIcB+YGOX2CjEOhTyxjEH1yvC2oPkFHnD6nEKzJDBbWsUmfmDNqV4XCbOsTy0j1OaVInqg+Of1jPYGOuE9HphEsjoPj+k7nrgG7holP2yQc/3zU5iRnFMo3Cr1PbWEkg43bUFM9q2fy0UDC8LvvfdI5rlB+6G8vRe33BpJ2C5O2qT7MZOK3oDhQXkGOe8fvDeX8QzMJCzr/YNrSbzrqNuzcBOgpzBXAG3y4GqRB6yK1samMvJgD0nmmm5GN3U/S5myGm7+H+K1MfMzNqI01ozB41/KW5wQ3Vw2Os6MWEobtiNoYtiM6x8XZEYThLarN6Dd1xbZDB7Wx+33mKCGNMDbWjHAbiY2B7h5CNvb4INsYbqsGx8bKa/8IhHWgMKwT6qRs7PEA/VVQG2tBuF8ge0igPn4R2dhTJG3us1dsd9TGil3rSm0Mtwnwbrkde0zXsfD2dtrGcdc8Q1jYK4eD2hj+jDWojdFy5j73CWpjsxHu6cTGQLYfIBt7jqS9fZG0qY0Vu6oW9D58PXVh2GBeT82VM9eW4D6J2lgrIy/+TJ7a2B+Qjb0ewMZw2mFtjK6bDNvY0NjY6wFsjLtyk1s3wDYGR0tRG/snsrGqGYVpb18k7eF2rDDMFRuj5SzVjtHjWjnuZLIf0xXvHNfCYyx4t5yO/sH6scGnTLYV1H7wUUNB7CdC0gFcXD7amfgVvMtdRTA9IK5JDlM/yNk6d9QWx+fp8Tr4vVk+6fgd3UevVID4M7J1U5dHH5rDfU/eTD4NSNvuXHK0g5tLxjqszhTm2zRe0i5snad7WXG/QI9fw2VA653fsXwH+FyFgeWZYZA/rD1xMpbT8R1c+xL00366vyFsWxe0zcLHhYRps7ijb4K2WfCuthl6xWJLQFyTHCYbMx1RyNkY7p/pERn4vZk+6eA2C+eNtlkQf6+AbRa+Bkq7KhRmu83COqRtFlfnuaNBgtZ50JnpCqUwx4xgzPeOEs0GQDnAmtoh6DqekwjHg3VhLPMUQx65tQa8tgzz3Y1EBvxuHfPeUO6No+s5LSjMtJefrhHh+jWVhOH6hXVCHdeugZ7CcHlaztNIGristKNtXBUjr8a9LXs3Wj1JF96Zk/07GtLF+/pSsbZYZ3dXqq2tr7udHt+mHdjiSAvpt7UnO3uTnbFYd1ss1RYb9PR72zt6epUQ0VTsPXUMdvrtfT1d0c54sruvt6Mv0d5bLH240rMmkw/Hbbp2I7J/a7kqmfiAV03in4Paq3NJv1HNpPfeurshXsTn//cwmGdVmcJndZn+8Ssz/eND2vWZ/jJC2EgUhvsb7UZl/8b6wlggRzWJf34271AmtegdeL+JSb+WpF8gN/MM9wUUq5J5BvF1+SzNygh2i/Mu2MfHQLYago+fUdnAdrRd6zZ2m6zxc3tkwtqS355W7eD6T+gPazwrOokD/gginxB+bi2z2uuvJ0i71kre0ukg5YDTryey2rA/nB7IQ/VDv3Ous6OflP62GmwP198aRjdUjhFExnpLMnJjApAJwqpQGMih49wxq1DGCksy2q2j6dy5A5j/4f3ZNxI+B2WDx2TY7nHfiuPfivrWTajfAFx4H9qpkSh8BBMOf0N5VTBx6bfhI4gOOb3i+GCTNT55rSF5hfh3o/Hn6WN4TKw/LFeFD+Z9zJgWMPG+PlOdh/gjmfi4joE8jV7/ujmSvIdlr/MKHX7GlU+ExKXcEl95PYLEHeGTDtUHJ0Mtg8N9+1FHZMVpUnvQjo5lKpl0cJ3CfX4dk75g/9DO9ZXgIKyG5BeH4byfmsnHo44bR0KedH4zhC/jeFQerq5JciN4Xo2e03QrSdwaEpeeX4BlrBaQsYlJp4bgjjDIHyE4Vcx7DR5fH7n/g8obYeTl+ppS08FYp2UK08HljPu075L2E7fjlcy752fy4Tj+06hP+17APo22JTgPp2fyz2ibTXksrZN0Tpf2XTQO7sdx/B8zfRdtHzCWfvbTAByB432UI7yJ9Pks0SfHARq9/rqhNlxH0sL8GPoXqoPfITl+M8M/LdBrgyGP+tnzM/h4WAYcj2JwfSdgcPUa3mtk5KJ1j7YdNYY0uP6MS6OahJVaPly/jbkGx2G4cNyf43ToswomfjH+Ue+DzeHWMDhcO19LwiJMGG3DcH5xG0a5CTcmw20jV+/8ys7EvTnZg/CqGoPsnP5wOyQ9RxntisaivZ3t6XSsryPZ01ZsjhKew7wi5Ou9/9GzapQv7fD8GZ2/w3OBVZnC9GGuDM/fYSyQo5rEr23e/D83pwrvNzHp4zkumhaXPp2/4+Y165j4ukwjzZt/25h7jrd3dyW7e6KxeDoeT3R1FCtXbo7ONPdkZ8wei0UYObm5J0h/sOaeuDbINPc0wo5+oqZ2hetDoSxrmTDKpzCn4caRXN+B+yLKNaY2b/6/yevfdwBnjTBhlcwzXG/GNxfmjY4ZuP8Blz6jnJvr6yPkb45LRxB+NYkfb87L3tJciFls3A3fdVM9+c3bUO4L8Wc3b/4ff5NJMf3y5Ye5Q3Nelu2yv7m2A/Kg40Wb+fxHPLNOg+a/wkfWXZq9XP5P92nnaJ8bJXnCPLQaxWvziacdHptBvAiRtdLj14+PzvByAgb3P+DRZ6YxN2277KwrRNtoe8Plm6avfT3Kg4nvmmwK49eT+PB+lcePP6EMqU3t27z5f122H2zmZfA8M2c12XWQOrh38+b/uW+t/ewa5OZ4MLxTbJ5h/+ZC+Yu1jVR+iH9ocx7zICIX199zHB/PQdD+zvNKryumfguPE7hyPprEx3PM1Ja5+GCr2Dbxd/K0vYP4xzZv/l/Lvi77m2tHcJke38ynjcu0mpGVpn1Wcx7zpOzvRq+/TdKxfFiOgvV8VKZQFoh/evPm/4vtl4O07e6Xi7HnRRRwqExhvrn1Dxw/7PoHtW1sS9UkDJcBHddWM+kEHZPjvpO2IyMN+aX2o/0ohMXFB7xqEn9h8+b/OT40Cr3D1bkqH8wlzXlZFjUX5h+X48JMPl6mmU8b57+SyQ/Eb2Dyj+OPIrJC/BXNnm/+RzL5x3JdkCnEhPirESZdx2tg8sW1ufB8NBO/gclXo9dfL/Au1T2Oh3XPYVBOAenVe/1tQrtlmUJZMRZd4zfV7VGMrKayHsWkQ8t6bfPm/zmOUOsjp598uN7TOl7NYOF+RXqOo6OtI9bVlezq7ehNd7f19gz6/sLujnR3ItETS3T3pbpjA5pjsXW2H8Qb7LGDnXmP/NihFslp4pmUN2B+VmuIT+e1KL7f/C7mZ3g+go4dIP4zzZv/13Hvai7ENOVRO8oR6T4nGodyKVw3OZn9eN2Hmzf/z+394NYZMW+m/AziP4Awg+z9MPUZxbiPae2I7v3AbS8tcw4bx6/0ivcDESafML+mHfQnGAPqWAPBmZP9O1qio30dvoa8gckr5T+PNRfK1Uh0atIZ7rerGAysk2oSH9LFYx2al5Fef1vnyoTue6J2tThTGA7xn2je/L/++/PZ39z+Ejze+moznzbmGKMMso5kZMV1Zk2mMBzif7l58/9aX9f6yIrlwbJyYyew2aEYO+F2q5rIxLUfOP5A2w9u7GTaa0Xb3wiTjqmPweXAxQc8apPfb978f7G5oQjCh36pkUnHbz68WD9F9+Dgd3WaP24uxMVzGly7vyBTmF+I39GSx/yZDybwAO2WZ/Jxcmt1Xv8yE+QxUao7jjdgeeh82XPNhfkqxofo/DnHV3A/DTqhfAXSxW2saf7dQ7rEdqPdnOz/0RIdN0cZIWlbKsfuCEkP9IGf0TadK5s5MvIY1ymxfgaJr3fhPfJ4PevsTH/dUDnoHDTWMe4//9Scf4fWGa7d2C+TD8fxX2vOY76a/R10rxtgVPikSbk6nTfTbgGJg39zvBrrk9ZXiP9G8+b/OV5dbG3Cb38ejs/t8eN4td/ajOeTnyDrIkHWO//T7OXyH2S9E8tFdQrx30GYVKfcniyTTk3zulgebm6c8sBiOgW7p7IG1WmO17V4ufwnffIfVKcQfwTCDDL+M+lUYu9/UJ3C2ehU1qA6hfijDTrl2jOTTiH+VkOoU26ummszuHkW2l9yeabzrBiz1geTa7/8+h6/sjTt8YX4Uw1lyeWrNmC+6oTyVRcyXxC/xVK+Kn3yVRkyX7VF8kW5NMTflskX14fReVVuDzju1+lcF8TfkamX3Hga0h6K8TSua9WZwnybeIB2tO3g+kRcR+l6IzePafq2w2QvEfSMrlNEmHQwn+TGvtQGuP0OOE1qAxB/t4A2gHm6dlWZQpnnZJ9HS3K8DWBbpjYQdB8krSs4Pp0P0a6JiQ9cn7MBOhdRwaQT1Abw3kKYi5BeK0q1JXrSsXR3Z08iHU10xQb9LIpkNJ5qi/X0tMdSye7udJi1qohXqH9uLIL1WE3iH4ZsPk0wKwyY2h2XKcSE+Ecy9YjK6XnB1g24vQz0W0XtTHNiJruyUZ6pWCyW7mjr6erojUfTfb2DfrZLujPZke6Mtsf72lLxvuRgp9/T19Eb7U7E+pLJzmhnR1cp9qydqc3guC3tDzisCgNWxIBVbG/NfgSLaxeDzI1Z2jPfFiHpQT48ku/cNxte/3plY26smF4riO64veDc3ig6x8r1kdy6A4cVEcSi92T4tU3cvgST3VDePif7d7Q0F9hu4Nlg2Q3HL012w/Ud3Fk1h2by8fzaEO5uqMHCMn3TbPub/qC2AOnXe1ZtM2bSayWjV25PFL3vCrdHtPy4torj2a5g4fbH1B5x+0UrSRjWN4wRuP1U52TDaBvH7UWmfTC0o1zfirHpvPumls3/W15fiVK+g9Oy3L93cGvv4Lh9BLTc8RwALXduDoDbx4nLhbpK8jfWhU770Vl5XBoPHGcjERJWw+SD+6aC9gEcBzKdJ2X6Rp1rv8/LFMrMjY25b5A5bjoQDo3To/PkeN2fxsd4dN7k0ZbN/3NzkHQuRrvVmf6YVOagdRvifQbJ8EdkQ1QPtI8sN55tqc828myOe4Th2drRvmig3NgWlu29tpTPc/2glusbLfl3aJ0yrWVRe/9uSx7z29nfXBsBMo70zO0CN1dE9e+3fkbbhdweJ0O7wK2dY7lWZ3jMHyDMIGvnXPnB82Jr5/S8F249ptg4/z3sTH9My2d/tw31+gHtVzF3oH0nrkeUmxTj9HTumLNLXO+4fjLoGgU3x1jpIxsXj2L7pU11jeOGmS8w6dCUP9NcWnURrCDzX6Z2HWMdSbDw+zUBsILO8fl9v+p5/fmCpT1rgcfU5bpnzbRHuYkJo/NypjMzcDocVpUgVrUgFpRbmDpL5aBrK9oBp6kmuF+eufn/9/rpmYVxcmMsFKd6Ji+fdkdkCsO48ZR+9n9ZDO48Wu3nZP+OluQ6kxxfl8OP93F9JK37ds5eaOsNWvch/XqPr09zROQxn+nM2T43P0D342O+cFkmH4+GVTLPKgxYGwWxNglirRPEWiOIda0g1lpBrJsFsST1JZlHKbm4drZcbPUmQSzJui1pEzcIYg23X8Ptl808Sur+SkEsSbu/RRBLsm6Xa32UbKPLta+VLMerBLG2hH5oS8ijpFyS7Wo59tv6Nx23l4t9SerrNkGs9YJYktykXPu04fo4dHks1357SxinSdrEFYJY5Wr3Nwpiletcx62CWDbbaIjL7QvUDvZK0TWQz8/c/H+d159bCM7L95nOq63z+nMcybQjJD3P49cEIH3THHw9E1bS9x2xdCIV7elpi/f0tXd0dIS1DYjPfe/MrS+Arkfa0XUPt0+jHulVuyoUVkfCqlEYyKh1/+6MQvnt3CfZ1hNE/zh9rm76nZ3MYWkHZTPGK7Q1XB+5dUU4X5XbpwrrmnhdkdvXESH43HlO7+2LmpmXFb+HZcT54/a6RVD63HP8O0Ke43RxeodnCt+je9KoLDS/lYycnC4qGF2YvrMtdn439y1KJZFduzpGFsH1yVTQtrFcvz/Q58bBHffzUksOX9qzYH7vQamVi/c6p+/w5KIl85ML9urrW5RavJhaGN5lSHOLtcHFofFofM4auVzQnTRhd/hgLLpbyLTDJ+ipH9xuvRHkPb/TzHEc7vQKHO536gGWua6IzEcTmbFcdQSrvgjWEoLFtfyANbII1gEEizsZEt7zOwURx8E9N3eKtt/Jk1jmhiIyL80Uyozloqdyji6CtZxg4fdHE6zGIlgrCBZ+n57C2eSTDo7TiJ43MWlz+FSXWxWReWWmUGYs11YEa0wRrFUEC78/hmCNLYK1mmDh98eS98b5pIPjjEXPxzFpc/hUl+OLyHwckRnLBe8G6U3Ho+eCvVfgkQakP1i9aTG90t1HExhZm5gwultwApPOBCYdDqtaEGuEIFatIFadINZIQaxRglgNgliNglhNglhbCWJBWwhtE+Zmc7L/R0tyiTao15ir0DYR63ooRhiQfr3X375ttIkc18D6oTMmY+3I02fqr8cy+oGyHM+EUXvEXwTh+GNRHqk9YrutJs9aWzf/38Rg0jaX63PwMzyint5amDdu53AQO8K43C5yKN9it35t11qYF+6mGPwu/cIK4o+YlcfcMYvJfRlCv2gWaAP66APAxmUtZ8exTtDpRK+/g7BJTJ4jTPxK8jeWW/fHS1ryuDQeTRO3I5NIGK43k0kYrntTSBi2+6kkbLBsd6RgOlhHtJ1pFEwH63ssSWesYDq47KCsGr3+ZUdnQoO2WdyX6nT84de27N/Kp+nXttCTwSD+W615zIOyv+2Ob2IddHyAHa3/2H65+k/teTIKozY4BYXRsSN2XLsButDtxoaWPC6NR/OBy3YiCTN92WKJtySC1AWc/mB92cLNf5m+bGlkZOXaB1o3Ob7WyKTDYcE8QR3B9uT0kR5Cjh0PahvlyrG5Phfe5dr0ykHRayzB9U0ekRnPQdE2zY8fU8e1W5Cn926hasnj0nhUHlzu1O6xrIJ6aqf59Ri5cJ9xV6a//J5BF+OQLsJwP6zzCSQM2z5t37E9Uc6I7ZByxnGMPEHqpna0/cJlNcInXxLpbAkcs9Hzb0MiXv86Xsk8M3E/ymX9uN+VrXyaftyPnlgC8V9A3O9qwv3szFOEq+PYfm3wwqDtBuiiFO43AeFzfSb85m4voHXIYzAoDp0L4LhKLJGIqSF+Zyzdl060d3bHe2IdiY6OdFu6s6OrrS/d3pbs60zF2pKJeHeqM5qOdaVSne2J3s6OdHdfb0ca0gJ9VhjyFoIzxXvTsUS7SinakWxr7+tIxPvindG+tvZ0LNYVi3e3dSUS6d62rr6ueCId74z3BuFMlubdAp8qBekPFmfi2iETZxrHyEr7EO0WZfLxaFgl88zUH9G2c6BY2sEuxSDrdpZsITFQW7C9bldsDXcgtkDbp1JtgfblprGxpfFP4LpMxz+2x8ZlssaQMJVzpUEeS+vkcZCHWzfj5g70eluN58/vqE1iuXH/Dc9oOXBpz81s/t9044+pnDEW3ZvFcWFTncdYdG8Wp49qEvYjxBe/1loYB/YLPY3ifIOsx3Bzs3bHlMHrNKRf71mtQzFTHeLGCdpmR3hm28Fl57dfrZ7JaxBbxjIFsWVuzAzxtE38oHVg8fAO2BEo3k8M8WqZeDQtemITxqA3hf08i6Fx/0xONMW6oKeXcTcoc6f0NpEwLBM9zbKKySf9OiLi5ccpnH7oTmW8d8b0FcNoEoZtcSsShst3FAnD+0VgX9dIr/849SXUpvzDZ91DO1NfZOorcDsP8bmxPrxbbusjdIzMrY9y42BaZ/H6COVjU1FYKWsnvQFOk+bKmevP8BwHtE2cnY9FuHTuhLMHk/1MZOLj+QpqP9hG4N1yXUO3YSMQNg2FYZ1QV2zNPoj9mNqGoDYD73JrrSMD4pps12RjnNy4zlEba2Tk5tovv701eM4J581vzbgxWwbFbmXDe9K0q0JhgpwqxZ2si3VYnSnMt6kP0C5snafrj7htputPuAz81voxJt5HhL/2ATnol5YewTTNg1g6OTUw56Ynp9qeByn27QudBwl6cmqE/C7lhNIKQSywjTomTFC/XZR3Ykf5o3Zh1+1A7rDrdrhcKJ/FeqacHNcp2v/hOkP5rK31tIhPviTSwe9R+68QTCfIuEMiHe57Ne77Mzr2DXujgWm8h786xOt2e83i0/Q7cZ+u20H8w9F+0H2yvy1/4RmqjmP75ca51J7x+JHaIB4j4rKljms3QBelrNvRdgPbJcTDY1YooyNRGZ1Oyp37dtHEB7lvFmuZfHJ2Du/WMe8J2kc31857RHfcTeicDVD7wDZA7QN/J0LbFfzdHf2mFDvOdkBPYcasp/vUb0iD1m86/vD7an4vxLfprVxBbt7mcLWjN/dA/PmkTbFkM+ytXPQWD1ObjfPHtdlH+uTvUlQ3z55VPD3ulqoICeNu6eK++6VlBHWiOmAeIP6SgGMwvA9Au6pMYf7mZJ9HS3Ps7Sb4++jqTGG+uTE0jk/bQO4bZdxmUH7u12/gvzEWd8MXtbMaJj7Go3Z2ISojuG2H4130FBBuDpvjHfT2J2xbdUjm20l9tjTu6+R4MDhubpq287ie0HaentSCw7AdhL3pDnQR9qY77jQQrp2gbQHXb3P1FvCHot7iPpzWW+7MA9OJQsXqOb21HpcltW9cZ+pIGLc+ROuMdnNJetw6Cq4zI1FaNZl8XOl1bO1A15VI5qpMXnZIH+ylFoVBvBzfsyNrFGStz+LjWwTrkDyQlwoSn/6uJs8eQRwK5xGXI843LnftRqIwiF+JnoGMMC9Xg8JGZsJh1RKsESVggVxNTPwRA5SLw6ohWHUMFn6Gv6+8B9UJ7uQh3K/ice+nA4x78bt+494nEW/7LOFtuI+nba7pFKmw435ufqGBeS+nX69/nyBYHwPfUgXp13tWOUCMciasV+7mY8tjjDaQhxtDc+Ws169He/3LjNtXgcdy9Nwg00243J4HEz/g+j/pm3Bx2iO9cOMvrh7Teo7jP43q8YuG8RflEqYznzwv/LwJyMqVSx0J43iriRPVGuQycSJOLsyL6R7nevK3KQ8mu+PGqEPIS9s5XorzTnmpaXyoHS2DBiY+N2ZsIvGxzrl6Scdr3Jpe2HqJx3IvBphjwu0snWPi6ifuo+l5YSDLnOzf0ZAu2ZnqbutIxHsT6e5kV7SLzvl4SEcjLaTfGe9tTybau6O9qfbOZEdnsfT/mP2jjoRJ95N1TD6l8Lui7Wk6DyssfwL6bZv6oXVEchwD9e34TB6f5kU7bs0N3tF1HexJ/94OvaPdCQg7QsJOZNKFsJMyvBzanYzCaDt9CgqjNx6fisJwG871C3Oyf0dLcMoGuy1zu46xnj9PA/vfO2Ml7Tjg72MHP9c+7GsHvwPwYU+5J4cdBWw6jyqtm/3t4OfK9gA7+AnAP9BO2ebwD7KD3wb4ByN8G/ZziB395/APtaOfHP5hdvSTs//DregnnpP/CCv4HTn5j7SDn7PPo+zgtwP+0XbwuwH/GDv4KcA/1g5+jnseZwW/sw3mH+/JVizTXkf6v+f1nx/TLjdP7VnlnaFPJufO9KbzMBxWFYPFjTv9viuBcO5/zwumQ0t7kXI6rA6Yb25OjuqQw+LmK03rsCYs0/6empDxR4SMz82bVRni14XErw8Zf2TI+KNCxm8IGJ/uEwIM7cr1rKXRduSJmc5QAV002Um7M6gumoguLJVNzHJ+c+0Xd+b7aCa/TSQ+zTuOy2FpBzav6xK0B/NSSw5duCS1uMIHC5cHTpPGp7/B1fjgVBJ5uXcp968m4VzbiZ+P8Hle6/O8zud5vc/zkT7PR/k8p3tKwO2TKfz7UPL33Iw5/r7Zv5u8/i5CPH1u629vENOSkBVskvsdMcQx7ce3PH8ZuM2EZ/U++ZkjI0+uTask8lD90L6X47V0DUQ7mKeKMGFBOC8OO1QQS1IuSaxDLMglOc7ieDTEs/mdi3ZQ/pa/mWjnvqPBN6rN8wrzjveRVpJ39e9GFI7jd0TymGdmn5m+rbG8D7QraNtEv/+zc2uk+fs/bowX5vs/7fA8KA2rZJ5VGLD2E8Q6tEzlksQ6xIJcpv1cA21/uD1opnmJsN8c0DkIbsxfa5APv0/PE/Frv9aSNIu1X3i/EI7/gpfHvIrkkWsvgnKNfTKFWNz6LpXdD2tvgmWa/6kpgnUgwQp7xx7GOohg+d2B52cTWL/0OzK//W/FsLTbN1OIxe0zs7w+3Aky1RfJN/3miDs3qY55LyIma1sHpws5/I5e7sZbQfxObo8W5RujrJRzLPAeWEh/sM7gDLonjfuWEd7l9p9RG+TmOxuYdJqYMLrGVwrW0UJYXD0oRa6jhOTS7khBrMMFsY4TxDpWEEsqj1zbVS42Ial7SZuQrNuSch0jiCVpq5LlCPYFXBfi/ib7P8cnBPvEDvq9pef174/rLaUdIemB/jySX9NZiCB3PRNWyn7g7u5Uqj2eTsai7YmORKrNxBEH+j0yjg+6brCj6zZujz4+l0a7KhRWT8KqUVjuu0LlH4gUym+JuwXSP8eHcHw6zxG0LMd4PNcA/eB6q3+bzss0nc9Jz7qgdR6H4XpiOkcUxij4Wx3TPAKXR268Q8ey3F4A7ntfbh6B3lNbbH6gFoXj+K9m/9f5h0PWw+bZxvwIxapi8qUd2Gc1if9G9n/996cihZic3vEcxT4ZzzevQe6px1h0bsPv3GDaxnFYdG7D7x55vzYUY9G5De7OelNfzdXPRuZ9OrYaXUSufTOFWPj90SQdv+9F38PO5MPwWW3aVaEwybl5bSePRfJy0Pzi/iDi8WeSc/sKID63DwFjQF1oYuLDfllOP6OHUD/VIfXDrSkE1c8+GY/VD67j5WY/tQb9cHXJ9G1kMXvbm+gH74PBZ3VR/dQOoX5M9lOsnaf64fSJMQ4k+sH7ieoN+ilX+zF9w8vpp9j5JAcR/XD90/vZfkz6wf0kp59RBv1sKfYDfT+nH9ALt+aHz5ZJEK7HrT1VoGf7ZLyC/GKZqxEurMdR/gwL8lqGp3zSDspdIf7uCJNyV279azSTHxNHGqyzOwCr2HkVVOaw62wmvm1aZytWvynf5sYB3Hgax8NxOO6Pw/3GGZ5nfV4pCvaPORQ4CMN7ZOl4fYzXX28RBquS/I3zpPP/NGp/aDwqD9YRli1IW7NPZvP/XD0JMi7DWNTm/Po9ikXL1s48UPD98O+XNbz6QdFr+DqD9UkdVy9Abl0vKiryuDQeTRPbH60XnM45jmuaF7A87xpar3RPDT6HIuydznietj6Ezrm2CMK4u3jCnlcUIb9z888ez70ot4D4ixG3+C3J3xCcbdoZlnNyc1EmzsnNCTQweuLmBOg5D0MwZukMO2YJejaYSZ8YY5+MV6Afrp0dwjELq58RBv3UFslvkDELxqBzJkHHvENZv6pD6ifsmBdjHGjQTxnM2bL6qTHoh6tfpnPSitkbnTPhxgCcfgbprDDr7Y9JP/o3nTPB+qEckNs3yn2jsE+mMD/cfAD+hsCmjju78ue+Qvnic1+xq0LhOP5HsgDS53ulO5OxdCKZTrYn+/raepPFzveC5yMy+fBKIut78md/57gWjk/C6jL98w/pwLm2wIEoFshBz8H9ZBaAO6eWnu+K068h6RfIzTzDtk6xKplnEF/b3kPZl2yc29bb3tHT29aejKZi+s94sXLl9ITbIu1A17gsapi8VZP4n4/k8/wEamfei8ukp+M9aYgX8fn/PQzmWVWm8BlXRth2IT6kXc/ICGH4bGDcTmo3Kvs31hfGAjmqSfxvE9vF9gbvc2cT47OeaVpc+tR2uXORRzLxdfl8hbRHOO/S8wjvpUnw8TMq25MW61Wqp627s6e7tz3aF+2OdSeK1St8zkrEK+zvPI+fM8Zza7ifq/H4fR+AR+eYf5xNV8vwfAWPifuhfTP9ManM+Dnu8+EbrmoS/+dIhhfRWJTqIVc3CbawPQW+Wy/XnzD6sDFPFvQsFm4vE+VBmKvul8nHo2FB5vxtY3F8M2z7blqnoPvKMOfC32K97FNH8V4r/C7UUWrvr6K+7hXUjgOuR2Qc6ZnbBZxfyqvx+bNcfNouQPy/GdqFYneq7ZvhMd9AmHQ9q9g3WAMdL3BrSfRbJK694sZaEG8w7guxOZdR7MxusI8mEh/rkatHdI2u2Plb+2S8gjxydonrHddPVjJpRJg0TN8nFqtHlQy2X9pU1zgutzfVjwdAOO6DcXztoH2sJrg/yUbSuhtdURgH8MaiOE2kz8X6OyBTGMadHa+f/TD7B3dmsfZzsn9HS3JtKa7vl8Pv6OLO65XD70zY/QaxMwn4dXbw45a/cczpZ6Qd+du5tUA5/HgftyYmKH/OPkfb0X+cO5NNUP4od+6XIH4HXReENLSDtPF4TK7fbuuNkPQ8jx83QPr1RFZhHpEbN4wh8lD90HHDWEbWJiaMtvFjmXTGMuk0MWH0G7NSsI4TxDpKEOtwISyu/ytFriME5RohKJeUviTzKCkXxwPKwVY5/lAudVvSJo4RxBpuv4bbL5t5lNR9vaBcUnavf48UlEuybpdjfZRuo8u1r5UsxyMFsbaEfmhLyKOUXNLtarn223TepFzsS7JdpXM3pch1tKBckmOrcuWYw/Vx6PJYrv32ljBOk7QJOjf8frR7Oj9dLjxacjzUJCiXzTYa4uL1Xtjrox2cOUHXMJ8ma4Z29vO09XFr6BGvMO1aS2lHSHqex68J0G+XsDz0Xnl6f/mcAcraE0snUtGenrZ4T197R0dHhOCDrPRZkP0E3PqC3W9X23q4PRt073wVCqNnfVSjMPwtKj2nq86S/EH0j9NvYuLTc7qCliWc04U5Jv22F9swnAnOfSsB+xLwvgBuj0eE4ON9OHjf0q8r8rLi97CMOH+m79krfZ7j3xHyHKeL06N3o9L9aVQWmt9KRk5OFxWMLoKcc4brKeDZ2O/alu5MdqQ7o+3xvrZUvC852PePt7UnO3uTnbFYd1ss1RZrH+z0w96/ns7+dvz+807c7luQ/31z/znsoeLyop1p35Vuqyd7+d/N6B3t6D5wHHYQky6EHZzh5dAO3/dA7z/H/QvdK4nv4qXf9GHuP4KE4XEn7ZPxnC3tyzGnpd+g4nkX+v0l5q/0vB3M33PfHmX/tnEvYFe0LcntuRG0w76xjPyNKG/a7Z2xkvb77g53G22cdnPt4Ldx97hL2hbsWz09i8d9SwntkuX2NhUh6XkeP9aCZ/We3f4lQtIDeah+4Ldui7bO/p6XWnL40p4F83sPSq1cvNc5fYcnFy2Zn1ywV1/fotTixZSx0hachmNH49B4NH7QXOyT2fw/9yUDZf3Fvm4y3QRDvzoqdrLXfgSL2+3PjRxwPByHO+EKh3P4tDxqisg8l8jMpWn5hrF2kLXWICtOf6A32uB870vyzX21Ae9xXyXQsuJGzTi8xkdWzxvam3MqGLmC3JxjSdYukHVkSFm5UzAsy9oNso4KKSt3wlEl+ZvGw3G4Ewlw+Egm7UGytSTopCGkTrgTnC3LmpsFGx1SVu6EaMuy9oKsjSFl5Zh4JfmbxsNxapn3cfhoJm3aB5lk1g4YY6MhTW6miY5qub6bm+UynfxPT/fHfUwdCcPto9+pe9heuFPlTLPxphs1RpEwXH+gTEZ65X+SSCr791CfJAJs2O2ZsrbhmbIiDurzPpk8ftCZMnhH11GoY/o3bqO02xdhR0jYfky6NvOsbKLd8s3I8bGef/sLo/ZJ2b8rmbi4LuAvvbly8ZhnEQaH6haX45zs/7FEIqYmFjpj6b50or2zO94T60h0dKTVKkNHV1tfur0t2deZirUlE/HuVGc0HetKpTrbE72dHenuvt6ONM1rhSFvpi9yi62ilHsbPj3791C34S3Z38NtuNElLLexccvtDduGm7gf14Zzs4fQbhdr33EbDtg2+8UudKOspTKLjfX821xow6d6eYf1TE8FwDj0RJIJ2f/1fMhYH7war3hbWenzHqxg1TEYnqC+TLsMsBym1XMX2vbm7N9D3bbPyP52vG1PDrftZjcYbTvsGNO/xyA87bi2HcLwyhld5aarXjgMr8rjk32A7+L35mT/jpbgcH9hac6+bSwjP6QF/QW0gXpuYmL2t1ptUutMxyYXzO9LLpm/8JwjU+ctTS1eQg9fqyR/03C6AQqSxvGoi5C/6cJhhPxdwcTDLsjGKNPGK47umzaoudBdwDTKUHcXmAbgsOGhQIFLWG7OEzabOe247sJv2VU7aN7xb5BpoF0Kd5gfYOPhg/6dO+TX49uOOV7pegG7sTUc0W6s50/RofkHej8K/T5n4ZL56ZWHLl2wYH56fqrv0IVLUh5xtOn3a5Zxtuh71EE8F5pQmCkb6iY0nv3teBPaM1hNqCWm1cmdE2e7CeXuQwMbhn2g+HepTajlGfAOyzpMcN8mgA4srwwHPkMY0q/3rNprbi8atwOHO4+X+5aGjqCqMv3zwX1LA+Wr40xD8aht0bvY8bCBnkPJ3c+n8bdFaW2X/W25W+8Zym4dno3I5PWR63vRs2qkv/f0g+OTMBt3LWyT/buc71qA2ayRXp4u7YTwaF2hq2YYT9MrmNHYTK/2XpRKLuHJFffhEP67wkeIoONxjO8Z0qKYOJ4rRC2W/XuoidoD2d+Of+QTGx7rmh10bnjcahrrwpQk/m0iaoDLEbX/b+/qYyTLqvp9XdUzPdU9sz07u0DQBBIiBNSkvrq6CzVpsj077K77/cWysEt/VM8OLrOwMxsWkKQ0BggS/UuCmmgIgmhCokajBqPwh5FAJDFixAgSDARDiCFB4z8mOrfnnapf/fp3b72afre7erZuUnmv3j3v3HPPvffcc+8597wLlIfjxHB7IWbbfGguUtugGeWhIsmKwT1EO+bh4SI+QISHi/gAER4u4gNEeLiIDxDh4SL8IF/m0hzWvTbpd9MeZq6vnRP0o7uvT7NDOzK1bPJ+b47PJmqWMY76Cj4rixalsPIiJJU5IKPynNOLECu/5pLKykZMiVIfh/NKlLlsXrn63PObF3sP9TZHYioodYjzHRXnE6tKIZXL/odMITHTBqbY9z0yt5+GinhmNC0H3vcp8Vqko9bUlpR3LptXcP250R/CcVKeZVYnj+ODgJfhmB7kudGmvgfB/JwjevhZrD3Y0y2R5bfU9sDphFPM02/S9kCe4/dPE6qBE/NJic4YL6rAi48DXobjMivHgBdzgv4UvFDjNHP75a+aMjb6169qXFcD7yk5qVSF+UjZqp3snmN/KJpYXvu0nl+bOyu9endta625tdla3Wq3trrdzUar0Wk01nZ3mvWddnN3pdHpbHd73d1Ga3drpbfZWdnsdnYavfpmZ4fLmhN0zVG9TkbqVRHvq+82nQzwAHnDJwOVaT1E/0KE/oUA/S5A/7hYO3yy0O5PFaCfx7FP6/m1VW+1epvNdqe3Uu/01rprve7q7spqfXtzd3dntd7e3vKBmTr1lm/X1WZ9q9ntNVrd3sr23rc6G1ZWjXhzStTf6oWnX3jZUhHvq9N+iwEeYNtyjNCaeIf/z4l3uW1rgbIRZk7UMYRDyTVF/ynxThH6mf9LAfpDckedIlTtG8PB8o1l0VzgvVNUrurfjPPEGJx8Gkud4FUntTLKQ5x8Gisj2jAv5vaj5gSlr3AdlCxh3QplYuwE23HYXv3F/P9Rb6/i8j5zo+3rnNbXN/qj8OihrOSH4WNv6V/Or56G33EaZ+ibqQMbhNvfJ31az6/1Ayajx9oPx0w1UkeD/zDU8ZNUxwrVkfls9VV6bIl1bMwTPb8KNP8e0az0R9W3mG8Ir+SqilARi5tn94nX6c2MynNO749Y+TWn5ed6OfQ0eN5Bvqp2ULKe19uqH08iG7Dcjf7163H4TuTNFj9vt93s9VbW2ltb1+4aO43DLn97pbO1fY0J9d6ebt0cV/4b8/vjbdpbbc1OPcRT0VMPFYJT7xzkZMQr3fCezXdodswo7wLksflu0pMRyiTI+6VqL0D5FqX0vUJ/nBSmv2vdbk35RrFJsgp5Md8oo9HDvJ74k8IvDv3u0vi+NQfxBlUkKJuf28ATzDd45EOiduwW1ZGs/FpSvg11JBWpSsVs9vsDt+X3g3hxG5tXNx+/dPVy78oV3ker0P+ix3fsP+/JGp3mZ6f2k0PJ6GGZiPh4ryWj/3MBOKxnmfsCvIZX+7mxo0KxPYNFoPFk3w3SQPeEZyY/jsqXr5X/n2ZfPvPbOw57Kt38/+x41sHxzyI1jE+zSA3l9+kikRo4soLlF4mskAXwzs5NFZNt/5H/OebuuLuzSGLxZLLtLf0hfjUmlWyzdzACAZ4jMfn1BODmNfdbRbmW92Rf0+HT2yCP19xvhzx2mX0K8tjunGb9uNJNfHaqE1s/zlxfo2lfvHpXHu664cZ9pSwBb96cBv+gbe9Kg3+wn3p3mrYd4L8nDf7BtwLQfT9F/7k3Df8H+O9Lw58B/vvT8GfQ/x9Iwp/mgP4Hk+DvDOh/KA3+Qf98OA3+FcP/SBr8XcP/aBr8PcP/WBr8A93z8ST4V9u2TvpkPrDUsaYscHVu/96tT2zfTrX+M14oP4OKoEd9jQJpC+GqClzLbvwanvd61dW5YjxMtC8x4GHM9wLpUV/HYB7GfHcRl+LhfAFcqm0N/sSE8CcnhFe+q9UI/KkJ8dcmhF+cEH5pQvjTBeGtz+MXBKw/29ol0be2CvvdWPk1orXsMXWaylO8WE5T9mpRXiwTLxK1TSNxfQfy6yzVl9vXyl8meK47wipcPqEt0OTBNVugjzJwZS6AC9sDy2R4vrcU8omvEL3qXdb9OTSBkp34/GTg+ULg+anA81rg+WLg+VLg+Wmn00Z/9P999P9CPw5/Pv+/7PanjH78PNV/d4hllUGr9Ul1n0VgivhtJtIjC8tMe3ZYfpsVoof5w3Ov0mvZb9MntgVNqvNi3n0l4iqTrjJx3ZuArjLXWUqPNrjYuLrRcjDP2j+x/XRF2T6tbD9vXXSjdccwPBV619/fAvkI38mGON+ZPzvCcAJrRWXTtIYTUGdv7N1lyvMJ90E5ryKezUVw3VkirvumlK4ycd2bgK5YPMAblT841qzPxfYl1FcyM8pbEDgzyjP6+BnTh+/z+bSQ/PowlTlOfp2EfIT/jhvi/CjVUcmLorrGRn8Ul7LvMu0hXLEvzTLvT4zBdTfhUlHYY/0Zcd1DuNSZ61ifQP7aPHijX2hFus73R3FVBa7E9uHol1MzQU+RL6dmxIf1UmjVvtbl4e9sqzBUJeJf5fO4zu3XN5aStHNjJaPyrJ0dtZeVXyNaS+53A30j9nVXn1jfOC1oXRZ53AfVfudpUc6yyGMb30FwPVISLjUODkLXwyXR5dNDJeJ6oERcj5eI67EScZVVRyW7pqVPlMn7MvtEmWO7TLoeLRFXmX21zHa0/mW6rsF+M78qfaLEObFT5LxULVHZGZVn/HNU39gXkjneOeYdxB+42+31Vpq7m436SqvT6rVjOiI+Y5tH0bndeH06Da/b6owhfl3apyrk1ShvHvIG54Su/X4/G6U/ke5WiP9KH0J43uco2pa3Oq1rGH9w3Pr72Jmv2LkuPg/GYx7zcJzEzoNhLJgi+wiqjmq9w2tZ5QuAz2L7CBz7atz+wALkI/wP8quvfysbpb1onVPsjzCuqqiXT9Y/5wn+R/nV//+TbBSn4nssjh3SxHyvjcHFextq/Wu4Fsfg4r0NfJ9jNS2NwcV7G/g+x946HcGF4/EW8T6vrc6Moet8fxQXvn+GylF7O0pmG1zKczrX0prvJ3+WDeng+uJ8kLlRf5CYX4HBKz8ExGFjYVnAm7+s4s+ZI+TP/IT8UTaFovzZ6DvJHxzj09Z/FiL8UWNJydmi/e0O4g/6wZyK8GfhCPkT6z/j5DzzR/ETcdxN/EF/olqEP9Paf4rGOIjNdYjjHuKPmp9u5v4T4w/Ok4o/SxH+vFT6j839ij/GF2XzszJRh7Uyle0J9ceNvhupr1qToD2O9WczyHsavhIou6juavA/AzhZd1X2rzOiPjEdSdmzitjZVByh5Ug5hkvZ2WL69qR2tpi+HbOzjRvfrG+rdYBaTyMcwijdH/ND6wznku8r1a3/ow5lyfLQR5bX67e6/XzLBK4K/cc6+fp/FeQPwzE9yCOkrYis2ehfv6pxUmRdhri4z4XmPcbFbZtmH6i4P/zNYsOrHQpfJx8zyE9OalwY3X5czM0N8TIcl4n9j8dFLJ61Tyzz1L5A4n3XifnKPjUYhwLlPyfFc9ynrU3AcyWLLA/7n9Gm5qci+4oZ0Ym6Bc6NrFsY/BXQLb5F9VOx9BLrnKuT6pxqLyqmc6o9gdOCT2pPgOM8HMGaZXXSNcs4XYv5o/iJODb6boQ/Ss4e4ZpF8udkhD8LY+pbZM2ivtcz6Zr3KMfX/IT8mXTNizjujvBnCvZsJX9ORPhTNL5q0f7GeyZqDaD4g3FmDps/ZcqfGH/8Pe+ZIH9YB1R+o+qMwkZ/tD5qPwDPEEx7fK/P5AiOOr6XPT/ZH+ZXiNY9+vP7ga6F8JR3qr+//lbOjcbO/OMcwTTHzvzD/KVpiLWu+ISyyCfjNbbFCVG3eYL/y2xY58+DnNmDFeV5uC9H4LLAdQ+HeFbtjz5TbYR91+Ct7Fp/P42Wtwh5KCd9Wsr/I78Ql9ExT/B/R30X+5u9vyzKX6DyR+gWz7jvLgr4RQHv2+cLJI+w7mXvI+yVSfjxGdP25YTjqrfV7q5udbdX6jv1bqPbKvL9HIuzkrnR+c45vWeMe2s4z4W+n4PfwkH4f8zL9TT8+5zGGfp+Dvrf4P/Q9/rsDBd/w+efgYbvwlqU+TAYm4S75P5U+FO9g/lE8CPFPlnRWCzKl4n1INRV7+wP4TivyJ5/alxK35xUvsfsFOxXhjoXnsX6XmCMoq8VvmtjlPv7D2Cu+z7IccPriMZFF5cLWF/Wq42fJwLwLBcM/ocRuXBC1BvpOt/XOH8EONmeNe4M1o2uF5Qtic8iKXml1lr4nVCfqpBXpvxJvZcRs9di/1gmeOSjGkdFvhOL42Oj70bqqPoljjs1T1ZEGZko4zh8SwrrZ/k4ByO8TyYf5wnv13Igz7szc6Mwhu8cwCzTnIv8u6s/mqe+V+uf/UP+R8Us9r/1/H/9QKndU3N/efg7aypeb3n4V1tpzyCubqrvtJSIv5n4jOOAP4tp6F9RtsDy8Dd3lE2sRPoH/fNMGv43VUy2Eumvq7hfJeLvsF3QyvDJysb1WHnzdns7o/Kc0+sGK79GtJasRwzWDbcSPcwfXjecE7QuizyW8edEOedEOcsij8+YHQTX4yXierhEXA+UhEvNfweh68ES6TpZIl1l8avMOpZJl9IDpqGvKv1hWsZ2mX3i0RJxzeTXTH6lrGOZvK+VSFdZ/d7fL5ZIV5ljexrHY9kyelrn2jLb8aEScb0U5qGXQh3LoqtsuTqt8zbvm0xL/ypTrvLezUHoeqREuspcW02rjjkbj0dXx2mdt18K67Qy+wTvDd+M/Z73p6dFjy5zPbRcIl0pZbTBor3XfH18spgTbMP8KtkM0/jztHeUDT1zo2UvJCo7o/Kc0zYBPruE9BjdNZF3ED+1rcZuq1ff2mo3t3ZWOp1ORviNVn5WxJ9A2RfSnl1tbymfDfadr0Iex/qYhzw8i8pxuk4lor8I/7H8ZQHPcbqKtqXF6UIdk8/2Yh+2mODqrIT5JaBfgPLxyAg/+uGg39I35oa04ntII9Yvdp69EniO9xk9x3KxPP42KvunMS1c34qgU/FiTvCiSJwzHKeGL4W/a3t3dbOzu1pfae60e82dsecDSi9/ZXN1e3O10ei2G712Y+Wwy99c7XXbnVZzu7Xb3Vyrr40r/2X5/fH+/nl7BeV+AvpbaeN31uvKV6lM/CZLN/pD/FgXK9fLYzzjbfPR6cj7KWm/1rbtxN9WapwL0O+T+cKZ/ut5Y2uai72rD21e3nnuXXde6j27gyOMuRtLi276T3Pdnv8/6tNcr8jvj7m06hyWtErJn4QjUkorNTqVNmjvoPTy92fgHZ/OA+5DkmQr0yDJbIx5SXZbfr/9TG/7F+574dlnL+1e6j1//sVLV65eYXmGOB3dF5V947yOp10Ovjz/f9RycKa1FUozOejCGl1KjRZlXSqN9pyLyxLW2mzMXH7u6qXd993xfG/zam9nIPMcpaISbaa9FZdalnG8pdbq1mFJrTRnOJutxGdWB1LrQn+IX51rqxAcv4MS7s0A8+YAzF0Ac1cA5m6AuTsAcw/A3BOAQZvCzwdg7gWYewMw+P3n+wIw9wPM/QGYBwDmgQDMgwDzYADmIYB5KADzMMA8HIB5BGAeCcA8CjCPBmAeA5jHAjCPA8zjAZi3AMxbAjBPAMwTAZi3AsxbAzBPAsyTAZi3AczbAjBvB5i3B2CeApinAjBPA8zTAZh3AMw7AjCbALMZgNkCmK0AzDbAbAdgdgBmJwDTA5heAGYXYHYDMBcB5mIA5hmAeQZgKgBzCWAuEUxibWs1rUxvNorEQEjzfeFm4Vih/H3h1DEQVDyBUAyEPZj+kJ6M8qr9/fVQtkBrX6/dbgAc9y2OI2C0+GT9V8UYsH7r8d8PZT3iRmnHdypUvnP77awp2mKt3tlM2++vx/3cq2N/FL/xz6cq5FUpr0jb+fR+gGPepVhdIu/SjJPGYDcK6ceyfDrZd4NUIV4j/44qLtd9+f9pjst1Ib/HtegdUH6KtdVGEvyNuuE/n4b+tuG/Mwn+dt12Hr5ubeZSyqd6Xfk88Lx8MknZjUbReZl9htLoCcN5uWg8zLT+Vo16RviRHuVTpeI2s5/1IH4Z4EL4BagjwuO9vY/PdvKrirNyo9+I8zx/iuqm/N6K9CPEu+z284Z9W1RcILVzynGBPgC0v5NwqnZEPQhlCvIkFO+Iv39n8Jfzq8//N6dxFv2mnsFfAVrek9+P85d6n9P1z1ycp0XrPxeg9b1uWP9vB2hFepDWcf5bH4zAzQu4jGitOK3r23wVk8c32s9VnJu0/n/1fd/pVPXm8v1vEepQcftlEMOrPoX4+RzmYK/daVnKMYoM/tfyq+flRwI0OLe/X/uEulSoXxcZgx/Lrziux307yOhW8fcx3jLj8Gk9v9YPlhpp+1qzkTaOz9C3Kk0cn/qa8nFEWfIbVK5Z44rKcIP/bcD5ifxexepjfSLke8nfMHHu4LIKz6ux3nAG3lHjzGSowS9DuRXCoeBtjYayAc8t8Hxj8J/Kr57v38nv1XcysE0/7XTZ2KZLglYu+y8A52fz+9g3S9U3SFlHPCNoQT5v9EdpMfjP5VfPh+/l92r/Ay3IPlUhr8z1hafj+0AHt/98f7TeZX67FHmmvsPBcd6xDfjMk/q+jZpf1Hi1d5UcWY7Ul/uP/50FXAre8M0T/F/lV6WPnoV31JirBnB+EWj5Gzdaf2yDGsD9faBsrH9F1MfgbxX1R/izRKvB/60L139Z1B9jaJ0inAb/JcD5vQCdWC8lc+25Oj91q6jXLW4/X+xdxXuDQ94rHHxG2cqrOd0nFolWzMPyse5qbJ8VtMba+qwoh9v6a/lV6WinA3SG6MNxz2N8SeDCeWXafUq+mf8/ap+Sm+38RnNtrdNtbl2z6O1s7+60W4ddfqfdaaytba5td7Z3u+3trcMuf5q+A/GfBnvt98P8ftx3IP4vApcFrns4xLNqf/TZtH8H4n/z/9P8HYj/Nnz5Fete9l70XpmEH58xbdZ3fL9+Q47gePvKdbaPt69co3lYvnLoixbzlQv5r1UAJuS/hjAh/zWECfmvIUzIfw1hQv5rCBPyX0OYkP8awoT81xAm5L+GMCH/NYQJ+a8hTMh/DWFC/msIE/JfQ5iQ/xrChPzXECbkv+bzE/sxHYo/B44xB3VJ68dU3F76UvNjagIc962YH5P1X+XHZP3W4/85KOu8G6Ud8cXW2ml9cVa2E89j0o+J27XaHy0b87DtqsDPJvEnhZ6C/EnBf8+f2Mk5Xkc4p/Vv49FR+Sr9bP5/mn2VVvL7Q/BVaqb1VRrqzufT4G+l9VUa+lpdSEP/wNfqzWnw9wz/XSnwX9t+MF8uXNOHdIcic7tPbFPg79ZhOam+McZzWhr/sKEPwQLQqeydbL/CNa+y8TM862uM/9Th1HefvxfaIU8I+pVd3bly5ZPHmciuvjZP9TW/Cl/Xx6hM3PPnNvIJZZD/LVEbMQz7e52Gspnn+O48wT+ZX30d5rNRnMqHbBFw3kk4Df4pwLmQaTqdi+ub9vyMgEc7hNGjvi13ht6L2QYVboSvBPCw7YfrOQfPagJ32m/wDMck+gZkoky0mSP8s0TXrcTTGM/876woF/e0a1TuWSrX96FF6kNG26LT8oVPeJ9Iw9s28xG//YZ8OEH5Bh/zSVTy3sO9n+qCa2Vlw2depPlWVXNfP0NeqP7B/ezF/LoXqSQL8+KE4EVsXX4YPhpniV6Uu/NEk5J/yjd7Uvm37Pa37wLlKZ9QlFlcjvLD4H4X8gE0fDw3fCi/etpel43Sp+IAor+i+m4kv4P7xbF5Vu21oH/Txwgv2sjUvGU6PsdV/SHg/PX8PuVewbW0xrxQ/mZWJtKT5hzAcA6yPhDyXa24UR4a/CfcaFtYX8Q2nhd4DH5RlIv9mf3iFqlcnIMqogxcpyT2Ra3H1kaJ27GbUXnGD3yG5decbpv1cugZ7N8q/2XkD6/3FtPQs+Z1l2U32j98wvU5tg3SgXvFLJdw/v8UPOcxo+SS7S3NE/xnAedn8nvlS4v+slzmXKBMXsvw/rpPHMMC70+KOmE/4/Fq8J/Lr2rdUbSPsMxAeCWrbiEauF1DZWP/2OjrsouemzH4P82vOLcyzvlAfUIy8M8BJ/NU+XXGeKp0nyVRr1vcfj7yOmscT/nMAvqRFuGpwf+1G9b/dYH6F+WpwX8RcBZZH8d4Ok4/ZJ4iv3ktMI6n5/ua1qI8NfgvuWH9madKnsV4avBfAZyHzVOsM+85hPbtUG7i+VD1Xi2CczGAU8mvk6IOsbZUMo3b8p/yq2pLVa/FgvVaKqleSxPWy+D/NVG9KoF6VSas1+KYerEubfDfFvVScxjvy+NYVutW3gs0+O9CeTYu1Xod94R9qvZH67KeP68fKOn1Osq9+f5ovWN6gE8sO9ScqPS8Zaf7OeZhG3D7q/6SwbONvhupYybKQX1Sra25D+DZQlUm9wGD/6/8Oq4PoJ7uU7U/SvN6/rx+oKT7AM4H3AeUf0hs/lDzKO+3+MTfjMBxoPoA73WM893Y6LuROmIfQJu07XVMu899NUdws/ncH7XP+6Q+5zedz323s9tttbYare5Or9voHKXP/e05Aj8uX06ycl6U5+FeG4HLAtc9HOJZtT/6bNp97l8DOoxP0+hz/+Mkt7DuZe+H7ZVJ+PEZ02Z9ZxrOEv1Wfn+8ff5XdmbfYokn03HO94f4lW6C0fr9/e1uFH6c/sP7vpUk7T2M9J3Id3Utle/qu4k/aXxXU3/1obEW81091vHgwAfvA5G2ysqrT135kmdUdqJ+Xti+ZOXXXMp+NbQvVYke5g/LmURnN/bZdZGeecEf9kfgtsP1ptrXQbxzBI/39j4++4n8GovhlFGec3pvCfWVV1HdUvmiVqicSgnlcP/waT2/1g+UmnW2O2I5yi+Fx3Qan9DmLEZinD/HKkbiG/OripHIY3qSGIltqhvqdQcd00hXLF5YCv05UdzRNe6TzpWrz3DbltnflU92mfSrvU70VduA55in9rR5fkT4uwDnhfx+nP+E8lHmeWUxUB7Kc7bp3Au0PJHfF/9OI3sqhZK13BLBr+fX+gHTaaoVlmFloxX2KGapwS4X0ZpqllKWa+QPz1Jn0vCnjp5NOEtu9PfzhungSGEokdl7VXkPYK9WI2iO8rhNkHdLouzMjY78wao58B5HtDL4p/Orp/uXAB75gbTEvH5jkdyQHhUN7xbKU9q/2lHA2dGnKuSVucrz/PkVoAPr49N8f5QXincIPynvbDwvEzzyUa0IsExuP+5P7HldEe9lAo/axeLIWUVmNp/MomB4967wbB7w+nTYp3XNe3+aT+vaCY3j8JW7/HLTWUenKSLWRwz22u+j+f0469xvRuCywHUPh3hW7Y8+m3br3Mfz/9NsnbNTGdNonbO+c/NYxzrtmXUsnmbWsUlSY3dmHYvzZ2YduxmsY816ER0By3+JWcd2M8KP9MysY5PrmjPr2Mw6ZvSE+tzMOjazjk2aElvHdmfWsTD9M+vY9TSzjhVPM+vYGP7MrGMAO7OOHawvzaxjo7TMrGPX08w6ltOU459Zx66nmXVsmKr90Wcz69j19FKwjv10juB4W8fah3Z2LNGucDPtLrj+XgzWhXd3UT7YO2onxb4Tsxd/0g3vXwb4fMJvxfD6K5GFKHHs/3pjmixErjzc9eMdn34YP/4C4E/Bn0Tx6esqPn2J9DfM+reV4/NrELOAXNvVuevyTu/F3s4jmxcvXrp88eHe9vO9q2+68nDv2uPneROVDSVo2OFkbGIcGf2fi+BwTm+oofGjSKjHRJu07SIqF5Z/WKEei4ZiMd6dFLSqTxaHDH9YzklRjsI1VyIubm9sj/X8Wp8stfhB6rChbJTBZHk1UedMwPOSD+n212cAL8NxmdhONcrD/rBIeTjmligP2+405bF8UFfnihlu8L25QL3KKAd5xKpVKuMyh0I9UWI52HbWVir8GYdamnQMz4tylLHcpl5P13qgTBUG1SdTa9i54H43xHlHfp/W+aK+yv0fE4dZw/6rDLbcn1E2cB9UodWKyg38BNuHAC/DcT3UNrzafhwsrd3+Nnowv3qan4Z3EKfRjbT6VMSYXDRULX8aZtrmANXO3D/Q/MD9A7f+Wa7gtjfyhNO4Oed3AS/DWVLtrGQKlsVb2xVBL8qNad+CvZj/P+otWFwyxObMxMvuwjr2YEvP7Z+TU+jYFaKH+cPjTzmG8bzu00Z/CMd5FfFs7pBxHZ1zZ32laF+YVudOXqviu6wT+bTRH8JxXmzOOy647H2fYuE31Vok5lxp+qLSwW2biGXcLS7cNkYXfprDuf31NNzseIOhQ3keLXMriWU6lpVYt+2odYglte7jdlfhy5Xey+2u9N5M0DBOt/0XwMtwllQfySgv5lbC7e6TWqvOU55yQFRuAaGwuD7h9iLidE67k5hepRzSQnpCzF2E9Tm1lvWJx5DBfzq/JtbB5RhaiNSvEqmf4uv5vq7fF/Krh/2DAuWpPsV9UY0py8MxxW2knH9jdTD4P8qvHDrap8MPY15vezpuAzqQ1j36+6P1VmHMEZ7XlAcJY84yRM2hajxyPzsh4BEf97PP51fPmzdko/Rhn68R7Vj3mGsSyy7sW6eA5q/n94n36A9tz4XnJewHk85LxotJ5yV2C8M8tfeu5MTRu/fpcYt7IjxucYxWBDyP23Hj3PTHZbe/Lbl/45g5RXlYLs/Nag8j9kkDHDOh9fm8qIN/7xuAD9sR5Tu+y/Ld4H8EtHwrv1c6EfcvJZeYFue03IutHYrsgSfWuQuvSafhcJJakyXWpwaff1X7r6qdvZv4Gbe/zZC+gfyB9829oIiOrvTwmCw8DB0dyx530IPbWI1jHucI/z/51efbZ2Rj65eM6HMu3oaxNkf+Gq2xPXfVLhnd1yLlKLpi8l/RhToAHy2p0f9YHWL9TunjRzgHr6g5GOvOc3BMF/aJ20AdS1H68TLBI8/VuGTdFMuNHRWJjUvUW228xOYvlLNsn1DjE+fom9n1+RXZsL6vhL61ByvK83Cvj8BlgeseDvGs2h99Nu2uz68F2ezTNLo+vyp/aRpdn63vTMNnO16e3x9z1+vOzPU6nmwe2eiP4ndu/9yOcxe+o+yt5/O8BQfHrdzQPs++bynanefTMvl2TtDP+8xn8/9eT3htfn/p8vbzvXf1Ll9907vfPeLEuufYap6sjhJbsjP6P84r9Tgc5jKn/KP2JOjm98dc8q0dluRLJJnaiS2AUvIpS2mF4Pgdnx+TjocVaiwRn5qJd6RaRVYmWP5BPVWxrJpL2oejHu4xT5YydyAVrqNsU+Q1tukeTH+YN0d5Vcg7QXmoxaOV/NUAx2OQNRucq8yq63H8JOD7qfw+sfaydpTaC6+andOrTeP5UR2mf0P+f5oP078mv190Q62wBfhCYwT1OLZOqB2ZxOO5abQqzzHlfe81XgtdeuXqc8/37rp8/sXe9gtXLz13+Y7N7Wd6jhIOPuyYcy48MWNFFY4KvK/ScVCK1/L/R60U/1h+P1OKo6mVWBlrp47jppRiJXCsD5sZC++NJoO5ADAXAManG91WUJP2nZSn3ChxWY6xlm/mCd0mHhPIXji/Or+//NzVS7vvO3/5PS/0XujtPPDC1rOXtu984fL2dUH97LOOEivdGf3njQqWyVWBhxO+l0Edpl1WvzL/f9SyGo//+IQxxFPI6tvS4K8rF6jb4f42qif2vfWSaDB81g/m3f7E5qOBEkn0ZeXT13CUlBnJ0rn8ehs8uz1AK7uKrZdDb9PwJ4oiKPsMmrwXKc/aTsmjLPBfbbaGYLMI3tMiz3BaWyG9Vg+bvzAqn+Etk5doRk6AfyA/Um1CqL7A8bud02OG9QCWqSXTujlYdAMNFSqTaUQY1X/ZGFCl55UCsKr/opsR08fvsUsNP+ONHCfgBwv1/DofwIXuRQjP7tup2vCcoMlo/3/QDoAybw0tAA==",
      "debug_symbols": "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PWp61PSo6VHTo6ZHTY+aHjU9anrU9Gjp0dKjpUdLj5YeLT1aerT0aOnR0oPTg9OD04PTw+PcnDhJknqSJlmQx/lNlFSSalJ6SHpIekh6SHpIevT06OnR06OnR0+Pnh49PXp69PTo6aHpoemh6aHpoemh6aHpoemh6aHpYelh6WHpYelh6WHpYelh6WHpYeHhhUuDKKkk1aSWxEmS1JM0KT0oPSg9KD0oPSg9KD0oPSg9KD0oPUp6lPQo6VHSo6RHSY+SHiU9Snpccd6vN6KXNQ2ipKvQWZxqUkviJEnqSZpkQVecD6Kk9Gjp0dKjpUdLj5YeLT1aenB6cHpwenB6cHpwenB6cHpwenB6SHpIekh6SHpIekh6SHpIekh6SHr09Ojp0dOjp0dPj54ePT16evT06Omh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh6WHh4cVRgyipJNWklsRJktSTNCk9KD0oPSg9KD0oPSg9KD0oPSg9KD1KepT0KOlR0qOkR0mPkh4lPUp6lPSo6VHTI+OcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOe8Z5zzjvGec947xnnPeM855x3jPOe8Z5zzjvGec947xnnPeM855x3jPOe8Z5zzjvGec947xnnPeM855x3jPOe8a5V391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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACDScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHABAnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjYtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI2LQIAAC0LBgELIgABgEQAByQCAAcAAAGeJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2QtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB7yUAAAR3LwoAAwABHgIAAgEKKgECAyQCAAMAAAIMJQAABIkmKACABAR4AA0AAACABIADJACAAwAAAjUqAQABBfeh86+lrdTKPAQCASYlAAACDS0LBAYLIgAGgEQAByQCAAcAAAJYJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAvAjAAACcS0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAApslAAAEmy4CAAeAAygAgAQEAAQlAAAErS4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAALbJQAABTstDgoBLQ4IAi0OBQMtDgkEIwAAA2MnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADZC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABK0uCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAANjJiUAAAINLgiARQAFIwAAA3QNIgAFgEMABiQCAAYAAAPkIwAAA4ktCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAAA/ojAAAEZi0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABK0uCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEZgEiAAWARgAGLQoGBSMAAAN0KgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVeEKDJz12ECzwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAEyCMAAATTLgCAA4AFIwAABTouAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFJi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAE9SgBgAUEAAEDAIAGAAKABiMAAAU6JioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "tZjRais5DIbfJde9sGRLts6rHEpJ2/QQCGnJaReW0ndfyZacZmEGzix70/+zx/5HtjWaaT53z4fHj18Px/PL6+/dj5+fu8fL8XQ6/no4vT7t34+vZ+393CX7AynvftQ71TYU0LUORW+jt7O3Mw8tyZVcZSgVV/VtqlWGtuzq/eJtGW1M2bUOBXDloZhcyXX4Yi6u6sOqBV3rUAJXGsrJtbj6vJpdZWjzdvProuPFVLrmVFzbUNu/rjzU4u3q49DH5ezq7eLzLF5Ti7crufr92Oexj6s+rvr9mrebzgMw0ImAClIHlEQOkAI0OMgG4oA5oDpkCKCAGFxieokeiulk04sCU4CN0cwotTg0dJAUoINRA6OkN0Uy0OWh7j9ZPgwQB9sBrAY2S3OA7Mw6CATwAE4pQO+OulFsiZSTgTjY0QyoDgUCYoyldwfGABusG86WQR1aCiAHi2cAD6gJAmyMLrlCDmgOyA52BANisB1BhxKzyOLJBtWBIYACxKGH2iEGt5jeokdiusR08enNntVcDMTBsr4DQkB1sMLRwSrGAN/DVpoDYUD0NBujCSB9f9hAHPpGdWgOVqssE8Ru2iFDADuU6CnRQ9FD0cPRw+ETOSY9xzqIQ0+2DjFYYnA/ZbLiammXe5ntwXayaC1spRqUZ58FPKjvV+tEQTT7eiJKJwmyGuE0nWsO6mk5iIL6IQ+K+0KCSTRJgmL3ob8pBvVE5a+vu128aB7eL4eDvWe+vXn0ffS2vxzO77sf54/T6W731/700Qf9ftufu77vL3pVz/9wflZVw5fj6WD0dXednZanNrbq02c3zmUa0K0DLDvoC664A2h9nA5AdGOBKxbE7oAJp0GGdmOQlw1qLeIOtQpPC2y3yyjLFpnQHQp8M0i3BrRsgCAQq8Akixa8bEEYq6CcNhlIdQMG2rQIbBEC5m9n8ScWFeZp1pVlQPp/PYA5ngvg2rZ5aOEPjyq4zUMLcXho4V32WLEo81T0c5EXHzFYORbWN2g8Ish5esjtQwYr2aUvyPmQXfcTuGwqNqUtFpu2shX6/RxbATUtRgGyso6WIzNqI5gefBsGprWtmI9qZW6LFrC6EpnJBYS8ZLK2obXEc9IqL1ZvXCmdpK+5KDqpLa9kpXTqHsaZtO+F60/WkfG6Dl5ax9pTljAc9GW+XPvWLGCmhZ5N22bBMwpo26LIs4YrbouCMF3LRd1mwdeK02TbQq51T/+Z22ZR5qdFpk0LqSUOpBbeYiCz3ghtWoSkOE/BbRHMnNKP6v+4hH8b3Gtz/3S83Pzg8WVWl+P+8XTw5svH+enb1fe/3+JK/GDydnl9Ojx/XA7mdP3VRP/8RP2yR+J7+2jWpn6d3+nnsTXBrlLVq3L/ZcH8Aw==",
      "brillig_names": [
        "slash"
      ]
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "view",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3449819541828076517": {
            "error_kind": "string",
            "string": "Function tally can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAXLQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjdbts8DIbvxcc5EClSP7mVoSjSNh0CBGmRJR/woci9j7RFORkgIXW2k+oxY70mJZJW/TW8bV/OP593h/ePX8P6x9fwctzt97ufz/uP181p93EQ69fg9E/KwxpWQ/bTkMYBnC9jHNYkI+CwZh3jNGK5RrkGvdGjgSp4AfIGZmG1qFoEgaQQBLJAAgOzZLGgzso8ATpnYBYwC1RLLoDeIBVQDyeIBQgMbDqbYNTp4ipmEmAF0fFuNXgXCujTJ+ACaBakAvrQCXSWrI8nZ8AF2CxslmCWQAapgDo2QSyQ0EAfIc777AzYQJbFSzjkyCAV0J2dwCy6dBOYxds9YxQKYxQjsIE+QhaKmAxSgYAGoYAmwARmSc5Ap0tuUEYDuYckQFbnJxBlQgHwBmZR54kUUgFfdFj3fQQyC5mFzcKaz+IGq6sjRAmQFNRDCgpq0Zs1RSkq8JQkwYFBKqAeTpALIBmYxds9Y2YKRE11ygqpwBipAoKBeMiSWtGTQS5AZtG4JtC6laWLgQtEZ5AKJHkEo0IqkM2SdbokUtIAJwgFwCxgFjQL6rP85bIarO08n47brXadqz4k3elzc9weTsP6cN7vV8N/m/15vOnX5+YwjqfNUX6VOLaHNxlF8H233ypdVvNs154agvaUcXYIPlcB/oZCmBVSUwE7Cl6rdFKQ4q8K4VbBtxVSTKaQksOWwr1R5LRkHSJGU4jkWwqhreCDpvioIG1t9gGCv5GIbQl57VgYgHneDMi3EqktIdlu+RQTQ2stc0dBCtgUJCVaCtBZTADK3gIBxtAS6QaCcyChqQDYcyNzXU6Y10JeWvenBcCcFrwosebUlDbTUtCe3M4s8DWz/HVm3cYB4eEqhfhwmd4dCcV2JF0NjlUj5qYGdjaF5r5JgaitAQ9XGnYSNFKupcbOLZKQ6qoSGBdJhJrjgm0JeLhYsdc+MZuEpCo1ixV7/dPF2nbc1cvM8x8anb6TamYkT22FTgMN4GqlhbZCN44ANY7o2hrdFK9rQXLcaqa4x3+rIa8/tFgCX+0J8Dc0kpW8/I+VlmlEru/WmKit0clRdGB+oKO5A2LAW43e3oZasLI03NboxpLJNKTy2rHkx2Mh949jmdsoJArNWO5+JeTQzFPqHEIhuxpLpqvDAvhvdNLqhxydFjZjwocl7jrAUfwLB7hecsgZoW7sddGyXySBeZFE5nlbQ1gogbNEXCZBfk6uPwJ5ksvN6+548xHromLH3eZlvy2X7+fD69Wvp/8/7Rf7CPZ5/Hjdvp2PW1Wav4TJnx9Snispryf99KWXUpHgo16CXqa0kvx/uqgzvwE=",
      "brillig_names": [
        "winner"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "join_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "is_init",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "num_players",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "game_over",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "first_capture",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "join_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec::capsules::CapsuleArray;\n\n    // Define a base slot for your array\n    use dep::aztec::utils::comparison::{compare, Comparator};\n\n    use dep::aztec:: macros::{\n        functions::{initializer, internal }, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n\n    use aztec::{\n        macros::{events::event}\n    };\n    use std::convert::AsPrimitive;\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        join_fee: PublicImmutable<Field, Context>,\n        challenge_fee: PublicImmutable<Field, Context>,\n        slash_fee: PublicImmutable<Field, Context>,\n        deposit_size: PublicImmutable<Field, Context>,\n        is_init: PublicMutable<bool, Context>,\n        num_players: PublicMutable<u32, Context>,\n        deposits: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        game_over: SharedMutable<bool, 1, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        first_capture: SharedMutable<bool, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally: 0 , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    // #[initializer]\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        join_fee: Field,\n        challenge_fee: Field,\n        slash_fee: Field,\n        deposit_size: Field,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.join_fee.initialize(join_fee);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.slash_fee.initialize(slash_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.num_players.write(0);\n        \n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender());\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender());\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n        let current_block = context.block_number() as u32;\n        // You can now use current_block for your logic\n        if current_block > storage.end.read() {\n            storage.game_over.schedule_value_change(true);\n        }\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[private]\n    fn submit_score() {\n        let score: TallyNote = storage.tally_note.at(context.msg_sender()).get_note().note;\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score.tally)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        let (gameOver, _) = storage.game_over.get_scheduled_value();\n\n        if(gameOver) {\n            storage.final_score.at(sender).schedule_value_change(score);\n            let (winner_score, _) = storage.winner_score.get_scheduled_value();\n            if(winner_score < score) {\n                storage.winner_score.schedule_value_change(score);\n                storage.winner.schedule_value_change(sender);\n            }\n        }\n    }\n\n    #[view]\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        // Ensure the game is initialized\n        if !storage.is_init.read() {}\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger != AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[public]\n    fn slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == context.msg_sender(), \"You are not the challenger for this address\");\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_note = storage.tally_note.at(context.msg_sender()).get_note().note;\n        let mut new_tally = tally_note.tally;\n        let mut new_capture_note = capture_note;\n        let randomness: Field = unsafe { random() };\n        let mut challenger_capture_note = CaptureNote {\n            owner: challenger,\n            capture_block: 0,\n            randomness\n        };\n\n        if capture_note.capture_block != 0 {\n            new_tally = tally_note.tally + challenge_block - capture_note.capture_block;\n            new_capture_note = CaptureNote::new(context.msg_sender(), 0);\n            challenger_capture_note = CaptureNote {\n                owner: challenger,\n                capture_block: challenge_block,\n                randomness\n            };\n        }\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the old note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
