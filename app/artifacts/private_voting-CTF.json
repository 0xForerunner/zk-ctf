{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBLJwAABAMnAgIEAScCAwQAHwoAAgADgEouCIBKAAElAAAARSUAAAB3KAIAAQSASycCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQQABCYlAAAHlB4CAAMBHgIABAAKKgMEBSQCAAUAAACYJQAAB70nAgMADycCBQQGLQgABi0KAwctCgEIAAgABQAlAAAHzy0CAAAtCgcECyIABIBGAAMLIgADgEQABSQCAAUAAADdJQAACRwwCIBGAAQnAgMAECcCBQQGLQgABi0KAwctCgEIAAgABQAlAAAHzy0CAAAtCgcECyIABIBGAAELIgABgEQAAyQCAAMAAAEoJQAACRwtCAEBJwIDBAQACAEDAScDAQQBACIBAgMtCgMFLgyARgAFACIFAgUuDIBGAAUAIgUCBS4MgEYABS0IAQMAAAECAS0OAQMuCIBFAAIjAAABeA0iAAKAQwABJAIAAQAAB0UjAAABjS0LAwItCAEDJwIFBAQACAEFAScDAwQBACIDAgUtCgUGLgyARgAGACIGAgYuDIBGAAYAIgYCBi4MgEYABgEiAAKASAAGLQsGBScCBgQCACoCBggtCwgHASIAAoBDAAktCwkILQgBAicCCQQEAAgBCQEnAwIEAQAiAgIJLQoJCi0OBQoAIgoCCi0OBwoAIgoCCi0OCAotCwIHACIHAgctDgcCJwIIBAktCAAJLQoCCi4IgEgACwAIAAgAJQAACS4tAgAALQoKBy0LAggAIggCCC0OCAInAgkECi0IAAotCgILLQoGDAAIAAkAJQAACS4tAgAALQoLCCcCBgQJLQgACS0KBwoACAAGACUAAAmuLQIAAC0KCgInAgcECS0IAAktCggKAAgABwAlAAAJri0CAAAtCgoGHAoFCAQcCggHABwKBwUELwoABAAHHAoHCQQcCgkIAAIqBwgJLAIABwAtXgmLgro3tDuZoTFhGP0g1C9RZsnp8T+16mWpbR4KbQQqCQcIHAoICgQcCgoJABwKCQoEAioICQsEKgsHCBwKCAwBHAoMCwAcCgsMAQIqCAsNLAIACAAwM+okblBuiY6X9XDK/9cEywu0YDE/tyCynhOeXBAAAQQqDQgOHAoODwQcCg8NABwKDQ8EAioODRAEKhAHDRwKDQ4B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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgADAAAKmCUAABT7ACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYlAAAI+AEiAAGASAADLQsDAhwKAgMBHAoDAQAcCgECAS0KAgEmJQAACPgtCwQGCyIABoBEAAckAgAHAAALDicCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAuhIwAACyctCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAALTCUAABT7LgIAB4ADKACABAQABCUAABRbLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAC4wlAAAS9C0OCgEtDggCLQ4FAy0OCQQjAAAMFCcCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABUNLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAUWy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBIAAMtDggEIwAADBQmJQAACPgtCwQFCyIABYBEAAYkAgAGAAAMNycCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABUNLQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEcABAEiAAaASAACLQsCASYqAQABBQLcbieAdhKdPAQCASYlAAAI+CcCCgQLLQgACy0KAQwtCgINLQoDDi0KBA8ACAAKACUAABDrLQIAAC0KDActCg0ILQoOCS8KAAQACicCEAQRLQgAES0KChIACAAQACUAABHxLQIAAC0KEgstChMMLQoUDS0KFQ4tChYPHgIACgUcCgoRBBwKERAAHAoQCgQMKgoPECQCABAAAA1PIwAADS4WCg0QHAoNEQQcChASBAQqEQ4QACoQEhEtChEGIwAADXAWCgsQHAoLEQQcChASBAQqEQwQACoQEhEtChEGIwAADXAAKgoGEQ4qChESJAIAEgAADYclAAAS9AwqCgkGFgoGCRwKBgoEHAoJBgQEKgoHCQQqBggHACoJBwYcChEHABwKDwgAJwIKBBItCAASLgiASgATLgiATAAUAAgACgAlAAATBi0CAAAtChMJBCoICQoAKgcKCBwKDQcAJwIKBBItCAASLgiASgATLgiATQAUAAgACgAlAAATBi0CAAAtChMJ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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "join_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "slash_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZndTis5DMffpddcJM6HY17lCKEC5ahSVVAPrLRCvPvaju0C0lTssHuDf3EzfxyPncm0b5uH3d3r79v98fHpz+b619vm7rQ/HPa/bw9P99uX/dORvW+bJH8yjc11vtpAArM4bS5mbQz2Odj8YuNin1cb1765BrYtm21madpezOK0aGO08QCzNibWKWK72pKy2WaWppV41eK0YPPA5pVk1sd8XWVbq1kbt2IWp+3ZbDNr89Dm4Zh22FjibmwJzM5xlbjVNrM0rcSt1uaBzYM+bbGxxN3Z1mTWxzStxK0Wp5W41dq8bvOwmrWxxI1ix7RkY4mbbZO41TazNG0uZm2e1IdaG0teBtvB68h8I5skJHPme0oOw0BrDQWkSBIDcJTQBIZBKQ7uqe6p7mng4J7uc2T5CujKg8OALlAdyIDcQ+bBVB2GQXZP9jlSaQolOXSDmh2kqrlMUNtDoRv05FAdyEB7RMEv1y5RGAbkHrI5I8lVKDAMMjh0A0gO1cEnF58sHa5Q3aM9TgxNmioJDIPeDTA7SMPxzjAk4ROqwzCQ4Cf0CZSSg11O2T25OsjlXFokvaKgTd4FxMOhkrS3eiTPXI8k2ZV6JLQyJLQyJC1VAdlzpB5Jc8nFkpO0gVF3yuHL4YPwaTkolfCVmFchKP6HtLBUCRM6dQgKH4YPwzdyUPgo5pFVbc6pBJGTl3LOYDXIVIPIqZQgdKoQ1J1aqOjmr9RzUPgw5qHVY866jkktiJyoBFlRcsg5yK+AnILOPppFmwHKLM0MJQeRk1bMJCvPDHJnjNBJVmTUgsgJ4woMlRG+ESr6eAMlMipyj6Rm83y4SfTzsaY+qZcyhGQPKaRETlIlk6RKjLqTtGCVtenjqGalFkROsiEboRPEPOkyo+Ekm3EFJXKSlpukD9FJ6CTxGYVP7n4tSuQkm7FSkyOKETrlHNSC/Nomm1mVCmtSu0boJLuyUQsipxZXtFDp4euhgqGCoSIP1yo93aSKJ0k3GqFRlzttNJxkL5kEnmd9HBp5xnsJnzw5qtRG1/yhUgsiJ83kpGE1hFprk7yuUB4TRuGD8EH4SvhK+GroRZ3qs86oBZFTjyt6XKG10ZUkG+rT6CcNW4c+4ozCJ9EbybVS90N2ZaPwSRW3pNSCyKmGcvX8Da1npZ6D0Anj/2L44n6MuB8j7scg/x+klY3v71cbP6Hfvpx2Ozmgfziy80H+eXvaHV8218fXw+Fq89f28KqT/jxvj2pftif+lFewOz6wZcHH/WEn9H51vjotX4p8tLCrB+/9IUDtuwo1Sw+oQuXqC4WWvq8wmivw+8gaBX5dCYVKqxQ6uQK/c6xRKPJMNYVWVylg5KGmvkIBRvNagEHnPPDu8W0JKsUlqI1FCbpQU6N4FDjaOZf98zrypbLs4LcD+4ei+iqRlyX4hEK+Ej6ZQF8SuZgM8nvKRZHX5JOf5N4eBVJalMh1WYMP6dGkJdXFbLQLEil6bPCpYVGiX0poTxAJ5dexFQktEGHwG3pbzsZY1qDhCSU654LPip8V6NJK0oiFwPm2Fk7Md6Pgk7WHwef3vhgH5Eubb40qRzprwPicUNncFjPa4Lz7nhXSF4VyocgzZe94SLSscaFCW7RrK2mdAqEp9NzWrYO3PF9HSbBOA7M3PB/pL6xk/L8acsjz6uo41mnw9wiuwV8XrNOg5DnNBMsaF1u+UGyAfbnlS/nxBljqjzfA0v6DDfByHEQRB9QVeyh/1RBRpN7W3BN+o4/y4nevdRL9nIuxLooSPc+4LooGsZBWcZ1EnPz49Y3WLeTcJfyEWycRp2h+vV+1EKx+Q7D2NQJUvUM+Hvz+jUDy+0mwLoKoKcL2wyV8Fbjh4fZ+f/r0o8i7SJ3227vDzoaPr8f7D5++/P3sn/iPKs+np/vdw+tpJ0rnX1b4zy/+VeCqpnrD73gy5Pa84q/bZMgvhr/4qxf+FG/eJZh/AA==",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3Bji29jp35Lndcg6AoUqRfpQdGtV02CihUGXa5JwW/e+9gBLmUmTeVyr33aaCB3wOf7/51zloRsUWGQqKk//jbf/2n//t///f//M//+t/+7X/97T/9X//xt//7f/7zv/zLP//3//wv//Zf/vHf//nf/vXxX//jb8f5/1GTv/0n+ofHn3r/Oe4/7f7Trz/5uP+k+892/8n3n/3+89bjW49vPb71+Nbrt16/9fqt12+9fuv1W6/fev3W67dev/Xk1pNbT249ufXk1pNbT249ufXk1pNbT289vfX01tNbT289vfX01tNbT289vfXGrTduvXHrjVtv3Hrj1hu33rj1xq03bj279ezWs1vPbj279ezWs1vPHnrt/NPuP/3604/7T7r/bPefDz05/3zojfNPuf/U+89x/2n3nx5/tuO4/6T7z3b/yfef/f7zvL52giaMBEvwG+hIoISWwAk9IZUplSmVKZUplVsqt1RuqdxSuaVyS+WWyi2VWyq3VOZU5lTmVI7YkRN6giRowkiwBL8hQiiAElpCKvdU7qncU7mnck/lnsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKI5VHKo9UHqk8Unmk8kjlkcojlUcqWypbKlsqWypbKlsqWypbKlsqWyp7KnsqeyqfcUd2Qk+QBE0YCZbgF/AZfhdQQkvghJ4gCZpwZol2giX4DWcMXkAJLYETeoIkaEIqUypTKrdUPmOwyQktgRN6giRowkiwBL/hjMELUplTmVOZU/mMweYnaMJIsAS/4YzBCyihJXBCT0jlnso9lXsq91SWVJZUllSWVJZUllSWVJZUllSWVNZU1lTWVNZU1lTWVNZU1lTWVNZUHqk8Unmk8kjlkcojlUcqj1QeqTxS2VLZUtlS2VLZUtlS2VLZUtlS2VLZU9lT2VPZU9lT2VPZU9lT2VPZb+V+HAmU0BI4oSdIgiaMBEtIZUplSmVKZUplSmVKZUplSmVKZUrllsotlVsqt1RuqdxSuaVyS+WWyi2VOZU5lTmVOZU5lTMGe8ZgzxjsZwwyneA3nDF4ASW0BE7oCZKgCSMhlXsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKo9UHqk8Unmk8kjlkcojlUcqj1QeqWypbKlsqWypbKlsqWypbKls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2IEDGLwNvA28DbwNvA28DbwNvA28DbwNvB28HbwdvB28HbwdvB28HbwdvB28Al4Br4BXwCvgFfAKeAW8Al4Br4JXwavgVfAqeBW8Cl4Fr4JXwTvAO8A7wDvAO8A7wDvAO8A7wDvAa+A18Bp4DbwGXgOvgdfAa+A18Dp4HbwOXgevg9fB6+B18Dp4HbwB3gBvgDfAG+AN8AZ4A7wB3gBvgjfBm+BN8CZ4E7wJ3gRvghd61aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx16tfrb4703p6u//bVyO/Hkfb/fpKu//cIBnIWXXp148r6/c6Grv/3Cb97j/f6Xrv7210rsxAN48vb1Nw4cwFl46ZUsPHm1TdyB53x1jr/06v2tCl397Rc2YAeevGP6v/TqvResq7/9wg148r7fy9PV3x7v76fo6m+/8AA2YL9jtfrbL5z3NVr97ZILr+s7/99TrxYWYAUewAbswOu+iomz8KlXCzfgDizACjyADdjv+2H1t8v7PU1d/e0R05+lVyduwJP3vW6jq7/9wpM3Z9ymXuWx/t2AHTgmXn+fhadeXfjNm/PeXv3t2ab/U68u/ObN9/dZdPW3Z5/XaOpVrnlNvbpwAGfhpVfrui+9ssm79Grek6u//bV6PLHez93qbz/v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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAIAAAAAAAAAAAAEwAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AELPwWYLZcjbQbWyn\njjR08kNKtYHHCswZ4db0yn2JHfwNMSHcBZ1pgmwaknUsz6mVGcGJy4Gl19UK9mv6h1rUfiUKJA/G\nFZntM/+RU1H7K/csUijNivEPPmfm2kBfjOn6GrquItxHGaqxtNqD9cbOKPJmVqQe5OH7ut21qVsb\niasFlzTXcL239LjX2MvcdgyOWl7JRSFsscfRpUhvJR72ehmdG0V9S4o4VYBQppO9MtafsSVoIisP\nT/swS+fKU/5EBtUR5JU8PO+wV58ZT8zTx2GmKQH2nDYThYR2TZgh0j4juVuI1S2ueynxwUF9SR2d\nf91/i2ANvav4N/JOqgM/7iSoSI5agHR2cXuJrfQumqHDE6CqtcjLBx9NINncwAHqD5wkHN6PgabF\na+1flgNMkFda+7exoloWIezCv4j0ie4p+aieKAZcad1t7BAhQUUD42lm7nFz/YhLIr9XsGBQwyqP\nxFWWtD084XjCfXuCSyrRkxlD5Cj3GRiwjBgp1qQaJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7\nBxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTCcxz5bzQwelJyXXStOPYBkrKb89\n7LbPtUNbVEAozXWtKZg2B7G9G2sA2qm+KMUtJB/zRfB3iNi02Rim4euielIJdCTmqcz2NU9/nh2g\n8ZW9T3A1NlCOYdcXtBtYFd7PGS8BWCQLexyxM1dmPtdAZ28JcVVp/amol1wpvhxz67G0AAYiMPtb\nUdEAqv2Fscco+i+KONTzgTpQQEKdqu7JQMUtLBY2GsAbAzQvY06DYTEc3agjG6WPbl/UPFSNndta\nkgm8xZDccvcZbUUDEP/TrhSVh6Efm/o5BcP2eFJJ3HKnDru2YNlfrX6JkgfR5EFpWPhpehqy2ElW\nl3SNPPMv3NsJcLVHQKYIVstUgdFnf9NUzLYr6kjIDSRbgvNQmZZSVRfLCsT+WywMI6n3iNYA5a4b\nCdIrEAI2ontHKBzczJo2HBOZLN0PPpoDTkbCiYD8rBawwa5ZoeYeE1OdjrI9urMwJmVMZ8iooCs0\noiyRGiwrAslSR/nnFRKPBAP5Mt/QKxjcdAQ1LDjojJqEEZ3MGHK6tZj+jAY5mIh1ohRjWH+QCdCx\nQ3RooLnRpducfkSrF0qLpWpX4T1VZ1BSx7dtAhkVAH3JTlwKbAA7pu/n4/yqcKdP324iJiewgjhW\nJt0RfBThjbS+bAx8URm8qh5tF0eAzV2tg81BVXptZN/yfgaQAOWX4pGVXeBVBl8RrxG4UAoKozcs\n7iquZdxFGhMS/VMBJGvFvuFb/b3/W1yjmojJs4vxXDCEQOdbjXFnkBueABpoyDGABFsj/M8rdvlH\nF6GptTRA9mxqwpSmfRpuv4doGNb/woUXcVbbLLl9pjSskCw+OT7i9kectdfRACeM1C4C0ut/JT5/\nL6tuJY5Rrm2rA7Muye9nyrpca6WMaEGQuwjx8vGXCKKwSQDXIcaVRs0XAEGDbAYQO8pzAFxKX0hV\nHzhNENef5EM6dhDKcDjJ/fa/eMOnkr7n8TAZ+nhC9VEUnWnl6h41ee5zGNUz75F6MGWzgjOrqXkP\nmMnBoSO1jgC3CdcFbi4du6JCFuVTdeL+BFiTUZKzvsJUutWaAGRaDC3Z+iFuPqAKnRl/6C3RNFBa\ntyhynDQem7ke3sf3ojoXQ+DTQTABvC8BrP9j7g0tgPeFfaHGEjhq+00hn1LJsCTEXKsV8whPYlx4\nIPD3x7E0r4wPW2NCewWcMqs3903zIRy0HLEQ2QI9HHvmZHDvQXASfbfBYWxiQhMkyP/t1FEgpTdh\npvVk7g2ZvkMl4anBMcg9WbFeYDZow1gKChzhjQtaDT7C5fKzBDrVkn917iJOe4uwdsAdnRXmldtJ\nYoR5L0k+SqJepx+Q/5V+KqqeomSYTxXLfqssT2ml2Ailb00MDfwyFqfkTkJc7/GGGfQrfw/rg2SO\nEbH+DYvGtgxvIQt+Bww1reRIgasMq+ppQb4/zeTE4IFhvnl5SCKu+7P2F0xNqsxv6+gtiDGpBETv\nEX32GkvxinRGtU2OzdDlJyENPQ9wXJw7Qm4veGR5CujPFMTyBusHozGX/1z2u6wLrwcDm+cLVXtv\nDU1Z+xKAoZlYPQqQ5tVT5L1kSbWO9QehChGFSw0wrqddreiukl/tbL8F77PitlsEvecaM00v6zMA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACIMez0949HhUOF97TDK3UZjuzjFzrsyjxMlENeJgzaWsRCX+Xyh4BG4SX49ZRzWfjGg/k\nGn52HOZnz8aNqh8W1gDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0Yx9fnPbrJvJUf+wMEiu793Dk/CafQMc0yN4/5DxvjJCzmrNEh\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBjJwAABAMnAgIEAScCAwQAHwoAAgADgGIuCIBiAAElAAAARSUAAAE9KAIAAQSAYycCAgQAOw4AAgABKQCAQwA7msoAKACARAQAAygAgEUBAAAoAIBGBAAAKACARwAAACgAgEgBAAEoAIBJBAABKACASgAAASgAgEsEAAIoAIBMAAACKACATQAAAygAgE4EAAQoAIBPBAAGKACAUAAABigAgFEAAA8oAIBSAAASKACAUwAAICgAgFQAACEoAIBVAAAjKACAVgAAJSgAgFcAACYoAIBYAAArKACAWQAALSgAgFoAAEAoAIBbAABIKACAXAAAZCgAgF0AAGgoAIBeAABwKACAXwDerSsAgGAAAAAAAAAAAAEAAAAAAAAAACsAgGEAAAAAAAAAAAMAAAAAAAAAACYlAAAUeCkCAAIA2yPyUQoqAQIDJwIEBAAnAgYEAwAqBAYFLQgBAgAIAQUBJwMCBAEAIgICBS0OBAUAIgUCBS0OBAUnAgUEAwAqAgUELQsCBAAiBAIELQ4EAiQCAAMAAAGjIwAABHwtCAEDJwIEBAcACAEEAScDAwQBACIDAgQfMIBPgEkABC0IAQQAAAECAS0OAwQtCAEDAAABAgEuDIBGAAMnAgYEBy0IAActCgQILQoDCQAIAAYAJQAAFKEtAgAALQoIBScCBwQILQgACC0KBQkACAAHACUAABUYLQIAAC0KCQYnAgcECC0IAAgtCgQJLQoDCgAIAAcAJQAAFKEtAgAALQoJBScCCAQJLQgACS0KBQoACAAIACUAABUYLQIAAC0KCgcnAggECS0IAAktCgQKLQoDCy4IgFAADAAIAAgAJQAAFT0tAgAALQoKBScCCQQKLQgACi0KBAstCgMMLgiAUAANAAgACQAlAAAVPS0CAAAtCgsIJwIKBAstCAALLQoEDC0KAw0uCIBQAA4ACAAKACUAABU9LQIAAC0KDAknAgsEDC0IAAwtCgQNLQoDDi4IgFAADwAIAAsAJQAAFT0tAgAALQoNCi0IAQMAAAECAS4MgEUAAy0IAQQAAAECAS4MgEcABC0IAQsAAAECAScCDAC6LQ4MCycCDAQNLQgADS0KAw4tCgQPLQoLEC4IgEoAES0KBhIACAAMACUAABXULQIAACcCBgQMLQgADC0KAw0tCgQOLQoLDy4IgE0AEC0KBxEACAAGACUAABXULQIAACcCBgAFJwIHBAwtCAAMLQoDDS0KBA4tCgsPLQoGEC0KBREACAAHACUAABb5LQIAACcCBQAHJwIGBAwtCAAMLQoDDS0KBA4tCgsPLQoFEC0KCBEACAAGACUAABb5LQIAACcCBQAJJwIGBAwtCAAMLQoDDS0KBA4tCgsPLQoFEC0KCREACAAGACUAABb5LQIAACcCBQALJwIGBAwtCAAMLQoDDS0KBA4tCgsPLQoFEC0KChEACAAGACUAABb5LQIAAC0LAgMAIgMCAy0OAwIAIgICBS0LBQQnAgYEAgAqBQYDOw4ABAADIwAABHwpAgADAGRf4PcKKgEDBCQCAAQAAASXIwAABMwnAgMEBC0IAAQACAADACUAABfzLQIAAAAiAgIFLQsFBCcCBgQCACoFBgM7DgAEAAMjAAAEzCkCAAMAXVRKsAoqAQMEJwIDABYkAgAEAAAE7CMAAAZrLQgBBAAAAQIBLgyARQAELQgBBQAAAQIBLgyARwAFLQgBBgAAAQIBJwIHAKgtDgcGLQgBBwAAAQIBLgyARwAHHgIACAUcCggKBBwKCgkAHAoJCAQvCIBNAAktCAEKJwILBAIACAELAScDCgQBACIKAgstCgsMLQ4JDCcCCwQMLQgADC0KCg0ACAALACUAABxdLQIAAC0KDQkMKgkICiQCAAoAAAWWIwAABggeAgAIBRwKCAoEHAoKCQAcCgkIBCcCDAQNLQgADS0KBA4tCgUPLQoGEC0KAxEACAAMACUAAByCLQIAAC0KDgktCg8KLQoQCwwqCAsEFgoEBRwKBAYAHAoFBAAEKgYJBQQqBAoGACoFBgQtDgQHIwAABggtCwcEJwIGBAEnAggEAwAqBggHLQgBBQAIAQcBJwMFBAEAIgUCBy0OBgcAIgcCBy0OBgcnAgcEAwAqBQcGLQoGBy0OBAcAIgUCBy0LBwYnAggEAgAqBwgEOw4ABgAEIwAABmspAgAEAGf8hHIKKgEEBSQCAAUAAAaGIwAADKMtCAEEJwIFBAMACAEFAScDBAQBACIEAgUfMIBLgEkABS0IAQUAAAECAS0OBAUtCAEEAAABAgEuDIBGAAQnAgcECC0IAAgtCgUJLQoECgAIAAcAJQAAHWItAgAALQoJBgEiAAaASQAILQsIBycCCAQJLQgACS0KBQotCgQLAAgACAAlAAAdYi0CAAAtCgoGJwIFBAgtCAAILQoGCQAIAAUAJQAAFRgtAgAALQoJBC0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEcABi0IAQgAAAECAScCCQCKLQ4JCB4CAAkBHgIACgAKKgkKCyQCAAsAAAd/JQAAHdknAgwEDS0IAA0tCgUOLQoGDy0KCBAuCIBSABEACAAMACUAAB3rLQIAAC0KDgktCg8KLQoQCyQCAAoAAAfBIwAADIUnAgkAEScCDgQPLQgADy0KBRAtCgYRLQoIEi0KCRMuCIBXABQtCgcVAAgADgAlAAAe8S0CAAAtChAKLQoRCy0KEgwtChMNJwIQBBEtCAARLQoKEi0KCxMtCgwULQoNFS0KBBYACAAQACUAACCwLQIAAC0KEgktChMOLQoUDycCCgAaJwIQBBEtCAARLQoFEi0KBhMtCggULQoKFQAIABAAJQAAJNktAgAALQoSCy0KEwwtChQNDCoMBBAkAgAQAAAIiCMAAAyFJwIOBA8tCAAPLQoFEC0KBhEtCggSLQoKEy0KBBQACAAOACUAACCwLQIAAC0KEAstChEMLQoSDScCDwQQLQgAEC0KBREtCgYSLQoIEy0KAxQACAAPACUAAByCLQIAAC0KEQQtChIKLQoTDi8KAAMADycCFQQWLQgAFi0KDxcACAAVACUAACXfLQIAAC0KFxAtChgRLQoZEi0KGhMtChsUHgIADwUcCg8WBBwKFhUAHAoVDwQnAhYEFy0IABctChAYLQoRGS0KEhotChMbLQoUHC0KDx0ACAAWACUAACbiLQIAAC0KGBUAKg8VFg4qDxYXJAIAFwAACYUlAAAnQAwqDw4VFgoVDhwKFQ8AHAoOFQAEKg8EDgQqFQoEACoOBAocChYEABwKFA4AJwIUBBUtCAAVLgiATAAWLgiAUwAXAAgAFAAlAAAnUi0CAAAtChYPBCoODxQAKgQUDhwKEgQAJwISBBQtCAAULgiATAAVLgiAWgAWAAgAEgAlAAAnUi0CAAAtChUPBCoEDxIAKg4SBBwKEw4AJwISBBMtCAATLgiATAAULgiAWwAVAAgAEgAlAAAnUi0CAAAtChQPBCoODxIAKgQSDhwKEAQAJwIQBBItCAASLgiATAATLgiAXQAUAAgAEAAlAAAnUi0CAAAtChMPBCoEDxAAKg4QBBwKEQ4AJwIQBBEtCAARLgiATAASLgiAXgATAAgAEAAlAAAnUi0CAAAtChIPBCoODxAAKgQQDi0IAQQnAg8EBAAIAQ8BJwMEBAEAIgQCDy0KDxAtDg4QACIQAhAtDgoQACIQAhAtDgcQLQsEDwAiDwIPLQ4PBCcCEwQULQgAFC4IgGEAFQAIABMAJQAAKFItAgAALQoVDy0KFhAtChcRLQoYEi0IARMAAAECAS0ODxMtCAEPAAABAgEtDhAPLQgBEAAAAQIBLQ4REC0IAREAAAECAS0OEhEtCwQSACISAhItDhIELgiARgAJIwAAC3INIgAJgEQACyQCAAsAAAwpIwAAC4cnAgkEFC0IABQtChMVLQoPFi0KEBctChEYAAgACQAlAAAo5S0CAAAtChUELQsFCS0LBgUtCwgGLQgBCCcCCwQFAAgBCwEnAwgEAQAiCAILLQoLDC0ODgwAIgwCDC0OCgwAIgwCDC0OBwwAIgwCDC0OBAwnAgQECi0IAAotCgkLLQoFDC0KBg0tCgMOLQoIDwAIAAQAJQAAKVktAgAAIwAADIUkAgALAAAMNiMAAAx0ACIEAgwAKgwJDS0LDQsnAgwEFC0IABQtChMVLQoPFi0KEBctChEYLQoLGQAIAAwAJQAAKa4tAgAAIwAADHQBIgAJgEkACy0KCwkjAAALcgAiAgIFLQsFBCcCBgQCACoFBgM7DgAEAAMjAAAMoykCAAMA5WI6+goqAQMEJwIDABAkAgAEAAAMwyMAAA+ALQgBBCcCBQQCAAgBBQEnAwQEAQAiBAIFHzCASYBJAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLgyARgAEJwIHBAgtCAAILQoFCS0KBAouCIBRAAsACAAHACUAACrXLQIAAC0KCQYtCAEEAAABAgEuDIBFAAQtCAEFAAABAgEuDIBHAAUtCAEHAAABAgEnAggAgi0OCAcnAggADS8KAAgACS0IAQgnAgoEAgAIAQoBJwMIBAEAIggCCi0KCgstDgkLJwIKBAstCAALLQoIDAAIAAoAJQAAK3ItAgAALQoMCSQCAAkAAA20IwAADa8jAAANtCcCDAQNLQgADS0KBA4tCgUPLQoHEC4IgFEAES4IgFUAEi0KBhMACAAMACUAACuXLQIAAC0KDggtCg8JLQoQCi0KEQsvCgALAAwLIgAMgEcACyQCAAsAAA4SJQAALVYeAgALAR4CAAwFJwIOBAMnAhAEAwAqDhAPLQgBDQAIAQ8BJwMNBAEAIg0CDy0ODg8AIg8CDy0ODg8nAg8EAwAqDQ8OLQoODy0OCw8AIg8CDy0OBg8AIg8CDy0ODA8AIg0CDi0LDgwnAg8EAgAqDg8LNwsACwAMJwIPBBAtCAAQLQoEES0KBRItCgcTLgiAUQAULgiAVQAVLQoGFgAIAA8AJQAAK5ctAgAALQoRCy0KEgwtChMNLQoUDh4CAA8BMAoADwAOJwISBBMtCAATLQoEFC0KBRUtCgcWLQoDFy4IgFYAGC0KBhkACAASACUAAB7xLQIAAC0KFA4tChUPLQoWEC0KFxEeAgAEBRwKBAYEHAoGBQAcCgUEBCcCEgQTLQgAEy0KDhQtCg8VLQoQFi0KERctCgQYAAgAEgAlAAAgsC0CAAAtChQFLQoVBi0KFgcAIgICDy0LDw4nAhAEAgAqDxAEOw4ADgAEIwAAD4ApAgAEAOxrNWAKKgEEBSQCAAUAAA+bIwAAEK4tCAEEJwIFBAIACAEFAScDBAQBACIEAgUfMIBJgEkABS0IAQUAAAECAS0OBAUtCAEEAAABAgEuDIBGAAQnAgcECC0IAAgtCgUJLQoECi4IgFEACwAIAAcAJQAAKtctAgAALQoJBi0IAQQAAAECAS4MgEUABC0IAQUAAAECAS4MgEcABS0IAQcAAAECAScCCAB+LQ4IBycCDAQNLQgADS0KBA4tCgUPLQoHEC4IgFEAES4IgFUAEi0KBhMACAAMACUAACuXLQIAAC0KDggtCg8JLQoQCi0KEQsvCgALAAQeAgAFAQoqBAUGJAIABgAAEJAlAAAtaAAiAgIGLQsGBScCBwQCACoGBwQ7DgAFAAQjAAAQrikCAAQAN5muhAoqAQQFJAIABQAAEMkjAAASWy0IAQQnAgUEAgAIAQUBJwMEBAEAIgQCBR8wgEmASQAFLQgBBQAAAQIBLQ4EBS0IAQQAAAECAS4MgEYABCcCBwQILQgACC0KBQktCgQKLgiAUQALAAgABwAlAAAq1y0CAAAtCgkGLQgBBAAAAQIBLgyARQAELQgBBQAAAQIBLgyARwAFLQgBBwAAAQIBJwIIADUtDggHHgIACAEeAgAJAAoqCAkKJAIACgAAEXolAAAteicCDAQNLQgADS0KBA4tCgUPLQoHEC4IgFEAES4IgFUAEi0KBhMACAAMACUAACuXLQIAAC0KDggtCg8JLQoQCi0KEQswCIBHAAsnAg8EEC0IABAtCgQRLQoFEi0KBxMtCgMULgiAVgAVLQoGFgAIAA8AJQAAHvEtAgAALQoRCy0KEgwtChMNLQoUDicCBgQPLQgADy0KCxAtCgwRLQoNEi0KDhMuCIBGABQACAAGACUAACCwLQIAAC0KEAMtChEELQoSBQAiAgILLQsLBycCDAQCACoLDAY7DgAHAAYjAAASWykCAAMApWsuTAoqAQMEJAIABAAAEnYjAAASqycCAwQELQgABAAIAAMAJQAALYwtAgAAACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAABKrJwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCyCARYBIAAIkAgACAAAUdycCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQUnRkiy9UEXvQAiBQIFACIQAgYnAgcEGy4CAAaAAy4CAAWABC4CAAeABSUAAC2SJwIGBBsAKgUGBS4MgEkABQAiBQIFLQ4BBQAiBQIFPA4DBCYoAIAEBHgADQAAAIAEgAMkAIADAAAUoCoBAAEF96Hzr6Wt1Mo8BAIBJiUAABR4LQsBAy0LAgQNIgAEgE8ABSQCAAUAABTDJQAALdgAIgMCBgAqBgQHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIASIABIBJAAUOKgQFByQCAAcAABULJQAAJ0AtDgMBLQ4FAi0KBgEm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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACDScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAA8nAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjYtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI2LQIAAC0LBgELIgABgEQAByQCAAcAAAGeJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2QtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB7yUAAAR3LwoAAwABHgIAAgEKKgECAyQCAAMAAAIMJQAABIkmKACABAR4AA0AAACABIADJACAAwAAAjUqAQABBfeh86+lrdTKPAQCASYlAAACDS0LBAYLIgAGgEQAByQCAAcAAAJYJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAvAjAAACcS0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAApslAAAEmy4CAAeAAygAgAQEAAQlAAAErS4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAALbJQAABTstDgoBLQ4IAi0OBQMtDgkEIwAAA2MnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADZC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABK0uCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAANjJiUAAAINLgiARQAFIwAAA3QNIgAFgEMABiQCAAYAAAPkIwAAA4ktCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAAA/ojAAAEZi0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABK0uCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEZgEiAAWARgAGLQoGBSMAAAN0KgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVeEKDJz12ECzwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAEyCMAAATTLgCAA4AFIwAABTouAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFJi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAE9SgBgAUEAAEDAIAGAAKABiMAAAU6JioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "tZjRaiM7DIbfJde5sGxLtvoqSylpO10CIS3Z5MCh5N2PZEtOcmAGdpa96f/ZY/8j2xrNNN+b9+n18vNlf/z4/LV5+vG9eT3tD4f9z5fD59vuvP88Su/3JugfCGnzVLaitStE09I1WjtaO1k7UdccTNGUu2I2Fd8qWrhrTabWz9bm3o4hmZauAKbUNQZTNO2+MWVT8SHRHE1LVwRT7ErBNJvavJJMuWu1drXrLONZlZumkE1rV92/ptRV421q46KNS8nU2tnmabyqGm9TNLX7kc0jG1dsXLH7VWtXmQegIBMhCnDpkAMaQHCQ4CApsEFMDsUggQM6+ODs07P3oE9HnZ4FCB10jGRGLtmgRgMODjI4SmAY5KYRFWR5UfYfNR86sIHuQCwKOktyAPXMGjA4UAcKwUHuHmWjSBMpBQU20KPpUAwyOPgYTe8GFB10sGw4aQY1qMEBDTSeDtShBHDQMbLkAsmhGkQy0CPo4IP1CBpkn4UaT1IoBgQO6MAGLdQGPrj69Oo97NPZp7NNr/qspqzABpr1DSI4FAMtHA20YnSwPay5GmB08J6qYyQBuO0PKbBB26gG1UBrlWYC600bJHAgg+w92XvQe9B7yHvIfTzHuOVYAzZoydbAB7MPbqeMWlw17VIrsy3YRhqthi1UnNLo04A7tf2qjdAJR19LRG7ETlojjIZzSU4tLTuhUzvkTn5fCDAIB7GT7z60N0Wnlqh0vW43/qJ5OZ+mSd8zd28eeR997U7T8bx5Ol4Oh+3mn93h0gb9+todm553J7kq5z8d30XF8GN/mJSu29vsMD9Vss1n15RhGOCjA8w7yAsumwNIfRwOgPhgERcskMwhhjgMEtQHgzRvUEpmcyiFaVjE+riMPG+RMJpDhjuD8GiA8wYRGHwVMfCsBc1bYPRVYAqrDLiYAQGuWkSsHkJMd2fxOxYFxmmWhWVA+LseQOSZDVTqOg8p/O5ROK7zkELsHlJ45z0WLPI4FflcpNlHDBaOheQN6o9IpDQ8+PEhg4XskhfkeMhu+wmUVxUbxNliUxe2Qr6ffSughNkogBfWUZOHUSreah49hhHD0laMR7UQ1VkLWFwJj+QCjDRnsrSh8v3oG5rLbPWOC6UT5TXnRSfU+ZUslE7ZQz+Tel+4fmcdiW/rSHPrWHrKQvT6LS/z+dq3ZAEjLeRs6joLGlFAXRdFGjVccF0UOB4zKRdlnQXdKk7ldQu51T35Z26dRR6fFglXLaRkP5CSaY0Bj3rDuGoRHPw8Oa6LYOSUfFT/4RL+b/Aszd3b/vTwg8dVrU773ethsubH5fh2d/X875df8R9Mvk6fb9P75TSp0+1XE/nzI8qXfUR61o9macrX+VY+j7UJehWLXOXnqwbzHw==",
      "brillig_names": [
        "slash"
      ]
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+19B3wcx3X+Hg8ACZAgIFLsogiS6vUqiittNcvqxbJkybIB3B0lWxIlkpKofmwqVqe6LVe59xLHPXaK8093EjtOnDixHTtOtdOcZif2f4bcd/fdw9u9Pdwb4EbE/H4D7O3MfvPNmzdvys7OpIID7uPpILgqfeA6ZXw6/D/P+CF2j/7jdbcQb6Fwr1+4NyDcO0S4t9z4TezeOiHekHBvvXBvg3Dv6PAeunnh/03h/0x7Lns0YOUzw4VCeSRXzuaz45nc2MRoMVMoTgyPZkezxdFiKTeaz5dHC6MjYxNjI5mxbCFfzlaKY/lKCLYorccL5WBxrRy6mAzQpZTlktLDygh0tbBHJOwpwmi3YPvVCjaXd8lzcdpNoWnzHJg+zxy/YbktCeqVY79hM/g/B950vRjuD4TX9Nyg+X2I8UuMX5o+cN/6PsCJk0mmPZcdVCw75Hto2iHhGriicnQF9RbNJ6H3AM9loVyWh/9XhP9Xhv9Xhf9X82Z8eXpqM2gjL2CCmKcsdEVzn13piRVao9hcu+R52PR5FvkNyVquAau4DK6Xw/VhzFquNb8PN36d1dd0/T65NJNBpj2XXaFYVmvTemWz3pGua8tP0dBlD1eU3wblVo/r9nrQ4Q1wvQ6uh5hubzS/jzD+SOOPmoWewCoF+ZYr+10Z+R6ddkjYgms1SkT+aEWlPUZRaV3J0HLUajxIhsd40hgfq8ez4JLncdPnmec3JIN1LBgm6+l6I9w/jhms483vE4w/0fiT0o14czqqV/Yn6/HMS2V/MpTxarg+PqbsM+Z31vic8XmhI6Y9X7ZI0Y4WHM2XFWC+zMNGu4J8iy4b7aJ+o10pKhbqsAeN9rC+QawMKxtE7dmCjWFDoCVHi5VJ6xurjYr6M+J4pBLV8I/EGP9R83vM+BcY/0LHDX+n63krDepojExfZH6/2PiXGP9SGP3NC2amIVmmKJN+4LkpbEheFv5/efj/lPD/qeH/08L/p4f/zwj/vyL8f2b4/5Xh/7PC/2fzqcyXp6e+mTxNuPcK4d5Z6anC1u7NnaMm6LzTEce50+dZ4jekSnIOVIZNcP0yuD6XVZLzzO/zjb/A+AvT7qf/Xq7Y2Jyn2Chc5Gjkoi2/UxTld76i/C72RH6nKsrvAkX5vcpxA3oR2ICL4fpVcH0hsw2XmN+vNv5S4y+bAdtwmmLZXKJYNq/xRLdPV5TfqxXld7kn8jtDUX6XKsrvCse24TVgAy6H6yvg+jJmG15rfl9p/OuMf/0M2IZXKJbNaxXLZtwT3T5TUX5XKspvwhP5vVJRfq9TlN+kY9swDjZgAq4n4fr1zDaUzO+y8RXjN8+AbThLsWxKimVzleOyuQrKoAzXFbjezMrmavP7Dca/0fhrhLLRHvNeqyeDiiSDayGvV8P12TETQ9eZ31uMv974G2BiKB3MzMTQdYp6MQ94bg0r1jY+gWMDquzetvAeOu2KeZ1iZdqaHGuyCVZ2m2IB4KxilEuaVjPegUOl3KpsrMht58q4XZgR5IqnqSxNuGabhGe2KyrxjWk1ZcigTG9MUJnb5b5NUQ6aMr2pBZk2SwtlehMYzQUgT5Rppj2X/Xk8Xm6yks0XyyPFzPB4oVgazudKuZFMqVCsZA3h3FjBiKYyWRgtjebyldxIbvLnuvz26xgZNmpIqFXdFl7fbP7vMP4WFJAD/dOc+bxZUf9uVW5MZmqdw62ODP5taYeEb0vr496uqAyu8n07VC4l3Njhcrty0Jxm36FYPnd4WlnvcFRZ70w7JHyng8p6V4dXVpvvu2a4smbacw2tYaY9p2pMq8pK3xuWdxV6MTvSjR8V0vqFU+D+qUKcneb/LuN3h78J++YI7FsAu1mcPeb/XuPvTrupm7eHOqo913OP8lyuNj9X+b5Xsf4E4LQX+92iWDfvU86z9oJBWz81y8XWyXsc6M6b0m7aCG3dOU1Rd+7vcN05JRzNauHZuvImB7rzgLLuuNCZm5X15gEHfUrNhZrSO4qotXgvj3lH8aD5/ZDxDxv/SLr1TxfblfWDIJPceLFULoyUS3nzvtvMM02MmPmo8fFsYWQ4Z6afhkcrxcnKZHZ4sjSazQ6XJ4YnMmMTmUpuuJCfHM9NjCHfR9MOCVtwrsTtkn9U0RDsczx40ZDhPqGCtSvDfcqjbrst0rygeSXItOeyDzpqnANdnhl8iftYWMEeD/8/Ef5/EspVXXEUC7jh+68nYNTErepjYD0fh+snYqzqU+b308Y/Y/yb01P3YdLKA1UkTfk+ldZvoRUVPPuUo8qiratvUeOZL0q60y4/+ymN4idK+z+9e1FaX8dHFPX72Q6fObD170kHMnxSUYZvddyLfQvY1Wfh+q0x9vZt5vfbjX+H8e9Mu/+muaAoz3c5atMs7lAoo56g8b1yAPLWlMvbOrx+2c9Gn3Uwsnt2htqkTHsuW3DB0yrY/OBAb9m1gg06EnSgyzNHFdGlLJY5kIU2x+UecFzhSeXd6AnPdzmuo+qt+bsUW/PnHLXmz4WteVzBtcv93WrccxMueb5HgefwSGVytDCSc8nzvdPnWeA3pJ7yu6FH/J60vIHte1lP+X3m9/uN/4DxH0y7/2ZCsQHIvk+xnn7I8SjmQ1Ae74frD8D1B1nZfNj8/ojxHzX+YzAXz1eFcrdJJx/5VEw67abB65t2o6OI5VVnyAXPD/vWgD+naBg+7qgB/zgMx3uDqYbXRUGmgoNb4bR5PucJz3QwwxVY4yWjVuaPcZR57TwrVs7ssZ7keZ5ino/zJM+KlTF7fOCHATrBE54nesLzJE94nuwJz4wnPLPBzNi4THsumwv07OVI2o885xXzvMiTjmUh8INn0ROew57wHPGE56gnPMc84fkCT3i+0BOeL/KE54s94fkST3i+1BOemzzh+TJPeL7cE56neMLzVE94nuYJz9M94XmGJzxf4QnPMz3h+UpPeJ7lCc+zPeF5jic8z/WE53me8DzfE54XeMLzQk94XuQJz4s94fkqT3he4gnPV3vC81JPeF7mCc/XeMLzck94XuEJz9d6wvNKT3i+zhOer/eE57gnPCc84TnpCc+SJzzLnvCseMJzsyc8r/KE59We8HyDJzzf6AnPazzhea0nPK/zhOcWT3he7wnPG5R5avOz++g85mAfna2B3prPx9KdL8PHHchwm6IMH/dAhk84kOF2RRk+4cl66xsV8/xWT/J8kxpWPqOxT2C5Yl3J6QFhNwd+tIE7POF5iyc8b/WE522e8LzdE553eMLzTk943uUJz6onPHd6wnOXJzx3e8Jzjyc893rC825PeN7jCc97PeF5nyc83+QJz/s94fmAJzwf9ITnQ57wfNgTno94wvNRT3ju84TnY57wfNwTnk94wvNJT3g+5QnPpz3h+YwnPN/sCc+3eMLzWU94vtUTnm/zhOfbPeH5Dk94vtMTnu/yhOdznvB8tyc83+MJz/d6wvN9nvB8vyc8P+AJzw96wvNDnvD8sCc8P+IJz496wvNjnvD8uCc8P+EJz096wvNTnvD8JU94ftoTnr/sCc/PeMLzs57w/JwnPD/vCc8veMLzi57w/JInPH/FE55f9oTnVzzh+auOeM5T5vlrgNXu9zEbPfk+5tcV8/wuT85g+I3AD55f9YTnb3rC8/95wvO3POH5257w/B1PeP6uJzx/zxOev+8Jzz/whOfXPOH5h57w/CNPeP6xJzy/7gnPb3jC80884flNT3j+qSc8/8wTnt/yhOefe8LzLzzh+W1PeP6lJzz/yhOe3/GE53c94fk9Rzy15yj/OtCbo3ybJ/Oy31fMc6HD9/g6xvB71sEeXz9QlOGznsxt/03gB88fesLzbz3h+Xee8Px7T3j+gyc8/9ETnv/kCc8fecLzx57w/GdPeP6LJzz/1ROe/+YJz3/3hOdPPOH5H57w/E9PeP6XJzz/2xOe/+MJz596wvNnnvD8X094/p8nPH/uCc9feMLTAvrAM+UJz3me8Ex7wrPLE57dnvDs8YTnfE94LvCEZ68nPPs84bnQE56LPOHZ7wnPxZ7wHPCE56AnPA/xhOcST3gu9YTnoZ7wXOYJz+We8FzhCc+VnvBc5QnP1Z7wXOMJz8M84bnWE56He8JznSc8hzzhud4Tnhs84bnRE55HeMLzSE94HuUJz6M94XmMJzyP9YTncZ7wPN4Tnid4wvNET3ie5AnPkz3hmfGEZ9YTnjlPeOY94VnwhGfRE57DnvAc8YTnqCc8xxzxnMd4tvu9YUoxzy84CPP8Qk/ynFbM84tmKM+Z9lz2xSk9+X3Yk++5X6KY5+c8+Rb5pZ60CZs84fkyT3i+3BOep3jC81RPeJ7mCc/TPeF5hic8X+EJzzM94flKT3ie5QnPsz3heY4nPM/1hOd5nvA83xOeF3jC80JPeF7kCc+LPeH5Kk94XuIJz1d7wvNST3he5gnP13jC83JPeF7hCc/XesLzSk94vs4Tnq/3hOe4JzwnPOE56QnPkic8y57wrHjCc7MnPK/yhOfVnvB8gyc83+gJz2s84XmtJzyv84TnFk94Xu8Jzxs84bnVE57bPOG53ROeN3rC8yZPeN7sCc8dnvC8xROet3rC8zZPeN7uCc87POF5pyc87/KEZ9UTnjs94bnLE567PeG5xxOeez3hebcnPO/xhOe9nvC8zxOeb/KE5/2e8HzAE54PesLzIU94PuwJz0c84fmoJzz3ecLzMU94Pu4Jzyc84fmkJzyf8oTn057wfMYTnm/2hOdbPOH5rCc83+oJz7d5wvPtnvB8hyc83+kJz3d5wvM5T3i+2xOe7/GE53s94fk+T3i+3xOeH/CE5wc94fkhT3h+2BOeH/GE50c94fkxT3h+3BOen/CE5yc94fkpT3j+kic8P+0Jz1/2hOdnPOH5WU94fs4Tnp/3hOcXPOH5RU94fskTnr/iCc8ve8LzK57w/FVPeP6aJzx/3ROev+EJz696wvM3PeH5/zzh+Vue8PxtT3j+jic8f9cTnr/nCc/f94TnH3jC82ue8PxDT3j+kSc8/9gTnl/3hOc3POH5J57w/KYnPP/UE55/5gnPb3nC88894fkXnvD8tic8/9ITnn/lCc/veMLzu57w/J4nPP/aE57f94TnDzzh+Tee8PyhJzz/1hOef+cJz7/3hOc/eMLzHz3h+U+e8PyRJzx/7AnPf/aE5794wvNfPeH5b57w/HdPeP7EE57/4QnP//SE5395wvO/PeH5P57w/KknPH/mCc//9YTn/3nC8+ee8PyFJzyDeX7wTHnCc54nPNOe8OzyhGe3Jzx7POE53xOeCzzh2esJzz5PeC70hOciT3j2e8JzsSc8BzzhOegJz0M84bnEE55LPeF5qCc8l3nCc7knPFd4wnOlJzxXecJztSc813jC8zBPeK71hOfhnvBc5wnPIU94rveE5wZPeG70hOcRnvA80hOeR3nC82hPeB7jCc9jPeF5nCc8j/eE5wme8DzRE54necLzZE94ZjzhmfWEZ84TnnlPeBY84Vn0hOewJzxHPOE56gnPMU94vsATni/0hOeLPOH5Yk94vsQTni/1hOcmT3i+zBOeL/eE5yme8DzVE56necLzdE94nuEJz1d4wvNMT3i+0hOeZ3nC82xPeJ7jCc9zPeF5nic8z/eE5wWe8LzQE54XecLzYk94vsoTnpd4wvPVnvC81BOel3nC8zWe8LzcE55XeMLztZ7wvNITnq/zhOfrPeE57gnPCU94TnrCs+QJz7InPCue8NzsCc+rPOF5tSc83+AJzzd6wvMaT3he6wnP6zzhucUTntd7wvMGT3hu9YTnNk94bveE542e8LzJE543e8Jzhyc8b/GE562e8LzNE563e8LzDk943ukJz7s84Vn1hOdOT3ju8oTnbk947vGE515PeN7tCc97POF5ryc87/OE55s84Xm/Jzwf8ITng57wfMgTng97wvMRT3g+6gnPfZ7wfMwTno97wvMJT3g+6QnPpzzh+bQnPJ/xhOebPeH5Fk94PusJz7d6wvNtnvB8uyc83+EJz3d6wvNdnvB8zhOe7/aE53s84fleT3i+zxOe7/eE5wc84flBT3h+yBOeH/aE50c84flRT3h+zBOeH/eE5yc84flJT3h+yhOev+QJz097wvOXPeH5GU94ftYTnp/zhOfnPeH5BU94ftETnl/yhOeveMLzy57w/IonPH/VE56/5gnPX/eE5294wvOrnvD8TU94/j9PeP6WJzx/2xOev+MJz9/1hOfvecLz9z3h+Qee8PyaJzz/0BOef+QJzz/2hOfXPeH5DU94/oknPL/pCc8/9YTnn3nC81ue8PxzT3j+hSc8v+0Jz7/0hOdfecLzO57w/K4nPL/nCc+/9oTn9z3h+QNPeP6NJzx/6IjnPMYznxkuFMojuXI2nx3P5MYmRouZQnFieDQ7mi2OFku50Xy+PFoYHRmbGBvJjGUL+XK2UhzLV0LsoxXz/LczlOdMey77d/P05PfxtB/l3KUov7/3RLe7FfP8D57kuUcxz//oSZ7nK+b5nzzJ8wLFPP/Ikzz3Kub5x57kuU8xz//sSZ4XKub5XzzJ8yLFPP+rJ3nuV8zzv3mS58WKef53T/I8oJjnn3iS50HFPP+HJ3k+RDHP/+lJnpco5vm/PMnzUsU8/7cneT5UMc//40melynm+aee5Hm5Yp5/5kmeVyjm+X89yfNKxTz/nyd5XqWY5597kufVinn+hSd5XqOY58CT+e3DFPOc8iTPaxXzPM+TPB+umOe0J3lep5jnLk/yPKSY525P8rxeMc89nuR5g2Ke53uS542KeV7gSZ6PUMxzryd5PlIxz32e5PkoxTwvVMyzgdq/xucHYYaPMf5Y448z/njjTzD+RONPMv5km57xWeNzVibGF4wvGj9s/Ijxo8aPGf8C419o/IuMf7HxLzH+paEMXmb8y40/xfhTjT/N+NONP8P4Vxh/pvGvNP4s4882/hzjzzX+POPPN/4C4y80/iLjLzb+VcZfYvyrjb/U+MuMf43xlxt/hfGvNf5K419n/OuNHzd+wvhJ40vGl42vGL/Z+KuMv9r4Nxj/RuOvMf5a468zfovx1xt/g/Fbjd9m/HbjbzT+JuNvNn6H8bcYf6vxtxl/u/F3GH+n8XcZXzV+p/G7jN9t/B7j9xp/t/H3GH+v8fcZ/ybj7zf+AeMfNP4h4x82/hHjHzV+n/GPGf+48U8Y/6TxTxn/tPHPGP9m499i/LPGv9X4txn/duPfYfw7jX+X8c8Z/27j32P8e41/n/HvN/4Dxn/Q+A8Z/2HjP2L8R43/mPEfN/4Txn/S+E8Z/0vGf9r4Xzb+M8Z/1vjPGf95479g/BeN/5Lxv2L8l43/ivG/avyvGf/rxv+G8V81/jeN/3/G/5bxv2387xj/u8b/nvG/b/wfGP814//Q+D8y/o+N/7rx3zD+T4z/pvF/avyfGf8t4//c+L8w/tvG/6Xxf2X8d4z/rvHfM/6vjf++8T8w/m+M/6Hxf2v83xn/98b/g/H/aPw/Gf8j439s/D8b/y/G/6vx/2b8vxv/E+P/w/j/NP6/jP9v4//H+J8a/zPj/9f4/zP+58b/wnhb2VLGzzM+bXyX8d3G9xg/3/gFxvca32f8QuMXGd9v/GLjB4wfNP4Q45cYv9T4Q41fZvxy41cYv9L4VcavNn6N8YcZv9b4w41fZ/yQ8euN32D8RuOPMP5I448y/mjjjzH+WOOPM/54408w/kTjTzL+ZOMzxmeNzxmfN75gfNH4YeNHjB81fsz4Fxj/QuNfZPyLjX+J8S81fpPxLzP+5cafYvypxp9m/OnGn2H8K4w/0/hXGn+W8Wcbf47x5xp/nvHnG3+B8Rcaf5HxFxv/KuMvMf7Vxl9q/GXGv8b4y42/wvjXGn+l8a8z/vXGjxs/Yfyk8SXjy8ZXjN9s/FXGX238G4x/o/HXGH+t8dcZv8X4642/wfitxm8zfrvxNxp/k/E3G7/D+FuMv9X424y/3fg7jL/T+LuMrxq/0/hdxu82fo/xe42/2/h7jL/X+PuMf5Px9xv/gPEPGv+Q8Q8b/4jxjxq/z/jHjH/c+CeMf9L4p4x/2vhnjH+z8W8x/lnj32r824x/u/HvMP6dxr/L+OeMf7fx7zH+vca/z/j3G/8B4z9o/IeM/7DxHzH+o8Z/zPiPG/8J4z9p/KeM/yXjP238Lxv/GeM/a/znjP+88V8w/ovGf8n4XzH+y8Z/xfhfNf7XjP9143/D+K8a/5vG/z/jf8v43zb+d4z/XeN/z/jfN/4PjP+a8X9o/B8Z/8fGf934bxj/J8Z/0/g/Nf7PjP+W8X9u/F8Y/23j/9L4vzL+O8Z/1/jvGf/Xxn/f+B8Y/zfG/9D4vzX+74z/e+P/wfh/NP6fjP+R8T82/p+N/xfj/9X4fzP+343/ifH/Yfx/Gv9fxv+38f9j/E+N/5nx/2v8/xn/c+N/YbztWKSMn2d82vgu47uN7zF+vvELjO81vs/4hcYvMr7f+MXGDxg/aPwhxi8xfqnxhxq/zPjlxq8wfqXxq4xfbfwa4w8zfq3xhxu/zvgh49cbv8H4jcYfYfyRxh9l/NHGH2P8scYfZ/zxxp9g/InGn2T8ycZnjM8anzM+b3zB+KLxw8aPGD9q/JjxLzD+hca/yPgXG/8S419q5wmNf5nxLzf+FONPNf404083/gzjX2H8mca/0vizjD/b+HOMP9f484w/3/gLjL/Q+IuMv9j4Vxl/ifGvNv5S4y8z/jXGX278Fca/1vgrjX+d8a83ftz4CeMnjS8ZXza+Yvxm468y3p5Vb8+Bt2es2/PL7dng9txte6a1PS/ansVszzm2Zwjb83nt2bf2XFl7Zqs9D9WeNWrP8bRnZNrzJ+3ZjvbcRHsmYdV4e5aePafOngFnz1ezZ5fZc8HsmVv2PCt7VpQ9h8mecWTPD7Jn89hzb+yZMva8FnsWij1nxJ7hYc/HsGdP2HMd7JkJ9jwCu9e/3Uff7lFv93+3e6vbfcvtnuDvMN7uZW33ibZ7MNv9je3ewXZfXrvnrd1P1u7VavdBtXuM2v077d6Ydt9Ju6ej3S/R7kVo9/mze+jZ/ens3m92XzW7Z5ndD8zutWX3sbJ7RNn9l+zeRnbfILsnz1eMt3vJ2H1a7B4odn8Ru3eH3RfD7jlh93OweyXYfQjsN/72+3n7bbr97tt+U22/V7bfAtvvbO03rPb7UPvtpf2u0X4zaL/Hs9+62e/I7Dda9vsn+22R/W7HfhPzXePttxz2Own7DYLt99q183Zdul2nbddA23W8dl2rXedp1z3adYB2XZxdJ2bXTdl1RHZdjV1nYtdd2HUI9r28fU9t39va95j2vZ59z2Xf+9j3IPa9gJ0nt/PGdh7VzivaeTY772TnYey8hB2n23GrHcfZcY3t58870GUI7Dpl644J6i40JxZyf7hd12vXudp1n3YdpF0XaNfJ2XVjdh2VXVdk19nYdSd2HYZdl2Df09v31vY9rn2vad/z2fde9j2QfS9i3xPYeXM7j2znVe08o513GzJ+vfEbjLfjdjuOteM6O845Opjq+uF6cfh/2Q9etuqG33nfaRhvWfj/rUtuqh59nS29ulsV/v/+sgvecufCY36OYcfFYJ4V/n/7Bw7/9JofzHsNhp0dE3ZBTNhFMWGV8P/mW/9m0WXPfXUrhl0X/n/nyvF3/PDnf7UQw7bH5GFHTNjOiDACv+WIA/97w98kVKs/Vnc2hb8z7blsL+Bq449mxiZ7g0anzD/fC5gO8HOE3+UGf/96b+veXG3ED1i6/eHvFMiSnqEwrHhvCcMWBPV6bK9vCa97GZ6LckdO2nJbKvCfB3mz7pSqi7RzNZ0+NcQPGrCz+dHhfG50OJcrlTPjpeGRylh+JJOfKObHJieymXwxN1oaGc9nMuV8ebKQKQ2PFUvl8bFivjIxPjZM2KeJ2PnyhIEqjg+PTmQr48OVzERhZDQ/XhkZKY2XxsxcVzFTyk4OZydz2cro6HixOD5ZHMtmK+WxYmW0hn26E7kcqCvWneEGv2arXuEEP18k/DOd4OcmCP+VgK/4LVOG8M9yg1+T/9lu8Gv6c06IHziQzbnAPeVANue5wa/J5nw3+HnCvwDw0w7wL3SCn62V70Vu+BcI/2I3+BXCf1WIHwB2djSfy43k7TuK0VImWyhN5kZN6zJRyExmxidz5bFCdqxSyBXyk6XJCfM+YzxbyVTGJ8cqowfACfsSJ9zzNdm8uupCN/O1dutSQTaZ9lzN5l8WjT1t8RP2awTs3Hh+MjNWyYwXR8dHyubFVMZ0FkbKE6PlynBufMJ0DHKlbDZbLpg/uXKpMDZRGs5ODJu3WcUJk1ytTC+vuijTbK2Pc4Uy/vB4Zqw8PDxC+K9Vxp+YGB4ZN/Ik/CuV8fOTw+VKfqRmj1+njD9eLFQqxfw44b9eGb+YzZSLuZGabo4r449NZIrDo6M1/ZlQxjf92nxpbLzWl5rUls9EOTNZyo7RmKkU4lMa1lHaZeW0QzeWYukFQeOYMGDp9zGu2v3uFEsP+ZTgHo2/SHaV6lSug0IY2hgelhbuUToS1msVsa5UxHqdItbrFbHGFbEmFLGoXruta4VaO1pxgp8fJfzNTvAzZcK/ygV+tt53vBrwAz3+Nfw3AH7KAf4b3ci/hn+NG/nUxpXXhvgusK9zI5taH2yLG/zauOB6N/i1PuoNbvBrtmGrG/wxwt/mBr/WR93uBr/Wx7vRDX6tj3qTG/wS4d/sBD9bk88OwNeznbmabbvFCX6+hn+rG/yafbvNCX6hhn+7G/zavModbvBr9vlON/g1+3yXG/xa36fqBL9YGyPvdII/XNOfXW7wa3MUu93g1+Z097jBr+n/Xjf4Nf2/2w1+Tf/vcYNf65/c6wa/1j+5zw1+rX/yJjf4tfbxfjf4tf7DA27wa/2HB93g1+znQ27wa/bzYSf4I7X+wyNu8Gv281E3+DX7uc8Nfs1+PuYGv2Y/H3eDX7OfT7jBr9m3J93g1+zbU27wa/btaTf4NfvzTIgfTB87z2/YdW52PdKPlhzAk9ZxKfblMrRGqquelYb5fHvdDfcVx2mlJPP5mH4f4+piPh/TIz5cPjifb8N6BK6DQhgvwx4hnR4hnUEhjPf92sF6RBHrbkWshxSxNPP4gCLWfYpYDypi3aOItUMRS1P2mnXo0Q7F2qmIpakTmrLX1K89iliadVtTJ3YrYmna6McVsTq1faQ+tdu+VWa4X0ibHIXNh7SxT8Vdmv1G3rav+u9L6rg8Hjn7zc5AeF0pb5+86uLxzZvLpbO3bN4WxDxm3alV+X6niTDFwhYkyEMQNBfv/KV1XB6P88FinM/CuoVnUwKWtKSGqzTKvCuCA2JQWfHu8Kbwd6Ytl80nyQemP1NDCclUSEMJks98N/LJpRg+8pkvyIfrMC+7VFBfgtINWBh/PuQR4+M1PY/3/iz8PxhMrUe0BD4lhKWFeyRfy/2PWd6wbLieuimHQjapnlL6fYHLelPXU0kvpCatN5hazprLjpKUq2TbeoUwwqJlgKinGH8B5BHj4zU9j/d+GP4fDKbqNNfTXiE/eA/19LvhdW9EfjaFvzNtuZERqZ3i9QDlpLmMOmk9oPT7Apd6V68HUjlJ9oRk1ydwHRTC+NRPn5BOn5DOoBDGu6PtYD2kiLVbEWuvItajHYp1nyLWg4pY9yhi7VDEul8RS1PvO1Fece1gq1jWaerqPkWsexWxNHVVM487FbE6tW4/pYh1iyIWvULk/UzCD4J6X4m395vC35m23IGxG6ZH+cB7mH4f46rLp95XkuQq9WlJPgvdyKfGZ6HAZ6EgHyrLRUIYYdFcC44ZMP5CyCPGx2t6Hu9lwgIbZJjW8THDIiE/eA/HDMelGvOGZcP11GU5YHrEG+9h+n2By3qTidULqf73BlPLWVE+mSTlinypLPuFMMKi7YdQTzH+Isgjxsdreh7vvYTpKeo019N+IT94D/V0lOkplg3XUyflkK0k1lNKvy9wWW/qeirpxUJBjr3B1HJWlE8mSbkiXyrLxUIYYdHUP+opxu+HPGJ8vKbn8d7ZTE9Rp/mnU4uF/OA91NPTQ9zeiPxsCn9n2nLFglSWevgj2X4hn7yeoaz19DqfuJ5R+n3BVL1wUc8GGJ8oPSDZDQpcB4UwriODQjqDQjqDQhgf17SDtVcRa4ci1m5FrPsVsXYqYt2niPWAIpamTuxRxKoqYj2qhCXZ53Z4PaLEy7p9iliadfspRSxNW6hZHx9UxNIsx6cVsTR1QlP2WnU7UM6jpk48pIjVqXZCk9fB0Geaa9NmT/aa9fFuRSzNPD7Robw0+xOaeeTvB3BsmQr/9wZT657iOLucYulRPvAept/HuOryqY+zJbkOCHIl2R0icB0Uwvg4+xAhnUOEdAaFMN5mtIO1VxFrhyKWZh7vU8R6UBFrnyKWpuyfUsSaK8fWsJ5WxNLUiT2KWA8pYmnar0cVsTRlr6mrmrLvVPu1RxFLU78eUMTSLEdN/dKsQ5r69Ygi1k5FLM08auqqZn3UzKNmf6JTy7FT+3JPKGJ1aj9Hs4851594ftQhTTuhyUtLv+w1n1dth9djSrys05S9Zh+A2lq+3o3wrXM7h5ZLvMaWz6E5WYPVZA5NWlvXG0zVQ0X5ZJOUM/KlslwihBFW+Flzw5owjH8I5BHj4zU9j/c2hUIZZJjW8TVhS4T84D2Sr10T9oLwR29EfjaFvzPtuVE+H0ppYNooJ0W9S3TEAqbfF7jUu3o9kMpJsi8ku6UC18Fgqu5wfVgqpLNUSGcOq7OwzlXCirNhFG5dr/Cctr3F9CgfeA/T7wuc2oVsnFwle0nyOdSNfGprlA8V+BwqyIfKcpkQRljLw9/YHmH8QyGPGB+v6Xm8V2Lt0TKIy+vAMiE/eA/boyvnNeYNy4brqZtySP7NB6XfF7isN3U9lfRCqv+9wdRyVpRPJkm5Il8qy+VCGGGtCH+jnmL8ZZBHjI/X9Dze28r0FHWa6+lyIT94D/X0mvDHQBBdP5PUZ8SV7DaXIT7H64OT8s6WM0nrA6XfF7isn/X6sCyhXEk+y53Ip1RJoj/Il8pyhRBGWCvD31gfMP5yyCPGx2t6Hu/tZvUB6w6vDyuE/OA9rA93MLuNZcP11Ek5ZDKVpHpK6fcFLu1kXU8lvZDav95gajkr8iknKVfkS2W5UggjrFXhb9RTjL8C8ojx8Zqex3uPMj1Fnebf6q0U8oP3UE/vZ+Ndnp9N4e9MW66clcpSD3880yvIWg8/N9YrlJce/sQo4a92gz9M+Guc4I/WyvcwJ/jFmnzWusEvEf7hbvSnxn+dE/x8nvCHnOCXa/zXO8Ev1PA3OMGfqNXfjU7wx2r6f4Qb+dTK90gn+JUi4R/lRj41/ke74V+z/8cCvuZcBOEf7wQ/kyd5HBfUXVrIE6VPfZFjIH4q4j9h8TBKq49huer3SXlD/nzcdxzwQRlEYR3XIlavEOaiTI+NyTem3x/DlefDOr4HznRlYt0eRay7FLEeUcKS+rbt8LpVkdcKJV5S/7cdrFWKWGklLOv4kYDt8FqtxMter+lQrMMUsdYqYh2uiLVOEWtIEWu9EpZ1/KimdnhtUOT1sCKvjUq87PURilhabYe9PlIR6yhFrKOVsKzjc6edgkXvkN3OdxXG3M535cfdzncVSm7nu4p5t/NdhRG3812FSeqrU3tIaaBuYfumN64oJP4WlNLvY1x1+dTHd4czPlw+fP3OOoHroBDG6+g6IZ11QjqDQhhfy9sO1uOKWDsVse5XxLpPEWuPItYORawHFLH2KmI92qFYmrp6jyKWluyldrtTdFWzPu5TxOrU+viYIpZmHepU2d+riKVpJzTbWk0brSl7TXl1qn5p9k00y1FT9geDnXhKCcte8zFsO7zuUOS1SomXJpZ1t1X1eK1W5KUle+uqiliaOsHn0tvBSithWaelE9bdpYh1uyKWpn5p8tLS1U62hYsUeWnqqmY5avHqZHlp6iqfW+2Uuq1pv55WxNLsf92tiKU5p7BXEUtzrLBHEYv69zSPfRiEpcL/bt8BZKb9DuAwN3xi3wEcJshVWg+ryKeUpJyRL5XlkBBGWOvD37i2H+OvgzxifLym5/Heu8KCG2SY1vG1/UNCfvAeydeu7X823Zg3LBuup27KIfkZsJR+X+C03mTj9OJwQY6SXtCzg0IY79MPCekMCelIZc/XvrWD9ZAi1m5FrL2KWI92KNZ9ilgPKmLdo4i1QxHrYUUszTqkWY6PK2LtVMTap4ilWbc19UuzDmna1YNB9g8oYmnaaLKF0ndUiv2PjPSdkyJ+7ZuD9TGywPT5WhwKl/4TFg+jtPoYlnLesnF5ixu7rQc+Q3AdhbW+RSzp2zgXZToUROcb03f7LWAx5/ZbwOKw228BCxXS+Y0gzxST3ZFOynI08V4qlH4f4+qqTh3J+HD58PHQUQLXQSGMr907SkjnKCGdQSGMt9vtYD2uiLVTEet+Raz7FLH2KGLtUMR6WBHrEUUsTdl3qq7uU8Taq4ilqV+aNuchRayDQfYPKGJp5vHRDsXSrNv3KGJpyd5e83W5naKrndoH0MSaa7fn2m2XdnWu3Z5rt+fa7edfu22dprw6VVcfU8TSlJemzdGU/b2KWJp1SLPd7lQb3an9Cc08avZ9NctRU/YHg514SgkrFUxdn9MO1pAiltY8ub1er4RlHV973A6vRYq87lDiZV1VEesuJSx7vSHQw3q+y95e828n2sFapYi1WgnLOk15HaHES1NXrdOsQ52q952ax+e7LdTkZd1c2+F/22HdnUpY9lpzzYOWvOz1GkVetyvy0mprrdNsHzXl1Ylth3VPK2JpjvnuVsTSfKezVxFLc35ijyIW/74N14alwv/SfvE2nU3h70x7rpRi6VE+8B6m38e4KvPJxsn1SEGu0n73inwmUwwf+RwtyIfK8lghjLBon0z8vg3jHw15xPh4Tc/jvV90Hfg/yDCt49+3SXul4z2Sb4/x/9PVmDcsG66nbsohl/j7Nkq/L3Bab7JxeiHVf0kv6FmpvHi7n7S8JKz7FLEeVcTarYj1kCLW44pYexWxHulQXnsUsXYoYj2liHWLItbTilia8npQEUuzPu5TxNLUe01bqFmOdytiadocTZ14QBFLU/Y7O5TXw4pYmjqh2TfRbLc1y7FT7ZemfmnWx0610ZpYmvp1jyIWyZ7GKzi+SYX/e9lzqUB1rFdIsfQoH3gP0+9jXHX51Md6klyPFuTayvlixJWuMQzTmelzvKx7SBFrtyLWXkWsRzsU6z5FrAcVse5RxNqhiKV1NpJ1OxWxNOvjPkUsTf3SlNf9ilia+qVZhzTtqqZOaNrVTq3bmvVRsw49roilWR8PBv16QBFLsw9Abe1AGIb9bdyPBMMwnbg+Pz5P8fqF51Lh/17GLxVo9rHHEu/XQen3CTJx0ec/LqFcSXbHC1wHhTC+duV4IZ3jhXQGhTDeNrWD9bgi1k5FrPsVse5TxNqjiLVDEethRaxHFLE0Zd+purpPEWuvIpamfmnanIcUsQ4G2T+giKWZx0c7FEuzbt+jiKUle3vN9+voFF3t1D6AJlanttuastfsA2jaaM3+RKfq6ly7PXtt2lyfvDWsuT757OnXXL9w9vSrE/uF1mnKq1N19TFFLE15adocTdnfq4ilWYc0245OtdGd2qZp5lGz76tZjpqyPxjsxFNKWKlg6hqndnjdpshrSImXvV6kiKX5fkhTXmsUeVWVeFl3lxKWvd4Q6GFp6YR1/NvmTpC9Zt3Wro9adcher1fCsk6zPh4M+sX3G2oHa5Ui1molLOs05XWEEi9NW2idpo3uVL3v1Dw+39taTV7WzfVN/G87rLtTCUuzP2GdlrzstWaf/HZFXlptrXWa7aOmvDqx7bDuaUUszTmFuxWxNN9b7VXE0pz/2qOIxfcbWgRhqfA/rfNFW2fT2RT+zrTnEu/jQun3BVPbKkU+tXW+y4Opcl0kyJXks8INn4kUw0c+KwT5UFmuFMIIi+ww7jeE8VdAHrndXgU8utm9v+g58H+QYVp3TrWRw0ohP3iP5Gsh/6SnMW9YNlxP3ZRDNvG+WJR+X+C03mTj9GK5IEdJL+jZQSGMz+EkLS+p7PnahHawHlLE2q2ItVcR69EOxbpPEetBRax7FLF2KGI9rIilWYc0y/FxRaydilj7FLE067amfmny0ixHTV6adkJTJzTL8QFFLE17T3aV+la8T7Ap/J1pyxWL1DfBvkwqaEyb90100s6Oplh6QSD36yj9PsZVl0+9XyeVG8qH9+tWCVwHhTBehquEdFYJ6QwKYbxutoP1JkUsTV4PKWHZ6/mBDpZ2HncoYj2giPWoItY9ilia8tqniPWkItbDilh7FbE0ZX+fItYeRSzNPD6liHWLIhbNR/O+hXWbwv+mOcyPDudzo8O5XKmcGS8Nj1TG8iOZ/EQxPzY5kc3ki7nR0sh4PpMp58uThUxpeKxYKo+PFfOVifGxEbd9h+JYbyC3rzr42Szhr3aDnyP8NW7w84Q/5Aa/QPjr3eAXCX+DG/xht3toZGv6f7wb/FHCP8ENfq1+negGf5zwT3KDXyL8k93glwk/4wa/QvhZJ/i5DOHn3ODX7GfeDX7Nfhbc4NfsZ9ENfs1+DrvBr9nPETf4Nfs56ga/Zj/H3ODX7OcL3ODX7OcL3eDX7OeL3ODX7OeL3eDX7OdL3ODX7OdLneDna/Zzkxv8mv18mRv8mv18uRv8mv08xQ1+zf6c6ga/Zn9Oc4Nfsw+nu8Gv2Ycz3OBPEP4r3OBPEv6ZbvBr9u2VbvBr9u0sN/g1+3a2E/xCzf6c4wa/Zn/OdYNfsz/nucGv9d/Od4Nf679d4Aa/Zj8vdINfs58XucGv9d8udoNfs8+vcoNfs8+XuMGv2edXu8Gv2edL3eDX7PNlbvBr9vk1bvBr9vlyJ/jFWv/zCjf4Nfv/Wjf4Nft/pRv8mv1/nRv8mv1/vRv8mv0fd4Nfs/8TbvBr9n/SDX7N/peCuqtj58sT5lVFcXx4dCJbGR+uZCYKI6P58crISGm8NFYojxQzpezkcHYyl62Mjo4Xi+OTxbFstlIeK1ZGa9zLInY7rv5eoeJCLtlKzS5sBvyUGv/RGv5VTvAztXp1tRP5lGp2+Q1C2eYKpeGJ8cxIZWR8fLRiGtFcyfwbNlpTKebGx/KT40aLShPl8Yn85FhuspQr5cujxtaU82PD5XK9zXqjtt5kMzW5X+NE7vX3Cdeqy310/1+7jPyZcBEG7aF+HaTVzfK1JfxN6+Ste2O1Huc6CMf4X+s78N+m99YwvX7ITwDpWEf57lLP9365jqVYekEgr3Gi9PsYV10+9TVOXYwPlw9f49QtcB1kYdbxd97dQjrdQjoS1tOKWDsUsR5WxNqriPWgItYeRaz7FLE083iPIlan6tdORaxHFLH2KWJp6pemvO5XxNLUL8069JAilqZOaNpVWgvZG0xtC/Xa5uHaWuxyMNVRGI4bUixsM8Q/rVqPx12a/cY8LTB+xdI6Lo/H+WC/qQL4UX0G60iOPRCu2cch/F43+HmS/YKgUaY8T70RsqJw6T9h8TBKqy+YKncX/UMpb8if15cFwAdlEIW1oEWsXiHMRZn2xOQb0++P4Srlg49vJHsk9b8pfm8ML4w/IKRNz5IM+yBMUYa5OBliXaT0FwHPUnnixs1nb0ETVnse5UByW8ninVGty4Hr4IIIrID9XsnupQEPndsx4+y2A5SnVtsBlG2FhU3X7lnHbQOXuXW2rH/G5hbSQp64DkXNLaQhvKGuLqin94swvYWQZn9MmosZb4xv3RnVxvgDkLe0EKefcaT43QvqVI8Oy0+SHfHpZc8/n3SZ8tSqLmM5cm41OQf1csSyjSqXQ6Bcjlta58zTWxxE54N+l4T0iPshLK51VMZL4L7iHFfi8wIp/T7GVbkdqvVhljA+XD5kW2w7tDC8vmbLeOmU8eu33XhNeR4T5SBcI/wgg6M4GBfdIFAKIuLxYrfuwurU57gjUXYzzkeB6VoTXg8EU6s+34YMOaSFe9w8LxL4S9OvV1cbw7A7dA4L64kJWxAT1ivki8L64Lk3sucWCpiWwzUL6ngo2yCQ1YvMtSTnKF2KwjqdYeHzSxjW0iZYFzAsfH4pwzq0CdZFDAufP5RhLWuCdR3DwueXMazlTbC2MCx8nm/Js6IJ1vUMC5/nR32tbIJ1A8PC5/nWqquaYG1lWPg83+5tdROsbQwLn+dbq65pgrWdYeHzfLu3w5pg3ciw8PnDGNbaJlg3MSx8fi3DOrwJ1maGhc/Ts/0CFm+S8ehfxSYw8dZelH4f4+qqSV4XTJUryoe/dhoSuA4KYdxuDQnpDAnpSFiHKmItU8Raroi1QhFrpSLWKkWs1YpYaxSxDlPE4narWXt9cfXA/7j2mp5D3cV4aYgjtdGIEdUfSAfJ+wUXMs5SmlIf85pqYxhOwfG+KU4XDbIwnEpbwsKwj8ntPk6zLWVhCyGM8oN9zG6Wny3hfbfD9UwG+4JRsuLjFul/ECSbzpGm5PpZuhrpoLx4GzOomA7v12M6hyimg1inVRvTWSqkQ3rD6+Cm8HemPVdJkg9Mvy+Q7comHT7Z2duuspB4OmSmt6uUxhOoK/yVgzRmkLa3xOmTzeXtZhL/5bdcPL55PkRF08npLGbxDmW/l0XQ2sTi8R2sqFvCeSAWOs4jbnpGSl8yi3TdLdy3Thpu8a5sqzt94POrYtJZ3mY6y4V03O6aUX+ze5gb/NpbQGmIi3mi9PkOYBQu/ScsHkZp9QVTy8iFGZDyFlfO2PVNMhWwpkUstzuh1Mt0dUy+Mf3+GK5SPvBtEtq5JWHf0Hbrnl3QiC3ZCrerS/LDSfWR0p+plahJ34RLXXV6dpCFWcdPm5DeSvcI6UhYDyliPaaI9aAi1h5FrB2KWJp51CxHzTzuVsTSzOMDilgPK2Ldr4i1VxFrnyLWfYpYmjqhWR8165CmTmjK6x5FrEcVsTRlf7cilqbsH1HE0pSXpi3cqYilKa9OtYWa8tK0OQdDn0lTJzTbbS3Z22u+03Sn6L2m7O9VxNLUe808atoJzT6ApryeUsRK8rWmNK6n+NIKd2le6mBZ4V5k8c6o1uXAbU7SFe5Fdi8dyCvcLfbP2NfTa9iz1rmdj83nUiw9nseApd/HuCqXf23OSlq2JM17kuzWClwHhTB+WrS0pGmtkM6gEMbb7XawHlDEelgR635FrL2KWPsUse5TxNLUiQcVsXYoYmnqhKa87lHE0pTX3YpYmvJ6TBFLU1f3KGIdDOX4iCKWprw026Gdilia8urUdkhTXpr2XlO/NG2OZn3U1AnNPpOW7O01n4PpFL3XlP29iliaeq+ZR0070an9r6cUsWgORvrEhS+tl8awh8Wkg88flgBLGg9TfOkzkLi5HvwshZ51e8JRfa5HKg/8bIfSn85cD8kty+LxuR60bYdHYAXsd5bdi5rr4euW9oYTWW5P2JKXmvP1inGfJkqfTOI9rr/4/JIIrKgdAQ4NZFndH8rKlvuJSxsxmy23pTKW8srXE66KSB/LvpvFfQS4ZZZGp+VCrlI6i9pMZ5GQTr/wXCriP6XD7/F0JM6UDq4hJP2wc6Vv6a0/w8srLTy7vVoPx/hfhN0r3xZiSp9RRulvCtLDddSnVxvjk23uCeoywThc3yn+c6BTRzN9P5TlGfMpcSZM3JUCOdMn4pzD+5l9crQWWLRPlJb0KVJvIMsjCOQy4XrXK8hBSufINtM5UkinX3iu3XokcY57lzDddBCL6qRb3Wh9VxMuZ9ydma87xp2V+Q5iV0MYvuPiLs1+oyxs3c0n2A3F7bu0mZPhahaGMuR1HJ0kQ5JFUhkOBFNlyOv2EiEfUr3n32u0Wu+Xx3DAdAZYGP/UEMOwfvYxfmmBXzqGX5+QjttvA1rXweUsDHVwBQtDHVzJwlAHuV6/AcL4p5dvhLAeFoY7g/Nd6q6FsD4Whrtwt1ofqFxsepuVdgvDfs5mFrZAwHX7aWM+n6RdwvT7GFddPvV30FL9l3ZVJNmtELgOsjDrbq/W4/GwtHBvXgzWfYpYjypi7VbEekgR63FFrL2KWI90KK89ilg7FLGeUsS6RRHraUUsTXk9qIilWR/3KWJp6r2mLdQsx7sVsTTLUdN+acrrYUWsnYpYmvLSrEOa/QlNed2viDVnV2fPrmrJ3l7zd9Cdoveasr9XEUtT7zXzqGkn7lHE6tT+6q2KWNRf5fNb9hrfp9AcAG5Fp/kueDb3HcE88X1HUFapiP+ExcP4viMr3OQtdt+ROD3AOT++xWA7+44Q1kztO7IyJt+Yfn8MVykfhyrKJMnpFNLcUqtlK21VS886rmO19RyHxsgJ02/n250ci0fvVucFU8tuZQRWwH7n2L2o9RzSnkT4rnqiT+aM76ql7X/5aQhvhnfV5fBaei8wGDSGoa7RNnZuT3dpfZ4/zcJwnj9qL68gkOfIKU+tnkKA33chN8SMOoWgB8Ix/ta+Opcjh2TMFGDid260XoXi07tJXEOAcTgHin8TcOBrCChOV0S+FkRgPgC6eEufjBkImFK++li+OIdexoHi3wH5Omaojo9x6Dfa12urjdwWCmkFEfcQG5/lYXHpNnvWXuMJFTyM6wqXFz4fJVOuKxT/7hhd6RE4YH55uXIOPE5fBIc3CRxwy8PJLdffEp4YETDHD75Js9+8KHkR9Ag4UY7w7TMP9Mk49DtO/XAZygIhjQURHPFZKx4SX6l8TXl7OUJA84QMSInNC2QnHRFBttTxiWGJv03lJ7f1uOETe3Kb9A23tE0xPSu9k+frm5Kmsyior6Pbtn3L1ihd4GXPf3dHpJ8Sng/YsynhXhA0fucs9U94nls9RbJX4C+l09dmOn0J01naZjpLE6azvM10lgvpcCypv2pduVoPx/gfADt+/JCMOS8Ck45MofjSGEJa20LxpTmQQ4U8SnsbrAiap42y5O3eyha5NpuD4GuHpLFsUq6nzzDX7ha59glpY9tvGrerbypvPXfL9jKaGE4jYNe83ec7nfPmbEEE1UUsHl8GzaeHutnvZez3QoGf5IgHOs4lHTR3VEVJVp+DKnrSUGNakgnBKkpqz4e/+Kw0/JWW6ePUYtTS6Sjzs7namDeK/5UY8yN9PhO3M7f0SYr0qY90as5aFoZywmX1+7GrUzFrQzQIU+zGTFr5ZIfqPLh8uqvJZWEdl510sg9+XsO3+sVPj9awMFwuxz+JaqZXXF9x2Rs9i58WUHntgHi8abwFfqdZfEyT4t8K6UhDInq2m8X/hjAkGhQ4EZ9e9ryuzoxMkAxvC6Y6Crs9aMw7ht0B8U+t1uNxJ03vUJ6sLOa3ML2D5ci5ESbaGCzbqHL5LpQLP2QS07sliM4H/U4L6XFZUrh1VMZ3MIxN4e9MW644nmLpBYE83KL0+4KpsnUx3LqD8eHykboNMYdM3gbXCH8Zg6M4GBfdZUApiIgnFftK4TnuSJTdjPPPYBbuH9iMMFZ9fjYuckgL9/jooEvgL6XT02Y6PUI6fNW0dfwwyy3B1LxS2PXwHD948gYI44dZbg2m5ovCtsVgbo/BvDEm7KaYsJuFMMvpmkV1jtwcS1WDmhqp7KLqQRTW6QwLn7+DYd3ZBIsfkInP38mw7mqCdRHDwufvYljVJlj8gEx8vsqwdjbB4gdk4vM7GdauJlj8gEx8fhfD2t0Eix+Qic/vZlh7mmDxAzLx+T0Ma28TrG0MC5/fy7DuboK1nWHh83czrHuaYPEDMvH5exjWvU2w+AGZ+Py9DOu+JlibGRY+fx/DelMTrIsZFj7/JoZ1fxMsfpgcPn8/w3ogBste82EWPv8Aw3qwCdZqhoXP07P9AlYq/E/dr4fgvl53J5v4KxhKv49x1eVT7349FEyVK8qHz3Y/LHAdFMKwLcIwTOdhIR0J6zZFrDsUse5UxLpLEauqiLVTEWuXItZuRaw9ilh7FbHuVsS6RxHrXkWs+xSx3qSIdb8iFm/L4vr19pp/xSz16+k5tGd8eijNnsH4iBE1bkgD5zuacB5inKc7frDX6xnWdMcP9noDw5ru+MFeH8ewpjt+sNfHMyx8ntvcXU2wTmBY+Hwr4wd7fSLDamf8cHO1Eaud8cPlDGu64wd7fVLQiDXd8YO9PplhTXf8YK8zDGu64wd7nWVY0x0/2Oscw5ru+MFe5xlWO+OHAsOKGz881ASryLDw+YcY1sNNsIYZFj7/MMN6pAnWCMPC5x9hWI82wRplWPj8owxrXxOsMYaFz+9jWI81wXoBw8LnH2NYjzfBeiHDwucfZ1hPxGBZd2a1EQuff4JhPdkE6xSGhc8/ybCeCuLz+KKgEQuff4phPd0E68UMC59/mmE90wTrJQwLn3+GYb25CdZLGRY+/2aG9ZYmWJsYFj7/Fob1bBOslzEsfP5ZhvXWJlgvZ1j4/FsZ1ttisKy7pNqIhc+/jWG9vQnWKxgWPv92hvWOID6PpwSNWPj8OxjWO5tgncqw8Pl3Mqx3xWBZV6k2YuHz72JYzzXhdRrjhc8/x7De3QTrdIaFz7+bYb2nCdYZDAuffw/Dem8TrFcwLHz+vQzrfU2wzmRY+Pz7GNb7m2C9kmHh8+9nWB9ognUWw8LnP8CwPhiDZV252oiFz3+QYX2oCa+zGS98/kMM68NNsM5hWPj8hxnWR5pgncuw8PmPMKyPNsE6j2Hh8x9lWB9rgnU+w8LnP8awPt4E6wKGhc9/nGF9ognWhQwLn/8Ew/pkE6yLGBY+/0mG9akmWBczLHz+Uwzrl5pgvYph4fO/xLA+3QTrEoaFz3+aYf1yE6xXMyx8/pcZ1meaYF3KsPD5zzCszzbBuoxh4fOfZVifa4L1GoaFz3+OYX2+CdblDAuf/zzD+kITrCsYFj7/BYb1xSZYr2VY+PwXGdaXmmBdybDw+S8xrF9pgvU6hoXP07P9AlYq/E/vn74M9/Xe9xSyKZYe5QPvYfp9jKsun/r7py8HU+WK8uHvn74icB0Uwvic41eEdL4ipCNh3amIdZciVlURa6ci1i5FrN2KWHsUsfYqYt2tiHWPIta9ilj3KWK9SRHrfkWsBxSxHlLEelgR6xFFrEcVsfYpYj2miPW4ItYTilhPKmI9pYj1tCLWM4pYb1bEeosi1rOKWG9VxHqbItbbFbHeoYj1TkWsdyliPaeI9W5FrPcoYr1XEet9iljvV8T6gCLWBxWxPqSI9WFFrI8oYn1UEetjilgfV8T6hCLWJxWxPqWI9UuKWJ9WxPplRazPKGJ9VhHrc4pYn1fE+oIi1hcVsficY7N1cq8Pr+PWydFzOO/EPzFMs2cwPmJErcNLA+dm6/HGGed21uNNMKx21uNNMix8fifD2tUEayXDwufpWek7uGuqjWFb4Dn+DcP1EMa/rbsBwm5jYfgdHJ+X3gZhd7Cw7RB2Jwu7EcLuYmE3QViVhd0MYSSjnqD+HRx9H0ky2hLe72V5Ix3cFP7OtOmkk8u4HLHcUhH/g2DqHLt13AbgCTIpls5tiukg1qnVA/9JR1F/+XYZt7N0+D2eDj5/ewQWnnL3xmo9zvUQjvFvC8teOilSWpu8Be6dUQ0i80rPkk5xu7Yp/J1pz2UJv+oGPx9nfzFPlL706X4r+oVp9QWB2K5sUpJdXN6QP9dDbA+SrBu/q0WsXiHMRZneGZNvyeZKXKV8RNVNTCdu19pqDC+MH9c+kwx3QpiiDHNxMqxCmpT+dHatJbmtYfHI7swLgsi+DscK2G9+0mM6kHetlWxbbwRPSreZHcfnKV7cFhZJ7IaUjsSZ0sH9BaidsH2EZ9i38qR3uOUHftfCTwCm+H+xpI75bIgpfXcTVVdSkB7uTUBlz/n1BHWZYJzrI/i9E9o9voPn9UKeV8VwJkzc/wE58xNjKf57Wb/LURsp9rsorQHGl5cPz4tUJlzvbhXkECVb67Cfgv0YjP/hFvspqN+8n4Kc6FlprMflIKUT107emjCdvjbT6RPSabcfIqUjceZjKuvQnnyO2RPSO6xb+Cx9B9/N4v822JMvxtgTvj6F9524jeX2hNKLsidcPyn+r8bYE6lvfmE1mjNhoj1BztyeUPzfZPbEUf9JtCeUltReLgxkeQRBsvZyoSAH1+3lQpbOnYrpIBbVFakvx+1Pq31rfJ73ZaPq6zcWyWlK9RV1t5vFfxTq65+y+or6TjKX9Ia3UXcK6fI6EwRTx2fWxdmyOyOwkrZRFP87MW1U3FjDurixdNycI8bDOHHzf+mYNFBv8T71jbHtvJ7FvYvFvTMmbtS40V6Xw2u3Y/vRLNWFncFUR2G7BM4Uthviv6paj8ddmv3GPFldOWOojsvjcT4op10RmJK94LvqU57nCbhVhos2gMuL9tni9f8XYV2w9f8ni2Q8rifWXRriuR2/juZ4+aLj5cvlw51UvsTblu9NQ3VcHo+nWYWw3SwMbTbf2w1tPWFY2feGiXZqXZpOfWlFnlJ9keTJ3xFIbSfKs5thnNBfj7Owv5ETxeHthXVUf6jOkvy6hOet430/ij8Qpmnl82tDcvpx9S0IZLuAcuB7Mu4KZC5SninusUwfsY7p6WOhpo97GGdMe6+jtFMsvSCQ53kp/X6BD/HuE8K62uBazI6M5IYLpWJlYni0WCynGD5x5ff4HOXdQvwBIT7J+h4nss6XpC2h7wa5WtcFYXtZWDeEEUdbh7461Mj/bkf8k8gf0x8U4p9ercdrpSwHhXT4mKMdrDunibUkaKwDUluIfRveFlYhDPcBfUWEXU5i63aG19zuYz65HTyN2Tps/xR1qCD1R7mt2+Mo7aS2jtLvD6LLtk8Ia8fWlYqFbKEyVpwoVfLl0kglFUxtE9LCPW7rJL1dLMR3bCsykq3j9qwLwvawMLR1xFGydW7axXwmifwx/UEhPrd1SctyUEiH27p2sO6cJhbZOuwH8X4q2jreT60K+UFbx8dlZzGb5Gbre3mOkNtU5GsdjqGrICcuX46D97DfjM/wORuKfxH028/vl/lRHs4R+ElrijBfr+qPjlcV4tmhMvWjNpe3X3TV+NZy6aLy5Nby9nQg0+NZ5Nnnw6mAxbOui927kf3m0zdbGA41wV1Bc4cqgVhS0SE2b3ovgyHPHw4duO5lfCmtTeH/TJtOGjryptbNa7xc4mEFpd8XTFU5F8tHpKlNlA9vHt28lshl7KGtfOrbuquqU2XDeZC+SNvhpyL+U375Pd5MoC5yvYkzgVEm6yYwWZv76/G5DUiyZCvJq3i8h/E3szB8dZaKwefTINdCPaYDSqWuDuXD7Uk/uax00g/qE3ajovRfOr6B4sctJbOOXjXELS2SdAt1iXREKmd6Rnod3s+4tvrqv19Ix3Wd6mf5QT3mXbxWXz1K+tvsFdquiDoZ9QotC+EYfxe8QtvLyhOfRznvz1e1HjZDdSbXap2RyiGuzjRbsk8ylF6xvrraGCbVGUmuXHe2CBykdk7SnS0R6VhXqk4/Hf48xUvST0E56OlCNnE/hdKfqX7K9QnlSvK53Y18MklskWQ/pdepvE1BGyMNf6TXfdge8eHiu0KjErd0Ia6OSq/g9y8JZMMi1/2tuPow3XQQi46H6Q5/05jlw9BX+2B/9PN0JEwPPCMte+D5QR3CNuhjrA3C1zFxr//5GOtMaIM+Oc0+hcvlhM3aEX7UDj4f1d9dKPCy19eE11TGNBXzJSjjL0QM963D8vkKKx+0hVL5UNrSNAI9i7ic428Ax1+LqXvI8Tcj4tnra4Op8bgtCgK5v8PLsApYUny+/IDi/07CcQPpg9s+UFYcN2D58z5Q0vaIywnjIwbZoEEWn8vQOtKL74FefJ3Vb8mOTrcOR/VXo2y/4+nJsaR9FEq/L3DZZ6r3UaSjAON04i6Bf6kaHb8q4EvlZudSuJ0fBCxKFz9Jq7J7vI2K69NYh7bnB/0yBuZP6hfRNviIkcT2t6rPUp46od4k0Wspnbg+062K6WB95p97VSFMsW4VSPY7gafUR8b0rd8FeUgzDCk+n9fk+LtYfHq+K5CX81J94O3e0eG7R6vj/8Xa3rg8WkfHPqYETmkhDl86ujuopy1xvohxpvj/C201Xx4vjV12Aib/JKC2xBAw+cnl+Co8iR2VXtfhKzniIy3T3sOew9eCvMwlbP5qXsLZzXB4PufBvUEBW3o1bf2m8HemTUd49Oq2C9K4W+DTzeL3L27kdS+TaZzMrL9HSBe3WRxk6d7D0rU69PWhRkzihuMBLHdeJryfynlexcIp/lKoz4eE19JSFmwfVy2W08bxw94YrnsErlhndlQbwyn+CpDXN4dkrsgHuc7e/KTcN2+Y96g2ykeyH9KnFq3aD2npQJWFYVvM7a80NxjXxmA5SPH5Mk2KfySUM42t4uY1LT61S9K8BZ8DuBXyENdONXu9fvxiGTfq87LN1cb8UvwXwDzHSYvltK3DOphpMe3TI9L+t0PqmHkmQ2nuQ7P/J5UVLt3g5RI3rzcoPM8/mXDxGRWmKbXPvK/f6mdU+HzUlgAUbp3j/mzisSul3yfIxMXYtRpMlWvcO52dQvzbY+LvEuJL5YZj12p4D/tElC6OXXexe3G2uJldeGWLdgHnjjH+b4JdOIfZBeTFP5NDm7E0kLkEQXwZDQrP8+2QXI0Ll7L83B6Tn1bf5+LzM/Up6VKWTpTeXMH0ZrqfSr8P9OZ1MXrD331K77qlMkgyBx9XBtcnTOeONtNJ+pnp81mntijp1BOgU1tj+nnPdznfpZiONNfD2y0uXwyjdPi9uH5SleUnSm92LpbTTKo3FP8O0Js9CfRGKoOorZYw3Zla+zNT9jAOS+p7U3ypbxvXB6sK8aX5aOnzTtJtt5+3JF9PQun3Ma66fOr9XWmOYKcgu0VBfe5jvLwtmxs9tTy59Zbrt/PCIMDBoFHIuxggxQ/Yb/6cJdXF4twupGEd7keCijTInq+y+xw/CadmcZuFS5VwZ0Q+gyBZJcTnW91bkX8HS/GfhUmUJPtBoPKcUQ0i88r3g7gzgntayENfxHNc9tIeGMRJyjPFfy4mz3c1yfPpLM9R+7rhbx4vLeRhQSAvqojbs+bQoJF7q/qEz89UZ+VQlk5U4/6xiMnjqAWqV0M4xn8DNO6fZI271Pl2nf+ovZ8wX1dDnKg9SLoETOv4hygU/wth3h1P/IjfVFFa0kQpLsj/0uLmsokrc4p/BZT5VxKUeVz9kfY0i7MVXndksuVMEh3H9L3vyHwn1SjkpB0Z/lxcR4bHjarU7XZkJE5RcVvtyOAIYCeL2+qKEXye4rldTZWbsqIZ3+pgZYraUBFXWMSN4PjqK47PGwD8KFSSHV9hQfG/AZ2Ybw0duJbKalkEvyBIVlb4/Eyt7lnG0nExi2sdn9GY6c56lA7SlyLNOknfb7HBxEECxl8EDeYPWYOZdBVZkplarvNBkGyGP66+Ja0/XEZdAqZ1vANVq/8DB/67/YK2mJm9t3bFxI0/pR+3qqJPCGtrU6CRSjYzPDySr+TGR8vFYd5GEld+L8kbvbVCfLczRgVxU6CdIFfruiCsysK6IQzfDPKNMnY64p9E/pj+oBAfB+utlKUmFm1uIQ3WZ8uWJT0gg+IvCG1T0o2nsd3ikzjSRsV8MMTzyG2idZvC/800qdLEUXpUPvMFLvzLoNqkCcjl20ONeYla+dMVkV/MWyBgRMmOpzFPePYNQSO3uxJwkyaeEOPWCJ4WY6ZWoEjpHNZmOocJ6bh884VpNuuPrR+oP4P2JuqN1E3VejjG/+lgHfOIEJN/lcs58jKQ+kLcRvKVdzwOtzcU/1ioV80OJsB8xukZ9seQc9SE1kmsP1YNGvO+KfydadPFTWjxPHcF9dW9aB9fyfJA8ddCOWcHWsM8KwLzyoE6ZqFFzLMjMM8DzJEYfVwRNKYnrQSVVrgPCs/jqlvkoly+tcOZtrrBrx3kc4MgC8wTpd/uV8CY1kx9tS7lLa6c8ZA6/mZawrqhRaxeIcxFmV4fk29Mvz+Gq5QP3q+Q0lkhyITib4vhhfGpDqPu07MkQzz8T1GGubjyxsMIKf3pHM5EclvB4lEbNy+YKvutEVgB+72C3UsH8uFM1ma+ObTz0rzJ8gjOxIHf4/qPz3P9d2MzR8rSSmlyvC/GOXKXZr+Rty3vf19Sx+XxEIPrcdRBp5LNjcKQ5nKb1Xvr8GUEvfDctn3L1vL5W6++aXx7+bSbytdtF/R3Acsf1zu+491WFhfnZzEef5l5A/t9E/t9s8CHOy4TdP1CvCgn1Q+sj0fD9XTaB3ye4knprGsznXVCOnFYRwtYFH+7EH+dEJ/yIdlLsgF4CKsL+y3VIWwzKP3p2G+S20YWj8Zc84Lo9quZ/d7I7kXZb0lXtkTwpHSb6YrUR+BYOH6iRSdYl7tZ/N1sPOSmPzuWJ/uOfQySmds+w9j+fhemR/LGeylIv1/gQ7z7hLB25qdzo/lsdtS8Qi9nCpnxUu19o1SX8R6v+zcJ8Y8V4pOsb3Yja3Ej55tArtZ1Qdh2FtYNYdie8PlpN/ZpLJH8Mf1BIT6fL0lalhLW6dPEovlptPFUt2fKNrm1Ka33J/nuD1UI4wu5dgIWzqVzJ/VDKb9Wb78zVMfl8ThXLA8+F7pVyEeKhREffi+urCgelRXqi49lhXWPO6msKL+tlhWWBy+rbUI+UiyM+PB7cWW1LSadRW2ms0hIJ67NTtKmSulInJvt1vVeNh9J9g7nx/HZ7dV6OMbvg3nTD8TMRyJHxE4F8rswbqPpeZwfj+uLUfyPxsyPb2N5xnxyjpjnLiFf1vH5cYr/KdYfdDQOEOfHKS23/cHWbVGKhVUh/mnVejzuJHtDebJlvGJpHZfH43xQJ/mCcamfilh8nF4S+FA+bw4a+WPdsI6/98Xnb2ZYzXb84ovi8fkkXzgh1gUMK+7de7Nd3S9iWNIHCoR1VxOs6xhW1C7tXK8krC0MSzrYkLB2NsG6nmHh8zsZ1q4mWDcwLHx+F8Pa3QSL72qJz+9mWHuaYG1jWPg832VnbxOs7QxLOtRFmsvHdinJroBuDqjJtnxw20ztCijJPW5x+90C10EhjM9x3i2kc7eQjoR1gyLWHYpY2xWxblbEulUR63ZFrDsVse5SxKoqYu1UxNqliLVbEWuPItYWRawbGZa0jkGybYuC+lho//ueU8av33bjNeWAOexPUhr4+6aI9AeF54MYLHwmLi/Y1+RzXpTPnkB+P0t4fM3IL2AMRLtzSe/gkE+SEwEcvdPPJW1XO3VthTSfQc8OCmF8nNnKO812ddy606py+inh+aAJFv3Gd4kUT5pnxbzyMT/VPZyTQAy+Zo/iLw7TlXb6bDYW4+8ApPEWtuvEZyCYai/4dxjSmFKa28f3htZ1QZiiXk9KuxyifLqryWVhHZdd3ElHWPaDLD7KUZrj4v2qZnpFdpSPFfBZnBOTyvJwlqb0bgjv8TbtcCFvUjrr2kxnnZBOHNbhAlZc+cW9+47brdnRbnK5uHotzQtM5903yW0Ni8fffUtzLRwrYL/XsHvN3n1jmW6N4EnpNtMVfD5OJ7e0mc4WIZ0oG28d9nv4vC7FPy208W7fvY7m4757dPv92Wjid+xRu2Yi7z4hrJ137JXRXGYyXylnivmJiclMKc5mtLoD0UYhvtu15aPiO3b8psG6Lgi7k4VhW0kcpXfsbuzgaCaJ/DH9QSE+H2+0upOrBha9Y8e2hOr2TNkmtzalc9+x49qQVt7bYnnw97Y3C/mIa7Ol/qRUVjfHpHNkm+kcKaQj9Y9TEf8pHX6PpyNxbvbe9go2ppJ2i8Vnb6zWwzH+38F729fFrInmfW1eJ1AHreP1HnffTtK+U/wSjOH4e1vp28wbq9GcKY2k35lT/KtZH8NNOy+/t4377pXPF7T63au0V4DbPI5UpO8CyUl2jX+DsxPC+FoKnFPl6w13Qxifn+FznhiG74xuYmHSuwcKuwfCrmdheMIE6ih3km3Gzck2t/COG/WmysKkPTaktVFHwTWGEVd+j+sbPr814jluRxx/85J1XKdr3yVJ33xjnnjffbrrgjCtPoalLbu4vMWth8L3dPw9m4R1R4tYvUKYizLdHpNvySZIXKV88PG8VM+OEmRC8e+M4YXxB4S0Z3q+RpKh1nwNye14Fo/6HfOCqTp4RwRWwH4fz+5Fzdc0+z79yUGZc9L9gij+16Af9wxc8+94EOu6oDHsOgi7Lbx2+45nZFyaV+Gyuw3S5mOg24X8JG1LKU9Wr+a30JZivwm5ISaW3y0QB7/Fx/jvg37ukUMyZiqIn9fmOpR0DwGK/6GYvjbF6YrI1w0RmL8KuvjRCF0PBEwpX3ztJ+ewlXGg+J+EfNF7zyAIxHb2Ovh9bbWR23YhrSDiHm8LtkeExaXb7Fl7vQOupbae6+stLD69V4+SKdcViv+FGF2R1vTGvc/mHHicbREcvixwsO3EwjB8csv1t0S8Cu2Ca26epaLkRXC9gBPlSAw2e1QdOA79jlM/6TVyEHGPFwM9i3txlsrXlLdHvSuex8C2RCQ2L5BdkvV4nbZuwPV6vLj9JlCW0rpkvm5A+vao1XSmu26A68J1EemnhOcD9mxKuGfd/n7M/APX0liUz320OhaVKgfHitojqFyth2P8P4lZb7AVeEiYtMaa4kv94riNjJuNL/n3adI4JS5tlGWSOf04rtK7Huzz87UUyO+uFrmePsNct7bINapeUhtmjPTVN5W3nrtlexmrCqcRsOtedo/H4Z8tbIuguojF49PefEs13m7yNulGgZ/kJNPAuaSD5o6fM/A3UEVPGmpMSzIh0ucZfEiHz0pDOmlaNq77Lh22hBh8uRPF/6cY89PsUwqu9lUhvrQFnvTpRZWF4XP4GmU/drUeRvEcL3cqScudwqT2u+5qoyx2BlNlgfG57HYJ8XdCHL7cCaet+aFFOD1cDRo5S9P30quhqsBH0mue3+6I/G6u1sMx/s9j9E+SibRVM8XfLcRHOVXDa+mzmN0sDJ/jr/JR/yieY/0rS/qH+eX6F3dIsHVcdtJnH/iKA5cuY3yU42Awte5SmpL9q4bXuOWi9Ho7FfGfuPJ7cUsLzqk2puPqkDV6Lcjrk9SVs9fZoDE+HvTO65MUn+SMUy1S+XWz+CsOOfAfDyXnU8/W4fTjqkPktLHu3yFw5WkXYbvyw8LruO4b38p7HXD/x6Ho5/nrUGx3rmdhUVu2ovwxn1jm3MZR/COB54+HDlxLtgSn0a3rgjBFW1JptS2T7CrG57ak2QHlfBkR6mnUuTqIhTKP6gf1BHIfBLfWx/gZKCN+CDm2mVXG/dYWuSftG94B+fg+28ofZbmTpSmVlWT3B4PoNjBJuUv53QOcpfhoJzD+iwTZc8zuQNalXRGYLwVMvpV2M8yrIzBfDpi8ryK1nzvhHq8j0mdN2Kby/gjWkbtZGHLn7eZeSJ/HfSNLH8OwDvN0gxi+0nL8OL7ctlPYZXggdXjdy/CU7WI+riyPEfKTtCzviMk/x6LnuoKp+irVob2CvC4+RMbsbhHz1UL7KvV1rqnW074som9gHe8bWMdt4B0CL+xzSO101HEorxPq66yNIbPljNTuoix4u1uFMEl23KbsFOJXIQ7vw2P8N1Qbw5KcdYfpTKdd+1LE2YASrr1exXhUw99Sf8xeVyAc418XY8clGcbJvNm4nS9prULYLhYm6XSn6SvKh+trnCysa3W8zvUV7WaVhcUd+dRsHitOX3Fr/Y+xflgV4vFDmyUdSKozfKkz2kEpPu8DUfzdCfpVyCHuU4uk8wNSG7c3kNPGeosy4Qd8U/z7Etrz8NLxOCqbleoHypXXjzgZWtdqH5FkFvd5v1Q/9rAw1E9ed6oCh6R1h56VDnlvtuUPH9dJ58ZiH5Pbeor/TIytrwoc2mlf+TyDJNc429Fputwptp7PF0i2vtmZtFsS9DWuj+FfFeJLn9m0+m7jVuC/H7s6Nd+zUfZhUvsdL/u4emBdq30kXvZx7zakJelJbUrUufNRNoXPW1L8z7RoU+L0Kk6WrdoU6Wz22Ztn7Gy9irMpVZZO0raqmQ26IsGRnHF6FPfuq5kecfsk6VFa4IV2UvqM1rpN4f9Mmy7JkZlYvopzP8UUS4/kgfcw/T5Bjop8snHlKh2r5vaYy0zBmjxeV6y7qjpVNpxHFa7xeXoXZt1FgMOXa0tH/dr69E0210TpRK2BoDT4fMC3Ye7sWwyz2ZaZcXUf36+/crHMFXHjjpTcCVhS/GrQmDeK/92YMaBkPyXdovjN+nB8fQfqA5/Pltp4no60lkBqlyn+3yYcH87MO/tcdrbf2VfD6yTv7LEM+HugqpAO1gteB6Q+mlRf8ShNqW6hTUCOxMO6zRCHz5tI/TvkTduk8v7df7XYvzsE7rXaLvM60+pYXCqHOJshlc2UNTkxNmMnPCP10bhMa3lYUsdMss4nTqbN7FA1vI6zQ0llypeCUjpJZUrxF0D+o+xwUplS/IUxMpVkFCfTZu/sq+G1ZL/5p9BVAQtlypctS/ObcTKl+EtiZCptbVAFDlymFH/ZLMoU87yHPVeFMN7n5PauL+K5wRjMnRGYdB+fi9vmWipLyabxslwXU5ZSvnYmzNcupXztajFfFP9IR/m6NSJft7aYr51N8nUryxfFP17Il9SGRY1rpTkX6/jcP8U/WaiXB/OcGZ8Xk/rhceuX4vRlOuObDJvbiNtyRFqrLs3T8TVaL0moA7gtiXVdEOZaB1CXuQ7EfRZi3XTnnAeF+DROlnQg6rh7TGc6OnD84sZ4rtbWUt64nHAcgXMUfByxC9KV6iKPvzO8j2trsb7x9ScU/wLQV762NurT/ouWyGlH1RU+p0HxK0vqmJeE19Ln/Hx9Qqu2G+UcZbsvn7PdDbabZCbZbl6n42z3FiEdaTstadsDenb/uob+5vyrwrMUX+rzYfyo9QlviOkbSXNAKKdcBOYW0PtrlzTmH8uR1jvZeDcv0Ul7a8zYQRoLxH1C2Gxuh68dwnEFPcvzzcvqZmYXpPcjXCbYV8X4vK+KYZh+sz74biGPXIY9EfHRVmL8OwU9S7L2QeKXtF3cCVy5Tdf+nJS/25He38R9+zB77whzOckWY365La4Ksoibs5bKsApxotZESnYabTGvH82Ow4rTFXrW6squsDCkuauodwKYJt7jfSh8ntcVys+TUFf4unlpPjWu315bgxNjF6U8xNWFpO98pf7MrpjnpPecmNam8H8mU2nLUXpkt+YLXKLay3eCHL89JHNNTeHbnpPazhSTE9pgRduQSbH0gmDqWIG3TVJ7s0mFT/2drDQPKNU7ks8eJ3yyFXwni/qL72SxbKT+g9T/xfHIh1jbJdmAKuBmIBzjfwL6ZR+NwAyC1m0nrs/9xqJGXO01atXwWrItu1mYND6M+16HODT7Nomvc6T4nwPbEPeN4Yy8+8xWZn1tLMlMWhvL225J/1AXzmBcpbng3QI+nwv+jZh+aNz63Dtb5F4VuPN6zuvOhxL0UdtZn7sKwjH+78f0DaoCh7i+wU4hfhXiTHd9Lm7JuR+7Wg+jeHPrc+VtSSnNZmvjPsdst/SNUdy7bmlOGXmshnCM/50Y/dPe/4R/B5h0jfCsfwuUyeZme86Mv9OIWyMsrYuS1qbgt2jPhPrnUo4jo5lan5bKkPSVuy4Ix/j/FuprH+SD/ne1wbMyMp6t5Mcr48XxUqkwOb6E4VtHZWa3mbL68KMldZmRnLRlZh3hd7vBr3332wV5TQt5ovRJl+ZB/FTE/yCQxyyUVh/DUs5bNi5vyJ/PFXQxPnQdhdXVIlZvRNgmnXzXyjQdk2+eflR8qQ7Q/Z4YfIxPdh11uIfJYr4bWeTiyq0H0qT0p7NtNv0+jMWjseS8YKq8uyOwAvb7MHYvHcjbZnO71B9MzTc949imJN5OlNLvC5zWh5od6GZ8ououbid4zZbxUrjLJzd5vOhQnAjHs82LrtYssntcHeax56gbKDWhnGdKwJBEQJgDQSMHfFYyJemIdIOgrq7cfDTDout0DJcojBTD6I/BmKs6c1VHcHNVJ1nV0e6N50ZHh8dyE5nCSGmyUirkm/XGtdOfnBieKJQnJoezheF8IVOa6fTLE4WxkYmxyWKmlBnLjs14/kfGR03qY4XxwnBmMjMy3MpoiHQfe1a8rku9xh4Be1B4nuJJ6XAdnh+TDjeZqaDe6+sJ4nuI3Sz+i8I3hdJKjh54hvKBB67Nj+DQJeTZOn7gGsXfBBz+dejANdVbNN34duPlS+O5crvcFTSmTfHPXFrHPC28pvKRereDgWxnMAzLkmS0MEhW7iSTIJDLsZvFp1mPqHJfwPJN8c8Vyn2AxZFk0Cvww3tx+t8bgSWVmXXbqzL3i4E7n/nrE/ilBX4Uf6EQH20S8ZFks5CF9TFsKR3MK5Y1P7CR4l8u5FWaTaS0Z2M3ZZRhd7Ux37iLd1qIz8ujX4i/COKQzAZZfCwbqY4uZGGYbg/jINl41Ev+ZkaaGUAbJXXPUQbEs1fIr17ZTWZTLD3KH97D9PsYV2VdyraqIySffjfyycTpYL8gH+Kz2AmfTO0Q8kEhbeJKXzGhXcH4/SBDjI/X9Dzeux0OyLL3B+A5wh9kYdbRLs0pISwt3Js3S1iDAhbKjcrU1uMbmCz4yQTSf8Ll9zhHLE/S+TgbMd10EIv6UVJ9sn5T+DvTlsvnKB+LhXxQ2qhXenWnOJLU1lH6fYHTupyN02GUD5WbVPfp2cFgqg7fVq3Ha6bfmI6Eta9DsfYqYj2giPWwIpamvO5TxHpQEeseRawdiliaeXxIEUuT125FLM36qFmOexSxNOvQo4pYmuWoqauPK2Jp6tcjilhPKmJp6n2n2hzNPD6liHWLItbTilia8tLsm2jqV6f2CzX1vlP7cjsVse5XxDoY+nKdqveafZO5Nq01rE7ty3WqLdTsy2naQs1y1JRXp/a/blXE6tT+192KWJp1W7MOacpLsx3SrEOdKntN+6U5L6fZN+lU/dLs+3ZqH7MT2w57zd9ZabQdAxHYeB33blhKJyVwlt4pzwOM3mBqfjXfKxP+Ekf4lO9DBFlhnih9/o6ZwqX/hMXDKK0+hqWct2xc3uLeReN7d5RBFNYhLWL1CmEuynQwJt+Yfn8MVykf/Yoy6VbE4muDpPovvb+l+EuE+JKeDAhp07NUtkshTLFsc3FlizaC0p/OV0Ykt0tYPNpReF4wtW4cEoEVsN+XsHtpwEM3U/ad/6a1Nbiml59mPvNrJIbzKZYe5Tlg+Xq+rJG4o1qP126f4QlFLM05+r2KWJ06n6GZxz2KWJ363qZT57jepIh1MOjE3DuN2ZO9prw05wQ186g5n6FZjp269kxT7+9VxOrU+X5NnZjrfz0/bPQeRayqItbBYAs79Z3ZLkWsxxSxOnVeXbNNm3sP0RrWwbB+QLMOderas7m24/nRdsytt5g9nZibU5i9PGp+k9Cp4yFN2Wuup96jiNWp/Zw5OzF7/Yk5OzF7su9UO0H9r7i1M47XESXe7o/Sn6m1OZJcpTUXra5Ridu/C/OEYcghbp+wASGdXuG5TYGKrHI8v3yNgsTjEHUe+SKVAa6T4frrct0LphcEsv5S+n2Mqyv9Xcr4cPlw/T1U4DoohEWtzaLwwLnM8xPTlbmjdW2xMpfWiLUic+vurNbj8bC0cG9eDNZORaz7FLHuV8Taq4i1RxFrhyLWPkWshxSxNPO4WxFLM48PKGI9rIj1mCKWpn5p1kdN/dK0hZq8HlTE0tT7g0En7lXE0tSvRxWxNPOoKfu7FbE09f4RRaw5O/H8sBOaeXxSEUuzP9Gpsn9KEWuuDrWGVVXEmqtDsyd7zbH7HkUs/h0tziHx+VFpvmVpTDr4PMbD39J3VtdWGzkdCs8tYZxazTs+T/GkdAbaTGcgYTou8tMrPLcp/J9pz9W+Q17WPnaR3yDs5fq8CzQHiGcN4NkUX1zWWA549kSaPZuCcuhm8Tcsr2N+OcTk59kEcN3L8FKB5lxp8lPdKf0+xlWXT33udh7jw+XD527TAtdBFmbd7dV6PB6WFu7FYd2niPWoItZuRayHFLEeV8Taq4j1SIfy2qOItUMRa2eH8tqniKWp95q8NGV/vyKWZjlqyv5uRSzNPD6liHWLItbTilia8npQEatT67Zm20H9CRpTYP+RzieRzkTj51/huW+IgWHIL+7kaXy+K+I5ng++XobCN4W/M+25LOEvcINf22On2dl/lL50Rl4q4j9h8TBKq49hacsuLm/In+uBtB4pDmt+i1iOT/CulWncmWKYfn8MVykf/BxIqZ6lBJnQ/QUxvDD+gJA2PUsy5OcGbgp/Z9pzuTgZYl2k9KezPxHJbR2Ld0a1Lgeug/MjsAL2ex27lwY8dHFn76YE/LjyHYx43rq4M3H7hecof3iG5QoIX8DSWCFwXBHDEZ+neFI6qTbTSQnpcCxpjsa6crUejvGPD+dopLMoVwr84uriKiH+SohDfCTZrErwnHX9QlrEierxarivbQsxPeKL9zD9PsbVVZu0mvHh8uF1Y43AdVAI43ZhjZDOGiEdCWsl44C6NUPll5tu+a10wye2/FYKcm21/HgfYY2TfGQniddhwVRHYWshba4Lh0MY1hXu0uw35snar58M1XF5PM4HdYy49QpcFeVU5vkNBF7Y1j5Tnco/iJHFWpDFgvV1XB6Pp4n6vY6FYXkMsTDUp/Us7DAI28DC1gp8ktRN67iNidOrlYrpoIxWsXRWKaaD8l7D0lmjmA6WHZXVQDC17LCe8DqeFu7xdFYL6VB+sK+P758mlstpYt8Gn6U9OLtZ/CVDdcxyiEl1fB3w0qvjuQzlbSiY6ihsPaS9loVtgDCuzxshjOvgERCGZcudZDdIFtZuHNWC3UC7zet/XPvuqD+UuH2n9GeqfY/rF1sX177Ts1K9pXfDA4JcMU9RHKQ+4nTtnds+RvKypfRnqu+9JqFcpX7QGiZzDOPrJKS+dByHuH75SoGDlM6qNtNZlTAdn/NDbQ7Zy/Gw8bFtzkPLG+PQt4q3rqrHeYTFobVAT8LaiX3htdS2XF1tDFsPYXyP5g1CmMX/eihAkhm2JXxu5AjASAv34uZGjojA6gKsXsDi7TrF/xRry48EXL06PjxCcjsKOHF7d7SjtJPaO0q/X+BDvPuEsK42uFYmRzP5zPBwqTxcmCgWKimGT1z5PT5fdIwQX9onm2R9bOBE1rnauRbVOv4xIFfruiDsaBbWDWHE0er9V4ca+R/jiH8S+WP6g0L8CyAPrZSlSyy0BxpY86eJtSRorE9oc9zaoNywZIPISXWev1vDOkZjrJSAJY0LKE8W86Xr67g8HueDdh658XxI7Qe9rxgIpsr1KIZ1dBOs0xnWUQKvfgGL23g39TZ5n5bSl+y4iz6tZJelekGyO1bgOiiEHTUjcs2NcV7oKOw4SBvlyZ1UL4i3rRfbWqgXqH+YfpTMUZfJpg4E0XadP8frW5L+jCNdL0xX149ywydW11E+09V1tFtcF9PCvXkxWEcoYpHeSH19vs6/1b7+gMDZbT85Nyq1c+SkMjuKhR0XkX/uJDtAebJ24Lb1dVwej/NBmR/LwmahHRo+mNoh6+ibmnbr08GGJdW1VMR/Soff4+mgTvM+2UZ4Dt8P/JS9H6Dn8P0APntRtR6O8a+CeZj/CzElu0gcqR4eD2GKtqz2HvWEYKqjsBMh7WVwzZ1kr4h3q+8HsZ6fyMKw/E5iYVgfT2ZhaHczLOx4gc909QvLKkmff7rpSP0x1/WFtx3HKqaDZUdlNRBMLTveNzmOpcPv8XSOENJpVv9XrZDTjKr/11Xr4Rj/Uqj/h4WYvUIeZ7OOH8/CToIwrs8nQxjXwQyEYdlyJ9kNkkWr7wexbClPbufycuPcvgQCL7QvfP78BOCF7ze5k+SEc3+PTdO+8vLG+k7cBoKpMuRzI62290cJ+ZDSGWgznQEhHcd1bkIqd3JSufMxwokR+eeuWd1pZYyAMj+BhcWN393IMPkYgdKfqfG71N7Ejd+PF7jyvoJ1vP98vJDO8UI6BzuWZH9TEf8pHX6Pp4M6zetmVB/hAtZHoOeSjhEo/unQR7g4xJTmk4kj1UO0GYq2rMz7AeikfkCrYwTi3eoYod2+vr3OsjC0yTkWdqLAZ7r6hWU1031q1/WF9ydcja1430RqT1MsjNLh9+L6JrwtjKr/16+Q00w6RqD4w1D/t7ExAuZxNus4H5NLfX0Ky0IY18EchGHZcifZDZJFq2MELFvME3Lvgns4Zj+/euB/N4u/KywnW2bVFY3pbYQ0KO39c0osnlQf3c7/JP++hNLvC6bWdxd9LKlfII3pJbtNzw4KYfj94HTsgmRjOm2Ojq/hxfE7lht3zebvWvnWAesYH4cjH0U5VbidCgReGbjX6rcOJ4EsWumnuOyL2Os8CztJ4JOknlvH9V3Snedb/0GqX+2mg2VHZTUQTC073k85kaXD78X1U3ibjP1I7Kd8dIWcJvZT8Fm+JpLib4R+yidYP8XRWKSlOo76O92+CIXlIQzLlrtm45tW+inYd8c8Ifek/RSK/2VWTo76FZklLF+STOf6O+77OziXy21cq/0dPnfaKf0d/q3IbPR3sK7O9XfqYXP9HTmdg7W/g/UEwyidZv0dqZ5J7yiwv/OPCfo7+GxUf2cQ+js/Zu2oo3eLXvZ38J3kdOdluN1oNoeSYmlH9YvOqx74z+dvfgHzN/+3IprXRkj75pWN8eb6M37N31BZzs3fTOWD9W2uP1MPm+vPyOkcrP0ZrCcYRuk0689I9azZ/M3xK+U0W52/+b+VdcyTwuu5+ZtGh7KYyfkb3k+h+C9i5TSb8zdx3w046l8k7u/wNUGuvxuQ1gTFfTeQZE2QvebzN9NdL4P62EnrIe01n7/B+tnqd3I49milv4NyJm6O37mXeF8gEHhhX6DV/g6+H5/u2nvt9fVow1232zO19v75un5nINC3R1I942MO67C/c9VKOc2odTW8v0Px/wH6O29k7aij74JbquOov7yfJOlzq2tuktoN/Na4lf4O9mW53Wg2h0LlgP00vXLI184fKgRTHYUVIW38lpY7SWbE28rsyg11XB6Pp4l2pMjCUCeHWRjahREWhuU9ysKwLo+xMLSdL2BhOB54IQtD/X0RC0P9fTELQ/19CQtD/X0pC8N+/qbwutP0h9fVYQjj38mMQFir38mg3n1kYx2Xx+NcUb+J96Kgvj/y5vL2s8q3XDJ+zdWl8e1Xb7nuwvINN5a3be9isLxJ5Z+dHRtBF3GCGLrWzWNhR7Lwc6pT46HrF56jNEhtCnB/NoYrlH5fMLV4XAxXCowPlw8frhQFroNCGF/OUhTSKQrpSFikK9LSd35sn7TFy1Ex6SwROHeaCVnCwtCEtNM8TXcZH3HrFfgoymmEm8VA4DUK91odFg2DLFoZFqHMebOKOsObVbQtvFnF8ubN6rDAJ4k9sY7ru6Q7cXZxuumgjPi0dl4xHZR3gaVTUEwHy47KaiDQt3tSPWs2LPo1NixqtiUBHxZR/D+FYdFXWXfczad0rdVx1F8KG4Mwrs8vgDCugy+EMCxb7iS7QbJoZ1jE7cYQxL+m2hi2Hp47gj23AcJwOPV19koatyIdYhi49et6FoZbVW8A/M+HgFyHvgU69LdML5Nud0Txpc97jxHyK21Lxac43QzrO0t/KexFENbO9mI/TjCMkMpZ2hoP7c8Z1Ua+GwW+aNf49M0/gY79NOIVGKaNesd17CQhvvRaT5oCo2c77bNLPnWEw2s+HMXhNZ86wuE1n3LEdrfVz7XwNVpSHftpxNQfpdGKjh0PuFcxHSNuvwAd61/VmPbJTdLmOpYR4mN58S0PUI/o2V7hOUU7lukXuJKTdIVP67WqK1KfmOst9qtQJtxJOkZyakXHeDlLtgTbJK5j0pJEfE3PdWwJLCMcSqBj0tYWSXWM2tk5HWsMm2kdG0qgY9gn4jomfeaDS1u5jh0JOpZPoGNx/bE5O1YP62QdyzuyY/xzManvFKc/kr7hKwPe18LXEPRsJy09RPm46E/F6VZS/cGljkn0J8XSIVwsH+vi+lf0rLQVwlEJceN4xLWDkq5LS32l/vyJLAyfOy4inahPB/iWDhT/3LBu4pGXVB54BACl3Rv+74IwxfcAw5ZHFnhwGXZXG/MdN16yrtU6TzIbDKa2C3z5N5YBr3cbBUxpKx5Jn46I4d+qPkkcO2n5kGRfki4t4K8rW7V1SW0WLldqxWZJS++S2ix6VtriMel8RhyPOB2L+0RC0jFsn/kSHXwuaokO2izMG7dZFP/6hDYLt6GyrgvCXNsslCG3WVKdl5YmJa3zJLO4LZxaWeaEmLjFMJXpeoi3gHFdH0zlul7Im3Qk0voIrKRHIlH8p0L9IDuHc9J65V4/EgnrHtkBSvsIR2mnWHokb7yH6fcLfIh3nxDm4kikpFvoU/wjhfhxRyK5eSckH4mEc+PWdUHYESwM6z++q+FHIjk6uiuXRP6Y/qAQnx9j1OpxCC6w0B5oYM2fJhYdiYT2k2zOTNlMt7Yul5dsHTnJtvCjl7Aut3r0EuWp1aOXUOZ8a+6NLE0uc+pDDQRT5bqRYR3RBOt0hrVR4NUvYPG2xNHaq8RHL1H6UnuhyCcbZ/+l+ifNRXJbJi3zdSvX1o8rQ3lyJ9ULPJKslaOXpH5enMxRl/nRS1L7wZ/j9S1Jv8mRric+eonr+kY3fGJ1XXqH16quo93iuhg3RyphrVfEIr2R2scBls56IZ249nFA4Oy2P54rSu0cOanMNrKwoyPyz51kByhPrW6rjjLnW0nPQjuUeFv150M7ZB3fcny69elgw5LqWiriP6XD78WtD+V9siF4Dtc5fo+916LncD4Ln+XbqlP88+CY7B+EmJJd5MesdsqRka1uq45rulpZ5xx3PA6WH5/XitsyO8lxTshnuvqFZZWkzz/ddKT+mOv6wtuOoxTTwbLjxzVi2a2HawyjdPg9ns56IZ1m9T9YLacZVf/5fDbFfynU/3SI2RtMzeNs1nH+rgXfU3J9xrlproM4N41ly51kN/CIyVbWOWPZ8qMp3MwZ5ka4fQkEXmhfrq42huE7lVaPXsI5xlaOXpKO+ZPsK19XI/Vrp9veS+9NpXQG2kxnQEjHcZ1r+XhWPkaYjeNZUeb8nWrc+N3RtiaJxwiU/kyN35u9k+VjBOmoT95XsI73n6VvFqT15Ac7lmR/UxH/KR1+L25rDV43h+A57COMsj4CPZd0jEDxT4Q+wgtDTGk+mTi63e6o9WPkWh0j4FFxrYwR2u3r2+vpbC2DfKarX3FHe7nuU7uuLzN9DKy0NoX3TaTvuY6NSWejkE6z+v/q1XKaSccIFH8t1P/XsDGCo+2yWq7jfEwu9fWl9V9Jjm5Najemu8Uvli3mCbl3wT0cs/MjDSj+1WE52TLbvLoxvSFIg9LeP6fE4sVtZedm/if53hCU/kxtZSf1C+K2sjtW4CptX9UN19OxC5KN6bQ5Or51r3QUeNI6hvN30926l4/DO2GLY+ta3bNh7hh5OV8a6Rysx8jzfkqrx8hL9UzqR2I/5YnVcppJjyKobWsK/ZSnWT9l7hj5epzpHiMvfW+XYtyT9lMo/ntZOTnqV4hb93KZzvV33Pd3cC6X27hW+zt87rRT+jt8697Z6O9gXZ3r79TD5vo7cjoHa38H6wmGUTrN+jtSPZPeUWB/548T9Hfw2aj+zn+tqWP+CWtHHb1b9LK/o7FHFbcbQxAmzaGkWNpR/SJ+pAHF/yHM3/xgdTSvIUj7yjWN8eb6M37N3wyF13PzN1P5DEHYXH+mHjbXn5HTOVj7M0NwjWGUTrP+zJCQTrP5myVr5DRbnb/5AfRnloXXc/M3jQ5lMZPzN7yfQvE3snKazfmbuO8GHPUvEvd3+Jog198NSGuC4r4bSLImyF7z+ZvprpdBfeyk9ZD2ms/fYP1s9Ts5HHu00t9BORM3x+/cWzqiyrpW+zv4fny6a++119ejDXfdbs/U2vvn6/qdgUDfHkn1jI85rMP+znlr5DSj1tXw/g7F/yPo71zI2lFH3wW3fAwd79Pi+hSuz9inSLLmJqndwG+NW+nvDEFY3H4zFA/nUKgcsJ+mVw75LPHIBlMdheG+URvgmjtJZsTbyqyVo5fQjvDjeePOMUC7wPfgPhiPc+o0/eF1FfdY5N/J4B6LrX4ng3rXytFLqN/EexpHL/EmlX92dlQE3XaOXtrAws+pTo2Hrl94jtIgtcHt5GZjuELp9wVTi8fFcCXL+HD58OFKTuA6KITx5Sw5IZ2ckI6ERboiLX3nRy9tFNLZGJPOEoFzp5kQfvQSmpB2mqfpLuMjbr0CH0U5tXRElXWtDovwGKpWhkUoc96sos7wZhVtC29WsbyjjnNCPknsiXVc3yXdibOL000HZcSntTOK6aC8+Um+WcV0sOyorAYCfbsn1bNmw6IPsGFRsy0J+LCI4v8KDIs+zLrjyGu26jjqL4XhUWJcn/EkS66DeBwOli13kt0gWbQzLOJ2Yw3Ev6baGJb0aKSh8NqW3+fZK+kuiLeGYayGsLUs7DAIWwf4+8Lvk7kOfQV06A+YXibd7ojiS5/3HinkV9qWik9xuhnWd5b+Uhge59TO9mJJt/r/gwj7Q2lw+3NGtZHvkMAX7Rqfvvk66Nj3Il6BYdrSUaIUv9m2x0PhtTQFRs922meXfOroRAjjw1FpG3RpeJ1kS+6kOoav0ZLq2Pcipv4ojVZ07BjAPY/pGHH7IejYT1jaJzRJm+vYiUJ8LC++5cHc9u2N/R8uE+4kHWt1+3apnCVbgm0S1zFpSSK+puc69j+gY/MPa0z7hCZpt6pj1M7O6Vhj2EzrGC9nreMCaGkr17FF8GnO6gQ6Ftcfm7Nj9bBO1rHVCXRsOnaMfy7W7PhDrj9xRyBIfS18DYFH0fDnZnNZEl+qpdmfitOtpPqDSx1bOcZEWk47BPfi+lf0rLQVwsaEuHE84tpBSdelpb5Sf54v78Pnjo5IJ+rTAb6lA8UvhnXTlkfcMSaUdm/4vwvCFN8DiMeYoAy7q435jhsvWddqnSeZDQZT2wW+/BvLgNe7IQFT2opH0qf1Mfxb1SeJYyctH5LsS9KlBfx1Zau2LqnNwuVKrdgsaendENyLs1l49A3f4jHpfEYcjzgdi/tEQtIxbJ/5Eh18LmqJDtoszBu3WRT/1QltFm5DZV0XhLm2WShDbrOkOi8tTUpa50lmcVs4tbLMCTFxi2EqU5z/XcC4rg2mcl0r5E06RmRtBFbSo5co/p2hfpCdwzlpvXKvH700BJzIDlDa6x2lnWLpkbzxHqbfL/AZCq/7hDAXRy+tZ1yb2aENQvy4o5fcvBOSj17CuXHruiBsPQvD+o/vavjRS27WVtSPXoqTP6Y/KMTnxyUlLUuXWGgPNLDmTxOLjl4agufJ5syUzXRr63IZydaRk2zLAhaGdbnVo5coTxazlaOXpPeUKSEfksypDzUQTJXrEMNa3wTrdIY1FMNrQxMsfvSNVH/7hed4u+RoHVfio20o/b5galkp8skmlStfV7ZR4CqtiUC9wDBMJ269F2INKWKRXkj6y7etXieksy4mHXye4rnt7+Rykh0hJ5UZXzdwRET+uZPsD+XJ2p9Wtq1GmW9kYeuFZx3XzcTbVvO66aZM4+um1M62Ujet41s6T7c+HWxYrtffUdlKa41wHdnn2HsDeg7nC/BZvm11TYeG6phfDDElu0gcHX960/KRfK1uW41rZlpZR4r1nL8PwPLj8wZYH/m7piTH5SCf6eoXltX6iHxppIMymqn1qrzt2KiYDpYdPw4Py473c1o94nadkE6z+v9nh8lpRtV/Pl9I8f9lXR3zL9jckKOj+Fqu43wuG98DcX3GuT+ug1FbeHIn2Q08wq+VdaRYtnzrfzdzMrkCty/oJPtydbUxDOesWz3aBudwWjnaBm0HL2+s73zdgtSvnW57v1bIh5TOQJvpDAjpOK5zLR9/yccIs3H8Jcqcv7OKG7872jYi8RiB0p+p8bvU3sSN36WjFHlfwTref5bWhEvrdQ92LMn+piL+Uzr8Hk8HdZrXzag+wuDa+jP4XNIxAsX/K+gjLA1vSnO3xNHtdjKtH9PV6hgBj+JqZYzQbl/fXk9n6w7kM139ijs6yXWf2nV9meljNqV3/7xv0upxeGuFdJrV/5PXymkmHSNQ/D+A+p8LMR1vR9RyHedjcqmvL62vSXI0ZlK7Md0tVLFsMU/IHbccWw8YfMt4iv+yENSW2UvXNqa3BtKgtPfPKbF4s3DEeOJv758PR4zb6264no5dkGxMp83R8a1RcfzezjdvrXwTj3WMj8M7YQtZ61r9Jh63iZ07pnvumO64dKQtyaR1iLyf0uox3VI9k/qR2E+5dq2cZtKt3in+F6Cfcj3rp8wd012PM91jurHvjnlC7kn7KRT/TlZOjvoV4taoXKZz/R33/R2cy+U2rtX+Dp877ZT+Dt8adTb6O1hX5/o79bC5/o6czsHa38F6gmGUTrP+jlTPpHcU2N/5YIL+jrSukfd33g/9nY+wdtTRu0Uv+zv4TnK68zLcbjSbQ0mxtKP6RXzLeIr/KzB/88W10bzWQNrDhzfGm+vP+DV/Q2U5N38zlQ/Wt7n+TD1srj8jp3Ow9mewnmAYpdOsPyPVs2bzN/+gNH/zBPRnfjQ3f7Pfdcr8De+nUPyfddD8zXoh/47XBCXu7/A1Qevd8IldE4Tymc6aIHvN52+mu14G9bGT1kPaaz5/g/UTy427ZmOPVvo7KGfi1klHAFnXan8H349Pd+299vp6tOGu2+31EfnSSAdl9HxdvzMQ6NsjqZ7xMYd12N85+nA5zah1Nby/Q/F3QX/nuBDT7XdurR/zxfu0uD6F63Ora26S2g2SRav9HezLcrvRbA6FygH7aYrlUCYeJwVTHYXhvjxDcM2dJDPi3erRNmhH+PGnqJMZFoZ2ge9xfDAel9Np+sPrKu5hx7+TwT3ssFy5a6Z3rRxtMwRhxHsaR9usZ783sN8bI+i2c7TNEAtPerTNkJAGqQ1u1zUbwxVKvy+YWjwuhisnMT5cPny4crLAdVAI48tZThbSOVlIR8IiXZGWvvOjbVrdtmSJwLnTTAg/2gZNyBBcc9fMTEx3GR9x66QjgKxrdViEx/y0MiwagjDerKLO8GYVbQtvVrG8o47LQT5J7Il1XN8l3Ymzi9NNZwji8GntExXTQXnzk1JPUkwHy47KaiDQt3tSPWs2LNrJhkXrwzhJh0UUfwsMi/aw7ribT+laP+aLd3/xqKYhFoYnBXIdxONGsGy5k+wGyaKdYRG3G9gP4kfb4NEz69hzePQMDqf40TOE/76ZKdfaFuPrBJlQ2kOO0k5Sx+PsH/KW+mHtbEOYK09MDo+PV/KTlczkeKWcCqba3rh+GK/jGP8QIb7baY38OOk9bkO4HuRqXReEDbGwbgjD6Qa+DeF6R/yTyB/THxTin1Gtx2ulLKW2cn4wPSza7g+3PeCfq/Ixm3Vu7UDycQ+l38e4KvOpjXukcUKXINf+GLlK24jwZSmtbmOGWGT3pXHPSpZOq+OelUJ+Om27Rr78BW0Y6gd3UpuN2zVOd9xD3DppWznrWh33rAdZtDLuQZnzaWbUJ/56AvWJT/UPQRif8l4v8EliT6yLe03TFZEvjXRQRlx/Vyqmg/LmfcJ1iulIW4xKW4bycc8QS6dZG7hWSKfZuOebh8tpJh33UPwrYNzzLdY/HgJes1XHUX+lqX2uzzi1z3UQp/axbLmT7MZQeN3Ocl5uN+L6JKjjs9EnofRnqk+ykvHh8onrk9CzUr3FraS4fWi1T0JlORBMLaNVLB0pPytj0lkl5Mdt/zRbkWwmOamN4ktU1kNYq30SnEdopU+CMg8fc22vslKbzHmhLWu1TzIUXrfTJ+Gv01CfuN2Rts9ppb+CfJLYE+vixn0z1Sfh+rtKMR2UNx97rlVMB8uOb2kv2cTp2r24PlZUn2TJOjnNpH0Sin8m9EmWhde97PnZrOOov1J/hesz9le4DmJ/BcuWO8lukCxa7ZNg2fJ31cS9W4i7goVR3A1QXqeH1wPB1Pq3KGgMWwFhC+Ea00XdWRHUXbkq8zw6TH//0VBDMua8CEzSR2lej/Lh9uiiyax0dBHaqe5qY56wPqWF+HzuVJorwTrF+1Kok7wv1SVgYR+H5gYleRLH2ZAnckwiT6nfllSeJCNJnqsZ1ioBC2UcJ0/sM1rXBWGu5YkcuTxXN8kTl6ckf5QTyUj6dOQwhiX1wbG+87lrwu4R4nObhPFPAZtzzFAjv0XwPNeFhQI22tC4etYn5KOfheGz+z/pXNbIn9rbs8B+X8bSXi+kHVcfNgjx10McKq8k273jc7M5/zDEwpLOP8Qt6Y/b6rbVuQmSUytHAF8W0VejNHhd5Dq2RuCLfUA+z3Ql6Ng1LG1JZ6T5e4q/UYiPfTOuY0MQRs86XvKcl+aqyUl6tJ6FoR5xHUM94nNckh5RGC5RHYJr7poth06qY7ych1garejYEOB+k73fJ9ndADp21wzrGNqqmdGxzlo/QmHDEIYy4U5Lx+5K0F4l1bH1gLuT6RjVxz2gY/tY2tJnr6h3XMeaHevKdQxtAj3badse8/dYuLyd2zjpmGcKa/XI4aQ6hp+xJtUxXs7S5z5JdexIwD2a6Rhxewp07D0s7WObpM11rNlRtST3ueOpG8Nm8nhqqZwlW4JtEtexjQJf/Eye69gHQcc+m0DHMO1WdYy/N5nTsdnRsc8m0DHpyE3pvQHq2AcjdOxLoGO/m0DH4vpjc3asHtbJOva7juwY365V6jvF6U/cEe9SXwvHWPRsJ239g/Jx0Z+K062k+oNbDSXRnxRLh3CxfKyL61/Rs9JRBGsT4sbxiGsHJV2XttqS+vN8ex187oiIdKK27uNHKlD8H8I85fFDB66luWRK2+1ccmZYmktGGXZXG/MdN16yrtU6z9eyYrvAt1/DMuD1LmpbvsGIozCQz7oY/q3qk8Sxk7bvkOxL0k/7+fqGVm1dUpuF24W0YrOkrW+S2ix61urMn0UcsdoMN45HnI7FbVEo6Ri2z3yLDHxuQ0Q6aLMwb9xm1bbsGwr/B/E2C4+Bsq4LwlzbLJQht1lSnZe2Bkla50lmcUcotbLNCGLu30o01D8qB3qnduhQPc6GoUbO9F4YOa+OyaP0rgHfLdN89wDjgM/2Cs/plXPra+P4+5z1EBa3lp+/I8L6tYaFYf1CmXAn2TWSUyt9eV7Oh7E0sKys4zauS+BrcSeWH7juY+nSM5vC35kWXa5UKmcL2ZGx0XKhUBor8u3brCNdXOgg/UJxfGRyfCSbHStky4XsjKc/WRyemDQkMuXsfnHMdPrF0sRoZiQ3PlaaHC7li5PN0qcjPXuq9XC06dbND39bXmkhPuF1s/jFoTCu8SPhNel7t5De/vfuMfFSEf/3Ywj3uqqN93qrU+Onq1PjU9p91akcKWwhhGF7Y92i8DfKC7GIRzeLf8rQgf9UJgvgGXp+UEh/AUu/gbdwD9sCjpUW7lF8Wz4vGgrxwnuYd8U2Pkvcehg+3uPcSHesXlsb+6NQ+aU1Mq3qUtSaVuvo+E9qD3sCJzLJEf58xk8Jv/YuszuYKidKe4GTvFUqScoB0+9jXF3oH6ZHfLh8+HfOvW7kU7bfVpPuYf3tEWTDecxnHPsccZTGBMSJwrogjHjsX7N1RCPHeY44uq2jldq+A9j/w/XZVwzV08WywTEZ6j22rRh/fKiO+brwegBw6XmyUwshfL4QTr+pvOYJcfm34fibuHO5YnzSyZ6IvPawvFL8zUMH/ltuRy+VMVF+yGteBOYbAJPGtISJ6/ri6jzFXyjExzpGfAaCqXVzIXsOufcGjQ7vSeWTYnF53xKPvJ7P4s6PSIfLQ+KwQMCRvv3oZVwxTa4P1vGxTFpIB+sUtvm9QvqK7UNRaivJUVgPyy+GYd4vq9bjcSeNIylPNr9nDNVxeTzOR6prmn0jut8N93m6aRa3h8Xl+xcgx24FjoNCOj0Md34M/xTD6RKe6w/k+ij9T8o3JfCV2pp200Gs11Qb08FyxjbtkaE6LrfjaeHZm6v1cIz/xFAd87Hwulmbxm0J5uHyav0et9m8H8vrJJ/T5W0Xj4PtOMZ/89CB/9h2cfuAWPbes0ONaUt9BKnfx/sIXxyqY749vI7rAwwEU2XDdbiXpYX9Y2pfuAzeN1Tn8e6h6LRIrv0xebT3PjAkx0MOGI9jSG0nYUj1mp4bEHjxusdtR09MGlJ7JqXRzcLaLR+p3ca+htSHkcKxPcd0+L15Qvxm/Y++CGwJt0fAkez8AhaWEsK4DcP8og3jfRNpTIa2Uap3UWUX1/eWuCfpV/XEcJfkh3ZIe44yM5rJZiZHipVKtjQ8PlFoNkdJ92lekfK1/z/c64Z8WYfzZ3z+DucCu6qN6dNcGc7fIRbx6GbxvzZ04L80p0rPDwrp4xwXT0tKn8/fSfOavUJ8W6a/NXTg2sXcc644Njo+NpHJ5iq5XH50eKbnvocLw9nR0fHRyeHJylhhcmLG5/7Hhitj+fxENj9WKo9lZzz/5UJ+opKtjI1M5CuZ/Gh2xt89jGdy5p3LxEQxWx4fG6s0Sx/HaylI37qk8yEU//tDB/5bzBPZHMG8GEzrbqo2YlL8HwImnyOQvgeU8kn3u4X4fGxq3UAwtT2hZ/m4AuM50adsNlsZLkyMDk/mzNTW5Iy/y6uMjA9XRjLFXKlQzpXGZzr9idLwZGYsny2Nj49kRoZH29Fn6yQ9obaYyj3NuDfDmheDlYrB6m6CdTrDwue5PvLxv3W9wdT+l+L8SyHF0qN8BCzftTY6mFqvXLwvaCbXeUx2Uj9/UAjjcxBS/7RHSEfCSili8e8io2yT9D4uTm/4nNGm8HemPZdYb2rvTYOZ0Zs049NMb6S2Q3o3SWdSxNkQaS+AmcKKm8NyPYebVBco/b7AqW5m4+SaFuTK50XxWT7+tY6Xn2SrpPccvmCh/ZHmta+uNoZJtkoaz/N5KendHrdxA0F02XC7K7WtyJfPk56w/sB/aT2Aoj6KR2/yd8mO2vdhaW6PXL+Qb17uOJ/Dy5a/o8cwad+OlMAhzX6jLGzaLzyijsvjkZN0JMXCeoR8SHNJvA2Q+kBx6wfi5iQl+01nBKQYZhDEzzlJfdPp9KExvQsYF8pvjxAf8bpZ/FPXH/iPe8hwTBpDWndjdSom55y0blO8VwCHbaBDXA68jey0frbrvUrjxtPWTaefbR1vi6bbN3aF5fpdKO/PR61juXR9/Rlep6Q+C99nkOK/dn0d8/LwWrIRxHFhEG8XpLkiLv+o9SfcLlD88Ri7IL3rRF43VmXMEmDyuSVp/l4qP7ovrVGLe78nvVdrNs7fj12diun4W4+C9K0Hyqe7mlwW1nHZSe+1pHeSgyy+1HZiPeJ9k2Z9+ri1Lrh/2KWgN7ydlMaQKSENaY4xHcFNisexo9Lmssa4rcwXxMkwLn9xc2ndTbCSzH/F2XXEuoBhSWtP4rCSzvHxdSFx8yuO1ignHlNT+jM1v9JMrry/ELc2QOp3x9luyf5IWF2KWN2KWFRurdRZzoO/W7GO+jTdDPeiDQf+W7k/tb4xDuE9u74e55n1Mj/rzq82hknjKXvv/DBNaf2x9ZvC35m23Mi41F/Xw8+VpDaS1303a/gLk0nrPl/D72j+Ittqn0CaH+BrRrC/cFe1Ho+HpYV782KwHlLE2qeItVcRa4ci1r2KWDsVsR5VxNKUl2YetXhJdrZTdPURRSzNuq2pEw8qYs3Zrzn75TKPmrLfrYilqfePKWJp1u1OrY+aNrpT21rNctyjiHUwtEMHQx41eWna1U5st+01H7d3in5pyusJRaz7FLE0+yad2qbN1cfZy2Onttud2nZo1iFNndiliNWpev+wIlanznU8rojl0kZTXGmtoXW0Voq/Azlnw4H/vcHUvoXivHyJr4mjNDDtXkdpp1h6QSC/E6D04+bg+4Swtr7vyFby5czERCE3USoODw+3qhsUX9ovRHq/QLJe6EbWE9I6jT6Qq3VdENbLwrohjDha2X91qJG/m/2DChNJ5I/pS3XzjZCHVspySdCoa1gfpfeKb6g2hklrtfC9orSuI8Xw8f0vrlW6fEOdKz6HHDF/0lq3FKQv3cfrFLuP6WJ651Ubn+Nr0jgXnt+0wFOSxTxBFtK76DTDwHqKe0ZI36KkGXfregUuiu8ny0ltY6d+f2DPVaQ9TTeXt59/48Q1V0+eVb5l28uuK50/vnX71ePXvKxU2lreto1rGK4y5LlFaUhxeDweX9JGKRd8JU2rK3wQi68Wilvh02zXI75aSPo6n55bEJEOxsG369KbcAmfl0dvE84XVRs5R+1EF9VaItZ1DEuy/IS1sAnWFoaFz/OdtxZFpINxsOVeJKQt4XNZ9jfhfH21kTPy6mdYi5tg3cCw8PnFDGugCdZWhoXPD7DnBiPSwTgDcH9QSFvC57I8pAnnbdVGzsjrEIa1pAnWdoaFzy9hWEubYN3IsPD5pey5QyPSwThL4f6hQtoSPpflsiacb2KckRc9m6Q1XQb3FVuvxCMNSn+mWtNmcuWrj5YLXAeFML5acLmQznIhHQmrWxFrviLWAkWsXkWshYpYixSx+hWxBhSxBhWxDlHEIltItgn7ZpvC/5m2XL5A9Rr7KtwmoqxnY4RB6fcFU/XbhU2U+hooHz5jstQNn1Jce71UkA+V5TIhjOsjfhGE8ZdCHrk+ot52s3ufCUe+gwImt7lSm4P3cET9CTaillYOJ9EjxJVWkVP5NttN8osbGvNCz0XtJsm/sKL4b9lYx/xyiCl9GcK/aFawASV+g7CxrPX0OFs7AWpFMNVR2Eohzykhfpr9Rt62PV6wvo7L4/E00Y7wE1iw3vATWLDurWZhqPf8dJaZ0t2FiumgjLidGVBMB+W9lKWzVDEdLDsqq4FgatnxmdCkNkv6Up2PP6Jsy7c3yGlG2Ra+MxjFvx9sy3fYWxw345vsMB8foOP1H/VXqv9cn1dBGNfB1RDGx47oJLtBsrB246j1dVwej+cDy3YFC4v7ssVRvyWfpC5g+jP1ZYs0/xX3ZcuAwFWyD7xuSv21ASEdCYvmCXoZdqAnj8os9rFzSXWjU/vYUptLz0o2PT0jcs3mpbYpYJxxDorbtKj+MXeS3aqdwGT8T4bquDwe54PlzvUeuSrKqcjzGwi8sM14pjqVPzlJFoeCLFrp+6HMl7Mw1H1u31GfeJ8R9ZD3GQ8V+CSpm9Zx+4VlNT8iXxrpHAx9zIEg2oakgql1PC3ci+v78b5sVN9v7UY5zai+H9+xhOLvgL7fUHjtdp6itTqO+uuiX5jUbpAs2un7LQd8qc2k66jTfxYK6fG527i5AKmvks3ns2aIP5KtlCr54shYbiI7nB8erhQqI8OjhVKlWBgvjZSzhfF8bqw8kqlkR8vlkWJ+cmS4Yg9lrFBaJM95MXlroc+Um6xk80WTUmZ4vFAsDedzpdxIplQoVrLZ0WxurDCaz1cmC6Ol0Vy+khvJTSbpMzmad0u8qxSlP1N9JskOxfWZDhW48jbEumur9Xg8LC3ci2uPuO2cLpZ1fEfEuPd2jnQhP11dcP3ertk73OnoArdP7eoCb8vjxsaOxj+J6zIf/7geG3fIO4Z8XDmnY/g4ek+eIz7SezNp7sC+b+sJovt3XCeRN7bfdI+Xg5T2GdUD/6X5et5+DzTB4muzpL5wXJ1HLL42S5JHNwurQH/xko2NcWi90ATEuTS8jpubdTumTF6nKf2+wGkdysbVIWmcYHV2fhCvO1h2UevV+oS8JtFl5JREl6UxM8WzOlHaOL14uAIWT/a5KibeAiEeT4vv2IQY3SzuG0MMi3sT29EUZcF3L8N1iX0sDMtlkIUhJ76bpXSql7RjcD8LQ/nwlcq4dibuK4bFLAx18RAWhuW7iIXhehFa17UwmDpOvRVsyr1s7Jt0TVJcW4F2nuJLY316ttPej/AxsvR+VBoH8zqL70d4f2wNhLXz7uTHUF95PHJSOUvtGc5xkG2S9Hwp4PK5E0kf4vRnhRAf5yu4/qCO0LOd+g7dhY5Q2GEQhjLhrtk7+yT6E2cbkuoMPSu9a12YEDdOd+N0TOKNdY7r2IDAW7JfUWtrcM4J8xb1zvg5aAdpx1/piy1ck2ZdF4Qp9qnK0s66KMPuamO+49oA61qt8/z9I9pm/v4JyyDqXT9i4joi/NqHeEinp1hHNsbNDomZMd4vQMf7Nta1+q6GeLf6rgb7Ybyvhf0bbtewj8b7KVhmvD8lfYnK/wfB1DGHdXw+JO4E2bRiOny+GdNxtRt7VJ9YIx3pux++Bm429R/LVuoz87LGfjEvH1wXzWXKv4MJguT1jeSUtI3tFdI5mOSLtpo7Sb4Uz/Kck29z+bZ6Ys105TuP5WNT+DvTnuso+SaVIcnCcmnlPSfqKOUp6hQp6cQ9wiAbJH09bh294+Gnw/+EvbteAM8rlql4ihSlFXeiupS/tJC/CyLyNxDONdm4/72xeXpxJ3RL37Xy8QTflQIxqHy7E+aB4v8i4ZgB22/ruqqN+dsU3s+058TTOLC/2l1tzLc05sP4fMwgfVOLdZrvxC/V6RT7jVjSiVRcz3qE+IjH9awv1DMrm2OGGvlJdZzCpDnXuL4mhaFu9QLno0MevYGs45vC35n23Ij0rpGcNJeaYmFYT/g7VL6zCIahHrTazpEsLK9WTmaTdq+Q7AS3BQsErlK9JfzZqLfYxvJ6K32jH7cDTrN6TuuwpPVoXL+xzvSyMOl9Bq8z1p3B0pPm/bHOLIS0eqr1uNrvXa0jWaeBc1e1zp3SJ31ZAGEUj7j2uuGaIa59IT6eetcLfCgv81h8ft3N7r3giDpvzCOWI+abjxsWQhjFT8M94kjzSD0QtrDaGtYChjW/DSziNSjEnz9NXhJWD8PqFbDwHn4PeALUCeyLSnMduL7yJVCmaNuwz4PP8j4PxX8V9NteFl5L+6pwmxu361GrJ++1OgfjeN4k8alKtT5J4LQPkOV9JpSrdFKv4zFGgfhI+9RI5Wzfty4OppYZ8qu1yfA83+cm7uRW6R19XP9Aav+0T27FtBcGrY2/pHrM6znGvwzq8fWsHkunMKUYvyCIL8O4Mkf5ElepXHpZmNRvjesTLYjhFdcnknhhv5ivye1jv+PyEKd30hh1FvulRalfinnn/dK48aF1vAz6hfjSmHGQxUeZS/WSj9ekd1Ct1kscy10f0ZZiPtDO8neyUv3ENprvb0VcNoW/My268ZHyWGE4n5vMV8bGRzOjfM4nABktdJD+SG6yOJ4vjmUmy8WR8eGRZuk/F/7oZWHa7WSvkE8t/NFMscznSZX55x3P92b59w3K+Bmqb6+u1vF5Xqzjc7L4jK3rpE/2+mh4xrpLATvFwi4T0qWw11RlHtZdDmHcTl8BYfyE3tdCGNpwqV3YFP7OtOGMDo467tsNLw2i+2mk/6dUnaSdI/xT3eDX7MNpIX6gh50h7NOBe8oB9zPc4Ndk/wo3+HnCP9NN2dbwX+kGv0D4ZwG+C/052438a/jnuJFPDf9cN/Kp6f95TuSTq/E/3wn+cI3/BW7wa/p5oRv8IuFf5AZ/jPAvdoNf67u9yg1+hfAvcYI/UqD5wSfDiqW55qrTdrqW9ojm8yQSVpeAJY0Lo75ToHDpfxAkk6Gj3ctrMuxOmG9pzozLUMKS5hPj3pO6PU0jMxw3Jpd0h+LPbzH+ghbjS/NgXTHxm+3DnWQ+Ky7+ohbj97cYf3HC+FSnpH0uSFdwf1IX7/zi6iym38e4atfZfpaeJItD3KQ9klQWhzBZOCqbrOP81uyjtK/4gJDfQRaf5x3jSljWkc7bukf2Y3N5+7lbtpe3zYvAwvLANHl8fk2uJwInHUzVM/4sH1v0sHDJduL9BRH3eyPu90XcXxhxf1HE/f6I+4sD2Z1abfx9Dvt9ejU6PrZlg8FUl2Ke33f1O5jBtDS4kk5K16mYOP0R+NY5nr9MbDPpXl9Efjbp8KnZtDTjw+XD216p38zfgVh3WrUej4cl6VNj2DmKWJq8NLHOdsDL9bczFC+uXk03HQyj8nd8ilORf4eGadv2bHPQmHdpXQy2tYMQjvGHU3XMN4T3ZnFNymhS29QJa1Kk9QPSWlX+fhb7FzjPysPi1gNIWKcpYp3Tobw0sc52wEtax9yu/cG6RjqX5JsDad2JtGaDr0dOerqh9M0f36siyn7dw9JsZr8WQDjG/0FQx3wTy6NkL+h+s77GqdVGLOn9LucehXUKw8Lnk5zjhlhnMqyoc9ai9BmxXsmwotasRekEypfawSRntTXD4muYpPUsjufjRohTX4tcpX1+pO8HU2pcC8OSLPTwhyd7WX6U8UekNVopJrtFTso5m3gNLKU/U3tGJl2TJn1rSM9K68+4Dkrzo/1COoNCGH+H2A7WRUpYUj1oh9eFSrysu0AR6zxFrEsUsV6liKWVR8l2dYpOaMpeUyc067Ymr4sVsTR1VbMcSb+or0tx/zL873Y/gvqeZ9L+I1JfQDPtFEuP5Bew/Mbt3Vf7LkwIa2c98NhYuVzMVcazmWJ+OF8uxPURp/s9MsYnWfe7kXVBWqOP++1Y1wVhfSysG8Jq3xUa/2yqkb+jvlsi+Uv9IYzP5zmSluWSQO5rkHyk+olhqNN8zzfEbGWvSdSzuH0vaYzS7FsdaUyTYmF9QpqtylKaR+DtdbP5gV4Ix/j/FP63v2lT8Fbz7GJ+hGN1CfmyjvSzm8X/9/C/1YH3pRoxJbnjHMWp1SAyr0nOQkcsPrcRdVZ5lN1DLD63IZ2LHte+Ihaf22j1vHNpb5QB4fkk551L35AOCM8PsDBpbmcWv6satbr2wVSdB88vtgfWS+evS+sKKL60DgExqC4MCvFpPa4kn4FZlE9Pi/LpaUM+p1YDUT5YxztNf+L2i5DqkmRnk+rbKUw+uA6mL0Y+OOc40/KJ059mdp7LR5InYpzJ5COd6+eT/mjvN/JKJh+pfXo+60+zb4/5N+con/4Y+RwM+oNtvySfxSxM+hYb+7CUpvTuCfuPp1aDhvxKYwR8H8f7z/RC3sruKxFpJ+27UvwXAibvu0rvvwaE/Ez3/VdcP7jV919x/eC491/N6h3vB0v9cz5vwONhHKlPjuFR/X/k3GwcwPvb0x0HoB1pdxyAdS5uHJBkvYubOZjka7kp/Zla79JsfMXfPy0WuA4KYQtnRK7Z2pp07DMHjDOuiW51f06c7/p1aFN4PJ4m6vISJovFHSILvoYD961Hu8adJCfKk33ud1uQE5bHEhaGOsPPA+Xfi2OYNI+VYjyxLUObz9syin8VtGXvmFfnaR32cfi35V3VRp6bwvuZ9txIq30cae4jro8jjUEXC3KSxqAdMMYS5bMgRj6t7s8jyRMxTq0GDfKRbKNP+qM9xuJj9A4bYznXn2byOTNGPnFzhLOpP/Nj5CP1q6XzApPqGx+jS+8nJPnM0F7HI62O0bX3LeNjdGwTeb9NWqcorYk/tdqYH2n8iWvWXcp4ZLS+zyiVL+4ziq4LwjH+W0IA7f2kKiPj2Up+vDJeHC+VCpPjzfaTovvzq/XwNOO6n394XeuTYnwW1ludmn9Kh/ZRpT4QxyIefN/V94YA0r6ofD9RTL+Hpd/AW7iHus6x0sI9im917+3hQy72CZssDk9MForjmXLW/sw1K1dJTmiLrCNZY1n0CHnrZvE/mqrn+eNgZ/bHFdKz8b4cEy8V8X8/hnCvq9p4Tyoj1F2KXxvfVqdypDDcixbtpHWLwt8oL8QiHt0s/heZ7qK+0fPSXri4tzBPS0qf6660D+9CIb4tn08ze4R51x7770+T4eM9zu3LDutVeaIwNjIxNlnMlDJj2bF8s3qF+4akGP8gqLeHUtsVt84/HUxtD3k8jh2VNm+vMa60biQqfxTOzw/Atve0amMYPfpEGMmW39dSjXEI7xtgR/6I9VdQfrSPljRuRz3ZF/6Q9v6zflP4O9OWK5Qdr4Uflb5/08MfyUv73inijxN+rxv8nONvBWryWeiGf1Fas6aHnytJ856K/EeluURF+dfKd8AN/4y0d4oi/rA0F1rrq4TX2M7ota+FySR9KEy/j3F10d5jesSHy4fP9S8VuA4KYdzGS2evSuesDwphfK12O1iXKGJdqIh1nhKW1P61w+t8RV7zFXlpyUszj5q8pH5AJ+iq1H/olLqtqRMXK2LN2a85++Uyj5qy71PkpaX39nqhIi/Nut2J9VHbRndqW6tZjhcoYh0M7dDBkEctXtp2tVPbbT5v0in6pWlX+dxNO7wuUuSlObbq1D7mXH2cvTx2art9MIzTNHWCzw0/H/Wez093Sj9aczw0qMjLpY2muLgvKO17aB19u8nfYT7M3hm62eurUJLWqaWCxrQXOEo7xdILAvmdAP/WX9pfsk8Ia+f9+0S2ki9nJiYKuYlScXi4dkZB0n0SKb60Jk16v+B2b5HCRNy6UWm/iwUsrBvCiKO030WvI/5J5I/pDwrxp7uvJ+13gX1MPCeO8MjR3prSGsfTwjBcFyDti5Fi+Lj3BX679tZ5da74HHLE/EnfB6Ugfek+XqfYfUxXOj9TCksJXHh+0wJPSRbzBFkk2YME6ynhuVjHU6iMjA9XRjLFXKlQzpWarnvk60T5Wpvp8mDO9TmaRbR7Dvg/b87RxHrC82KdZF/oGWurVgX168PhGev4OX8YdqaQLoXx8/UwDPds5udo4p7C/BxNtL18LTqeJ8fX8WO/mLdJOCbjbRnOZ/Jvb7C/x787wTkJ/s0F9u1qa4rD3y6+XxvNFEalNSeKelhaKvDne4Y8X84CdWGDrDvdDX7tPLjxEE/6xoD31R3Zq3KKpRcEcl+9tv43cGufUyw94sPlQ9e2LpN93Fzefv6NE9dcPXlW+ZZtL7uudP741u1Xj1/zslJpa3nbNt7j4RaQh6PjcXg8Hj9pLk6tHvgv7e7Ne41dTbDiduTuYljdTbBOY1j4fDd7riciHYwjnbKO4RI+L49mu0KczjhLafYKnBW1t0hcF8RwxfTjdmlwzLU28u1tkas0Kkuz3zwexpF2jsPwBULaqZmRSewO6XEyidsh3RHXUeK6sEWu0i4WjrmOEddFLXKVvpRNs988HsbpEZ7H8IVC2jOka+Mkk/4WZSLt9uGYa22WZnGLXKVdBR1znSSuAy1ylXrKafabx8M4PcLzGL5YSHuGdK1EMhlsUSaYb3pW+iombiY3blfjRSwMdXsxC4sbRUt9HWlWic84YR+B71gr7VbFdw9AGyLthsJ348H6QLJdGHT+18OV8Pdsfz1MPX2/Z9EKI3OzaPGO6t6p1Tp+0lk0esbaINypZwCese40wE6xsNOFdF3m2ehE7SstR6fv5ZYG0baSZiRWhr/TQlysC1E7VnObImEgDpctluOm8H82n8+aJmwkWylV8sWRsdxEdjg/PFwxM/DDo4VSpVgYL42Us4XxfG6sPJKpZEfL5ZFifnJkuDJWmhyu8LzOi8lb3Neqzd4wdLoNXxv+nm0bvj68nrPhsS7v2MbmHNsb0YbH9dMkGy7NjJLdbmbf0YbzfrYLnRuFU8sclVl2aRBtc8mGrwnqDuXMv5hHnG4Wd3n43/bxl0bg9QTNbWU64jl6u9UrYASK8op7A4884t4s+2Dbh8Lfs23b14XXntv28TnbHu9mwrbTaip7jbtlWifZdgqT3rxLb875+x98c078Xa7Sw/bC0bxPYanAn9Ki9oJsoJ17WRFemzdp5h3aJePXXF0a3371lusuLN9wY3nbdnwFhSLkYgtYsjxpjMddiv3mL0VT7Pc8IR66JIuG4hYlSd39uMVbPjQXNI0y280FdgMwbG4o0ODyjs153qWZs05qLqJeKVtH5h2vidN0mxRe1xEbhw/2uraxXyDbjk1B+3IhvXE1HLFuaRDdRSfzT937RXB93ZbtV1duOffGa665unJ1uXTulu3lgDlu+qPMMmaLP8cdxfPBhNJM2Wyb0Fx47bkJnZgpE+pq5YC0h5prEyqdE0I6TGs98bpdE+p4BnzYsQzz0rp9koHbb2IyhRRLL2ByDFj6M3UmRtK9mKXvTPgIqqs6NR/SdyZUvjbOYRCP6xY/7xOHDTRa429yrSN9t/hHQ1rHhNeOm/WJ2WzW6d78al0etbYX7nWD/PbLB+OzMBf7Kx8V/u7k/ZVpNmthUO8unQB4vK7wt2aIZ7tXNKNxoHt1ytby+Ha5cyV9VIO/50WQSDoeR/wgJi2OifF86ahlw9+z3VEbC68976iNeT7WLXbaWJfi8WeaddQcv8pyLae8685enIGOW/bFbab0n7B4GKXVFzjV4Wxc3pA/6YZ0aDf/GFTC6mkRazbLFGUdd2gM79B2QRj/gA07rZRH2wkYgni8DvI5Ymyr6PWDxTge8KhT4bhjOjbXMa3Hj+qYHhf+7uSO6cbwGjumecCLqiM4qKfrJJ/LOKrPOeIqfdokTW7YTvSy8Hrb9i1by2ded9qO8uSN9hXVKeOTVyWepZwXRDfMmFEJIw3PS86HTvFo+Hu2O8W0VsXzTvHoTHWKHXXGCo5nR8VOsWRwkrwAojhnQBx852+di5dEUgeR0o1ar+C4QR/thBdIZJCtcR4Krw/McJx23Q03lm8slw58lHv6jddNHjDU11wTMMc73Sn2O+ptEv3uEnC4w+dSkIdOt9Wrw9+zbatJTvR/WaAvrwzY6kPd4GdwR6yA5QXT5W1SoMiB8EgPpAm5eSys1olk/FL6/LKcS1pIixy9ND4U7pE8/z9tTcr97tEIAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAWLQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjbbuM4DIbfxde5EClSh7zKoCjSNh0ECNIikyywKPLuS9qinMxCQurM3FSfGes3KZG06q/hbfty/vm8O7x//BrWP76Gl+Nuv9/9fN5/vG5Ou4+DWL8Gp39SHtawGrKfhjQO4HwZ47AmGQGHNesYpxHLNco16I0eDVTBC5A3MAurRdUiCCSFIJAFEhiYJYsFdVbmCdA5A7OAWaBacgH0BqmAejhBLEBgYNPZBKNOF1cxkwAriI53q8G7UECfPgEXQLMgFdCHTqCzZH08OQMuwGZhswSzBDJIBdSxCWKBhAb6CHHeZ2fABrIsXsIhRwapgO7sBGbRpZvALN7uGaNQGKMYgQ30EbJQxGSQCgQ0CAU0ASYwS3IGOl1ygzIayD0kAbI6P4EoEwqANzCLOk+kkAr4osO67yOQWcgsbBbWfBY3WF0dIUqApKAeUlBQi96sKUpRgackCQ4MUgH1cIJcAMnALN7uGTNTIGqqU1ZIBcZIFRAMxEOW1IqeDHIBMovGNYHWrSxdDFwgOoNUIMkjGBVSgWyWrNMlkZIGOEEoAGYBs6BZUJ/lL5fVYG3n+XTcbrXrXPUh6U6fm+P2cBrWh/N+vxr+2ezP402/PjeHcTxtjvKrxLE9vMkogu+7/Vbpsppnu/ZUWeJUZgfPqQrwNxRSVZDiaSlg1weoPhBXhXCr4NsKKSZTSMlhS+HeKCAuWQfSGigKAVsKoa3gg6b4qCBtbV5JCP5GIrYl5LWTiwRgzrNEvpVIbQnJdsunmBhaa5k7ClLAphBCailAZzEBKHsLBBhDS6QbCM6BhKYCYM+NzHU5YV4LeWndnxZ1OSUtaFFizanJ6FoK2pPbmQW+Zpa/zqzbOCA8XKUQHy7TuyOh2I6kq8GxasTc1MDOplAAy3HZVWprwMOVhp0EjZRrqbFziySkuqoExkUSAaAWPLQl4OFixV77xGwSkqrULFbs9U8Xa9txaU4Nz79pdPpOqpmRPLUVOg00QG0ZPrQVunEEqHFE19bopnhdC4qu3TQ8/l0Nef2hxRL4ak+Av6GRrOTlf6y0TCNyfbfGRG2NTo6iA/MDHc0dEOXAcKPR29tQC1aWhtsa3VgymUa6eqf8L5b8eCzk/nIscxuFRKEZy92vhByaeUqdQyhkV2PJdHVYAP+NTlr9kKPTwmZM+LDEXQc4in/gANdLDjkj1I29Llr2iyQwL5LIPG9rCAslcJaIyyTIz8n1WyBPcrl53R1vPmJdVOy427zst+Xy/Xx4vfr19O+n/WIfwT6PH6/bt/Nxq0rzlzD580PKcyXl9aSfvvRSKhJ81EvQSzmiSv4/XdSZ/wA=",
      "brillig_names": [
        "winner"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "join_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "is_init",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "game_over",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "first_capture",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "join_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        join_fee: PublicImmutable<Field, Context>,\n        challenge_fee: PublicImmutable<Field, Context>,\n        slash_fee: PublicImmutable<Field, Context>,\n        deposit_size: PublicImmutable<Field, Context>,\n        is_init: PublicMutable<bool, Context>,\n        deposits: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        game_over: SharedMutable<bool, 1, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        first_capture: SharedMutable<bool, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    // #[initializer]\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        join_fee: Field,\n        challenge_fee: Field,\n        slash_fee: Field,\n        deposit_size: Field,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.join_fee.initialize(join_fee);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.slash_fee.initialize(slash_fee);\n        storage.deposit_size.initialize(deposit_size);\n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n        let current_block = context.block_number() as u32;\n        // You can now use current_block for your logic\n        if current_block > storage.end.read() {\n            storage.game_over.schedule_value_change(true);\n        }\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[private]\n    fn submit_score() {\n        let score: TallyNote = storage.tally_note.at(context.msg_sender()).get_note().note;\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score.tally)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        let (gameOver, _) = storage.game_over.get_scheduled_value();\n\n        if(gameOver) {\n            storage.final_score.at(sender).schedule_value_change(score);\n            let (winner_score, _) = storage.winner_score.get_scheduled_value();\n            if(winner_score < score) {\n                storage.winner_score.schedule_value_change(score);\n                storage.winner.schedule_value_change(sender);\n            }\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        // Ensure the game is initialized\n        if !storage.is_init.read() {}\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[public]\n    fn slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == context.msg_sender(), \"You are not the challenger for this address\");\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n\n        // New values assuming the reponder does not have the flag \n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let new_responder_note = CaptureNote::new(context.msg_sender(), 0);\n        let mut challenger_capture_note = CaptureNote::new(challenger, 0);\n\n        // The responder has the flag\n        // Update the values accordingly\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            challenger_capture_note.capture_block = challenge_block;\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_responder_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
