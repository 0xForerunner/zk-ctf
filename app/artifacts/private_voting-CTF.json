{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZzdblS7DsffZa57kU8n5lW2ECpQtipVBXXDkY4Q735sJ7ZX2VrRNMO5YX511/pPnDhO4lT8vHx++Pjj7w+Pz1++/nN599fPy8eXx6enx78/PH39dP/98eszWX9eAv8TU7m8y3f0iZd3QJ+Zfm78ieOztPFZ0+Ud8mcbnzB/BhifLczPMj9xfPb5c+/jE+m9mO4uKQSFPiHChBQJGgN9WaS3Uk4KailRoSrghFoU1AJZgV5P/BWtTuh5AkYFakbqd5fMLRxQJ0S1RLUktXA/CmS1ZH2GmzpAlbkzB6gF9JnGFmpqRmpqDneXEuhXOTHUCdyMAWpJaklmwQlZLUWf4WYIVFXmQc00+gWqAk7g8RygFu4xAe6xAfxWY8ABNRQFtUS1RLWkrNAm8CgPgAncdQP4K5ABJ/AoD6D4KdRRlUd5QJvQooJaelJQC+oz7MUAHADsxQD+ikgQs0KbwLE6oE7gABhgFpxQ+PXE0CdwJAyACRwJA9TCU2sAtycz4AQeiwFtAs+vAdPSOH4GcHsKAcfPALVw/BRkoC+t1NSWowJb6Nsbj0VlndYn8LdXfp0ntwCqBdlS7y49sAUY2EJD2bkPB6iFI6F2BrZQMzrHoQD7DoGhTuhq6WyhFnZkS2JgCzUMeeYOUAu7DIWBLdQwZJcBGOqErJasb/HAiaUUBbVw+HHjkcOP24McfgPU0tiCDGRpbOEeG6AW7rFGjY+Bs1XjVBygGJmNI3gQh3ADoaaEM2iIZtTEGKKR2aLZONn2wMQR3KMQKGWzZbNx/phUjLpSzUZm4zViEqvI9/KU7FmIbYWpRyOz8aBOKkZ9UuKommS2mIxYpTKJbyDENl7IkvjWhUCpmI0TzSRUEt8GdSUwG2ebQeIbCvGqyL2b2DeMQqCEZuOInYSTMvs2qStFs3HiGcS+YRJiZe7TzL5hEWJblQU9GpmtBqNi1JXYt0lma8mIVWSrIL7JZkF8Q9k28LocpAns3MAii/1EXp0DK8lipYiG2R/Ibi1uLW7lkVF0K/izLTj6t/XoCIYoz2bB4oiKNWTHZshxpwiGKThWwxwd3Vr82SIK3Lu1RsfqiIayq5nYDJu/1vy1HhwPVhcbHg/sihCSo7UMYnAsjv5ayo5uzS6Wrb1QomN1tJZBdbHqr7nzAP4Vza1NnuXohJ4cwXAM98Di2BVbSI4m1qJbo4nJAkqJVrA4omF2a3ZrcSun0om8KVBshrwxUATD5s82f1Z22byXptwqX5EF5Yt5FvbRyCqIhtmtWZrDvvXRSO7UPtrQBaUNsrWXkEtRkNuQuA2dJ1ke1JS4oyfhJFmjB8m+dpDb7DnZLwY5OXCDEgh2Q86Rim5Nbk1ulVCc6Nbiz0r8Daz+bSBnliaHluhYDdEfQLPGEBwPVjSMbk3+bALDHB2bYUmO8mxlrMGxOqKhTJ2J3VACaaKLDTcHNkN0K9qzSeYLH2IIm2GMjtURDccIDfTXsr+WwbC4tbjY8HhgceyG4C0DF2v+WvPXmresu7WLGB8hE2bHpphDdKyOaBizo4nl5NbkYjJuvIVMshYrdkMZoYEyQrwPJkRDaZmgHBsnSuLmrTJhN5Q4Gyi9zltfQjAsbpVe5410GsvwQOn1iW4Ft4JbJUUP7IJVzu7RUb6C51uViTPRrTJjS5OTfnJshtWtfKyKRYoBkrsmulWCYGI17G7tbkW3olnlcDhRxngiGiZ/Vtb0yuMG0iV8wkpyrptWPilEPm4lOdtFPmcRdkM0qxzsFMEwulXaMFDyPZ/M0liUBma3SqfyiY3mgnwFCIqVe7LJMsynNEKxskNNwlO8aBKeAyWXDJSlVdK2nAkpkxF2ae9AWZ8moqHMi4k8sFlqNdKczA51GeOJYCgJemIxbP5s9wdkYDM73yX6JnZFlO3eRDQc7R3o1tFe7j6UOTQRDGURnYiG1V+TlX4guIKEJxdZCKsjGkqUTGyGw6GB+hrVs4LjwYqGMTs2QynHcRWGsBlK7ExEQ8kPAyUrT+yGoGNBCIYtOLp1eCEVuOEFSg0uG0qsTwRDWUK5bkNYHdEwZ8dmKFluor9WXawerC4GLgYu1lys+WvNX+v+mqRtrg/lKGlbcKa2JEVCeTYLNsPxFQPBcAR4ECyOaIhuRbNKqUvRrdGtKTgerN1QtlQTwbD4a8Vfkxkgvo3dPdegMgyHBlZ1CEYqHniwoqFkxFIFu2IL2VH6jEN5bN4ngmGyr5D618ScHbuheDHR2tCqW6s/K7E+0XWbf9uIh/zr191FS/Mfvr88PHBl/lCrpwr+t/uXh+fvl3fPP56e7i7/uX/6IQ/98+3+WT6/37/Qb6lzH54/0ycJfnl8emD6dedvh/NXaf/OM01eJ65gElhfacRzjRq6toCwmwK8bkU6V+iVTx+i0GsOZwprP3gro370dOZHOdegSkCbErQxgbNW1IUfpWhndtoH7flxHI9ezvxYaVAO1gEhTtE06ut29IVG5r3akCjRW0HZ8GqJwkWxIUEFjlOJuHCFiuBxatAczd4Z/bXEIjobmELz2KSt6GZ35nrWnXzaPu8Mc4QyYDttR1zEJ9XJNcQ7Lbln0RVXARq6TTQa4lMJWHjC5SF1hZqfd6I80IrmXYr5tEv/QIjGPxCj6fYYTYsYjVh1WGgvkA7RAXtdSqW4sy5Niyil06h2KZ0742k70iJK6UClCYwOSeFcYxGmBaIOC6XRcq6xiFO6ptJZ22h9OV2V2kKioDaj1RC2JCq3cUoc5v1bJCBafNEF5KnEsi+S9wWcTvu8CFG6bdBZn+kgZxJ04/AGDdRm0JVFOddYJdLA12EzzDu6Rv1NY5VILbqo9HmusAhQiOoIHLLovxSWfti6RC6FU431NLG+oBuPfjpNcv//anCNX32BehiTWN+g0S19tdj3NFq1bN4OW6e3aaCtKjRr9jQ89dAODk41lmkUcrQ0WvPpuJRFfFRPPnSXdJ7Oy+1ptCwTWLI0Src2pxKrHqVCmk17KpSdprB1d/g5hU6zp91RF8ssbcm1HVwEPx3apUaKtkJSqXJXo5kG4J5Gto0LFafjpkaqplF323HYdbS8p1FsU0pF7l2NZH1aat/VANNom31a0OKjhs121GT9cZz6b9Sw+KiwGafV5i3tBsueBvh8gdJ3NWxsATb7w5comnJtM63bAYwK9ee7Y1jkU8i2NEAu9SwVwiKf9tZVgmrj6XRPebUnuHdWaAVNo50vcm15dgLN6nQvfJz58fp2oC+2WDd9QTBfENu5L2VZPwpWP3qVTfNrjbrqjwB2lizxVGPlCxXpdWypMl/PfVlFaS0682nCnUd6W4Qpdl0YEA/rNf7WG7jwpGftjdwX6+RSA5N6kilQ9jS6zRbSqJsa7gtm2PTFCh4ZFzlsrVF1bSkhxFt9IY20pUElNasSBAibGlZEKqFtt6O7BtzeH21vXEq0fTZtgTY1gq3XVFNLN/sSS970xbJ6SWFzbFOwsU1xc2yjHSlJo93cH2lxtF22I0fTyPm8T3F5iAp2tRAPtwK/l19WGZmuYYsXbuE0J8ew2Eg1X/bpLsxFuK70WmRVTPIkdLir4Vh5LZFWhzm0ZT8FXIgsCjnVJt3x5uptEqj7Soh105VkeZ2OdWlTpFmQpbZwZrnsgx0aAMr5Nkhi8XQflA8VuoSn1xRhNety9WLjcU/3r0jtt1+5LC+g0KKMMG1pdPn7zXlvk/ba0YNVs/c1oh1v6f6obrbjujuoP3IJtS6s1+Z1qc3afEk3S1xVHYurK6iry2MrjWpz/9V+7Leb1pT+QF5f3UFdmdeXR7Fr8/qquH5lXl9KXJfXl65cm9fXx+zr8vryetHqSXRzUbckolfF46GM8yYJ/yOP2PdakW1QCPdaUe02jS6N254E+L1zxz1HgknQjdyeRLHNXK5bjvyJ0ALb6kdoe440vxRsmLYk0LsT05ZE87WgwI4AFl0YsW71g/8BE6a9Ftj8wlZvdGFPoHebn4SH+8h+tQL6HgUP5dHfV7LVfVPqVgBLvcetVjQr5b36k45+/WDavT++KsK9oQ1WsO54+CObN7XBKnDhcBv6JoXkCvFWhbzXhmxRGUq+dSyOf5DyBgX700A83ve/SaHdFg+x+6a5HwsRNW9JJNySwOoFaoBNieQSbU/CytOEe45EtL/aSuH8z1mulYi/lWTe04/3nx5fXv3/Hb9Y7OXx/uPTw/zxy4/nT4fffv/vN/2N/v8f316+fnr4/OPlgZX8PwGhf/4CypV0TH9/d4n8Uy130BL/xL/MVJHKvfCP8luKYKjh/S9u2v8A",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgADAAAKmCUAABT7ACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYlAAAI+AEiAAGASAADLQsDAhwKAgMBHAoDAQAcCgECAS0KAgEmJQAACPgtCwQGCyIABoBEAAckAgAHAAALDicCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAuhIwAACyctCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAALTCUAABT7LgIAB4ADKACABAQABCUAABRbLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAC4wlAAAS9C0OCgEtDggCLQ4FAy0OCQQjAAAMFCcCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABUNLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAUWy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBIAAMtDggEIwAADBQmJQAACPgtCwQFCyIABYBEAAYkAgAGAAAMNycCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABUNLQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEcABAEiAAaASAACLQsCASYqAQABBQLcbieAdhKdPAQCASYlAAAI+CcCCgQLLQgACy0KAQwtCgINLQoDDi0KBA8ACAAKACUAABDrLQIAAC0KDActCg0ILQoOCS8KAAQACicCEAQRLQgAES0KChIACAAQACUAABHxLQIAAC0KEgstChMMLQoUDS0KFQ4tChYPHgIACgUcCgoRBBwKERAAHAoQCgQMKgoPECQCABAAAA1PIwAADS4WCg0QHAoNEQQcChASBAQqEQ4QACoQEhEtChEGIwAADXAWCgsQHAoLEQQcChASBAQqEQwQACoQEhEtChEGIwAADXAAKgoGEQ4qChESJAIAEgAADYclAAAS9AwqCgkGFgoGCRwKBgoEHAoJBgQEKgoHCQQqBggHACoJBwYcChEHABwKDwgAJwIKBBItCAASLgiASgATLgiATAAUAAgACgAlAAATBi0CAAAtChMJBCoICQoAKgcKCBwKDQcAJwIKBBItCAASLgiASgATLgiATQAUAAgACgAlAAATBi0CAAAtChMJ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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAECAS0OBAEtCAEEAAABAgEtDgcELQgBBwAAAQIBLgyARQAHLQgBCAAAAQIBLgyARAAIJwIJBA0tCAANLQoBDi0KBA8tCgcQLQoIES0KBhIACAAJACUAAA3bLQIAACcCCQQNLQgADS0KAQ4tCgQPLQoHEC0KCBEtCgUSAAgACQAlAAAN2y0CAAAnAgkEDS0IAA0tCgEOLQoEDy0KBxAtCggRLQoCEgAIAAkAJQAADdstAgAAJwIKBA0tCAANLQoBDi0KBA8tCgcQLQoIEQAIAAoAJQAADwQtAgAALQoOCS0IAQEnAgQEBQAIAQQBJwMBBAEAIgECBC0KBActDgYHACIHAgctDgUHACIHAgctDgIHACIHAgctDgkHLgiARQAMIwAACC0NIgAMgEkAAiQCAAIAAAhDIwAACEImHAoMAgAAKgMCBAAiAQIFACoFDAYtCwYCMAoAAgAEASIADIBIAAItCgIMIwAACC0cCgYBAAAqAwEHLwoABwABLQsEBy4CAAeAAygAgAQEAAQlAAAPeC4IgAUACAAiCAIJACoJBgotDgEKLQ4IBAEiAAaASAABLQoBBiMAAAKuKACABAR4AA0AAACABIADJACAAwAACOkqAQABBfeh86+lrdTKPAQCASYlAAAIwScCDAQNLQgADS0KBA4tCgYPAAgADAAlAAAKxS0CAAAtCg4LJwIEAFQKKgUEBgsiAAuARgAEJAIABgAACngjAAAJMQsiAAWASgAGJAIABgAACk4jAAAJRicCBgBYCioFBgwkAgAMAAAKJCMAAAldJwIGAFkKKgUGDCQCAAwAAAn6IwAACXQnAgYAXgoqBQYMJAIADAAACdAjAAAJiycCBgBgCioFBgwkAgAMAAAJpicCDQQAPAYNAQsiAASARAAFJAIABQAACbslAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACeUlAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACg8lAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACjklAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACmMlAAAMEi0KAQctCgIILQoDCS0KCwojAAAKogsiAASARAAFJAIABQAACo0lAAAM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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZvbbly3Dobfxde50IkSmVcpisJN3cKA4QRusoGNIu++SS6RXE73EmxNexN/w5n1DylRog6Tv+5+e/j12x+/PD7//vnPu48//XX368vj09PjH788ff50//Xx8zNb/7pL8k/OePexfrjLpd59bPIXj791vq78OieGVg2IoTBAMzBLF4uoYWEggTGBskE/oKRsYJZslgwGNKE0A5wgDh4wv6I0e7yZYGco7HMRN0pmEDdKFYADakoGZslmyW6hCdJKB+CEWgzGBHGjDAGaANUAJ3Sz9DFhgIE8hQxYDXACmYWmpaVqMCZIGx7QJ5RkAAb8FZWbpUkbHoATGodTs8CYANkAJnSzSPMqDLMM+4xEoSBRHIATSL6iCIwDQDLhADCgCbkZmEW64AB5nBscpAsO6BNaMoAJYBZJ2gPEH85wkL44YEzQcBT6BDQLgoH4AwzUDKalJ7Y0bswuidSKAEyQvmhVQCys03sx4G9v8vgoBmaR0dS6gFg4Sbq0YUOBccBIxUAsnPwjswXYjSF5qCCxQxagCd0sXSzs4RhiqQJiYccGNgOzSMgAAmJhx1BChiFAE7JZ8nwKpePUImNHoZpF0k+cR0k/8Qcl/RTALMCWzlGgtFgXi7SYwjCLtFhn50kmq94EcAKYRbL3AO7czt9O0t0HzGwhTAZmIbaMLMCWIXNdkoljktuy2yT+SWhUitMwqm6T7D1I0ndUJVGWaThJAg9QAqPuNunHSWgkrTJpGKHbsBtpaF1JlLkhctbYUElsMm9nje2gsJGR9O6kYaSxHeQ2mR0nsQpKQckSG2YlsUkbZIltUtjIaFSnYSSxTXKbTPeTREULncSGWuokNpQ2KBIbdiUwKm6T4jMJjSS2ScOouU0q0EEa21ASZWnTIrFRUmIbZSUykhE4yW3oNnSbVINJY1KVWWBSN5KKMEl6Qb63luzUjap41ZWaExnJiCKJo0quTUKj4e8Ot6Hb0G0yb03qk5rM/pPASPpjUnMiI8k1AqVhJP0xqRvJOJoETmQEriKl4CCN7SC3Df+c9of0oFa1STgJktlAFyspKerySVpfq9PE1gLJEXSFpQsqQEeZ7gy740iBLTAewxDDsFKIkYv1lAJboD/WcwmMx4paZUz1mgJVoSui47F6PDCsEFYI6xHxgd1RZmlDcMQUGJ8l/+zQxWWSbhm6YkykKN+mq9mhnuWsiI4QVik8WVe1o6tVgh/6xbkpgiOFVYokT1mKqiupi+rOgbkFkmOpgfrF4joenumCWgqiYXfsKbA5jvgsxgfUX1kWZ9SGmoiGJJlsSI7q78Swqr+ytM5Uc2B31FyfSI4Qj2n7HthDQRO8FEUIJEdN8InD8QjoQHusaKk2PFnJMdfA4VhUrCoOR03wieTYwBFSIDp26wvG7jhSYFiPjALZAMmMzvVEUX1Qqw5I2S4U3cBx+RCUAam7HN3FHVTBSGbDSd1IFveT3Nb9c5JJSkXDl5VnKSI4URQN0VG7VlZzpWh/TiTHMRx1n9h0X6dDZyIaVk1FWbwyomMOq3aXLBCLFjXD7ljDWsPawqo9dyAoSt/rDs1Qv6LqVrMEulWrVZZdQdFyZUiOstrncimoM+XEk5UcdbxMDCuEFcLaw6ruHKiNOhEdyT8LRX2QzgKdCKv0BehEeFibikkHgE43spthHI49rJrBE8ERw6o+HEiaGlkRDXuqgfoV0upHzZG9EqNapSWPmiObonLUHNkWMYJF0TUnJzZHbZ2ieMxzEts4xtaB3VFPISaqblIkRy3vE8Naw1rD2sLawgqhC2HVlJs4HLXuTYzHRjyGzWIbR3dLSx6F5kBNTw0INaADS1g1oImqIB2guzPDsDZNrqo4HCEHxlf0HOitjqMGkiOGDxhWis/SMKSUA/3bZn2i798/3Nk51y9fXx4e5JjrdPDFx2Ff7l8enr/efXz+9vT04e4/90/f9EN/frl/1r9f71/4XW7ch+ff+C8L/v749CD0/UM8na4f5UXQmE93nj5cAF4r5JWC9N1UaOAK/bVCuVbAgabAxb9cKbw1itGvolgptO5R8Ax1pQDXCrVLwVMF3m6gK/Di8pVEv5aQfdSU4PSgkKDXEuNaYmC1bODVXr5qS1wo9GJOjN7xSoEWYXBFrBYHV6Z+pbGMo0Qc/VIh55UbBN6aOZqCi+vbs6JBZAVt5RU1U4BaL8dXu5bgNYJJcIXPp8R6HUdeJCdXPDQN3kRdayyyk0eIJQaX83atcXt65lV+NvL8hFMo75EAWYVOiTK2JHrOPkrytcTtKV4WMyevHovNOVxIL1N8rUHmBs/k7VpjkaK84PcBnzDGSYUfNBYpip5dWNu1wiJBe05Ryq4VlnF4FeCQ0qXGeph4W7SR8HKYFPp3NbjuWG7wmcWpTzK8QwOtruaRcU+DF46ugW1Tw2dRPmxIexox9fApRb/UWE6j3dc6fCBaL/ulLvIDYvIBgOvpvN4+jdbby3z9J+r8ujnQQuG92nVVaYtKXzKaH3wPe921S42SvULyBnJXY7hGpz2NmjzF6nnV8i4NX4ryScGuH6dVx6h7Gi3ZFMSHDLsaxduUj793NbprjM02beT5AWnTDyjeHueh/04Nzw/om3kKPm55Ndj2NHqMFz4o39Xwvu19sz2iRPGQG5vTOvp4Gfl6dQx48zYY6OZ98Nsjob29wmjkGuO6yPXFopJnYZvV+fT6PPLz2/2gKLYEm7FQ91jolB1/i2W1MG3NYsH2ajb9YWO/2tlTshmILxfypcYqFr4o9QOGNOA6llWWQrORzwPuOtP7Ik0JrTAQteszisWmmC9crTUqLurkUoOKRVI5UfY00EcLa8CmRsRCtW/GguQaizlsrQFWW1pK+dZYWKNsafAluZ8SpJ42NXpzjbHtB4ZGv709xl6/tOzrbF4CbWokr9d8bVNujoUvKzZj8Vm9lbTZt3wB6Rp5s2+zbylZY9zcHmWxtV36UbNr1Hrdprja6vts2s4j/4fDl6UXbfjIb3g9m67m9Jyqb7AT9MtZnRY1f8S6gS99QkMOpl5p1EWvxCSWTwrpB4XVaWkmXzWURNcai0oLPmShpj0F8vuIDHtxlFj9lNOYf5fG8Pzkq75FJPTvavDqwo9e+sA9jRFHjIPKngYlP4qicq2xXEF13391vhO4XpWmRcdgPR12Frpc6afVcrBCnNvC9WXR2pGCxR057QT/5sjqMIp8xDGWLQ3UnyIdfuSy5wcmvxjY18h+UoC5wqYfvqpkjcXV1Wr/xJXWT2/lN2mX13DLi6NU/99R0vumIV+astz1kMmrnYv8ntirS4dNkRznt7nhrkiPZsVdT6rP7oy7noDf/mQ4zSPvFPHtbQak3XBiVuRbpF2R5guICotwlkfSMOJIevNarpWbJd50MJ5XN1FvPhlPq3tOj6RdL4UWAuR31wS4I/DWYbvyIVmPUtkLwscrDbixFfYEEH20M57u4vDNChRFhU5Hgz8o5Lo6yEI//CmIecuL4cdYdNpUv12Bkt9506sDqHf44Ie1SFT3fPDTp3S6CXyXQgmFfKtC3fOhelamVm/ti/OPMd6h0DB6cy8K/9XVZj5kjFUOnjfhULckCm1JEMThbO+bEiUkxp6EH83K7893JMAPAgC3fu90FqDXAj/zy/tPjy+v/mfud5F6ebz/9elhvvz92/On07tf//vF3rH/2fvl5fOnh9++vTyIUvz3Xv7nJ+AtHlD7+cNdlld84dZzl1fyptzh8YGLvDzeBf7s+Pm7uPY/",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "view",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18220743557690211299": {
            "error_kind": "string",
            "string": "Function has_flag can only be called statically"
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+19B3wcx3X+Hg8ACZAgIFLsogiS6vUqiittNcvqxbJlywXA3VGSJVEiKVFdRxKUaPViSS5yL3KvcdxbEuef7iR2nDhx4jh2nGqnOc2O7f8Mue/uu4e3e3u4N8CNiPn9Btjbmf3mmzdv3pSdnUkFB90H00FQTh+8ThmfDv8vMH6I3esW7i0W7vUL9waEe4cJ91Yav4Xd2yDEGxLubRTubRLuHRveQ7cg/L8l/J9pz2WPBax8ZrhQKI/kytl8djyTG5sYLWYKxYnh0exotjhaLOVG8/nyaGF0ZGxibCQzli3ky9lKcSxfCcGWpPV4oRwsLpdDSlkOaUU5dLGycsk7pYeVEehqYY9I2NOE0a7g+9UUMJd3yXNp2k2hafMcmDnPHL9huS0zvgu42vL6BfCm66VwfyC8pucGze/DjF9m/PL0wfvW9wJOnEwy7bnsoGLZId/D0w4J18ADXSuXCvwTeg/wXBHKZWX4f1X4f3X4f034fy01RbXmPz29ubaRFzFBLFAWuqK5z672xAqtU+xWuOR5xMx5FvkNyVquA6u4Aq5XwvURzFquN7+PNH6D1dd0/T65NJNBpj2XXaVYVuvTemWz0ZGua8tP0dBlj1SU3yblVo/r9kbQ4U1wvQGuh5hubza/jzL+aOOPmYOewBoF+ZYrB1wZ+R6bdkjYgms1SkT+WEWlPU5RaV3J0HLUajxIhsd50hgfr8ez4JLnCTPnmec3JIN1PBgm6+l6M9w/gRmsE83vk4w/2fhT0o148zqqV/an6vHMS2V/KpTxWrg+MabsM+a3nWTKGZ8XOmLa83pLFO1owdG8XiEcRHnaaFeQb9Flo13Ub7QrRcVCHfag0R7WN4iVYWWDqD1bsDlsCLTkaLEyaX1jtVlRf0Ycj1SiGv6RGOM/an6PGf8s45/tuOHvdD1vpUEdjZHpc8zv5xr/POOfD6O/BcHsNCQrFGXSDzy3hA3JC8L/Lwz/nxb+Pz38f0b4/8zw/1nh/xeF/88O/784/H9O+P9cPpX5wnRdmeneGcK9Fwn3zklPF7Z2b+48NUHnnY44zp85zxK/IVWS86AybIHrF8D1+aySXGB+X2j8RcZfnHY//fdCxcbmAsVG4RJHIxdt+Z2mKL8LFeV3qSfyO11Rfhcpyu8ljhvQS8AGXArXL4Hri5ltuMz8fqnxLzP+8lmwDWcols1limXzck90+0xF+b1UUX6v8ER+ZynK72WK8rvCsW14OdiAV8D1FXB9ObMNrzS/X2X8q41/zSzYhhcpls0rFctm3BPdPltRfq9SlN+EJ/J7saL8Xq0ov0nHtmEcbMAEXE/C9WuYbSilD67ErRi/dRZswzmKZVNSLJsrHZfNlVAGZbiuwPVWVjZXmd9XG/9a468RykZ7zHutngwqkgyuhbxeBdfnxkwMXWd+bzP+euNvgImhdDA7E0PXKerFAuC5PaxYO/gEjg2osns7wnvotCvmdYqVaXtyrMkmWNkdigWAs4pRLmlazXgHDpVyu7KxIreTK+NOYUaQK56msjThmm0SntmpqMQ3ptWUIYMyvTFBZW6X+w5FOWjK9KYWZNosLZTpTWA0F4E8UaaZ9lz2F/F4uclKNl8sjxQzw+OFYmk4nyvlRjKlQrGSNYRzYwUjmspkYbQ0mstXciO5yV/o8jugY2TYqCGhVnVHeL3L/L/Z+FtQQA70T3Pmc5ei/t2q3JjM1jqHWx0Z/NvSDgnfltbHvV1RGVzl+3aoXEq4scPlduWgOc1+s2L53OFpZb3DUWW9M+2Q8J0OKutdHV5Zbb7vmuXKmmnPNbSGmfacqjGtKis9VdYq9GJuTjd+VEjrF06D+6cLcXab/3uM3xv+JuxdEdi3AHazOFPm/z7j7067qZu3hzqqPddzj/JcrjY/V/ner1h/AnDai/1uUaybr1POs/aCQVs/NcvF1sl7HOjOvWk3bYS27pyhqDv3dbjunBaOZrXwbF2514Hu3K+sOy50Zpey3tzvoE+puVBTekcRtRbvhTHvKB4wvx80/iHjH063/uliu7J+AGSSGy+WyoWRcilv3nebeaaJETMfNT6eLYwM58z00/BopThZmcwOT5ZGs9nh8sTwRGZsIlPJDRfyk+O5iTHk+0jaIWELzpW4XfKPKBqCRx0PXjRk+KhQwdqV4aPKo267fdOCoHklyLTnsg84apwDXZ4ZfIn7WFjBXh/+fzz8/wSUq7riKBZww/dfj8OoiVvVx8B6vh6uH4+xqk+a328w/o3Gvyldv6/dg6CKpCnfJ9P6LbSigmefdFRZtHX1zWo880VJd9rlZz+lUfxE6cCnd89J6+v4iKJ+P9XhMwe2/j3hQIZPKMrwLY57sW8Gu/oUXL8lxt6+1fx+m/FvN/4dafffNBcU5flOR22axR0KZdQTNL5XDkDemnJ5a4fXL/vZ6FMORnZPzVKblGnPZQsueFoFWxgc7C27VrBBR4IOlHlSRXQpixUOZKHNcaUHHFd5Unk3e8LznY7rqHpr/k7F1vxdjlrzd0FrPluLAVYq9/TIvTvtkPC7HTTv73E8n5Zpzx3I93uguVHCdTo8fq+acuUmkaf2MFmz7J9WNg586PReGCI9nW5cTBC1i/H7zO/3G/+B9MGt7ekFAF+Kyt0WxXxwY6ZdP572pOV832y3nBrGTCvzxwVuMq+d55Rino/3JM8LFPN8QuBHZTxRuZ644nlSMDs6lGnPZU9WlOf7PDHopwR+8DzVE54ZT3hmAz/qZC7Qq5MjaT/ynFfM8xJP7FAh8INn0ROew57wHPGE56gnPMc84fksT3g+2xOez/GE53M94fk8T3g+3xOeWzzh+QJPeL7QE56necLzdE94nuEJzzM94XmWJzxf5AnPsz3h+WJPeJ7jCc9zPeF5nic8z/eE5wWe8LzQE54XecLzYk94XuIJz0s94fkST3he5gnPl3rC82We8LzcE54v94TnKzzheYUnPF/pCc9XecLz1Z7wfI0nPMc94TnhCc9JT3iWPOFZ9oRnxROeWz3heaUnPK/yhOfVnvB8rSc8r/GE57We8LzOE57bPOF5vSc8b1Dmqc3P7n/xmIP9L7YHems+H0t3vgxf70CGOxRl+HoPZPi4AxnuVJTh456st75RMc9v8STPN6lh5TMa+3sdPD695PRgn12BH23gzZ7wvMUTnrd6wvM2T3je7gnPOzzheacnPO/yhGfVE567PeG5xxOeez3hOeUJz32e8LzbE573eMJzvyc8X+cJz3s94XmfJzzv94TnA57wfNATng95wvNhT3g+4gnPRz3h+ZgnPF/vCc/HPeH5hCc8n/SE5xs84flGT3i+yROeb/aE51Oe8HyLJzzf6gnPt3nC8+2e8HyHJzzf6QnPd3nC892e8HyPJzzf6wnPpz3h+T5PeL7fE54f8ITnBz3h+SFPeH7YE54f8YTnRz3h+TFPeH7cE56f8ITnJz3h+Sue8PyUJzx/1ROen/aE52c84flZT3h+zhOen/eE5xc84flFT3h+yROeX/aE51c84flVRzwXKPP8NcBq9/uYzZ58H/Prinl+pydnMPxG4AfPr3nC8zc94fn/POH5W57w/G1PeP6OJzx/1xOev+cJz9/3hOcfeMLz657w/ENPeP6RJzz/2BOe3/CE5zc94fknnvD8lic8/9QTnn/mCc9ve8Lzzz3h+Ree8PyOJzz/0hOef+UJz+96wvOvPeH5PUc8teco/ybQm6N8qyfzst9XzHOhw/f4Os7we8rBHl8/UJThU57Mbf9t4AfPH3rC8+884fn3nvD8B094/qMnPP/JE57/7AnPH3nC88ee8PwXT3j+qyc8/80Tnv/uCc//8ITnTzzh+Z+e8PwvT3j+tyc8/8cTnv/rCc+fesLzZ57w/D9PeP7cE56/8ITnLz3haQF94JnyhOcCT3imPeHZ5QnPbk949njCc6EnPBd5wrPXE559nvBc7AnPJZ7w7PeE51JPeA54wnPQE56HecJzmSc8l3vC83BPeK7whOdKT3iu8oTnak94rvGE51pPeK7zhOcRnvBc7wnPIz3hucETnkOe8NzoCc9NnvDc7AnPozzhebQnPI/xhOexnvA8zhOex3vC8wRPeJ7oCc+TPOF5sic8T/GE56me8Mx4wjPrCc+cJzzznvAseMKz6AnPYU94jnjCc9QTnmOe8HyWJzyf7QnP53jC87me8HyeJzyf7wnPLZ7wfIEnPF/oCc/TPOF5uic8z/CE55me8DzLE54v8oTn2Z7wfLEnPM/xhOe5nvA8zxOe53vC8wJPeF7oCc+LPOF5sSc8L/GE56We8HyJJzwv84TnSz3h+TJPeF7uCc+Xe8LzFZ7wvMITnq/0hOerPOH5ak94vsYTnuOe8JzwhOekJzxLnvAse8Kz4gnPrZ7wvNITnld5wvNqT3i+1hOe13jC81pPeF7nCc9tnvC83hOeN3jCc7snPHd4wnOnJzxv9ITnTZ7w3OUJz5s94XmLJzxv9YTnbZ7wvN0Tnnd4wvNOT3je5QnPqic8d3vCc48nPPd6wnPKE577POF5tyc87/GE535PeL7OE573esLzPk943u8Jzwc84fmgJzwf8oTnw57wfMQTno96wvMxT3i+3hOej3vC8wlPeD7pCc83eMLzjZ7wfJMnPN/sCc+nPOH5Fk94vtUTnm/zhOfbPeH5Dk94vtMTnu/yhOe7PeH5Hk94vtcTnk97wvN9nvB8vyc8P+AJzw96wvNDnvD8sCc8P+IJz496wvNjnvD8uCc8P+EJz096wvNXPOH5KU94/qonPD/tCc/PeMLzs57w/JwnPD/vCc8veMLzi57w/JInPL/sCc+veMLzq57w/DVPeP66Jzx/wxOeX/OE5296wvP/ecLztzzh+due8PwdT3j+ric8f88Tnr/vCc8/8ITn1z3h+Yee8PwjT3j+sSc8v+EJz296wvNPPOH5LU94/qknPP/ME57f9oTnn3vC8y884fkdT3j+pSc8/8oTnt/1hOdfe8Lze57w/BtPeH7fE54/8ITn33rC84ee8Pw7T3j+vSc8/8ETnv/oCc9/8oTnP3vC80ee8PyxJzz/xROe/+oJz3/zhOe/e8LzPzzh+RNPeP6nJzz/yxOe/+0Jz//xhOf/esLzp57w/JknPP/PE54/94TnLzzh+UtPeAYL/OCZ8oTnAk94pj3h2eUJz25PePZ4wnOhJzwXecKz1xOefZ7wXOwJzyWe8Oz3hOdST3gOeMJz0BOeh3nCc5knPJd7wvNwT3iu8ITnSk94rvKE52pPeK7xhOdaT3iu84TnEZ7wXO8JzyM94bnBE55DnvDc6AnPTZ7w3OwJz6M84Xm0JzyP8YTnsZ7wPM4Tnsd7wvMET3ie6AnPkzzhebInPE/xhOepnvDMeMIz6wnPnCc8857wLHjCs+gJz2FPeI54wnPUE55jnvB8lic8n+0Jz+d4wvO5nvB8nic8n+8Jzy2e8HyBJzxf6AnP0zzhebonPM/whOeZnvA8yxOeL/KE59me8HyxJzzP8YTnuZ7wPM8Tnud7wvMCT3he6AnPizzhebEnPC/xhOelnvB8iSc8L/OE50s94fkyT3he7gnPl3vC8xWe8LzCE56v9ITnqzzh+WpPeL7GE57jnvCc8ITnpCc8S57wLHvCs+IJz62e8LzSE55XecLzak94vtYTntd4wvNaT3he5wnPbZ7wvN4Tnjd4wnO7Jzx3eMJzpyc8b/SE502e8NzlCc+bPeF5iyc8b/WE522e8LzdE553eMLzTk943uUJz6onPHd7wnOPJzz3esJzyhOe+zzhebcnPO/xhOd+T3i+zhOe93rC8z5PeN7vCc8HPOH5oCc8H/KE58Oe8HzEE56PesLzMU94vt4Tno97wvMJT3g+6QnPN3jC842e8HyTJzzf7AnPpzzh+RZPeL7VE55v84Tn2z3h+Q5PeL7TE57v8oTnuz3h+R5PeL7XE55Pe8LzfZ7wfL8nPD/gCc8PesLzQ57w/LAnPD/iCc+PesLzY57w/LgnPD/hCc9PesLzVzzh+SlPeP6qJzw/7QnPz3jC87Oe8PycJzw/7wnPL3jC84ue8PySJzy/7AnPr3jC86ue8Pw1T3j+uic8f8MTnl/zhOdvesLz/3nC87c84fnbnvD8HU94/q4nPH/PE56/7wnPP/CE59c94fmHnvD8I094/rEnPL/hCc9vesLzTzzh+S1PeP6pJzz/zBOe3/aE5597wvMvPOH5HU94/qUnPP/KE57f9YTnX3vC83ue8PwbT3h+3xOeP/CE5996wvOHjnguYDzzmeFCoTySK2fz2fFMbmxitJgpFCeGR7Oj2eJosZQbzefLo4XRkbGJsZHMWLaQL2crxbF8JcQ+VjHPfzdLec6057J/v0BPfu9K+1HOXYry+wdPdLtbMc//6EmeexTz/E+e5HmhYp7/2ZM8L1LM8488yXOvYp5/7Eme+xTz/C+e5HmxYp7/1ZM8L1HM8795kud+xTz/uyd5XqqY5//wJM8Dinn+iSd5HlTM8396kufDFPP8X57keZlinv/bkzwvV8zz/3iS58MV8/y/nuR5hWKef+pJnlcq5vlnnuR5lWKe/8+TPK9WzPPPPcnzGsU8/8KTPK9VzPMvPcnzOsU8B57Mbx+hmOeUJ3ler5jnBZ7k+UjFPKc9yfMGxTx3eZLnIcU8d3uS542Kee7xJM+bFPO80JM8b1bM8yJP8nyUYp57Pcnz0Yp57vMkz8co5nmxYp4N1IE1Pj8IM3yc8ccbf4LxJxp/kvEnG3+K8afa9IzPGp+zMjG+YHzR+GHjR4wfNX7M+GcZ/2zjn2P8c41/nvHPD2XwAuNfaPxpxp9u/BnGn2n8Wca/yPizjX+x8ecYf67x5xl/vvEXGH+h8RcZf7Hxlxh/qfEvMf4y419q/MuMv9z4lxv/CuOvMP6Vxr/K+Fcb/xrjx42fMH7S+JLxZeMrxm81/krjrzL+auNfa/w1xl9r/HXGbzP+euNvMH678TuM32n8jcbfZPwu4282/hbjbzX+NuNvN/4O4+80/i7jq8bvNn6P8XuNnzJ+n/F3G3+P8fuNf53x9xp/n/H3G/+A8Q8a/5DxDxv/iPGPGv+Y8a83/nHjnzD+SePfYPwbjX+T8W82/inj32L8W41/m/FvN/4dxr/T+HcZ/27j32P8e41/2vj3Gf9+4z9g/AeN/5DxHzb+I8Z/1PiPGf9x4z9h/CeN/xXjP2X8rxr/aeM/Y/xnjf+c8Z83/gvGf9H4Lxn/ZeO/YvxXjf8143/d+N8w/mvG/6bx/8/43zL+t43/HeN/1/jfM/73jf8D479u/B8a/0fG/7Hx3zD+m8b/ifHfMv5Pjf8z479t/J8b/xfGf8f4vzT+r4z/rvF/bfz3jP8b479v/A+M/1vjf2j83xn/98b/g/H/aPw/Gf/Pxv/I+B8b/y/G/6vx/2b8vxv/H8b/xPj/NP6/jP9v4//H+P81/qfG/8z4/zP+58b/wvhfGm8rW8r4Bcanje8yvtv4HuMXGr/I+F7j+4xfbPwS4/uNX2r8gPGDxh9m/DLjlxt/uPErjF9p/CrjVxu/xvi1xq8z/gjj1xt/pPEbjB8yfqPxm4zfbPxRxh9t/DHGH2v8ccYfb/wJxp9o/EnGn2z8KcafanzG+KzxOePzxheMLxo/bPyI8aPGjxn/LOOfbfxzjH+u8c8z/vnGbzH+Bca/0PjTjD/d+DOMP9P4s4x/kfFnG/9i488x/lzjzzP+fOMvMP5C4y8y/mLjLzH+UuNfYvxlxr/U+JcZf7nxLzf+FcZfYfwrjX+V8a82/jXGjxs/Yfyk8SXjy8ZXjN9q/JXGX2X81ca/1vhrjL/W+OuM32b89cbfYPx243cYv9P4G42/yfhdxt9s/C3G32r8bcbfbvwdxt9p/F3GV43fbfwe4/caP2X8PuPvNv4e4/cb/zrj7zX+PuPvN/4B4x80/iHjHzb+EeMfNf4x419v/OPGP2H8k8a/wfg3Gv8m499s/FPGv8X4txr/NuPfbvw7jH+n8e8y/t3Gv8f49xr/tPHvM/79xn/A+A8a/yHjP2z8R4z/qPEfM/7jxn/C+E8a/yvGf8r4XzX+08Z/xvjPGv854z9v/BeM/6LxXzL+y8Z/xfivGv9rxv+68b9h/NeM/03j/5/xv2X8bxv/O8b/rvG/Z/zvG/8Hxn/d+D80/o+M/2Pjv2H8N43/E+O/ZfyfGv9nxn/b+D83/i+M/47xf2n8Xxn/XeP/2vjvGf83xn/f+B8Y/7fG/9D4vzP+743/B+P/0fh/Mv6fjf+R8T82/l+M/1fj/834fzf+P4z/ifH/afx/Gf/fxv+P8f9r/E+N/5nx/2f8z43/hfG/NN52LFLGLzA+bXyX8d3G9xi/0PhFxvca32f8YuOXGN9v/FLjB4wfNP4w45cZv9z4w41fYfxK41cZv9r4NcavNX6d8UcYv974I43fYPyQ8RuN32T8ZuOPMv5o448x/ljjjzP+eONPMP5E408y/mTjTzH+VOMzxmeNzxmfN75gfNH4YeNHjB81fsz4Zxn/bOOfY/xzjX+e8c+384TGv8D4Fxp/mvGnG3+G8Wcaf5bxLzL+bONfbPw5xp9r/HnGn2/8BcZfaPxFxl9s/CXGX2r8S4y/zPiXGv8y4y83/uXGv8L4K4x/pfGvMv7Vxr/G+HHjJ4yfNL5kfNn4ivFbjb/SeHtWvT0H3p6xbs8vt2eD23O37ZnW9rxoexazPefYniFsz+e1Z9/ac2Xtma32PFR71qg9x9OekWnPn7RnO9pzE+2ZhFXj7Vl69pw6ewacPV/Nnl1mzwWzZ27Z86zsWVH2HCZ7xpE9P8iezWPPvbFnytjzWuxZKPacEXuGhz0fw549Yc91sGcm2PMI7F7/dh99u0e93f/d7q1u9y23e4K/3Xi7l7XdJ9ruwWz3N7Z7B9t9ee2et3Y/WbtXq90H1e4xavfvtHtj2n0n7Z6Odr9Euxeh3efP7qFn96eze7/ZfdXsnmV2PzC715bdx8ruEWX3X7J7G9l9g+yePF8x3u4lY/dpsXug2P1F7N4ddl8Mu+eE3c/B7pVg9yGw3/jb7+ftt+n2u2/7TbX9Xtl+C2y/s7XfsNrvQ+23l/a7RvvNoP0ez37rZr8js99o2e+f7LdF9rsd+03MXxtvv+Ww30nYbxBsv9eunbfr0u06bbsG2q7jteta7TpPu+7RrgO06+LsOjG7bsquI7Lrauw6E7vuwq5DsO/l7Xtq+97Wvse07/Xsey773se+B7HvBew8uZ03tvOodl7RzrPZeSc7D2PnJew43Y5b7TjOjmtsP3/BwS5DYNcpW3dcUHehObGQB8Ltul67ztWu+7TrIO26QLtOzq4bs+uo7Loiu87Grjux6zDsugT7nt6+t7bvce17Tfuez773su+B7HsR+57AzpvbeWQ7r2rnGe2825DxG43fZLwdt9txrB3X2XHOscF01y9cr/jBC9bc8DtPn4Hxlob/v//5pyY/t+Iv/w/DVoT/37Lspuqx19mSrbs19NyKi9585+LjfoFhJ8Skd074/23vP/JT636w4OUYdm5M2EUxYZfEhFXC/1tv/dsll7/ra9sx7Lrw/ztWj7/9h7/4q8UYtjMmDzdHhPWF/2856uD/3vA3Cc7qj9WdLeHvTHsu2wu42vijmbGJ3qDRKfPP9wKmA/wc4Xe5wT+w3tu6N1Yb8QOWbn/4OwWypGcoDCvXm8KwRUG97tpr0rtehuei3JGTttyWC/wXQN6sO63qIu3cJOGfHuIHDdjZ/OhwPjc6nMuVypnx0vBIZSw/kslPFPNjkxPZTL6YGy2NjOczmXK+PFnIlIbHiqXy+FgxX5kYHxsm7DNE7Hx5wkAVx4dHJ7KV8eFKZqIwMpofr4yMlMZLY2auq5gpZSeHs5O5bGV0dLxYHJ8sjmWzlfJYsTJawz7TiVwO1hXrznKDX7NVL3KCny8S/tmAr/itUYbwX+wGvyafc9zg18r33BA/cCCb84B7yoFszneDX5PNBW7w84R/IeCnHeBf5AQ/Wyvfi93wLxD+JW7wK4R/aYgfAHZ2NJ/LjeTtO4TRUiZbKE3mRo31nyhkJjPjk7nyWCE7VinkCvnJ0uSEed8wnq1kKuOTY5XRg+CE/RIn3PM12VxWdaGb+Vq78lJBNpn2XM0mvywae8biJ+zLBezceH4yM1bJjBdHx0fK5sVRxjTmI+WJ0XJlODc+YRruXCmbzZYL5k+uXCqMTZSGsxPD5m1TccIkVyvTl1ddlGm21gd5hTL+8HhmrDw8PEL4VyjjT0wMj4wbeRL+K5Xx85PD5Up+pGaPX6WMP14sVCrF/Djhv1oZv5jNlIu5kZpuvkYZf2wiUxweHa3pz7gyvul35ktj47Vx34S2fCbKmclSdozGNJMhPqVhHaVdUk47dGMpll4QNI7ZApZ+H+Oq3S9OsfSQD8qHxkcku3J1OtdBIQxtDA9LC/coHQnrCkWsVypivUoR69WKWK9RxBpXxKJ67bauFWrtaNkJfn6U8CtO8DNlwt/qAj9b7zteCfiBHv8a/lWAn3KAf7Ub+dfwX+tGPrVx5TUhvgvsa93IptYHu84Nfm1csM0Nfq2Per0b/JptuMEN/hjhb3eDX+uj7nCDX+vj7XSDX+uj3ugGv0T4NznBz9bkswvw9WxnrmbbbnaCn6/h3+IGv2bfbnWCX6jh3+YGvzavcrsb/Jp9vsMNfs0+3+kGv9b3ucsJfrE2Rq46wR+u6c9uN/i1OYo9bvBrc7p73eDX9H/KDX5N//e5wa/p/91u8Gv9k3vc4Nf6J/vd4Nf6J69zg19rH+91g1/rP9znBr/Wf7jfDX7Nfj7gBr9mPx90gj9S6z885Aa/Zj8fdoNfs5+PuMGv2c9H3eDX7OdjbvBr9vP1bvBr9u1xN/g1+/aEG/yafXvSDX7N/rwhxA9mjp3nN+xCNrte6EfLDuJJ66wU+3IZWsPUVc9Kw3y+ve6G+4rjtFKKpRcE0+fzMf0+xlV5XJpNsfSID5cPzufbsB6B66AQxsuwR0inR0hnUAibquphPaSItU8R6wFFLM083qeItV8R635FrLsVsXYpYmnKfkoR6+EOxaoqYmnqxJQilqZ+7VXE0qzbmjqxRxFL00Y/pog1pYil2XZQn9pt3yoz3C+kTY7CFkLa2KfiLs1+I2/bV/2PZXVcHo+c/aZmILyulHdOXnnp+Nat5dK527buCGIes+70qny/00SYYmGLEuQhCJqLd+HyOi6Px/lgMS5kYd3CsykBS1pSw1UaZd4VwQExqKx4d3hL+DvTlsvmk+QD05+toYRkKqShBMlnoRv55FIMH/ksFOTDdZiXXSqoL0HpBiyMvxDyiPHxmp7He38a/h8MptcjWgKfEsLSwj2Sr+X+RyxvWDZcT92UQyGbVE8p/b7AZb2p66mkF1KT1htML2fNZUdJylWybb1CGGHRMkDUU4y/CPKI8fGansd7fxv+Hwym6zTX014hP3gP9fS74XVvRH62hL8zbbmREamd4vUA5aS5jDppPaD0+wKXelevB1I5SfaEZNcncB0UwvjUT5+QTp+QzqAQxruj7WA9oIi1RxFrShHr4Q7F2q+Idb8i1t2KWLsUse5VxNLU+06UV1w72CqWdZq6+ogi1j2KWJq6qpnHqiJWp9btJxSxblbEoleIvJ9J+EFQ7yvx9n5L+DvTljs4dsP0KB94D9PvY1x1+dT7SpJcpT4tyWexG/nU+CwW+CwW5ENluUQIIyyaa8ExA8ZfDHnE+HhNz+O9U8MCG2SY1vExwxIhP3gPxwzHpxrzhmXD9dRlOWB6xBvvYfp9gct6k4nVC6n+9wbTy1lRPpkk5Yp8qSz7hTDCoi2AUE8x/hLII8bHa3oe7z2X6SnqNNfTfiE/eA/1dITpKZYN11Mn5ZCtJNZTSr8vcFlv6noq6cViQY69wfRyVpRPJkm5Il8qy6VCGGHR1D/qKcbvhzxifLym5/HeOUxPUaf5p1NLhfzgPdTTM0Lc3oj8bAl/Z9pyxYJUlnr4I9l+IZ+8nqGs9fQ6n7ieUfp9wXS9cFHPBhifKD0g2Q0KXAeFMK4jg0I6g0I6g0IYH9e0gzWliLVLEWuPIta9ilhVRaz9ilj3KWJNKWLtVcS6SxHrYSUsyT63w+shJV7WPaKIpVm3n1DE0rSFmvXxfkUszXJ8UhFLUyc0Za9VtwPlPGrqxAOKWJ1qJzR5HQp9pvk2be5kr1kf9yliaebx9YpYndqf0Mwjfz+AY8tU+L83mF73FMfZ5RRLj/KB9zD9PsZVl099nC3JdUCQK8nuMIHroBDGx9mHCekcJqQzKITxNqMdrClFrF2KWJp53K+Idb8i1iOKWJqyf0IRa74cW8N6UhFLUyf2KmI9oIg1pYj1sCKWpuw1dVVT9p1qvzR1dUoR6z5FLM1y1NQvzTqkqV8PKWJVFbE08ziliKVZHzXzqNmf6NRy7NS+3OsVsTq1n6PZx5zvTzwz6pCmndDkpaVf9prPq7bD61ElXtZpyl6zDzAVYvH1boRvnds5tFziNbZ8Ds3JGqwmc2jS2rreYLoeKsonm6SckS+V5TIhjLDCz5ob1oRh/MMgjxgfr+l5vPf8UCiDDNM6viZsmZAfvEfytWvCxsIfvRH52RL+zrTnRvl8KKWBaaOcFPUu0RELmH5f4FLv6vVAKifJvpDslgtcB4PpusP1YbmQznIhnXmszsI6TwkrzoZRuHW9wnPa9hbTo3zgPUy/L3BqF7JxcpXsJcnncDfyqa1RPlzgc7ggHyrLFUIYYa0Mf2N7hPEPhzxifLym5/HeJGuPVkBcXgdWCPnBe9gevXJBY96wbLieuimH5N98UPp9gct6U9dTSS+k+t8bTC9nRflkkpQr8qWyXCmEEdaq8DfqKcZfAXnE+HhNz+O9G5ieok5zPV0p5AfvoZ6+NvwxEETXzyT1GXElu81liM/x+uCkvLPlTNL6QOn3BS7rZ70+rEgoV5LPSifyKVWS6A/ypbJcJYQR1urwN9YHjL8S8ojx8Zqex3t7WH3AusPrwyohP3gP68PtzG5j2XA9dVIOmUwlqZ5S+n2BSztZ11NJL6T2rzeYXs6KfMpJyhX5UlmuFsIIa034G/UU46+CPGJ8vKbn8d7DTE9Rp/m3equF/OA91NN72XiX52dL+DvTlitnpbLUwx/P9Aqy1sPPjfUK5aWHPzFK+Gvd4A8T/jon+KO18j3CCX6xJp/1bvBLhH+kG/2p8d/gBD+fJ/whJ/jlGv+NTvALNfxNTvAnavV3sxP8sZr+H+VGPrXyPdoJfqVI+Me4kU+N/7Fu+Nfs//GArzkXQfgnOsHP5EkeJwR1lxbyROlTX+Q4iJ+K+E9YPIzS6mNYrvp9Ut6QPx/3nQB8UAZRWCe0iNUrhLko0+Nj8o3p98dw5fmwju+BM1OZWLdXEetORayHlLCkvm07vG5R5LVKiZfU/20Ha40iVloJyzp+JGA7vNYq8bLX6zoU6whFrPWKWEcqYm1QxBpSxNqohGXd41U9XpsUeT1Y1eO1WYmXvT5KEUur7bDXRytiHaOIdawSlnV87rRTsOgdstv5rsKY2/mu/Ljb+a5Cye18VzHvdr6rMOJ2vqswSX11ag8pDdQtbN/0xhWFxN+CUvp9jKsun/r47kjGh8uHr9/ZIHAdFMJ4Hd0gpLNBSGdQCONredvBekwRq6qIda8i1n5FrL2KWLsUse5TxJpSxHq4Q7E0dfVuRawpJSyp3e4UXdWsj/z7gWdifXxUEUuzDnWq7O9RxNK0E5pt7ZQilqbsNeXVqfql2TeZUsTSlP2hYCeeUMKy13wM2w6v2xV5rVHipYll3a1VPV5rFXlpyd66uxSxNHWCz6W3g5VWwrJOSyesu1MR6zZFLE390uSlpaudbAuXKPLS1FXNctS0q50qL01d5XOrnVK3Ne3Xk4pYmv2vfYpYmnMKU4pYmmMFzblH6t/TPPYREJYK/7t9B5CZ8TuAI9zwiX0HcIQgV2k9rCKfUpJyRr5UlkNCGGFtDH/j2n6MvwHyiPHxmp7He+8IC26QYVrH1/YPCfnBeyRfu7b/zenGvGHZcD11Uw7Jz4Cl9PsCp/UmG6cXRwpylPSCnh0UwniffkhIZ0hIRyp7vvatHawHFLH2KGJNVfWwHu5QrP2KWPcrYt2tiLVLEetBRSzNOqRZjo8pYlUVsR5RxJqq6mFp6pdmHdK0q4eC7O9TxNK00WQLpe+oFPsfGek7J0X82jcHG2NkgenztTgULv0nLB5GafUxLOW8ZePyFjd22wh8huA6Cmtji1jSt3EuynQoiM43pu/2W8Bizu23gMVht98CFiqk85tBnikmu6OdlOVo4r1UKP0+xtVVnTqa8eHy4eOhYwSug0IYX7t3jJDOMUI6g0IYb7fbwXpMEauqiHWvItZ+Ray9ili7FLEeVMR6SBFLU/adqquPKGJNKWJp6pemzXlAEetQkP19ilhTilgPdyiWZt2+WxFrSgnLXvN1uZ2iq53aB9DEmm+359ttX9qO+XZ7vt2eb7efmbLvVF19VBFLU16aNkdT9vcoYmnWIc12e0oRq1P7q52qX5p93ylFLE3ZHwp24gklrFQwfX1OO1hDilha8+T2eqMSlnV87XE7vJYo8rpdiZd1dyli3amEZa83BXpYz3TZ22v+7UQ7WGsUsdYqYVmnKa+jlHhp6qp1mnWoU/W+U/P4TLeFmrysm287/G87rLtDCctea6550JKXvV6nyOs2RV5aba11mu2jprw6se2w7klFLM0x3z5FLM13OlOKWJrzE5rrc/j3bbg2LBX+l/aLt+lsCX9n2nOlFEuP8oH3MP0+xlWZTzZOrkcLcpX2u1fkM5li+MjnWEE+VJbHC2GERftk4vdtGP9YyCPGx2t6Hu/9ouvg/0GGaR3/vk3aKx3vkXx7jP+frsa8YdlwPXVTDrnE37dR+n2B03qTjdMLqf5LekHPSuXF2/2k5SVh7VfEelgRa48i1gOKWI8pYk0pYj3Uobz2KmLtUsR6QhHrZkWsJxWxNOV1vyKWZn18RBFrShFL0xZqluM+RSxNm6OpE/cpYmnKvtqhvB5UxNLUCc2+iWa7rVmOnWq/NPVLsz5OKWJp2mhNLE39ulsRayrEovEKjm9S4f9e9lwqUB3rFVIsPcoH3sP0+xhXXT71sZ4k12MFubZyvhhxpWsMw3Rm+xwv6x5QxNqjiDWliPVwh2LtV8S6XxHrbkWsXYpYWmcjWVdVxNKsj48oYmnql6a87lXE0tQvzTqkaVc1dWJKEatT67ZmfdSsQ48pYmnWx0NBv+5TxNLsA1BbOxCGYX8b9yPBMEwnrs+Pz1O8fuG5VPi/l/FLBZp97LHE+3VQ+n2CTFz0+U9IKFeS3YkC10EhjK9dOVFI50QhnUEhjLdN7WA9pohVVcS6VxFrvyLWXkWsXYpYDypiPaSIpSn7TtXVRxSxphSxNPVL0+Y8oIh1KMj+PkWsKUWshzsUS7Nu362INaWEZa/5fh2doqud2gfQxOrUdltT9pp9AE0brdmf6FRdnW+3565Nm++Tt4Y13yefO/2a7xfOnX51Yr/QOk15daquPqqIpSkvTZujKft7FLE065Bm2zGliNWp46FO1S/Nvu+UIpam7A8FO/GEElYqmL7GqR1etyryGlLiZa+XKGJpvh/SlNc6RV53KfGy7k4lLHu9KdDD0tIJ6/i3zZ0ge826rV0fteqQvd6ohGWdZn08FPSL7zfUDtYaRay1SljWacrrKCVemrbQOk0b3al636l5fKa3tZq8rJvvm/jfdlh3hxKWZn/COi152WvNPvltiry02lrrNNtHTXl1Ytth3ZOKWJpzCvsUsTTfW00pYmnOf2muL+T7DS2BsFT4n9b5oq2z6WwJf2fac4n3caH0+4LpbZUin9o635XBdLkuEeRK8lnlhs9EiuEjn1WCfKgsVwthhEV2GPcbwvirII/cbq8BHt3s3p/3HPw/yDCt4/sNrRbyg/dIvhbymz2NecOy4XrqphyyiffFovT7Aqf1JhunFysFOUp6Qc8OCmF8DidpeUll/1BVD+sBRaw9ilhTilgPdyjWfkWs+xWx7lbE2qWI9aAilmYd0izHxxSxqopYjyhiTSliaeqXJi/NctTkpWknNHVCsxzvU8TStPdkV6lvxfsEW8LfmbZcsUh9E+zLUJ+qN5D7JjppZ0dTLL0gkPt1lH4f46rLp96vk8oN5cP7dWsEroNCGC/DNUI6a4R0BoUwXjfbwXqdIpYmrweUsOz1wkAHSzuPuxSx7lPEelgR625FLE15PaKI9bgi1oOKWFOKWJqy36+ItVcRSzOPTyhi3ayIRfPRvG9h3Zbwv2kO86PD+dzocC5XKmfGS8MjlbH8SCY/UcyPTU5kM/librQ0Mp7PZMr58mQhUxoeK5bK42PFfGVifGzEbd+hONYbyO2rDn42S/hr3eDnCH+dG/w84Q+5wS8Q/kY3+EXC3+QGf9jtHhrZmv6f6AZ/lPBPcoNfq18nu8EfJ/xT3OCXCP9UN/hlws+4wa8QftYJfi5D+Dk3+DX7mXeDX7OfBTf4NftZdINfs5/DbvBr9nPEDX7Nfo66wa/ZzzE3+DX7+Sw3+DX7+Ww3+DX7+Rw3+BOE/1w3+DX7/Dw3+DX7/Hw3+DX7vMUJfr5mn1/gBr9mn1/oBr9mn09zg1+zz6e7wa/ZtzPc4Nfs25lu8Gv25yw3+DX78yI3+DX7c7Yb/EnCf7Eb/Jp9O8cNfs2+nesGv2bfznOCX6jZn/Pd4NfszwVu8Gv250I3+LX+4UVu8Gv9w4vd4Nfs5yVu8Gv281I3+LX+4Uvc4Nfs82Vu8Gv2+aVu8Gv2+WVu8Gv2+XI3+DX7/HI3+DX7/Ao3+DX7fIUT/GKt//lKN/g1+/8qN/g1+/9qN/g1+/8aN/g1+z/uBr9m/yfc4Nfs/6Qb/Jr9L7nBr9n/clB3dex8ecK8CimOD49OZCvjw5XMRGFkND9eGRkpjZfGCuWRYqaUnRzOTuayldHR8WJxfLI4ls1WymPFymiNe0XEbsfV31tsdSGXbKVmF64E/JQa/9Ea/lVO8DO1enW1E/mUanb5tULZ5gql4YnxzEhlZHx8tGIa0VzJ/Bs2WlMp5sbH8pPjRotKE+XxifzkWG6ylCvly6PG1pTzY8Plcr3NukZbb7KZmtyvdSL3+vuK69TlPnrgr12m/sZwkQft0b4N0upm+bo+/E3r8K27ulqPsw3CMf7X+w7+t+m9JUyvH/ITQDrWUb671PN9QK5jKZZeEMhrqCj9PsZVl099DVUX48Plw9dQdQtcB1mYdfydereQTreQjoT1pCLWLkWsBxWxphSx7lfE2quItV8RSzOPdytidap+VRWxHlLEekQRS1O/NOV1ryKWpn5p1qEHFLE0dWJKEYvWWvYG09tCvbZ5eJjaWhx3kKMwHDekWNiVEP+Maj0ed2n2G/O0yPhVy+u4PB7ng/2mrYAf1WewjuTYA+GafRzC73WDnyfZLwoaZcrz1BshKwqX/hMWD6O0+oLpcnfRP5Tyhvx5fVkEfFAGUViLWsTqFcJclGlPTL4x/f4YrlI++PhGskdS/5vi98bwwvgDQtr0LMmwD8IUZZiLkyHWRUp/CfAslSdu3Hrutq0Bc2kmB5LbahbvrGpdDlwHF0VgBez3anYvDXjo3I4Z57YdoDy12g6gbLeysJnaPeu4beAyt86W9c/Y3EJayBPXoai5hTSEN9TVRfX0fhmmtxjS7I9JcynjjfGtO6vaGH8A8pYW4vQzjhS/e1Gd6rFh+UmyIz697Plnki5TnlrVZSxHzq0m56Bejli2UeVyGJTLCcvrnHl6S4PofNDvspAecT+MxbWOyngZ3Fec40p8HiGl38e4KrdDtT7MMsaHy4dsi22HFofX12wbL502fv2OG68pL2CiHIRrhB9kcBQH46IbBEpBRDxe7NZdVJ3+HHckym7G+RgwXevC64FgetXn25whh7Rwj5vnJQJ/afr1ympjGHaHzmVhPTFhi2LCeoV8UVgfPHc1e26xgGk5XLOojoeyDQJZvchcS3KO0qUorDMZFj6/jGEtb4J1IcPC55czrMObYF3MsPD5wxnWiiZY1zIsfH4Fw1rZBOs6hoXP8y1/VjXB2saw8Hl+lNjqJljXMyx8nm/duqYJ1g0MC5/n28mtbYK1nWHh83zr1nVNsHYwLHyebyd3RBOsnQwLnz+CYa1vgnUjw8Ln1zOsI5tgVRgWPk/P9gtYvEnGo4UVm8DEW4dR+n2Mq6smeUMwXa4oH/7aaUjgOiiEcbs1JKQzJKQjYR2uiLVCEWulItYqRazVilhrFLHWKmKtU8Q6QhGL261m7fUl1YP/49preg51F+OlIY7URiNGVH8gHSTvF1zEOEtpSn3M11Ybw3AKjvdNcbpokIXhVNoyFoZ9TG73cZptOQtbDGGUH+xjdrP8bAvvux2uZzLYF4ySFR+3SP+DINl0jjQl18/S1UgH5cXbmEHFdHi/HtM5TDEdxDqj2pjOciEd0hteB7eEvzPtuUqSfGD6fYFsV7bo8MnO3XaYhcTTIbO9HaY0nkBd4a8cpDGDtH0mTp9sLe80k/gvvOXS8a0LISqaTk5nKYt3OPu9IoLWFhaP75BF3RLOA7HQcR5x0zNS+pJZpOtu4b510nCLd2Vb3UkEn18Tk87KNtNZKaTjdleO+pvdI9zg194CSkNczBOlz3cYo3DpP2HxMEqrL5heRi7MgJS3uHLGrm+SqYB1LWK53WmlXqZrY/KN6ffHcJXygW+T0M4tC/uGtlv31KJGbMlWuF1dkh9Oqo+U/mytRE36JlzqqtOzgyzMOn6ahfRWukdIR8J6QBHrUUWs+xWx9ipi7VLE0syjZjlq5nGPIpZmHu9TxHpQEeteRawpRaxHFLH2K2Jp6oRmfdSsQ5o6oSmvuxWxHlbE0pT9PkUsTdk/pIilKS9NW1hVxNKUV6faQk15adqcQ6HPpKkTU4pYWrK313wn607Re03Z36OIpan3mnnUtBOafQBNeT2hiJXka01pXE/xpRXu0rzUobLCvcjinVWty4HbnKQr3IvsXjqQV7hb7J+xr6fXsWetczsfm8+lWHo8jwFLv49xVS7/2pyVtGxJmvck2a0XuA4KYfw0amlJ03ohnUEhjLfb7WDdp4j1oCLWvYpYU4pYjyhi7VfE0tSJ+xWxdiliaeqEprzuVsTSlNc+RSxNeT2qiKWpq3sVsQ6FcnxIEUtTXprtUFURS1NendoOacpL095r6pemzdGsj5o6MaWIpSV7e83nYDpF7zVlf48ilqbea+ZR0050av/rCUUsmoORPnHhS+ulMewRMeng80ckwJLGwxRf+gwkbq4HP0uhZ92eoFSf65HKAz/bofRnMtdDcsuyeHyuB23bkRFYAfudZfei5nr4uqV94USW2xO85KXmfL1i3KeJ0ieTeI/rLz6/LAIrakeAwwNZVveFsrLlfvLyRsxmy22pjKW88vWEayLSx7LvZnEfBm6Z5dFpuZCrlM6SNtNZIqTTLzyXivhP6fB7PB2JM6WDawhJP+xc6Zt768/w8koLz9InkrzMvgC7V741xJQ+o4zS3xSkh+uoz6w2xifb3BPUZYJxuL5T/HeBTh3L9P1wlmfMp8SZMHFXCuRMn4hzDu9j9snRWmDRPlFa0qdIvYEsjyCQy4TrXa8gBymdo9tM52ghnX7huXbrkcQ57l3CTNNBLKqTbnWj9V1NuJxxd2a+7vgqCOM7iOGuyPiOi7s0+42ysHU3n2A3FLfv0mZPhmtZGMqQ13F0kgxJFkllOBBMlyGv28uEfEj1nn+v0Wq9XxnDAdMZYGH8U0MMw/rZx/ilBX7pGH59Qjpuvw1oXQdXsjDUwVUsDHVwNQtDHeR6/VoI459eXgNhPSzsWgjju9Thrt59LGwbhLVaH6hcbHpblXYLw37OlSxskYDr9tPGfD5Ju4Tp9zGuunzq76Cl+i/tqkiyWyVwHWRh1t1WrcfjYWnh3oIYrP2KWA8rYu1RxHpAEesxRawpRayHOpTXXkWsXYpYTyhi3ayI9aQilqa87lfE0qyPjyhiTSliadpCzXLcp4ilWY6a9ktTXg8qYlUVsTTlpVmHNPsTmvK6VxFr3q7OnV3Vkr295u+gO0XvNWV/jyKWpt5r5lHTTtytiNWp/dVbFLGov8rnt+w1vk+hOQDcik7zXfBc7juCeeL7jqCsUhH/CYuH8X1HVrnJW+y+I3F6gHN+fIvBdvYdIazZ2ndkdUy+Mf3+GK5SPg5XlEmS0ymkuaVWy1baqpaedVzHaus5Do+RE6bfzrc7ORaP3q0uCKaX3eoIrID9zrF7Ues5pD2J8F31RJ/MGd9VS9v/8tMQ3gTvqsvhtfReYDBoDENdo23s3J7u0vo8f5qF4Tx/1F5eQSDPkVOeWj2FAL/v4qcQEGbUKQQ9EI7xt/fVuRw9JGOmABO/c6P1KhSf3k3iGgKMwzlQ/JuAA19DQHG6IvK1KALzftDFW/pkzEDAlPLVx/LFOfQyDhT/DsjXcUN1fIxDv9G+XlNt5LZYSCuIuIfY+CwPi0u32bP2Gk+o4GFcV7i88PkomXJdofh3x+hKj8AB88vLlXPgcfoiONwrcMAtDye3XX9LeGJEwBw/+CbNfvOi5EXQI+BEOcK3z9zfJ+PQ7zj1w2Uoi4Q0FkVwxGeteEh8pfI15Z3lCAEtEDIgJbYgkJ10RATZUscnhiX+NpWf3Nbjhk/syW3SN9zSNsX0rPROnq9vSprOkqC+jm7Hzm3bo3SBlz3/3R2Rfkp4PmDPpoR7QdD4nbPUP+F5bvUUyV6Bv5ROX5vp9CVMZ3mb6SxPmM7KNtNZKaTDsaT+qnWlaj0c478f7PiJQzLmgghMOjKF4ktjCGltC8WX5kAOF/Io7W2wKmieNsqSt3urW+TabA6Crx2SxrJJuZ45y1y7W+TaJ6SNbb9p3K66qbz9/G07y2hiOI2AXfN2n+90zpuzRRFUl7B4fBk0nx7qZr9XsN+LBX6SIx7oOJd00NxRFSVZfRaq6ClDjWlJJgSrKKk9H/7is9LwV1qmj1OLUUuno8xPpdqYN4r/lRjzI30+E7czt/RJivSpj3RqznoWhnLCZfUHsKvTMWtDNAhT7MZMWvlkh+o8uHy6q8llYR2XnXSyD35ew7f6xU+P1rEwXC7HP4lqpldcX3HZGz2LnxZQed0C8XjTeCv8TrP4mCbFvw3SkYZE9Gw3i/9NYUg0KHAiPr3seV2dGZkkGd4eTHcUdkfQmHcMuxPin16tx+NOmt6hPFlZLGxhegfLkXMjTLQxWLZR5fLXUC78kElM79YgOh/0Oy2kx2VJ4dZRGd/JMLaEvzNtueJ4iqUXBPJwi9LvC6bL1sVw607Gh8tH6jbEHDJ5O1wj/OUMjuJgXHSXA6UgIp5U7KuF57gjUXYzzj+DWbh/ZDPCWPX52bjIIS3c46ODLoG/lE5Pm+n0COnwVdPW8cMsrw+m55XCboDn+MGT2yGMH2a5I5ieLwrbGYN5YwzmTTFhu2LCbhbCLKdrltQ5cnMsVQ1qaqSyi6oHUVhnMix8/k6GdVcTLH5AJj5/F8OqNsHiB2Ti81WGtbsJFj8gE5/fzbD2NMHiB2Ti83sY1t4mWPyATHx+L8OaaoLFD8jE56cY1r4mWPyATHx+H8O6uwkWPyATn7+bYd3TBGsHw8Ln72FY+5tg7WRY+Px+hvW6Jlj8gEx8/nUM694mWBWGhc/fy7Dua4J1CcPC5+9jWPc3weKHyeHz9zOsB2Kw7DUfZuHzDzCsB5tgrWVY+Dw92y9gpcL/1P16CO7rdXeyib+CofT7GFddPvXu10PBdLmifPhs98MC10EhDNsiDMN0HhbSkbBuV8S6UxHrLkWsqiLWbkWsPYpYexWxphSx9ili3a2IdY8i1n5FrNcpYt2riHWfItb9ili8LYvr19tr/hWz1K+n59Ce8emhNHsG4yNG1LghDZzvbMJ5iHGe6fjBXm9kWDMdP9jrTQxrpuMHe30Cw8Lnuc3d0wTrRIaFz7cyfrDXJzGsmY4f7PXJDKud8cNN1UasdsYPL2dYMx0/2OtTgkasmY4f7PWpDGum4wd7nWFYMx0/2Ossw5rp+MFe5xjWTMcP9jrPsNoZPxQYVtz44aEmWEWGhc8/xLAeboI1zLDw+YcZ1iNNsEYYFj7/CMN6tAnWKMPC5x9lWI81wRpjWPj8Ywzr9U2wnsWw8PnXM6zHm2A9m2Hh848zrCeaYD2HYeHzTzCsJ2OwrDut2oiFzz/JsN7QhNdzGS98/g0M641NsJ7HsPD5NzKsNzXBej7DwuffxLDe3ARrC8PC59/MsJ5qgvUChoXPP8Ww3tIE64UMC59/C8N6axOs0xgWPv9WhvW2GCzrXlJtxMLn38aw3t4E60UMC59/O8N6RxCfx9ODRix8/h0M651NsM5gWPj8OxnWu2KwrCtXG7Hw+XcxrHc34XUm44XPv5thvacJ1lkMC59/D8N6bxOsFzEsfP69DOvpJlhnMyx8/mmG9b4mWC9mWPj8+xjW+5tgncOw8Pn3M6wPNME6l2Hh8x9gWB+MwbKuVG3Ewuc/yLA+1ITXeYwXPv8hhvXhJljnMyx8/sMM6yNNsC5gWPj8RxjWR5tgXciw8PmPMqyPNcG6iGHh8x9jWB9vgnUxw8LnP86wPtEE6xKGhc9/gmF9sgnWpQwLn/8kw/qVJlgvYVj4/K8wrE81wbqMYeHzn2JYv9oE66UMC5//VYb16SZYL2NY+PynGdZnmmBdzrDw+c8wrM82wXo5w8LnP8uwPtcE6xUMC5//HMP6fBOsKxgWPv95hvWFJlivZFj4/BcY1hebYL2KYeHzX2RYX2qC9WqGhc9/iWF9uQnWaxgWPk/P9gtYqfA/vX/6CtzXe99TyKZYepQPvIfp9zGuunzq75++EkyXK8qHv3/6qsB1UAjjc45fFdL5qpCOhHWXIlZVEWu3ItYeRay9ilhTilj7FLHuVsS6RxFrvyLW6xSx7lXEuk8R635FrAcUsR5SxHpYEesRRaxHFbEeU8R6vSLW44pYTyhiPamI9QZFrDcqYr1JEevNilhPKWK9RRHrrYpYb1PEersi1jsUsd6piPUuRax3K2K9RxHrvYpYTytivU8R6/2KWB9QxPqgItaHFLE+rIj1EUWsjypifUwR6+OKWJ9QxPqkItavKGJ9ShHrVxWxPq2I9RlFrM8qYn1OEevzilhfUMT6oiIWn3Nstk5uPLyOWydHz1UhjH9imGbPYHzEiFqHR+FRzyHnCca5nfV4kwwLn9/NsPY0wSoxLHy+1fV4qxmWtB5P+g7utdXGsOvhOf4Nww0Qxr+t2w5ht7Mw/A6Oz0vvhLA7WdiNEHYXC7sJwqosbBeE7WZhN0MYyQi/g6PvI0lG28L7vSxvpINbwt+ZNp10chmXI5ZbKuJ/EEyfY7eO24BtECfF0rldMR3EOr168D/pKOov3y7jDpYOv8fTwefviMCKOinyBgjH+LeFZS+dFCmtTb4e7p1VDSLzSs+STnG7tiX8nWnPZQl/txv8fJz9xTzxOoiya0W/MK2+IBDblS1KsovLG/LnelgFPknWjVdbxOoVwlyU6V0x+ZZsrsRVykdU3cR04nat3R3DC+PHtc8kQ2wjFWWYi5Mh1kVKfya71pLc1rF4ZHcWBEFkX4djBew3P+kxHci71kq2rTeCJ6XbzI7j8xQvbguLJHZDSkfiTOng/gK4C+8b2bfypHe45Qd+18JPAKb4f7GsjvlUiCl9dxNVV1KQHu5NQGXP+UVtFXNDBL93QLvHd/C8QcjzmhjOhIn7PyBnfmIsxX8v63c5aiPFfhelNcD48vLheZHKhOvdbYIcomRrHfZTsB+D8T/UYj8F9Zv3U5ATPSuN9bgcpHTi2snbEqbT12Y6fUI67fZDpHQkznxMZR3ak88ye0J6h3ULn6Xv4LtZ/N8Ge/KFGHvC16fwvhO3sdyeUHpR9oTrJ8X/aow9kfrmF1WjORMm2hPkzO0Jxf9NZk+qQWPet4S/M206yZ5QWlJ7uTiQ5REEydrLxYIcXLeXi1k6dymmg1hUV6S+HLc/VZYOvxdnf6osP1H19ZtL5DSl+oq6283iPwL19U9ZfUV9J5lLesPbqLuEdHmdCYLp4zPr4mzZXRFYSdsoiv/dmDYqbqxhXdxYOm7OEeNhnLj5v3RMGqi3eJ/6xth23sDiVlncu2LiRo0b7XUlvHY7th/NUV3AOUxyFLZX4Exh+M3vpdV6PO7S7DfmyerKWUN1XB6P86lC2N4ITMle8F31Kc8LBNzdDJfCuoPp8qJ9tnj9/2VYF2z9/8kSGY/riXUvDQPdjl9H87x80fHy5fLhTipf4m3L96ahOi6Px9PEMpxiYWiz+d5uaOsJw8q+N0y0U+vSTOpLK/KsQhh/R4Dy5O8IpLYT5dnNME7qr8dZ3N/IieLw9sI6qj9UZ0l+XcLz1vG+H8UfCNO08vm1ITn9uPoWBLJdQDnwPRn3BjIXKc8U93imj1jH9PSxkKVy3Mc4Y9p3O0o7xdILAnmel9LvF/gQ7z4hrKsNrsXsyEhuuFAqViaGR4vFcorhE1d+j89RSntBDAjxSdb7ncg6X5K2hL4H5GpdF4TdzcK6IYw42jr0taFG/vc44p9E/pj+oBD/zGo9XitlOSikw8cc7WDdNUOsZUFjHZDawio8x9vC3RCG+4C+KMIuJ7F1ZNu43cd8cjt4BrN12P4p6lBB6o9yW7fPUdpJbR2l3x9El22fENaOrSsVC9lCZaw4Uarky6WRSiqY3iakhXvc1kl6u1SI79hWZCRbx+1ZF4TtY2Fo64ijZOvctIv5TBL5Y/qDQnxu65KW5aCQDrd17WDdNUMssnXYD+L91Co8x/upu4X8oK3j47JzmE1ys/W9PEfIbSrytQ7H0LtBTly+HAfvYb8Zn+FzNhT/Eui3X9gv86M8nCvwk9YUYb5e0h8db7cQzw6VqR+1tbzzkivHt5dLl5Qnt5d3pgOZHs8izz4fTgUsnnVd7N5N7Defvrme4VAT3BU0d6gSiCUVHWLzpvdyGPL84dDB617Gl9LaEv7PtOmkoSNvat28xsslHlZQ+n3BdJVzsXxEmtpE+fDmsepGPhl7aCuf+rZua3W6bDgP0hdpO/xUxH/KL7/HmwnURa43cSYwymTdBCZra389PrcBSZZsJXkVj/cw/pUsDF+dpWLw+TTItVCP6YBSqatD+XB70k8uK530g/qE3ago/ZeOb6D4VSG+9EoobmmRpFuoS6QjUjnTM9Lr8H7GtdVX//1COq7rVD/LD+ox7+K1+upR0t9mr9D2RNTJqFdoWQjH+HvgFdo+Vp74PMr5QL6q9bBZqjO5VuuMVA5xdabZkn2SofSK9bJqY5hUZyS5ct25XuAgtXOS7lwfkY51k9WZp8Ofp3hJ+ikoBz1dyCbup1D6s9VPuSGhXEk+d7iRTyaJLZLsp/Q6lbcpaGOk4Y/0uq8KPPhw8Z2hUYlbuhBXR6VX8AeWBLJhkev+Vlx9mGk6iEXHw3SHv2nM8iHoq32gP/p5OhKmB56Rlj3w/KAOYRv0UdYG4euYuNf/fIx1NrRBn5hhn8LlcsJm7Qg/agefj+rvLhZ42etrw2sqY5qK+SKU8ecjhvvWYfl8hZUP2kKpfChtaRqBnkVczvE3gOOvxdQ95PibEfHs9XXB9HjcFgWB3N/hZbgbsKT4hNfN4v9OwnED6YPbPlBWHDdg+fM+UNL2iMsJ4yMG2aBBFp/L0DrSi++BXnyD1W/Jjs60Dkf1V6Nsv+PpybGkfRRKvy9w2Weq91GkowDjdKIq8J+sRsdvpkMU/7Bgup0fBKxqeI2fpO1m93gbFdensQ5tzw/6ZQzMn9Qvom3wESOJ7W9Vn6U8dUK9SaLXUjpxfabbFNPB+sw/99oNYYp1q0Cy3wM8pT4ypm/9XshDmmFI8auMP8ffy+LT812BvJyX6gNv944N3z1aHf9v1vbG5dE6OvYxJXBKC3GqjDO9puqJ4Hwx40zx/w/aar48np7HvikuI+OfBFD8XwImP7kcX4UnsaPS6zp8JVdbZhVMl8s+9hy+FuRlLmHzV/MSDt+ukedzAdwbFLClV9PWbwl/Z9p0hEevbrsgjXsEPt0sfv/SRl6vYzKNk5n1+4V0cZvFQZbufpau1aFvDDViEjccD1QBk5dJlaXBeV7Fwin+cqjPh4XX0lIWbB/XLJXTxvHD3TFc9wlcsc7sqjaGU/xVIK9vDclckQ9ynbv5SblvThwP5LPaKB/JfmD8mdoPaenAbhaGbXGVpSPNDca1MfR8T0R8vkyT4h8N5Uxjq7h5TYtP7ZI0b8HnAG6DPMS1U81er5+4VMaN+rysUm3ML8V/FsxznLJUTts6rIOZFtM+MyLtfz+sjplnMpTmPjT7f1JZ4dINXi5x83qDwvP8kwkXn1FhmlL7zPv61WB6fqox6eDzVZYffI64Ou7PJh67Uvp9gkxcjF13B9PlGvdOZ48Q/46Y+HuF+FUhPo5d0bYGLF0cu+5l9+JscTO78OIW7QLOHWP83wS7cB6zC8iLfyaHNmN5IHMJgvgyGhSe59shuRoXLmf5uSMmP62+z8XnZ+tT0uUsnSi9uYLpzUw/lX4a9ObVMXrD331K77qlMkgyBx9XBjckTOfONtNJ+pnpM1mntinp1OOgU9tj+nnPdDlXFdOpQhj/DHw3PM+XFu9m6fB7cf2k3Sw/UXqze6mcZlK9ofh3gN5MJdAbqQyitlrCdGdr7c9s2cM4LKnvTfGrQvy4PpikS9J8tPR5J+m2289bkq8nofT7GFddPvX+rjRHsEeQ3ZKgPvcxXt6RzY2eXp7cfsv1O3lhEOBg0CjkvQyQ4gfsN3/Okupice4Q0rAO9yNBRRpkz+9m9zl+Ek7N4jYLlyrhnoh8BkGySojPt7q34l4Ix/hPwSRKkv0gUHn4Qt24/SDuiuCeFvLQF/Ecl720BwZxkvJM8d8Vk+fw8cg8n8nyHLWvG/7m8dJCHhYF8qIKwpBkfHjQyL1VfcLnZ6uzcjhLJ6px/2jE5HHUAtWrIRzjXw2N+ydY4y51vl3nP2rvJ8zX1RAnag+SLgHTOv4hCsX/fJh3xxM/4jdVlJY0UYoL8r+4tLls4sqc4l8BZf6VBGUeV3+kPc3ibIXXHZlsOZNExzF97zsy3001CjlpR4Y/F9eR4XGjKnW7HRmJU1TcVjsyOALgHZlWV4zg8xTP7Wqq3LQVzfhWBytT1IaKuMIibgTHV19xfN4A4Eehkuz4CguK/03oxHx76OC1VFYrIvgFQbKywudna3XPCpaOi1lc6/iMxmx31qN0MBteN+skfb/FBpN/3Ubxl0CD+UPWYCZdRZZkppbrfBAkm+GPq29J6w+XUZeAaV3URrgLwi+e3X5BW8zM3Vu7YuLGn9KPW1XRJ4S1tSnQSCWbGR4eyVdy46Pl4jBvI4krv5fkjd56Ib7bGaOCuCnQHpCrdV0QtpuFdUMYvhnkG2W46ZgVSknkj+kPCvFxsN5KWWpi0eYWVeAc97ZyNmxZ0gMyKP6i0DYl3Xga2y0+iSNtVMwHQzyP3CZatyX830yTKk0cpVcN8RYKXPiXQRR3AOTynaHGvESt/OmKyC/mLRAwomTH01ggPPvaoJFbNQE3aeIJMW6L4GkxZmsFipTOEW2mc4SQjss3X5hms/7YxoH6M2hvot5I3Vith2P8nw7WMY8KMaWvf6tBY3rSxGrcwQT0PK2843G4vaH4x0O9anYwAeYzTs+wPxZ3MAHFP4X1x3bD87M1ocXz3BXUV/eifTy72pgHir8eyjk70BrmiyMwXzVQxyy0iHlOBOYFgDkSo4+rgsb0pJWgUV+J8+dx1S1yUS7f2uFMO9zg1w7y2S7IAvNE6bf7FTCmNVtfrUt5iytnPKSOv5mWsLa3iNUrhLko07ivIzH9/hiuUj54v0JKZ5UgE4q/M4YXxqc6jLpPz5IM8fA/RRnm4sobDyOk9GdyOBPJbRWLR23cgmC67HdEYAXs9yp2Lx3IhzNZm/mm0M5L8yYrIzgTB36P6z8+z/Xfjc0cqUgrpcnxvhjnyF2a/Ubetrz/Y1kdl8dDDK7HUQedSjY3CkOay21W763DlxH0wnPHzm3byxduv+qm8Z3lM24qX7dT0N9FLH9c7/iOdztYXL7LDoXxl5nb2e9d7PfNAh/uuEzQ9QvxopxUP7A+HgvXM2kf8HmKJ6Wzoc10NgjpxGEdK2BR/BuF+BuE+JQPyV6SDcBDWF3Yb6kOYZtB6c/EfpPcNrN4NOZaEES3X83s92Z2L8p+S7pyfQRPSreZrkh9BI6F4ydadIJ1uZvF38vGQ276s2O1Qymwj0Eyc9tnGMunWHokb7yH6fcLfIh3nxDWzvx0bjSfzY6aV+jlTCEzXsrE1WW8x+v+LiH+8UJ8kvXNbmQtbuS8C+RqXReE3cjCuiEM2xM+P+3GPo0lkj+mPyjE5/MlSctSwjpzhlg0P402nur2bNkmtzal9f4k3/1hN4TxhVz4vgfn0rmT+qGUX6u33x2q4/J4nCuWRzW8lsZavKzi+qPWxZUVxaOyQn3xsayw7nEnlRXlt9Wy2gFh1fBa6lfxspLG2Hgvrqx2xqSzpM10lgjpxLXZSdpUKR2Jc7Pdut7L5iPJ3uH8OD67o1oPx/h9MG/6/pj5SOSI2KlAfhfGbTQ9j/PjcX0xiv+RmPnxnSzPmE/OEfPcJeTLOj4/TvE/yfqDjsYB4vw4peW2P9i6LUqxsN0Q/4xqPR53kr2hPNkyXrW8jsvjcT6ok1XA53LaKWDxcXpZ4EP5vDlo5I91wzr+3hefv5lhNdvxiy+Kx+eTfOGEWBcyrLh37812db+YYUkfKBBWtQnWtQwrapd2rlcS1nUMC5/fzbD2NMHaxrDweb6GbW8TrOsZFj6/l2FNNcHiu1ri81E7vURhbWdYcbvs3N0EawfDkg51kebysV1KsiugmwNqsi0f3DZbuwJKco9b3H6PwHVQCMP+GYZhOvcI6UhY2xWx7lTEulER62ZFrNsUse5QxLpLEauqiLVbEWuPItZeRawpRax9iljXK2LdxLCkdQySbVsS1MdCB973nDZ+/Y4brykHzGF/ktLA37si0h8Ung9isPCZuLxgX5PPeeHOzdL7WcLja0Z+CWMg2p1LegeHfJKcCODonX4uabvaqWsrpPkMenZQCOPjzFbeabar49adUZXTTwnPB02w6De+S6R40jwr5pWP+anu4ZwEYvA1exR/aZiutNNns7EYfwcgjbewXSc+A8F0e8G/w5DGlNLcPr43tK4LwhT1elLa5RDl011NLgvruOziTjrCsh9k8VGO0hwX71c10yuyo3ysgM/inJhUlkeyNKV3Q3iPt2lHCnmT0tnQZjobhHTisI4UsOLKL+7dd9xuzVUI024rouq1NC8wk3ffJLd1LB5/9y3NtXCsgP1ex+41e/eNZbojgiel20xX8Pk4nby+zXSuF9KJsvHWYb+Hz+tS/DNCG+/23etoPu67R7ffn40mfscetWsm8u4Twtp5x14ZzWUm85VyppifmJjMlOJsRqs7EG0W4rtdWz4qvmOvglyt64Kwu1gYtpXEUXrHXnXEP4n8Mf1BIT4fb7S6k6sGFr1jx7aE6vZs2Sa3NqVz37Hj2pBW3ttieVTDa+n9Ay8rqc2W+pNSWd0ck87RbaZztJCO1D9ORfyndPg9no7Eudl72yvYmEraLRaf3Vmth2P8v4f3tq+OWRPN+9q8TqAOWsfrPe6+naR9p/glGMPx97bSt5k7q9GcKY2k35lT/KtYH8NNOy+/t4377pXPF7T63au0V4Djvoz4LT05ya7tYGE4B8vXUuyFML7eEOdI+fwMn/PEMHxntIuFSe8eKGw/hPE9OvCECdRR7iTbjJuTbW3hHTfqzW4WJu2xIa2NOgauMYy48ntc3/D5HRHPcTvi+JuXrOM6XfsuSfrmG/PE++4zXReEafUxLG3ZxeUtbj0Uvqfj79kkrDtbxOoVwlyU6Y0x+ZZsgsRVygcfz0v17BhBJhT/rhheGF/agG2252skGWrN15DcTmTxqN+xIJiug3dGYAXs94nsXtR8TbPv058YlDkn3S+I4n8d+nFvhGv+HQ9ibQsaw7ZB2O3htdt3PCMT0rwKl93tkDYfA90h5CdpW0p5snq1sIW2FPtNyA0xsfxuhTj8+32K/zT0c48ekjFTQfy8NtehpHsIUPwPxvS1KU5XRL62R2B+FXTxIxG6HgiYUr742k/OYQfjQPE/Afmi955BEIjt7Db4fU21kduNQlpBxD3eFtwYERaXbrNn7fUtcC219Vxfb2Xx6b16lEy5rlD8z8foirSmN+59NufA4+yM4PBlgYNtJxaH4ZPbrr8l4lVoF1xz8ywVJS+CGwScKEdisNmj6sBx6Hec+kmvkYOIe7wY6Fnci7NUvqa8M+pd8QIGdn1EYgsC2SVZj9dp6wZcr8eL228CZSmtS+brBqRvj1pNZ6brBrgubItIPyU8H7BnU8I96w70YxYevJbGonzuo9WxqFQ5OFbUHkGlaj0c4/9JzHqDHcBDwqQ11hRf6hfHbWTcbHxJ6Uvft/B1k1LaKMskc/pxXKtCfOzz87UUyK/aItczZ5nrjha5RtVLasOMkb7qpvL287ftLGNV4TQCdt3L7vE4/LOFnRFUl7B4fNqbb6nG203eJt0k8JOcZBo4l3TQ3PFzBv4WqugpQ41pSSZE+jyDD+nwWWlIJ03LxnXfpcOWEIMvd6L4/xxjfqpBfN642u8W4lchDl/SJB0WJH1Kga9RDmBX62EUz/Fyp5K03Anz211tlIX0uQfG57LbK8THaWu+3AmnrfmhRTg9TGlKw1B8vcJfDUllKek1z293RH4r1Xo4xv9FjP5JMpG2aqb40qcsKCeuYyjfKRaGz1XDa0n/KJ5j/StL+of55fonfYqD8bnspM8+8BUHLl3G+ChHCqtCGKUp2T8qD9xyUXq9nYr4T1z5vbilBedWG9OpKqZThTB6Lcjrk9SVs9fZoDE+HvTO65MUn+SMUy1S+XWz+KsOO/gfDyXnU8/WNRwIfpicNtb9OwWuPO0ibFd+RHgd133jW3lvAO7/NBT9PH8diu0O3wq9CmH8s5ndQj4pvnXcxlH8o4Hnj4cOXku2BKfRreuCMEVbUmm1LZPsalxb1uyA8mp4PRhM19Ooc3UQqwr3ovpBPYHcB8Gt9TF+BsqIH0KObeZuxv22Frkn7RveCfn4PtvKH2W5h6UplZVk9weD6DYwSblL+d0HnKX4aCcw/nME2XPM7kDWpb0RmM8HTL6VdjPMqyMwXwiYvK8itZ/YB+R1RPqsCdtU3h/BOnIPC0PuvN28G9Lnca9h6Uuf4wZCukEMX2k5fhzfanjN24bL8UDq8LqX4SnbxXxcWR4n5CdpWd4Zk3+ORc91BdP1VapDdwvyuvQwGbO7RcyXCu2r1Nd5bbWe9uURfQPreN/AOm4D7xR4YZ8jbstz3j94tVBf52wMmS1npHYXZcHb3d0QJsmO25S4MSe2L4NC/KuqjWFJzrrDdGbSrn0x4mxACdder2E8KG9Sf8xeb4VwjH9djB2XZBgn82bj9mp4LW3rsJeFVSEMl+YewK5Ox5wLfUX5cH2Nk4V1rY7Xub6i3dzNwuKOfKoK6STVV3oWz7KUypIf2izpQFKd4Uud0Q5K8XkfiOLvTdCvQg5xn1oknR+Q2ri7AzltrLcoE37AN8V/XUJ7TuXidhyVzUr1A+XK60ecDK1rtY9IMpM+fef9Mawf+1hYFcJ43dktcEhad+hZ6ZD3Zlv+8HFd+LNBZ7CPyW09xX9jjK2X8tZO+8rnGaoQxpfISraj03S5U2x9lYVJtr7ZmbTbEvQ1bojhL+lKVeDf6ruN24D/AexqMC3fc1H2mF9e9trvNnjZx73bkJakJ7UpUefOR9kUPm9J8T/dok2J0ytNmyKdzT5384ydrVdVFoY2pVW9imsD0QZdkeBIzjg9inv3lXTsF6dHaYFXFXClz2it2xL+z7TpkhyZieWrOPdTTLH0SB54D9PvE+SoyCcbV65VuMc/cd7rhk/BmjxeV6zbWp0uG86D16c7gDvJ+GLA4cu1paN+bX36FptronSi1kBQGnw+4Dswd/Zthtlsy8y4uo/v11+8VOaKuHFHSu4BLCk+5h3j/3XMGFCyn1W412ofjq/vSPp+/a6IdKS1BFK7TPH/LuH4cHbe2eeyc/3OnmSW5J09lgF/DyTpKtYLXgekPppUX/EoTaluoU1AjsTDugrE4fMmYVCkPaBtUnn/7r9b7N8dBvdabZd5nalCWJKxuFQOcTZDKptpa3JibEazdT5cprU8LKtjJlnnEydTjXU+SWXKl4JSOkllSvEXQf6j7HBSmVL8xTEylWQUJ9Nm7+y5TFHe/FPoZjLly5al+c04mVL8ZTEylbY2iJMpxV8xhzLFPO9jz6HNqMJ1Ophu7/oinhuMwdwTgRnX/+QYUWVZFdLhZbkhpiyrQr72JMzXXqV87W0xXxT/aEf5ui0iX7e1mK89TfJ1G8sXxT9RyJfUhkWNa6U5F+v43D/FP1Wol4fynBmfF5P64XHrl+L0ZSbjmwyb24jbckRaqy7N0/E1Ws9LqAO4LYl1XRDmWgdQl7kOVCFM0v2ZzjkPCvFpnCzpQNRx95jOTHTgxKWN8aqAkYr4T2nye3Fra3FrKsw3jiNwjoKPI/ZCulJd5PGp3nUFcn+Trz+h+BeBvvK1tVGf9l+yTE47qq7wOQ2KX1lWx7wsvI47en6mthvlHGW7XzFvuxtsN8lMst28TsfZ7uuFdKTttKRtD+jZA+sa+pvz3y08S/GlPh/Gx/ENxr86pm8kzQGhnHIRmNtA769d1ph/ab2TjbdrmU7a22PGDtJYIO4TwmZzO8Qnbr0Fzzcvq13MLkjvR7hMsK+K8XlfFcNaGVtIa3u5DHsi4vM+OMW/U9CzJGsfJH5J20XsV3Obrv05KX+3I72/ifv2Ye7eEeZyki0OkzrguC3eHUyXBcbXWhMp2Wm0xVWWTrPjsOJ0hZ61urInLAxp7irqnQCmKa3BkN6d87pSDX8/AXWFr5uvwjNJ+u0U/40xdlHKQ1xdaNa2xr3n3BvzXBVwe4W0toT/M5lKW47SI7u1UOAS1V6+A+T4nSGZa2oa3/ac1HammJzQBivahkyKpRcE08cKvG2S2pstKnzq72SleUCp3pF89jnhk63gO9kqpL+1Ol02Uf0Hqf+L45EPsraL0ol6N5eBcIz/ceiXfSQCMwhat530rMX95pJG3DhbYV277xWqEBb3fpOvDcYy4WPxZt8m8XWOFP+zYBvivjEkXm7XjlfmfG0sX/8ad1RYVcBCXTiLcZXmgqX1inwu+Ddi+qFx63PvapH7boE7r+e87nwwQR+1nfW5ayAc4/9+TN9gt8Ahrm/gan0ubsl5ALtaD6N48+tz5W1Jk67P/Syz3dI3RnHvuqU5ZeSxFsIx/ndj9K8qcMA60Op8Lf8OMOka4Tn/FiiTzc31nBl/p4G6yd+FSOuipLUp+C3aG0P9cynHkdFMrU9LZUj6yl0XhGP8fw/1tQ/yQf+72uBZGRnPVvLjlfHieKlUmBzn28pbR2Vmt5my+vCjZXWZkZy0ZWYd4Xe7wa9999sFeU0LeaL0SZcWQPxUxP8gkMcslFYfw1LOWzYub8ifzxV0MT50HYXV1SJWb0TYFp1818o0HZNvnn5UfKkO0P2eGHyMT3YddbiHyWKhG1nk4sqtB9Kk9GeybTb9PoLF48ecoby7I7AC9vsIdi8dyNtmc7vUH0zPNz3j2KYk3k6U0u8LnNaHmh3oZnyi6i5uJ3jNtvFSuMsnN3m86FCcCMezzYuu1iyye1wdFrDnqBsoNaGcZ0rAkERAmANBIwd8VjIl6Yh0g6Curtx8NMOi63QMlyiMFMPoj8GYrzrzVUdw81UnWdXR7o3nRkeHx3ITmcJIabJSKuSb9ca105+cGJ4olCcmh7OF4XwhU5rt9MsThbGRibHJYqaUGcuOzXr+R8ZHTepjhfHCcGYyMzLcymiIdB97VryuS73GHgF7UHie4knpcB1eGJMON5mpoN7r6wnie4jdLP5zwjeF0kqOHniG8rGzOh2Tc+gS8mwdP3CN4m8BDv82dPCa6i2abny78cLl8Vy5Xe4KGtOm+Gcvr2OeEV5T+Ui928FAtjMYhmVJMlocJCt3kkkQyOXYzeLTrEdUuS9i+ab45wvlPsDiSDLoFfjhvTj9743AksrMuh1VmfulwJ3P/PUJ/NICP4q/WIiPNon4SLJZzML6GLaUDuYVy3onyyvFf4WQV2k2kdKei92UUYbd1cZ84y7eaSE+L49+If4SiEMyG2TxsWykOrqYhWG6PYyDZONRL/mbGWlmAG2U1D1HGRDPXiG/emU3mU2x9Ch/eA/T72NclXUp26qOkHz63cgnE6eD/YJ8iM9SJ3wytUPIB4W0iSt9xYR2BeP3gwwxPl7T83jvdjggy94fgOcIf5CFWUe7NKeEsLRwb8EcYQ0KWCg3KlNbj29gsuAnE0j/CZff4xyxPEnn42zETNNBLOpHSfXJ+i3h70xbLp+jfCwV8kFpo17p1Z3iSFJbR+n3BU7rcjZOh1E+VG5S3adnB4PpOnxrtR6vmX5jOhLWIx2KNaWIdZ8i1oOKWJry2q+Idb8i1t2KWLsUsTTz+IAiliavPYpYU4pYmuW4VxFLsw49rIilWY6auvqYItaUItZDiliPK2Jp6n2n2hzNPD6hiHWzItaTilia8tLsm2jqV6f2CzX1vlP7clVFrHsVsQ6Fvlyn6r1m32S+TWsNq1P7cp1qCzX7cpq2ULMcNeXVqf2vWxSxOrX/tU8RS7Nua9YhTXlptkOadahTZa9pvzTn5aYUsTpVvzT7vp3ax+zEtsNe83dWGm3HQAQ2Xse9G5bSSQmcpXfKCwCjN5ieX833yoS/zBE+5fswQVaYJ0qfv2OmcOk/YfEwSquPYSnnLRuXt7h30fjeHWUQhXVYi1i9QpiLMh2MyTem3x/DVcpHv6JMuhWx+Nogqf5L728p/jIhvqQnA0La9CyV7XIIUyzbXFzZoo2g9GfylRHJ7TIWj3YUXhBMrxuHRWAF7Pdl7F4a8NDNln3nv2ltDa7p5aeZz/4aieF8iqVHeQ5Yvp4payRur9bjtdtneL0iluYc/ZQiVqfOZ0wpYmm+K+7U9zadOsf1OkWsKUWsTtWJ+Xcacyd7TXntU8TSzKPmfMaUIlanrj3T1Pt7FLE6db5/ShFrvv/1zLDRmm3tXYpYh4It7NR3ZrsVsR5VxOrUeXXNNm3+PURrWIfC+gHNOtSpa8/m245nRtuxTxHrUFhvMT+nMHey18yj5jcJnToe0pS95nrqTp0v1OznzNuJuetPzNuJuZN9p9oJ6n/FrZ1xvI4o8XZ/lP5src2R5CqtuWh1jUrc/l2YJwxDDnH7hA0I6fQKz20JVGSV4/nlaxQkHoep88gXqQxwnQzXX5frXjC9IJD1l9LvY1xd6e9yxofLh+vv4QLXQSEsam0WhQfOZZ6fmKnMHa1ri5W5tEasFZlbd0e1Ho+HpYV7C2KwqopY+xWx7lXEmlLE2quItUsR6xFFrAcUsTTzuEcRSzOP9yliPaiI9agilqZ+TSliaeqXpi3U5HW/Ipam3h8KOnGPIpamfj2siKWZR03Z71PE0tT7hxSx5u3EM8NOaObxcUUszf7ElCKWpuyfUMSar0OtYd2liDVfh+ZO9ppjd80xMv+OFueQ+PyoNN+yPCYdfB7j4W/pO6trqo2cDofnljFOreYdn6d4UjoDbaYzkDAdF/npFZ7bEv7PtOdq3yGvaB+7yG8Q9kp93gWaA8SzBvBsii+saCwHPHsizZ5NQTl0s/ibVtYxvxxi8vNsArjuZXipQHOuNPmp7pR+H+Oqy6c+d7uA8eHy4XO3aYHrIAuz7rZqPR4PSwv34rD2K2I9rIi1RxHrAUWsxxSxphSxHupQXnsVsXYpYlU7lNcjiliaeq/JS1P29ypiaZajpuz3KWJp5vEJRaybFbGeVMTSlNf9ilidWrenFLGoP0FjCuw/0vkk0plo/PwrPPcNMTAM+cWdPI3Pd0U8x/PB18tQ+Jbwd6Y9lyX8RW7wa3vsNDv7j9KXzshLRfwnLB5GafUxLG3ZxeUN+XM9kNYjxWEtbBHL8QnetTKNO1MM0++P4Srlg58DKdWzlCATur8ohhfGHxDSpmdJhvzcwC3h70x7LhcnQ6yLlP5M9iciuW1g8c6q1uXAdXBhBFbAfm9g99KAhy7u7N2UgB9XvoMRz1sXdyZuv/Ac5Q/PsFwF4YtYGqsEjqtiOOLzFE9KJ9VmOikhHY4lzdFYV6rWwzH+ieEcjXQW5WqBX1xdXCPEXw1xiI8kmzUJnrOuX0iLOFE9Xgv3tW0hpkd88R6m38e4umqT1jI+XD68bqwTuA4KYdwurBPSWSekI2GtZhxQt2ap/HIzLb/VbvjElt9qQa6tlh/vI6xzko/sJPE6IpjuKGw9pM114UgIw7rCXZr9xjxZ+/WToTouj8f5oI4Rt16Bq6Kcyjy/gcAL29o3VKfzD2JksR5ksWhjHZfH42mifm9gYVgeQywM9WkjCzsCwjaxsPUCnyR10zpuY+L0arViOiijNSydNYrpoLzXsXTWKaaDZUdlNRBMLzusJ7yOp4V7PJ21QjqUH+zr4/uniZVymti3wWcvrNbDMf6yoTpmOcSkOr4BeOnV8VyG8jYUTHcUthHSXs/CNkEY1+fNEMZ18CgIw7LlTrIbJAtrN45pwW6g3eb1P659d9QfSty+U/qz1b7H9Yuti2vf6Vmp3tK74QFBrpinKA5SH3Gm9s5tHyN52VL6s9X3XpdQrlI/aB2TOYbxdRJSXzqOQ1y/fLXAQUpnTZvprEmYjs/5oTaH7OV42PjYNufBlY1x6FvFW9fU4zzM4tBaoCdg7cSj4bXUtlxZbQzbCGF8j+ZNQpjF/0YoQJIZtiV8buQowEgL9+LmRo6KwOoCrF7A4u06xf8ka8uPBly9Oj48QnI7Bjhxe3eso7ST2jtKv1/gQ7z7hLCuNrhWJkcz+czwcKk8XJgoFiophk9c+T0+X3ScEF/aJ5tkfXzgRNa52rkW1Tr+cSBX67og7FgW1g1hxNHq/deGGvkf54h/Evlj+oNC/AshD62UpUsstAcaWAtniLUsaKxPaHPc2qDcsGSDyEl1nr9bwzpGY6yUgCWNCyhPFvP5G+u4PB7ng3YeufF8SO0Hva8YCKbL9RiGdWwTrDMZ1jECr34Bi9t4N/U2eZ+W0pfsuIs+rWSXpXpBsjte4DoohB0zK3LNjXFe6CjsBEgb5cmdVC+It60XO1qoF6h/mH6UzFGXyaYOBNF2nT/H61uS/owjXS/MVNePccMnVtdRPjPVdbRbXBfTwr0FMVhHKWKR3kh9fb7Ov9W+/oDA2W0/OTcqtXPkpDI7hoWdEJF/7iQ7QHmyduC2jXVcHo/zQZkfz8LmoB0aPpTaIevom5p269OhhiXVtVTEf0qH3+PpoE7zPtlmeA7fD/yUvR+g5/D9AD57cbUejvGvhHmYn4eYkl0kjlQPT4QwRVtWe496UjDdUdjJkPYKuOZOslfEu9X3g1jPT2ZhWH6nsDCsj6eyMLS7GRZ2osBnpvqFZZWkzz/TdKT+mOv6wtuO4xXTwbKjshoIppcd75ucwNLh93g6RwnpNKv/a1bJaUbV/2ur9XCM/zKo/0eEmL1CHueyjp/Iwk6BMK7Pp0IY18EMhGHZcifZDZJFq+8HsWwpT27n8nLj3L4EAi+0L3z+/CTghe83uZPkhHN/j83QvvLyxvpO3AaC6TLkcyOttvfHCPmQ0hloM50BIR3HdW5CKndyUrnzMcLJEfnnrlndaWWMgDI/iYXFjd/dyDD5GIHSn63xu9TexI3fTxS48r6Cdbz/fKKQzolCOoc6lmR/UxH/KR1+j6eDOs3rZlQf4SLWR6Dnko4RKP6Z0Ee4NMSU5pOJI9VDtBmKtqzM+wHopH5Aq2ME4t3qGKHdvr69zrIwtMk5FnaywGem+oVlNdt9atf1hfcnXI2teN9Eak9TLIzS4ffi+ia8LYyq/9evktNMOkag+MNQ/3ewMQLmcS7rOB+TS319CstCGNfBHIRh2XIn2Q2SRatjBCxbzBNy74J7OGa/oHrwfzeLvycsJ1tm1VWN6W2GNCjtA3NKLJ5UH93O/yT/voTS7wum13cXfSypXyCN6SW7Tc8OCmH4/eBM7IJkYzptjo6v4cXxO5Ybd83m71r51gHrGB+HIx9FOVW4nQoEXhm41+q3DqeALFrpp7jsi9jrPAs7ReCTpJ5bx/Vd0p1nWv9Bql/tpoNlR2U1EEwvO95POZmlw+/F9VN4m4z9SOynfGSVnCb2U/BZviaS4m+GfsrHWT/F0VikpTqO+jvTvgiF5SEMy5a7ZuObVvop2HfHPCH3pP0Uiv9lVk6O+hWZZSxfkkzn+zvu+zs4l8ttXKv9HT532in9Hf6tyFz0d7Cuzvd36mHz/R05nUO1v4P1BMMonWb9HameSe8osL/zTwn6O/hsVH9nEPo7P2btqKN3i172d/Cd5EznZbjdaDaHkmJpR/WLzq8e/M/nb34J8zc/XxXNazOkvWt1Y7z5/oxf8zdUlvPzN9P5YH2b78/Uw+b7M3I6h2p/BusJhlE6zfozUj1rNn9z4mo5zVbnb36+uo55Sng9P3/T6FAWszl/w/spFP85rJzmcv4m7rsBR/2LxP0dvibI9XcD0pqguO8GkqwJstd8/mam62VQHztpPaS95vM3WD9b/U4Oxx6t9HdQzsTN8Tv3Eu8LBAIv7Au02t/B9+MzXXuvvb4ebbjrdnu21t4/U9fvDAT69kiqZ3zMYR32d65cLacZta6G93co/j9Cf+e1rB119F1wS3Uc9Zf3kyR9bnXNTVK7gd8at9Lfwb4stxvN5lCoHLCfplcO+dr5Q4VguqOwIqSN39JyJ8mMeFuZvWpTHZfH42miHSmyMNTJYRaGdmGEhWF5j7IwrMtjLAxt57NYGI4Hns3CUH+fw8JQf5/LwlB/n8fCUH+fz8Kwn78lvO40/eF1dRjC+HcyIxDW6ncyqHcf3lzH5fE4V9Rv4r0kqO+PvLW885zyLZeNX3NVaXznVduuu7h8w43lHTu7GCxvUvlnZ8dH0EWcIIaudQtY2NEsnLaVWhDIrl94jtIgtSnA/bkYrlD6fcH04nExXCkwPlw+fLhSFLgOCmF8OUtRSKcopCNhka5IS9/5sX3SFi/HxKSzTODcaSZkGQtDE9JO8zTTZXzErVfgoyinEW4WA4HXKNxrdVg0DLJoZViEMufNKuoMb1bRtvBmFcubN6vDAp8k9sQ6ru+S7sTZxZmmgzLi09p5xXRQ3gWWTkExHSw7KquBQN/uSfWs2bDo19iwqNmWBHxYRPH/FIZFX2PdcTef0rVWx1F/KWwMwrg+PwvCuA4+G8KwbLmT7AbJop1hEbcbQxD/tdXGsI3w3FHsuU0QhsOpb7BX0rgV6RDDwK1fN7Iw3Kp6E+B/LgTkOvRt0KG/Y3qZdLsjii993nuckF9pWyo+xelmWN9Z+kthz4GwdrYX+3GCYYRUztLWeGh/zqo28t0s8EW7xqdv/hl07KcRr8AwbdQ7rmOnCPGl13rSFBg922mfXfKpIxxe8+EoDq/51BEOr/mUI7a7rX6uha/RkurYTyOm/iiNVnTsRMC9kukYcfsl6Fj/msa0T22SNtexjBAfy4tveYB6RM/2Cs8p2rFMv8CVnKQrfFqvVV2R+sRcb7FfhTLhTtIxklMrOsbLWbIl2CZxHZOWJOJreq5jy2AZ4VACHZO2tkiqY9TOzutYY9hs69hQAh3DPhHXMekzH1zaynXsaNCxfAIdi+uPzduxelgn61jekR3jn4tJfac4/ZH0DV8Z8L4WvoagZztp6SHKx0V/Kk63kuoPLnVMoj8plg7hYvlYF9e/omelrRCOSYgbxyOuHZR0XVrqK/XnT2Zh+NwJEelEfTrAt3Sg+OeHdROPvKTywCMAKO3e8H8XhCm+Bxi2PLLAg8uwu9qY77jxknWt1nmS2WAwvV3gy7+xDHi92yxgSlvxSPp0VAz/VvVJ4thJy4ck+5J0aQF/XdmqrUtqs3C5Uis2S1p6l9Rm0bPSFo9J5zPieMTpWNwnEpKOYfvMl+jgc1FLdNBmYd64zaL41ye0WbgNlXVdEObaZqEMuc2S6ry0NClpnSeZxW3h1MoyJ8TELYapTDdCvEWM68ZgOteNQt6kI5E2RmAlPRKJ4j8Z6gfZOZyT1iv3+pFIWPfIDlDaRzlKO8XSI3njPUy/X+BDvPuEMBdHIiXdQp/iHy3EjzsSyc07IflIJJwbt64Lwo5iYVj/8V0NPxLJ0dFduSTyx/QHhfj8GKNWj0NwgYX2QANr4Qyx6EgktJ9kc2bLZrq1dbm8ZOvISbaFH72EdbnVo5coT60evYQy51tzb2ZpcplTH2ogmC7XzQzrqCZYZzKszQKvfgGLtyWO1l4lPnqJ0pfaC0U+2Tj7L9U/aS6S2zJpma9bubZ+XBnKkzupXuCRZK0cvST18+JkjrrMj16S2g/+HK9vSfpNjnQ98dFLXNc3u+ETq+vSO7xWdR3tFtfFuDlSCWujIhbpjdQ+8m3VNwrpxLWPAwJnt/3xXFFq58hJZbaZhR0bkX/uJDtAeWp1W3WUOd9Keg7aocTbqj8T2iHr+JbjM61PhxqWVNdSEf8pHX4vbn0o75MNwXO4zvF77L0WPYfzWfgs31ad4l8Ax2T/IMSU7CI/ZrVTjoxsdVt1XNPVyjrnuONxsPz4vFbcltlJjnNCPjPVLyyrJH3+maYj9cdc1xfedhyjmA6WHT+uEctuI1xjGKXD7/F0NgrpNKv/wVo5zaj6z+ezKf7zof6nQ8zeYHoe57KO83ct+J6S6zPOTXMdxLlpLFvuJLuBR0y2ss4Zy5YfTeFmzjA3wu1LIPBC+8KPXsJ3Kq0evYRzjK0cvSQd8yfZV76uRurXzrS9l96bSukMtJnOgJCO4zrX8vGsfIwwF8ezosz5O9W48bujbU0SjxEo/dkavzd7J8vHCNJRn7yvYB3vP0vfLEjryQ91LMn+piL+Uzr8XtzWGrxuDsFz2EcYZX0Eei7pGIHinwx9hGeHmNJ8MnHstGPkWh0j4FFxrYwR2u3r2+uZbC2DfGaqX3FHe7nuU7uuL7N9DKy0NoX3TVo9rnGzkE6z+v/StXKaSccIFH891P+XszGCo+2yWq7jfEwu9fWl9V9Jjm5NajdmusUvli3mCbl3wT0cs/MjDSj+VWE52TLburYxvSFIg9I+MKfE4sVtZedm/if53hCU/mxtZSf1C+K2sjte4CptX9UN1zOxC5KN6bQ5Or51r3QUeNI6hvN3M926l4/DO2GLY+ta3bNh/hh5OV8a6Ryqx8jzfkqrx8hL9UzqR2I/5fG1cppJjyKobWsK/ZQ3sH7K/DHy9TgzPUZe+t4uxbgn7adQ/PeycnLUrxC37uUyne/vuO/v4Fwut3Gt9nf43Gmn9Hf41r1z0d/Bujrf36mHzfd35HQO1f4O1hMMo3Sa9Xekeia9o8D+zh8n6O/gs1H9nf9eV8f8E9aOOnq36GV/R2OPKm43hiBMmkNJsbSj+kX8SAOK/0OYv/nB2mheQ5D2q9Y1xpvvz/g1fzMUXs/P30znMwRh8/2Zeth8f0ZO51DtzwzBNYZROs36M0NCOs3mb5atk9Nsdf7mB9CfWRFez8/fNDqUxWzO3/B+CsXfzMppLudv4r4bcNS/SNzf4WuCXH83IK0JivtuIMmaIHvN529mul4G9bGT1kPaaz5/g/Wz1e/kcOzRSn8H5UzcHL9zb+mIKuta7e/g+/GZrr3XXl+PNtx1uz1ba++fqet3BgJ9eyTVMz7msA77Oxesk9OMWlfD+zsU/4+gv3Mxa0cdfRfc8jF0vE+L61O4PmOfIsmam6R2A781bqW/MwRhcfvNUDycQ6FywH6aXjnks8QjG0x3FIb7Rm2Ca+4kmRFvK7NWjl5CO8KP5407xwDtAt+D+1A8zqnT9IfXVdxjkX8ng3sstvqdDOpdK0cvoX4T7xkcvcSbVP7Z2TERdNs5emkTCz+3Oj0eun7hOUqD1Aa3k5uL4Qql3xdMLx4Xw5Us48Plw4crOYHroBDGl7PkhHRyQjoSFumKtPSdH720WUhnc0w6ywTOnWZC+NFLaELaaZ5muoyPuPUKfBTl1NIRVda1OizCY6haGRahzHmzijrDm1W0LbxZxfKOOs4J+SSxJ9ZxfZd0J84uzjQdlBGf1s4opoPy5if5ZhXTwbKjshoI9O2eVM+aDYvez4ZFzbYk4MMiiv8lGBZ9iHXHkddc1XHUXwrDo8S4PuNJllwH8TgcLFvuJLtBsmhnWMTtxjqIz49eSno00lB4bcvvc+yVdBfEW8cw1kLYehZ2BIRtAPxHw++TuQ59BXToD5heJt3uiOJLn/ceLeRX2paKT3G6GdZ3lv5SGB7n1M72Ykm3+v+DCPtDaXD7c1a1ke+QwBftGp+++Qbo2PciXoFh2tJRohS/2bbHQ+G1NAVGz3baZ5d86uhkCOPDUWkbdGl4nWRL7qQ6hq/RkurY9yKm/iiNVnTsOMC9gOkYcfsh6NhPWNonNUmb69jJQnwsL77lwfz27Y39Hy4T7iQda3X7dqmcJVuCbRLXMWlJIr6m5zr2v6BjC49oTPukJmm3qmPUzs7rWGPYbOsYL2et4wJoaSvXsSXwac7aBDoW1x+bt2P1sE7WsbUJdGwmdox/Ltbs+EOuP3FHIEh9LXwNgUfR8OfmclkSX6ql2Z+K062k+oNLHVs5xkRaTjsE9+L6V/SstBXC5oS4cTzi2kFJ16WlvlJ/ni/vw+eOjUgn6tMBvqUDxS+GddOWR9wxJpR2b/i/C8IU3wOIx5igDLurjfmOGy9Z12qdJ5kNBtPbBb78G8uA17shAVPaikfSp40x/FvVJ4ljJy0fkuxL0qUF/HVlq7Yuqc3C5Uqt2Cxp6d0Q3IuzWXj0Dd/iMel8RhyPOB2L+0RC0jFsn/kSHXwuaokO2izMG7dZFP+lCW0WbkNlXReEubZZKENus6Q6Ly1NSlrnSWZxWzi1sswJMXGLYSpTnP9dxLiuD6ZzXS/kTTpGZH0EVtKjlyj+naF+kJ3DOWm9cq8fvTQEnMgOUNobHaWdYumRvPEept8v8BkKr/uEMBdHL21kXJvZoU1C/Lijl9y8E5KPXsK5ceu6IGwjC8P6j+9q+NFLbtZW1I9eipM/pj8oxOfHJSUtS5dYaA80sBbOEIuOXhqC58nmzJbNdGvrchnJ1pGTbMsiFoZ1udWjlyhPFrOVo5ek95QpIR+SzKkPNRBMl+sQw9rYBOtMhjUUw2tTEyx+9I1Uf/uF53i75GgdV+KjbSj9vmB6WSnyySaVK19XtlngKq2JQL3AMEwnbr0XYg0pYpFeSPrLt63eIKSzISYdfJ7iue3v5HKSHSEnlRlfN3BURP65k+wP5cnan1a2rUaZb2ZhG4VnHdfNxNtW87rppkzj66bUzrZSN63jWzrPtD4daliu199R2UprjXAd2WfZewN6DucL8Fm+bXVNh4bqmF8IMSW7SBwdf3rT8pF8rW5bjWtmWllHivWcvw/A8uPzBlgf+bumJMflIJ+Z6heW1caIfGmkgzKarfWqvO3YrJgOlh0/Dg/LjvdzWj3idoOQTrP6/2dHyGlG1X8+X0jx/3VDHfMv2NyQo6P4Wq7jfC4b3wNxfca5P66DUVt4cifZDTzCr5V1pFi2fOt/N3MyuQK3L4HAC+0LP9oG56xbPdoG53BaOdoGbQcvb6zvfN2C1K+daXu/XsiHlM5Am+kMCOk4rnMtH3/Jxwhzcfwlypy/s4obvzvaNiLxGIHSn63xu9TexI3fpaMUeV/BOt5/ltaES+t1D3Usyf6mIv5TOvweTwd1mtfNqD7C4Pr6M/hc0jECxf8r6CMsD29Kc7fE0e12Mq0f09XqGAGP4mpljNBuX99ez2TrDuQzU/2KOzrJdZ/adX2Z7WM2pXf/vG/S6nF464V0mtX/U9fLaSYdI1D8P4D6nwsxHW9H1HId52Nyqa8vra9JcjRmUrsx0y1UsWwxT8gdtxzbCBh8y3iK/4IQ1JbZ89c3prcO0qC0D8wpsXhzcMR44m/vnwlHjNvrbrieiV2QbEynzdHxrVFx/N7ON2+tfBOPdYyPwzthC1nrWv0mHreJnT+me/6Y7rh0pC3JpHWIvJ/S6jHdUj2T+pHYT7l2vZxm0q3eKf7noZ9yPeunzB/TXY8z02O6se+OeULuSfspFP9OVk6O+hXi1qhcpvP9Hff9HZzL5Tau1f4OnzvtlP4O3xp1Lvo7WFfn+zv1sPn+jpzOodrfwXqCYZROs/6OVM+kdxTY3/lAgv6OtK6R93feB/2dD7N21NG7RS/7O/hOcqbzMtxuNJtDSbG0o/pFfMt4iv8lmL/5wvpoXusg7eEjG+PN92f8mr+hspyfv5nOB+vbfH+mHjbfn5HTOVT7M1hPMIzSadafkepZs/mbf1Sav3kc+jM/mp+/OeA6Zf6G91Mo/s86aP5mo5B/x2uCEvd3+JqgjW74xK4JQvnMZE2QvebzNzNdL4P62EnrIe01n7/B+onlxl2zsUcr/R2UM3HrpCOArGu1v4Pvx2e69l57fT3acNft9saIfGmkgzJ6pq7fGQj07ZFUz/iYwzrs7xx7pJxm1Loa3t+h+Hugv3NCiOn2O7fWj/nifVpcn8L1udU1N0ntBsmi1f4O9mW53Wg2h0LlgP00xXIoE49TgumOwnBfniG45k6SGfFu9WgbtCP8+FPUyQwLQ7vA9zg+FI/L6TT94XUV97Dj38ngHnZYrtw107tWjrYZgjDiPYOjbTay35vY780RdNs52maIhSc92mZISIPUBrfrmovhCqXfF0wvHhfDlVMYHy4fPlw5VeA6KITx5SynCumcKqQjYZGuSEvf+dE2rW5bskzg3GkmhB9tgyZkCK65a2YmZrqMj7h10hFA1rU6LMJjfloZFg1BGG9WUWd4s4q2hTerWN5Rx+UgnyT2xDqu75LuxNnFmaYzBHH4tPbJiumgvPlJqacopoNlR2U1EOjbPameNRsW7WbDoo1hnKTDIoq/DYZFU6w77uZTutaP+eLdXzyqaYiF4UmBXAfxuBEsW+4ku0GyaGdYxO0G9oP40TZ49MwG9hwePYPDKX70DOE/PTvlWttifIMgE0p7yFHaSep4nP1D3lI/rJ1tCHPlicnh8fFKfrKSmRyvlFPBdNsb1w/jdRzjHybEdzutkR8nvcdtCDeCXK3rgrAhFtYNYTjdwLch3OiIfxL5Y/qDQvyzqvV4rZSl1FYuDGaGRdv94bYH/HNVPmazzq0dSD7uofT7GFdlPrVxjzRO6BLk2h8jV2kbEb4spdVtzBCL7L407lnN0ml13LNayE+nbdfIl7+gDUP94E5qs3G7xpmOe4hbJ20rZ12r456NIItWxj0ocz7NjPrEX0+gPvGp/iEI41PeGwU+SeyJdXGvaboi8qWRDsqI6+9qxXRQ3rxPuEExHWmLUWnLUD7uGWLpNGsD1wvpNBv3fOtIOc2k4x6KfwWMe77N+sdDwGuu6jjqrzS1z/UZp/a5DuLUPpYtd5LdGAqv21nOy+1GXJ8EdXwu+iSU/mz1SVYzPlw+cX0Selaqt7iVFLcPrfZJqCwHgulltIalI+VndUw6a4T8uO2fZiuSzSQntVF8icpGCGu1T4LzCK30SVDm4WOu7VVWapM5L7RlrfZJhsLrdvok/HUa6hO3O9L2Oa30V5BPEntiXdy4b7b6JFx/1yimg/LmY8/1iulg2fEt7SWbOFO7F9fHiuqTLNsgp5m0T0Lxz4Y+yYrwupc9P5d1HPVX6q9wfcb+CtdB7K9g2XIn2Q2SRat9Eixb/q6auHcLcVexMIq7CcrrzPB6IJhe/5YEjWGrIGwxXGO6qDurgrorVWWex4bpHzgaakjGXBCBSfoozetRPtweXTSZlY4uQjvVXW3ME9antBCfz51KcyVYp3hfCnWS96W6BCzs49DcoCRP4jgX8kSOSeQp9duSypNkJMlzLcNaI2ChjOPkiX1G67ogzLU8kSOX59omeeLylOSPciIZSZ+OHMGwpD441nc+d03YPUJ8bpMw/mlgc44bauS3BJ7nurBYwEYbGlfP+oR89LMwfPbAJ50rGvlTe3sO2O/LWdobhbTj6sMmIf5GiEPllWS7d3xuLucfhlhY0vmHuCX9cVvdtjo3QXJq5QjgyyP6apQGr4tcx9YJfLEPyOeZXgU6dg1LW9IZaf6e4m8W4mPfjOvYEITRs46XPOeluWpykh5tZGGoR1zHUI/4HJekRxSGS1SH4Jq7Zsuhk+oYL+chlkYrOjYEuN9i7/dJdjeAjt01yzqGtmp2dKyz1o9Q2DCEoUy409KxuxK0V0l1bCPg7mY6RvVxCnTsUZa29Nkr6h3XseOE+NJntdInKPRsp217zN9j4fJ2buOkY54prNUjh5PqGH7GmlTHeDlLn/sk1bGjAfdYpmPE7UnQsfewtI9vkjbXsWZH1ZLc54+nbgybzeOppXKWbAm2SVzHNgt88TN5rmMfAB37TAIdw7Rb1TH+3mRex+ZGxz6TQMekIzel9waoYx+I0LEvgo79bgIdi+uPzduxelgn69jvOrJjfLtWqe8Upz9xR7xLfS0cY9GznbT1D8rHRX8qTreS6g9uNZREf1IsHcLF8rEurn9Fz0pHEaxPiBvHI64dlHRd2mpL6s/z7XXwuaMi0onauo8fqUDxfwjzlCcOHbyW5pIpbbdzyZlhaS4ZZdhdbcx33HjJulbrPF/Liu0C334Ny4DXu6ht+QYjjsJAPhti+LeqTxLHTtq+Q7IvST/t5+sbWrV1SW0WbhfSis2Str5JarPoWaszfxZxxGoz3DgecToWt0WhpGPYPvMtMvC5TRHpoM3CvHGbVduybyj8H8TbLDwGyrouCHNts1CG3GZJdV7aGiRpnSeZxR2h1Mo2I4h5YCvRUP+oHOid2uFD9Tibhho503th5Lw2Jo/SuwZ8t0zz3QOMAz7bKzynV86tr43j73M2QljcWn7+jgjr1zoWhvULZcKdZNdITq305Xk5H8HSwLKyjtu4LoGvxZ1YefC6j6VLz2wJf2dadLlSqZwtZEfGRsuFQmmsyLdvs450cbGD9AvF8ZHJ8ZFsdqyQLReys57+ZHF4YtKQyJSzB8Qx2+kXSxOjmZHc+FhpcriUL042S5+O9Oyp1sPRplu3MPxteaWF+ITXzeIXh8K4xo+E16Tv3UJ6B967x8RLRfw/gCHc66o23uutTo+frk6PT2n3VadzpLDFEIbtjXVLwt8oL8QiHt0s/mlDB/9TmSyCZ+j5QSH9RSz9Bt7CPWwLOFZauEfxbfk8ZyjEC+9h3hXb+Cxx62H4eI9zI92xem1t7I9C5ZfWyLSqS1FrWq2j4z+pPewJnMgkR/gLGT8l/Nq7zO5gupwo7UVO8lapJCkHTL+PcXWhf5ge8eHy4d8597qRT9l+W026h/W3R5AN57GQcexzxFEaExAnCuuCMOJxYM3WUY0cFzji6LaOVmr7DmD/D9dnXzFUTxfLBsdkqPfYtmL88aE65qvD6wHApefJTi2G8IVCOP2m8logxOXfhuNv4s7livFJJ3si8trD8krxtw4d/G+5HbtcxkT5Ia8FEZhXAyaNaQkT1/XF1XmKv1iIj3WM+AwE0+vmYvYccu8NGh3ek8onxeLyviUeeb2QxV0YkQ6Xh8RhkYAjffvRy7himlwfrONjmbSQDtYpbPN7hfQV24ei1FaSo7Aell8Mw7y/rFqPx500jqQ82fyeNVTH5fE4H6muafaN6H433OfpplncHhaX71+AHLsVOA4K6fQw3IUx/FMMp0t4rj+Q66P0PynflMBXamvaTQexLq82poPljG3aw0N1XG7H08KzN1Xr4Rj/8aE65mPhdbM2jdsSzMPLq/V73Gbzfiyvk3xOl7ddPA624xj/TUMH/2Pbxe0DYtl7Tw01pi31EaR+H+8jfGGojvm28DquDzAQTJcN1+Felhb2j6l94TJ4eqjO491D0WmRXPtj8mjvvX9IjoccMB7HkNpOwpDqNT03IPDidY/bjp6YNKT2TEqjm4W1Wz5Su419DakPI4Vje47p8HsLhPjN+h99EdgSbo+AI9n5RSwsJYRxG4b5RRvG+ybSmAxto1Tvosouru8tcU/Sr+qJ4S7JD+2Q9hxlZjSTzUyOFCuVbGl4fKLQbI6S7tO8IuXrwH+41w35sg7nz/j8Hc4FdlUb06e5Mpy/Qyzi0c3if33o4H9pTpWeHxTSxzkunpaUPp+/k+Y1e4X4tkx/a+jgtYu551xxbHR8bCKTzVVyufzo8GzPfQ8XhrOjo+Ojk8OTlbHC5MSsz/2PDVfG8vmJbH6sVB7Lznr+y4X8RCVbGRuZyFcy+dHsrL97GM/kzDuXiYlitjw+NlZplj6O11KQvnVJ50Mo/veHDv63mCezOYIFMZjW3VhtxKT4PwRMPkcgfQ8o5ZPudwvx+djUuoFgentCz/JxBcZzok/ZbLYyXJgYHZ7MmamtyVl/l1cZGR+ujGSKuVKhnCuNz3b6E6XhycxYPlsaHx/JjAyPtqPP1kl6Qm0xlXuacW+GtSAGKxWD1d0E60yGhc9zfeTjf+t6g+n9L8X5l0KKpUf5CFi+a210ML1euXhf0EyuC5jspH7+oBDG5yCk/mmPkI6ElVLE4t9FRtkm6X1cnN7wOaMt4e9Mey6x3tTemwazozdpxqeZ3khth/Ruks6kiLMh0l4As4UVN4fleg43qS5Q+n2BU93Mxsk1LciVz4vis3z8ax0vP8lWSe85fMFC+yPNa19ZbQyTbJU0nufzUtK7PW7jBoLosuF2V2pbkS+fJz1p48H/0noARX0Uj97k75Idte/D0tweuX4h37zccT6Hly1/R49h0r4dKYFDmv1GWdi0n31UHZfHIyfpSIqF9Qj5kOaSeBsg9YHi1g/EzUlK9pvOCEgxzCCIn3OS+qYz6UNjehcyLpTfHiE+4nWz+KdvPPgf95DhmDSGtG5ndTom55y0blO8FwGHHaBDXA68jey0frbrvUrjxtPWzaSfbR1vi2baN3aF5fpdKO/PR61jednG+jO8Tkl9Fr7PIMV/5cY65ivCa8lGEMfFQbxdkOaKuPyj1p9wu0Dxx2PsgvSuE3ntrMqYJcDkc0vS/L1UfnRfWqMW935Peq/WbJx/ALs6HdPxtx4F6VsPlE93NbksrOOyk95rSe8kB1l8qe3EesT7Js369HFrXXD/sJeB3vB2UhpDpoQ0pDnGdAQ3KR7HjkqbyxrjtjJfECfDuPzFzaV1N8FKMv8VZ9cR60KGJa09icNKOsfH14XEza84WqOceExN6c/W/EozufL+QtzaAKnfHWe7JfsjYXUpYnUrYlG5tVJnOQ/+bsU66tN0M9xLNh38b+X+5MbGOIT31MZ6nDdulPlZd0G1MUwaT9l7F4ZpSuuPrd8S/s605UbGpf66Hn6uJLWRvO67WcNfmExa9/kafkfzF9lW+wTS/ABfM4L9hTur9Xg8LC3cWxCD9YAi1iOKWFOKWLsUse5RxKoqYj2siKUpL808avGS7Gyn6OpDiliadVtTJ+5XxJq3X/P2y2UeNWW/RxFLU+8fVcTSrNudWh81bXSntrWa5bhXEetQaIcOhTxq8tK0q1OKWJr9VT5u7xT9mlLEer0i1n5FLM2+Sae2afP1ce7y2Knt9qEwTtPUid2KWFOKWJp5fFARq1PnOh5TxJpSxOL1keJKaw2to7VS/B3IeZsO/u8NpvctFOflS3xNHKWBafc6SjvF0gsC+Z0ApR83B98nhLX1fUe2ki9nJiYKuYlScXh4uFXdoPjSfiHS+wWS9WI3sp6Q1mn0gVyt64KwXhbWDWHE0cr+a0ON/N3sH1SYSCJ/TF+qm1dDHlopy2VBo65hfZTeK15VbQyT1mrhe0VpXUeK4eP7X1yr9IpNda74HHLE/Elr3VKQvnQfr1PsPqaL6Z1fbXyOr0njXHh+0wJPSRYLBFlI76LTDAPrKe4ZIX2LkmbcresVuCi+nywntY2d+v2BPVeR9jTdWt554Y0T11w1eU75lh0vuK504fj2nVeNX/OCUml7eccOrmG4ypDnFqUhxeHxeHxJG6Vc8JU0ra7wQSy+WihuhU+zXY/4aiHp63x6blFEOhgH365Lb8IlfF4evU04X1xt5By1E11Ua4lY1zIsyfIT1uImWNcxLHye77y1JCIdjIMt9xIhbQmfy7K/Cedt1UbOyKufYS1tgnU9w8LnlzKsgSZYNzAsfH6APTcYkQ7GGYD7g0LaEj6X5WFNOG+vNnJGXocxrGVNsHYwLHx+GcNa3gRrJ8PC55ez5w6PSAfjLIf7hwtpS/hcliuacL6RcUZe9GyS1nQF3FdsvRKPNCj92WpNm8mVrz5aKXAdFML4asGVQjorhXQkrG5FrIWKWIsUsXoVsRYrYi1RxOpXxBpQxBpUxDpMEYtsIdkm7JttCf9n2nL5AtVr7Ktwm4iynosRBqXfF0zXbxc2UeproHz4jMlyN3xKce31ckE+VJYrhDCuj/hFEMZfDnnk+oh6283ufToc+Q4KmNzmSm0O3sMR9cfZiFpaOZxEjxBXWkVO5dtsN8kvbGrMCz0XtZsk/8KK4r95cx3zyyGm9GUI/6JZwQaU+A3CxrLW0+Ns7QSoVcF0R2GrhTynhPhp9ht52/Z40cY6Lo/H00Q7wk9gwXrDT2DBureWhaHe89NZZkt3FyumgzLidmZAMR2U93KWznLFdLDsqKwGgullx2dCk9os6Ut1Pv6Isi3f2SSnGWVb+M5gFP8+sC3fZW9x3IxvssN8fICO13/UX6n+c31eA2FcB9dCGB87opPsBsnC2o1jNtZxeTyeDyzbVSws7ssWR/2WfJK6gOnP1pct0vxX3JctAwJXyT7wuin11waEdCQsmifoZdiBnjwqc9jHziXVjU7tY0ttLj0r2fT0rMg1m5fapoBxxjkobtOi+sfcSXardgKT8T8ZquPyeJwPljvXe+SqKKciz28g8MI24w3V6fzJSbI4HGTRSt8PZb6ShaHuc/uO+sT7jKiHvM94uMAnSd20jtsvLKuFEfnSSOdQ6GMOBNE2JBVMr+Np4V5c34/3ZaP6fus3y2lG9f34jiUU/2bo+w2F127nKVqr46i/LvqFSe0GyaKdvt9KwJfaTLqOOv1nsZAen7uNmwuQ+irZfD5rhvgj2Uqpki+OjOUmssP54eFKoTIyPFooVYqF8dJIOVsYz+fGyiOZSna0XB4p5idHhiv2UMYKpUXyXBCTtxb6TLnJSjZfNCllhscLxdJwPlfKjWRKhWIlmx3N5sYKo/l8ZbIwWhrN5Su5kdxkkj6To3m3xLtKUfqz1WeS7FBcn+lwgStvQ6yjkxdSQlhauBfXHnHbOVMs6/iOiHHv7RzpQn6muuD6vV2zd7gz0QVun9rVBd6Wx42NHY1/EtdlPv5xPTbukHcM+bhyTsfwcfSePEd8pPdm0tyBfd/WE0T377hOIm9sv+keLwcp7bOqB/9L8/W8/R5ogsXXZkl94bg6j1h8bZYkj24WVoH+4mWbG+PQeqEJiPOy8DpubtbtmDJ5nab0+wKndSgbV4ekcYLV2YVBvO5g2UWtV+sT8ppEl5FTEl2WxswUz+pEafPM4uEKWDzZ58qYeIuEeDwtvmMTYnSzuK8NMSzuTWxHU5QF370M1yX2sTAsl0EWhpz4bpbSqV7SjsH9LAzlw1cq49qZuK8YlrIw1MXDWBiW7xIWhutFaF3X4mD6OPVWsCn72dg36ZqkuLYC7TzFl8b69GynvR/hY2Tp/ag0DuZ1Ft+P8P7YOghr593Jj6G+8njkpHKW2jOc4yDbJOn5csDlcyeSPsTpzyohPs5XcP1BHaFnO/UdugsdobAjIAxlwl2zd/ZJ9CfONiTVGXpWete6OCFunO7G6ZjEG+sc17EBgbdkv6LW1uCcE+Yt6p3xu6AdpB1/pS+2cE2adV0QptinKks766IMu6uN+Y5rA6xrtc7z949om/n7JyyDqHf9iInriPBrH+IhnZ5iHdkYNzskZsZ4vwAd79tY1+q7GuLd6rsa7Ifxvhb2b7hdwz4a76dgmfH+lPQlKv8fBNPHHNbx+ZC4E2TTiunw+WZMx/XJ1FzeGulI3/3wNXBzqf9YtlKfmZc19ot5+eC6aC5T/h1MECSvbySnpG1sr5DOoSRftNXcSfKlePPyrYfFybfVE2tmKt8FLB9bwt+Z9lxHyTepDEkWrb7nRB2lPEWdIiWduEcYZIOkr8et4yfNUPyfsHfXjvo84ilSSU5Ul/KXFvJ3YUT+BsK5Jhv3fzY3Ty/uhG7pu1Y+nuC7UiAGlW93wjxQ/F8mHDNg+21dV7Uxf1vC+5n2nHgaB/ZXu6uN+ZbGfBifjxmkb2qxTvOd+KU6nWK/EUs6kYrrWY8QH/G4nvWFemZlc9xQIz+pjlOYNOca19ekMNStXuB8bMijN5B1fEv4O9OeG5HeNZKT5lJTLAzrCX+HyncWwTDUg1bbOZKF5dXKyWzS7hWSneC2YJHAVaq3hD8X9RbbWF5vpW/043bAaVbPaR2WtB6N6zfWmV4WJr3P4HXGurNYetK8P9aZxZBWT7UeV/u9q3Uk6zRw7qrWuVP6pC+LIIziEddeN1wzxLUvxMdT73qBD+VlAYvPr7vZvWcdVeeNecRyxHzzccNiCKP4abhHHGkeqQfCFldbw1rEsBa2gUW8BoX4C2fIS8LqYVi9Ahbew+8BT4I6YesK3ykH21VcX/k8KFO0bdjnwWd5n4fivwT6bS8Ir6V9VbjNjdv1qNWT91qdg3E8b5L4VKVanyRw2gfI8j4TylU6qdfxGKNAfKR9aqRytu9blwbTywz51dpkeJ7vcxN3cqv0jj6ufyC1f9ont2Lai4PWxl9SPeb1HONfDvX4elaPpVOYUoxfEMSXYVyZo3yJq1QuvSxM6rfG9YkWxfCK6xNJvLBfzNfk9rHfcXmI0ztpjDqH/dKi1C/FvPN+adz40DpeBv1CfGnMOMjio8ylesnHa9I7qFbrJY7lro9oSzEfaGf5O1mpfmIbzfe3Ii5bwt+ZFt34SHmsMJzPTeYrY+OjmVE+5xOAjBY7SH8kN1kczxfHMpPl4sj48Eiz9N8V/uhlYdrtZK+QTy380UyxzOdJlfnnHc/3Zvn3Dcr4GapvL63W8XlerONzsviMreukT/b6WHjGupcBdoqFXS6kS2Evr8o8rHsFhHE7fQWE8RN6XwlhaMOldmFL+DvThjM6OOq4bze8PIjup5H+n1Z1knaO8E93g1+zD2eE+IEedoawzwTuKQfcz3KDX5P9i9zg5wn/bDdlW8N/sRv8AuGfA/gu9OdcN/Kv4Z/nRj41/PPdyKem/xc4kU+uxv9CJ/jDNf4XucGv6efFbvCLhH+JG/wxwr/UDX6t7/YSN/gVwr/MCf5IgeYHnwgrluaaq07b6VraI5rPk0hYXQKWNC6M+k6BwqX/QZBMho52L6/JsDthvqU5My5DCUuaT4x7T+r2NI3McNyYXNIdir+wxfiLWowvzYN1xcRvtg93kvmsuPhLWozf32L8pQnjU52S9rkgXcH9SV2884urs5h+H+OqXWf7WXqSLA5zk/ZIUlkcxmThqGyyjvNbs4/SvuIDQn4HWXyed4wrYVlHOm/rHtmPreWd52/bWd6xIAILywPT5PH5NbmeCJx0MF3P+LN8bNHDwiXbifcXRdzvjbjfF3F/ccT9JRH3+yPuLw1kd3q18fd57PeZ1ej42JYNBtNdinl+39XvYBbT0uBKOildp2Li9EfgW+d4/jKxzaR7fRH52aLDp2bT0owPlw9ve6V+M38HYt0Z1Xo8HpakT41h5yliafLSxDrXAS/X385QvLh6NdN0MIzK3/EpTkX+HRqmbduzrUFj3qV1MdjWDkI4xh9O1TGvDu/N4ZqU0aS2qRPWpEjrB6S1qvz9LPYvcJ6Vh8WtB5CwzlDEOq9DeWlineuAl7SOuV37g3WNdC7JNwfSuhNpzQZfj5z0dEPpmz++V0WU/bqHpdnMfi2CcIz/g6COeS/Lo2Qv6H6zvsbp1UYs6f0u5x6FdRrDwueTnOOGWGczrKhz1qL0GbFezLCi1qxF6QTKl9rBJGe1NcPia5ik9SyO5+NGiFNfi1ylfX6k7wdTalwLw5Is9PCHJ3tZfpTxR6Q1WikmuyVOyjmbeA0spT9be0YmXZMmfWtIz0rrz7gOSvOj/UI6g0IYf4fYDtYlSlhSPWiH18VKvKy7SBHrAkWsyxSxXqKIpZVHyXZ1ik5oyl5TJzTrtiavSxWxNHVVsxxJv6ivS3H/Mvzvdj+C+p5n0v4jUl9AM+0US4/kF7D8xu3dV/suTAhrZz3w2Fi5XMxVxrOZYn44Xy7E9RFn+j0yxidZ97uRdUFao4/77VjXBWF9LKwbwmrfFRr/VKqRv6O+WyL5S/0hjM/nOZKW5bJA7muQfKT6iWGo03zPN8RsZa9J1LO4fS9pjNLsWx1pTJNiYX1Cmq3KUppH4O11s/mBXgjH+P8c/re/aVPwVvPsYn6EY3UJ+bKO9LObxf+P8L/VgadTjZiS3HGO4vRqEJnXJGehIxaf24g6qzzK7iEWn9uQzkWPa18Ri89ttHreubQ3yoDwfJLzzqVvSOPOO4+b25nD76pGra59IFXnwfOL7YH10vnr0roCii+tQ0AMqguDQnxajyvJZ2AO5dPTonx62pDP6dVAlA/W8U7Tn7j9IqS6JNnZpPp2GpMProPpi5EPzjnOtnzi9KeZnefykeSJGGcz+Ujn+vmkP9r7jbyYyUdqn57J+tPs22P+zTnKpz9GPoeC/mDbL8lnKQuTvsXGPiylKb17wv7j6dWgIb/SGAHfx/H+M72Qt7L7SkTaSfuuFP/ZgMn7rtL7rwEhPzN9/xXXD271/VdcPzju/Vezesf7wVL/nM8b8HgYR+qTY3hU/x85NxsH8P72TMcBaEfaHQdgnYsbByRZ7+JmDib5Wm5Kf7bWuzQbX/H3T0sFroNC2OJZkWu2tiYd+8wB44xrolvdnxPnu34d2hQej6eJuryMyWJph8iCr+HAfevRrnEnyYnyZJ/73RbkhOWxjIWhzvDzQPn34hgmzWOlGE9sy9Dm87aM4l8JbdnbF9R5Wod9HP5teVe1keeW8H6mPTfSah9HmvuI6+NIY9ClgpykMWgHjLFE+SyKkU+r+/NI8kSM06tBg3wk2+iT/miPsfgYvcPGWM71p5l8zo6RT9wc4Vzqz8IY+Uj9aum8wKT6xsfo0vsJST6ztNfxSKtjdO19y/gYHdtE3m+T1ilKa+JPrzbmRxp/4pp1lzIeGa3vM0rli/uMouuCcIz/5hBAez+pysh4tpIfr4wXx0ulwuR4s/2k6P7Caj08zbge4B9e1/qkGJ+F9Van55/SoX1UqQ/EsYgH33f1vSGAtC8q308U0+9h6TfwFu6hrnOstHCP4lvde1v4kIt9wiaLwxOTheJ4ppy1P3PNylWSE9oi60jWWBY9Qt66WfyPpOp5/hjYmQNxhfRsvC/HxEtF/D+AIdzrqjbek8oIdZfi18a31ekcKQz3okU7ad2S8DfKC7GIRzeL/wWmu6hv9Ly0Fy7uLczTktLnuivtw7tYiG/L51PMHmHetcf+B9Jk+HiPc/uyw3pVniiMjUyMTRYzpcxYdizfrF7hviEpxj8I6u2h1HbFrfNPB9PbQx6PY0elzdtrjCutG4nKH4Xz8wOw7T2j2hhGjz4eRrLl9/VUYxzC+ybYkT9i/RWUH+2jJY3bUU8eDX9Ie/9ZvyX8nWnLFcqO18KPSt+/6eGP5KV97xTxxwm/1w1+zvG3AjX5LHbDvyitWdPDz5WkeU9F/qPSXKKi/GvlO+CGf0baO0URf1iaC631VcJrbGf02tfCZJI+FKbfx7i6aO8xPeLD5cPn+pcLXAeFMG7jpbNXpXPWB4Uwvla7HazLFLEuVsS6QAlLav/a4XWhIq+Firy05KWZR01eUj+gE3RV6j90St3W1IlLFbHm7de8/XKZR03Z9yny0tJ7e71YkZdm3e7E+qhtozu1rdUsx4sUsQ6FduhQyKMWL2272qntNp836RT90rSrfO6mHV6XKPLSHFt1ah9zvj7OXR47td0+FMZpmjrB54afiXrP56c7pR+tOR4aVOTl0kZTXNwXlPY9tI6+3eTvMB9i7wzd7PVVKEnr1FJBY9qLHKWdYukFgfxOgH/rL+0v2SeEtfP+fSJbyZczExOF3ESpODxcO6Mg6T6JFF9akya9X3C7t0hhIm7dqLTfxSIW1g1hxFHa76LXEf8k8sf0B4X4M93Xk/a7wD4mnhNHeORob01pjeMZYRiuC5D2xUgxfNz7Ar9de8uCOld8Djli/qTvg1KQvnQfr1PsPqYrnZ8phaUELjy/aYGnJIsFgiyS7EGC9ZTwXKzjKVRGxocrI5lirlQo50pN1z3ydaJ8rc1MeTDn+hzNIto9B/yfMedoYj3hebFOsi/0jLVVa4L69ZHwjHX8nD8MO1tIl8L4+XoYhns283M0cU9hfo4m2l6+Fh3Pk+Pr+LFfzNskHJPxtgznM/m3N9jf49+d4JwE/+YC+3a1NcXhbxffr41mCqPSmhNFPSwtF/jzPUOeKWeBurBB1p3pBr92Htx4iCd9Y8D76o7sVTnF0gsCua9eW/8buLXPKZYe8eHyoWtbl8k+bi3vvPDGiWuumjynfMuOF1xXunB8+86rxq95Qam0vbxjB+/xcAvIw9HxODwej580F6dXD/6XdvfmvcauJlhxO3J3MazuJlhnMCx8vps91xORDsaRTlnHcAmfl0ezXSHOZJylNHsFzoraWySui2K4YvpxuzQ45lob+fa2yFUalaXZbx4P40g7x2H4IiHt1OzIJHaH9DiZxO2Q7ojrKHFd3CJXaRcLx1zHiOuSFrlKX8qm2W8eD+P0CM9j+GIh7VnStXGSSX+LMpF2+3DMtTZLs7RFrtKugo65ThLXgRa5Sj3lNPvN42GcHuF5DF8qpD1LulYimQy2KBPMNz0rfRUTN5Mbt6vxEhaGur2UhcWNoqW+jjSrxGecsI/Ad6yVdqviuwegDZF2Q+G78WB9INkuDjr/6+FK+Huuvx6mnr7fs2iFkflZtHhHde/0ah0/6SwaPWNtEO7UMwDPWHcGYKdY2JlCui7zbHSi9pWWo9P3csuDaFtJMxKrw99pIS7Whagdq7lNkTAQh8sWy3FL+D+bz2dNEzaSrZQq+eLIWG4iO5wfHq6YGfjh0UKpUiyMl0bK2cJ4PjdWHslUsqPl8kgxPzkyXBkrTQ5XeF4XxOQt7mvVZm8YOt2Grw9/z7UN3xhez9vwWJd3bGNzju2NaMPj+mmSDZdmRsluN7PvaMN5P9uFzo3CqWWOyiy7PIi2uWTD1wV1h3LmX8wjTjeLuzL8b/v4yyPweoLmtjId8Ry93eoVMAJFecW9gUcecW+WfbDtQ+HvubbtG8Jrz237+Lxtj3ezYdtpNZW9xt0yrZNsO4VJb96lN+f8/Q++OSf+LlfpYXvhaN6nsFzgT2lRe0E20M69rAqvzZs08w7tsvFrriqN77xq23UXl2+4sbxjJ76CQhFysQUsWZ40xuMuxX7zl6Ip9nuBEA9dkkVDcYuSpO5+3OItH5oLmkaZ6+YCuwEYNj8UaHB5x+Y879LMWSc1F1GvlK0j847XxGmmTQqv64iNwwd7XdvYL5Btx5agfbmQ3rgajli3PIjuopP5p+79Eri+btvOqyq3nH/jNddcVbmqXDp/285ywBw3/VFmGbPFn+OO4vlgQmmmbK5NaC689tyETsyWCXW1ckDaQ821CZXOCSEdprWeeN2uCXU8Az7sWIZ5ad0+ycDtNzGZQoqlFzA5Biz92ToTI+lezNJ3JnwE1VWdng/pOxMqXxvnCIjHdYuf94nDBhqt8Te51pG+W/xjIa3jwmvHzfrEXDbrdG9htS6PWtsL97pBfgfkg/FZmIv9lY8Jf3fy/so0m7U4qHeXTgI8Xlf4WzPEs90rmtE42L06bXt5fKfcuZI+qsHfCyJIJB2PI34QkxbHxHi+dNSy4e+57qiNhdfzY91Yd8iNdSkef6ZZR83xq6yiYzllXXf24gx03LIvbjOl/4TFwyitvsCpDmfj8ob8STekQ7v5x6ASVk+LWHNZpijruENjeIe2C8L4B2zYaaU82k7AEMTjdZDPEUfNN50IeNSpeCbPN/nSMT0h/N3JHdPN4TV2TPOAF1VHcFBP10k+l3FUn3PEVfq0SZrcsJ3oFeH1jp3btpfPvu6Mm8uTN9pXVKeNT16ZeJZyQRDdMGNGJYw0PC85HzrFo+Hvue4U8xPOVgT68spAp/hwN/gZ3GUlYHnBdHnnP1DkQHikB9IgbwELqxkmxi+lzy/LuaSFtMjRi4jD4R7J8/8DfWPiGBLHCAA=",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "join_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "slash_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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nvOvxTznXzv7OWvKnH8dhjkwnPOvyzznX495zr8+Ax6c828Q5l+bvdqCtdk1mO3UIcx26obMdupGzHbqUGY7dRizneoy26lhZjs1wmynRpnt1DJmO7Wc2U6tYLZTK5nt1CpmO7Wa2U7dmNlO3YTZTt2U2U7djNlO3ZzZTt2C2U4dzmynbslsp27FbKduzWynbsNsp27LbKeOYLZTt2O2U7dntlN3MGCnXmOBnVrEbKf+j9lO3ZHZTt2J2U7dmdlO3YXZTt2V2U7djdlO3Z3ZTt2D2U7dk9lO3YvZTt2b2U7dh9lO3ZfZTt2P2U7dn9lOPYDZTj2Q2U49iNlOPZjZTj2E2U49lNlOPYzZTq1htlNrme3UOmY7tZ7ZTm1gtlMbme3Ukcx26uEG7NRrLbBTi5nt1COY7dRRzHbqkcx26mhmO/UoZjt1DLOdOpbZTh3HbKcezWynjme2U49htlMnMNupxzLbqROZ7dTjmO3UScx26mRmO3UKs506ldlOncZspx7PbKeewGynTme2U2PMduqJzHbqScx26snMdmoTs516CrOdOoPZTp1pwE69zgI7tQuznTqL2U6dzWynzmG2U+cy26nzmO3UU5nt1PnMduoCZjt1IbOduojZTl3MbKcuYbZTlzLbqcuY7dTTmO3U5cx26unMduoZzHbqCmY7dSWznXoms516FrOdejaznXoOs516LrOdeh6znXo+s516AbOdeiGznXoRs516sQE79XoL7NSuzHbqJcx26qXMduplzHbq5cx26hXMduqVzHbqVcx26v3MduoDzHbqg8x26kPMdurDzHbqI8x26qPMdupjzHbq48x26hPMdur/MdupTzLbqU8x26lPM9upzzDbqc8y26nPMdupzzPbqS8w26kvMtupLzHbqS8z26mvMNuprxqwU2+wwE7txmynvsZsp77ObKe+wWynvslsp77FbKe+zWynvsNsp77LbKe+x2ynvs9sp37AbKd+yGynfsRsp37MbKd+wmynfspsp37GbKd+zmynfsFsp37JbKd+xWynfs1sp37DbKd+y2ynfsdsp37PbKf+wGyn/shsp/7EbKf+zGyn/mLATr3RAju1O7Od+iuznfobs536O7Od+geznfons536F7Od+jeznepEeO3UUITXTm0XSdveMrJTcyI+2m8GdmquH7wM7NQ8f3i+7dT2fvF82qkd/OP5slM7ZoLnw07NzwwvrZ1akCleGju1U+Z4Wju1c0vwNHZqYcvwPO3UNVqI52WnFrUcj7RTi7PBI+zULtnhNbNTu2aLh+zUbhEOOzCJ1z3CY1cqvB5MeMpO7cmAB+3UXgbuXrjJAju1B7Od2jvCa6f2ifDaqX0jvHZqvwivndo/wmunDojw2qlrRnjt1IHMdmoJs51aymynDmK2Uwcz26lrMdupazPbqesw26nrMtup6zHbqesz26kbMNupQ5jt1A2Z7dSNmO3Uocx26jBmO9VltlPDzHZqhNlOjTLbqWXMdmo5s51aYcBOvdkCO7Uns51ayWynVjHbqdXMdurGzHbqJsx26qbMdupmzHbq5sx26hbMdupwZjt1S2Y7dStmO3VrZjt1G2Y7dVtmO3UEs526HbOduj2znboDs536P2Y7dUdmO3UnZjt1Z2Y7dRdmO3VXZjt1N2Y7dXdmO3UPZjt1T2Y7dS9mO3VvA3bqLRbYqb2Y7dR9mO3UfZnt1P2Y7dT9me3UA5jt1AOZ7dSDmO3Ug5nt1EOY7dRDme3Uw5jt1BpmO7WW2U6tY7ZT65nt1AZmO7WR2U4dyWynHs5spx7BbKeOYrZTj2S2U0cz26lHMdupY5jt1LHMduo4Zjv1aGY7dTyznXoMs506wYCdeqsFdmpvZjv1WGY7dSKznXocs506idlOncxsp05htlOnMtup05jt1OOZ7dQTmO3U6cx2aozZTj2R2U49idlOPZnZTm1itlNPYbZTZzDbqTOZ7dRZzHbqbGY7dQ6znTqX2U6dx2ynnspsp85ntlMXMNupC5nt1EXMdupiZjt1iQE79TYL7NQ+zHbqUmY7dRmznXoas526nNlOPZ3ZTj2D2U5dwWynrmS2U89ktlPPYrZTz2a2U89htlPPZbZTz2O2U89ntlMvYLZTL2S2Uy9itlMvZrZTL2G2Uy9ltlMvY7ZTL2e2U69gtlOvZLZTr2K2U69mtlOvYbZTr2W2U69jtlOvN2Cn3m6BndqX2U69gdlOvZHZTr2J2U69mdlOvYXZTr2V2U69jdlOvZ3ZTr2D2U69k9lOvYvZTr2b2U69h9lOvZfZTr2P2U69n9lOfYDZTn2Q2U59iNlOfZjZTn2E2U59lNlOfYzZTn2c2U59gtlO/T9mO/VJZjv1KWY79WlmO/UZZjv1WQN26h0W2Kn9mO3U55jt1OeZ7dQXmO3UF5nt1JeY7dSXme3UV5jt1FeZ7dTXmO3U15nt1DeY7dQ3me3Ut5jt1LeZ7dR3mO3Ud5nt1PeY7dT3me3UD5jt1A+Z7dSPmO3Uj5nt1E+Y7dRPme3Uz5jt1M+Z7dQvmO3UL5nt1K+Y7dSvme3UbwzYqXcy26mYPw47tb+wU9sxl/uuEFddNzTKuuGUYTsDMlwzyquLA6L8unh3KPhyHMgsxx8MtOl7mOWoHDef91rC532W8Hm/JXw+YAmfD1rC50OW8PmwJXw+Ygmfj1rC52OW8Pm4JXw+YQmf/2cJn09awudTlvD5tCV8PmMJn89awudzlvD5vCV8vmAJny9awudLlvD5siV8vmIJn69awudrlvD5uiV8vmEJn29awudblvD5tiV8vmMJn+9awud7lvD5viV8fmAJnx9awudHlvD5sSV8fmIJn59awudnlvD5uSV8fmEJn19awudXlvD5tSV8fmMJn99awud3lvD5vSV8/mAJnz9awudPlvD5syV8/mIJn79awudvlvD5uyV8/mEJn39awudflvD5tyV8Ou3s4DNkCZ/tLOEzxxI+cy3hM88SPttbwmcHS/jsaAmf+ZbwWWAJn50s4bOzJXwWWsLnGpbwWWQJn8WW8NnFEj67WsJnN0v47G4Jnz0s4bOnJXz2soTP3pbw2ccSPvtawmc/S/jsbwmfAyzhc01L+BxoCZ8llvBZagmfgyzhc7AlfK5lCZ9rW8LnOpbwua4lfK5nCZ/rW8LnBpbwOcQSPje0hM+NLOFzqCV8DrOET9cSPsOW8BmxhM+oJXyWWcJnuSV8VljCZ6UlfFZZwme1JXxubAmfm1jC56aW8LmZJXxubgmfW1jC53BL+NzSEj63soTPrS3hcxtL+NzWEj5HWMLndpbwub0lfO5gCZ//s4TPHS3hcydL+NzZEj53sYTPXS3hczdL+NzdEj73sITPPS3hcy9L+NzbEj73sYTPfS3hcz9L+NzfEj4PsITPAy3h8yBL+DzYEj4PsYTPQy3h8zBL+KyxhM9aS/iss4TPekv4bLCEz0ZL+BxpCZ+HW8LnEZbwOcoSPo+0hM/RlvB5lCV8jrGEz7GW8DnOEj6PtoTP8ZbweYwlfE6whM9jLeFzoiV8HmcJn5Ms4XOyJXxOsYTPqZbwOc0SPo+3hM8TLOFzuiV8xizh80RL+DzJEj5PtoTPJkv4PMUSPmdYwudMS/icZQmfsy3hc44lfM61hM95lvB5qiV8zreEzwWW8LnQEj4XWcLnYkv4XGIJn0st4XOZJXyeZgmfyy3h83RL+DzDEj5XWMLnSkv4PNMSPs+yhM+zLeHzHEv4PNcSPs+zhM/zLeHzAkv4vNASPi+yhM+LLeHzEkv4vNQSPi+zhM/LLeHzCkv4vNISPq+yhM+rLeHzGkv4vNYSPq+zhM/rLeHzBkv4vNESPm+yhM+bLeHzFkv4vNUSPm+zhM/bLeHzDkv4vNMSPu+yhM+7LeHzHkv4vNcSPu+zhM/7LeHzAUv4fNASPh+yhM+HLeHzEUv4fNQSPh+zhM/HLeHzCUv4/D9L+HzSEj6fsoTPpy3h8xlL+HzWEj6fs4TP5y3h8wVL+HzREj5fsoTPly3h8xVL+HzVEj5fs4TP1y3h8w1L+HzTEj7fsoTPty3h8x1L+HzXEj7fs4TP9y3h8wNL+PzQEj4/soTPjy3h8xNDfLZDfEbdirKyhspIQzgarnEj1bVV5W5ZeW1FVbgqXF5VXh+pikYbqsqqKqtrqyvd6nBZtCHcWF4dbYxjr8tY5k+Zy8xd1vUExg8RPryl+Y7zXYRfdz6zRHdyGcv8uSVlzmMs8xeWlLk9Y5m/tKTMHRjL/JUlZe7IWOavLSlzPmOZv7GkzAWMZf7WkjJ3Yizzd5aUuTNjmb+3pMyFjGX+wZIyr8FY5h8tKXMRY5l/sqTMxYxl/tmSMndhLPMvlpS5K2OZf7WkzN0Yy/ybJWXuzljm3y0pcw/GMv9hSZl7Mpb5T0vK3IuxzH9ZUubejGX+25Iy92Ess5NjR5n7MpY5ZEmZ+zGWuZ0lZe7PWOYcS8o8gLHMuZaUeU3GMudZUuaBjGVub0mZSxjL3MGSMpcylrmjJWUexFjmfEvKPJixzAWWlHktxjJ3sqTMazOWubMlZV6HscyFjGUWUP/s/fggXuANBA0RtKGgjQQNFTRM5iMoLCgiZSGoTFC5oApBlYKqBFUL2ljQJoI2FbSZoM0FbREv+5aCthK0taBtBG0raISg7QRtL2gHQf8TtKOgnQTtLGgXQbsK2k3Q7oL2ELSnoL0E7S1oH0H7CtpP0P6CDhB0oKCDBB0s6BBBhwo6TFCNoFpBdYLqBTUIahQ0UtDhgo4QNErQkYJGCzpK0BhBYwWNE3S0oPGCjhE0QdCxgiYKOk7QJEGTBU0RNFXQNEHHCzpB0HRBMUEnCjpJ0MmCmgSdImiGoJmCZgmaLWiOoLmC5gk6VdB8QQsELRS0SNBiQUsELRW0TNBpgpYLOl3QGYJWCFop6ExBZwk6W9A5gs4VdJ6g8wVdIOhCQRcJuljQJYIuFXSZoMsFXSHoSkFXCbpa0DWCrhV0naDrBd0g6EZBNwm6WdAtgm4VdJug2wXdIehOQXcJulvQPYLuFXSfoPsFPSDoQUEPCXpY0COCHhX0mKDHBT0h6P8EPSnoKUFPC3pG0LOCnhP0vKAXBL0o6CVBLwt6RdCrgl4T9LqgNwS9KegtQW8LekfQu4LeE/S+oA8EfSjoI0EfC/pE0KeCPhP0uaAvBH0p6CtBXwv6RtC3gr4T9L2gHwT9KOgnQT8L+kXQr4J+E/S7oD8E/SnoL0F/C5KNLCSonaAcQbmC8gS1F9RBUEdB+YIKBHUS1FlQoaA1BBUJKhbURVBXQd0EdRfUQ1BPQb0E9RbUR1BfQf0E9Rc0QNCaggYKKhFUKmiQoMGC1hK0tqB1BK0raD1B6wvaQNAQQRsK2kjQUEHDBLmCwoIigqKCygSVC6oQVCmoSlC1oI0FbSJoU0GbCdpc0BaChgvaUtBWgrYWtI2gbQWNELSdoO0F7SDof4J2FLSToJ0F7SJoV0G7Cdpd0B6C9hS0l6C9Be0jaF9B+wnaX9ABgg4UdJCggwUdIuhQQYcJqhFUK6hOUL2gBkGNgkYKOlzQEYJGCTpS0GhBRwkaI2isoHGCjhY0XtAxgiYIOlbQREHHCZokaLKgKYKmCpom6HhBJwiaLigm6ERBJwk6WVCToFMEzRA0U9AsQbMFzRE0V9A8QacKmi9ogaCFghYJWixoiaClgpYJOk3QckGnCzpD0ApBKwWdKegsQWcLOkfQuYLOE3S+oAsEXSjoIkEXC7pE0KWCLhN0uaArBF0p6CpBVwu6RtC1gq4TdL2gGwTdKOgmQTcLukXQrYJuE3S7oDsE3SnoLkF3C7pH0L2C7hN0v6AHBD0o6CFBDwt6RNCjgh4T9LigJwT9n6AnBT0l6GlBzwh6VtBzgp4X9IKgFwW9JOhlQa8IelXQa4JeF/SGoDcFvSXobUHvCHpX0HuC3hf0gaAPBX0k6GNBnwj6VNBngj4X9IWgLwV9JehrQd8I+lbQd4K+F/SDoB8F/SToZ0G/CPpV0G+Cfhf0h6A/Bf0l6G9B0qAICWonKEdQrqA8Qe0FdRDUUVC+oAJBnQR1FlQoaA1BRYKKBXUR1FVQN0HdBfUQ1FNQL0G9BfUR1FdQP0H9BQ0QtKaggYJKBJUKGiRosKC1BK0taB1B6wpaT9D6gjYQNETQhoI2EjRU0DBBrqCwoIigqKAyQeWCKgRVCqoSVC1oY0GbCNpU0GaCNhe0haDhgrYUtJWgrQVtI2hbQSMEbSdoe0E7CPqfoB0F7SRoZ0G7CNpV0G6Cdhe0h6A9Be0laG9B+wjaV9B+gvYXdICgAwUdJOhgQYcIOlTQYYJqBNUKqhNUL6hBUKOgkYIOF3SEoFGCjhQk75aX97bLO9HlfePyLm95T7a8g1re7yzvTpb3Ess7f+V9uvKuWnkPrLxjVd5fKu8Glfduyjst5X2RMUHynkN5h6C8n0/efSfvlZN3tsn70ORdY/IeL3lHlrx/St7tJO9NkncSyft+5F068p4aeQeMvF9F3l0i7wWRd27I+yzkXRHyHgZ5x4G8P0CezS/PvZdnysvz2s8VJM8Zl2d4y/Ox5dnT8lxneWayPI9YnvUrz9GVZ9TK81/l2ary3FJ5Jqg8b1OeZSnPiZRnMMrzDeXZgfJcPnnmnTxPTp7VJs9Bk2eMyfO75NlY8twpeaaTPC/pXkHynB95ho48n0ae/SLPVZFnlsjzQORZG/IcC3lGhDx/QZ5tIM8NkN/ky+/d5bfk8jtt+Q20/L5Yfrsrv4uV35zK7znlt5LyO0T5jZ/8fk5+mya/+5LfVMnvld4RJL+zkd+wyO9DpL0rv2uQ3wzI/fhyr7vc+y33Lct9vHJfq9znKfc9yn2Acl+c3Ccm903JfURyX43cZyL3Xch9CPK9vHxPLd/byveY8r2efM8l3/vI9yDyvYBcJ5frxnIdVa4rynU2ue4k12HkuoScp8t5q5zHyXmNtPPbrTIdHLlPWboNnKSLdysS+p9wua9X7nOV+z7lPki5L1Duk5P7xuQ+KrmvSO6zkftO5D4MuS9BvqeX763le1z5XlO+55PvveR7IPleRL4nkOvmch1ZrqvKdUa57lYiqFTQIEFy3i7nsXJeJ+c5cj++3Ke+vtPcyTFIuW7x3x4fbNnn6Mcv2RbGWzP+e1bXibF1x8jaTLp1NelcTVh5/Pf9HruvPKHTen/BsG016cbGf8+5bM2b+n3Q7gAYdrQmbLImbKombGn8d+SUDzvvf8FD42HYWfHf83rXnPvRX291gmFXaspwrSbsufjv1qfus/+CvW4thWEHdPTm8yBNWL0mrFETNk4TNl4TNlETNkkTFtOEnaQJm6kJm60JO1UTtkATtlwTdoYmbKUm7CxN2PmasAs1YUWdvcO6aML6asL6a8LW1ISVaMLW1oStqwlbXxM2RBM2TBMW1oRVa8I20YQN14RtpQnbKR42Y/B3Xa+97PS1YVjFGt7pqjRhm2rCNteEjdCEba8J21kTtqsmbE9N2N6asIM1YYdqwmo0YXWasMM1YaM0YWPiYdQYcIsm7LZ42BNLn3740lk19TDsDk26uzTp7tGku18T9qAG82FNukc16R7XpHtSE/a0BvNZTbrnNele1KR7RRP2mgbzDU26tzTp3tGke18T9qEG82NNuk816T7XpPtKE/aNBvM7TbofNOl+0qT7VRP2uwbzT026vzXpQkXe6XI1Ye2LvDE7atIVaNJ11qQr06S7pdg73X3xMGoe8Jgm3TOasC/jYdQ84HdNuv5dVv2+9t4Le4wbO2VXGDaki3e60fEwsk/WhE3UhE3ShC2Kh1HzhwviYdT84VJN+R7UlG9lV++wczRhv8bDqHnH3r28y7evJuxQTViNJmyUJmy0JmycJmy8JmyKJmyaJuxETdjJmrCZmrDZmrBFmrAlmrBlmrDlmrAzNWFna8LOjYdRduucPt7p5mnCFmrCFmvCVmjCztSEnacJu0ATdokm7DJN2HWasBs0YTdpwm7RhN2pCbtbE3Z/PIzqQ77VhH0fD6PGnB816X7WpPtVk+4PTdhfGsx/Ftk80rXr650uV5OugyYsX4PZSZOuUJOuSJOuqyasuwazpyZdb026vpp0AzRhAzWYpZp0gzXp1takW08TtoEGc0NNuqGadK4mXVQTVq7BrNSkq9ak20STbnNN2HAN5laadNto0o3QpBujSfdJP+90uf1X/VJ2a6f+3um6aMIejodRdusLmnQXDFj1S/WtF2nCrtKEXaMJezQeRtmfz8bDKPvzlDW9yzBbE/Z3PIyyI8vW9uazQhO2uSZsuCZsB03YjpqwXTVhu2vC9teEHagJO0wTVqsJa9SEHa4JG6cJG68Jm6AJm6gJm6oJO14T1rSud9gMTdgCTdgiTdgSTdgyTdgKTdiZmrCzNWHnasIu1IRdrAm7WhN2rSbsJk3YLZqw++Jh1DzgivW9012lCbtOE3aDJuwOTdhdmrD7NWEPasIe1YQ9rgl7ThP2gibsJU3YK5qwNzVhb2vC3o+HkTbmBt5h3eNhpI2pSddbk66vJt0ATdhADWapJt1gTbq1NenW04RtoMHcUJNuqCadq0kX1YSVazArNemqNek20aTbXBM2XIO5lSbdNpp0IzTpdtCE7ajB3FmTbldNut016fbShO2jwdxPk+4ATbqDNOkO1YTVaDDrNOkaNOlGatIt0KTL39A7XUU8jJoHbKZJt7UmbH48jJoHnKlJ93w8jFrfzdlIw0s8jOqTt9WE7awJ21UTdng8jJo/xOJh1Pxh5kbe5ftRU77nhnqHvaQJ22bYql9q3tEl6l2+bpqwfpqwAZqwdTRh62nCNtSEDdWEVWjCqjRhm2nCttCEba0J21YTtrMmbFdN2O6asD01Yftpwg7QhB0UD6Ps1hHl3um214TtpAnbRRO2jyZsP03YwZqwQzVhdZqwBk3YUZqwsZqwozVhx2jCJmnCpmjCToiHUX3IVZqwa+Jh1JhznSbdDZp0N2nS3aoJu12Deacm3d2adPdq0j2gCXtIg/mIJt1jmnRPaNI9pQl7RoP5nCbdC5p0L2nSvaoJe12D+aYm3duadO9q0n2gCftIg/mJJt1nmnRfaNJ9rQn7VoP5vSbdj5p0P2vS/aYJ+0OD+Zcm3T8fWnqka1fhnW4DTboLK+l0PeO/X6216jdf5RP/lVu45Z7z4fH/3excOB/gcuNXudWN+U6qY+Y/mg8wDeBHFH6uGfx/zomW7qxYKr6D8i2M/w+28CfSqDA4wTk7HtYxHq6ep8Wf8xGeiXqHPHHLrRvBfztQNum2jpnIO1Kn8LeJ4zsp2OFoVUU0UlURidQ3uDX1FZWN1dFKN1pbHq2uqw270fJIVX1lTdR1G6INdWVufUV1eX1DTXV5tLG2prpCYW9LYkcbagVUeU1FVW24saai0a0tq6yK1jRWVtbX1FeXNVSWu/XhuopwXSTcWFVVU15eU1deHQ43NlSXN1YlsEcYkcuqtiLddmbwE33V9kbwo+UKfwcz/Cfk/z+Az3gHgqvwdzSDn5D/TmbwE/qzcxzfMSCbXWJG6jaq8Hc1gh9O8L+bGf7LFP7uAD9kQHf2MIOfkP+eZvATurmXGfkn7KS9zeDXK/x9jOCHE/W7bxzfAdjhqmgkUhmVZ7NU1bvhsvq6SJUYHWvL3Dq3pi7SUF0Wrm4si5RF6+rraqvKqmrCjW5jTV11Y9UqdIW9nxHeownd3z9mQneiiX7/AEI2bnYuMWYd6I3dYvEr7IMI7EhNtE6YeW5NeVVNZUNVuTBnXPFQW9XQWBGpqRWGTaQ+HA43lIk/kYb6sura+opwbUVDZaS8VmSXqNODYybqNJyw0Q5hxq+ocasbKioqFf6hzPi1tRWVNUKeCv8wZvxoXUVDY7Qy0Z/VMOPXlJc1NpZHaxR+LTN+edhtKI9UJnSzjhm/utYtr6iqSuhPPTO+sMuj9dU1tQq/gVs+tQ1uXX24Ws35GuP4Kg/pVN4jmfOOu+oQys9xUue0Dsq/APHKPW8IofwgP1A+av6oZHd4rDmvxUQY7GNwWA7hp/KhsA5lxDqMEauGEauWEauOEaueEUu1a7NtrSwxjh5uBD9apfCPMILvNij8USbww0nb8UiA7/Dxn8AfDfBDBvCPMiP/BP4YM/JJzAvGxvFNYI8zI/vEvOBoM7JP2HjjzeAnbNRjzMgn0TdMMMN/Av9YM/jVCn+iGfyEDXycGfyEDTnJDH7CBp5sBD+c4H9KzIR+RhJ921Qj/EcS/c80I/xHE/wfbwY/wf8JRvDLEvjTzeAn+ueYGfxE/3yiGfzEutBJZvATttXJRvDLE3PwJiP4FQn9OcUMfmINZIYZ/MSa9Ewz+An9n2UGP6H/s83gJ/R/jhn8hP0z1wx+wj6ZZwY/YZ+cagY/Mf7ON4OfsB8WmMFPvNNYaAY/0X8uMoOf6D8XG8GvTNgPS8zgJ/rPpWbwE/3nMjP4if7zNDP4if5zuRn8RP95uhn8RP92hhn8RP+2wgx+on9baQY/0f+cGcd3Wo4dxR7y4wq5X2ud+Dk91D43RlvOVXvIcpNFSXlfIJ/zgD/jPLDez/sCmH8B4tXE+wKYn+IHywe+L5Bh7Qlei4kwXIftiXzaE/kUE2HY9ssGawkj1mxGrEWMWJxlXMCINY8RayEj1hxGrCmMWJyy52xDSwOK1cSIxakTnLLn1K+ZjFicbZtTJ2YwYnH20csZsYI6Piqb2qxt5VYUEnkrp8I6gLyhTYVdDvof8i1t1Q27JnFxPOXkEdfx40idxoYJdYfvVTNyZEP9TmNHHuNokkm3TYz2D5oIQyiso48yOE568Q73IV5sxkPeChEmTBsisKgtO1ilocxzPXiAGKqusDk8PP6/m5ULR/2UA+bfWlMJqqugphJKPh3MyCcSQviQnw6EfLAO47oLOcktLnkAC8bvAMoI48NnlR76vR7/LXaatyP1iUCICMsh/JR8Je8vorLBusF6aqYeysJ+9VTlX+CYbDdJPaX0ghrS8p3m9cy5rclPvVJ9Wz4RprDUNkOopzB+R1BGGB8+q/TQ79P4b7HTXKexnuYT5YF+UE/fjz/ne5RnePx/NytXWUmNU7gdQDlxbtP22w5U/gWOSb1LtgOqnqj+RMmugOC1mAjDSz8FRD4FRD7FRBg2R7PBWsSINYMRaxYj1tKAYs1jxFrIiDWHEWsKI9Z8RixOvQ+ivHTjYKZY0nHq6jJGrLmMWJy6ylnGJkasoLbtFYxY0xix1CtEbGcqfMdJ2kp4vB8e/9/Nyq2au8H8VDmgH8y/APHKy0/SVqLkStm0Sj6dzMgnwU8ngp9OhHxUXXYmwhSWWmuBcwYYvxMoI4wPn1V66KcWKooRpnR4ztCZKA/0g3OGjUKpZYN1g/XUZD3A/BTf0A/mX+CYbDeuVi+o9p/vNK9nRvm4fuoV8qvqspAIU1jxW6pS9BTG7wzKCOPDZ5Ue+m2J9BTqNNbTQqI80A/q6SZIT2HdYD01Ug/hRt96qvIvcEy2m6SeUnrRiZBjvtO8nhnl4/qpV8ivqss1iDCFpZb+oZ7C+IWgjDA+fFbpod+uSE+hTuNPs9YgygP9oJ7uEMfN9yjP8Pj/blauvIyqSz78ynAhUU7czqCs+fQ66rudqfwLnOZ6YaKdFSF+vPRAya6Y4LWYCMM6UkzkU0zkU0yE4XlNNlizGLGmMGLNYMSaz4jVxIg1jxFrASMWp07MZMQ6mRFrKRMW1T9nw9cSJr6kW8aIxdm2VzBicfaFnO1xISMWZz2uZMTi1AlO2XO1bYe5jJw6sYgRK6j9BCdf/wWbiUvv28a01dseZzNicZbx9IDyxWlPcJYRvx+Ac8tQ/Dffad72GOfZDSGUnyoH9IP5FyBeeflJzrMpuRYRclWy60LwWkyE4Xl2FyKfLkQ+xUQYHjOywZrFiDWFEYuzjPMYsRYyYi1jxOKU/QpGrLZ6zAxrJSMWp07MZMRaxIjF2X8tZcTilD2nrnLKPqj9F6eucurXAkYsznrk1C/ONsSpX0sYsZoYsTjLGFRbjrOMnPZEEyPWf8GWO50RK6h2DqeN2WZP/DvaUBMjFidfXPoln/G6ajZ8ncbEl3RNjFicNoAaa/F+N4Uvndk1tIjvPbZ4Dc3IHqw0a2jU3rp8p7keMson7KeeIb+qLrsSYQqrW/x/uCcMxu8Cygjjw2eVHvptHRdKMcKUDu8J60qUB/op+co9YZu1Sy0brBuspybrAean+IZ+MP8Cx2S7cbV6Qa2h5zvN65lRPq6feoX8qrrsRoQprO7x/6GewvhdQRlhfPis0kO/3ZGeQp3GetqNKA/0g3q6I9JTWDdYT83Ug/+94Cr/Asdku0nqKaUX1DiV7zSvZ0b5uH7qFfKr6rI7EaawesT/h3oK43cDZYTx4bNKD/0ORXoKdRrraXeiPNAP6un+8X+KHO/2mWk/TdljWIYwHW4PRuo73OD6bQ8q/wLHZPtMtoduPuWq5NPdiHzqG/3oD+RX1WUPIkxhqSuVYXuA8buDMsL48Fmlh37jUHuAbQe3hx5EeaAfbA+jUL8N6wbrqZF6cN1Gv3qq8i9wTPaTST2l9IIa//Kd5vXMyE+Dn3qF/Kq67EmEKaxe8f+hnsL4PUAZYXz4rNJDvxOQnkKdxt/w9CTKA/2gnk6K/5PvUZ7h8f/drFxDmKpLPvwaN5+QNR9+pDqfqC8+/Noqhd/bDH6Fwu9jBL8qUb99jeCXJ+TTzwx+vcLvb0Z/EvwPMIIfjSr8NY3gNyT4H2gEvyyBX2IEvzbRfkuN4Fcn9H+QGfkk6newEfzGcoW/lhn5JPhf2wz/if5/XYDPuRah8Nc3gu9GlTzWc5IuhyiTyl/ZIuuA+CGPX4WFw1ReBQjLlN1HlQ3yj+d96wF+oAy8sNbLECufCDNRp+tqyg3zL9TwisshHT4bo6UykW4mI9ZJjFhLmLAo2zYbvo5n5KsHE1+U/ZsNVi9GrBwmLOnwVWHZ8NWbiS/53CegWH0ZsfoxYvVnxBrAiLUmI9ZAJizp8BUu2fBVwsjXYka+Spn4ks+DGLG4xg75PJgRay1GrLWZsKTDa6dBwdo9jmV2vaus2ux6V7TG7HpXWb3Z9a7yqNn1rrJKs+tdZXXKVlfjocoD6hYc3/jmFWW+vxFT+RcgXnn5Sc7v+iN+sHxUu1SyG0DwWkyE4TY6gMhnAJFPMRGG9/hlg7WcEauJEWs+I9Y8RqyZjFhTGLEWMGLNYsRaGlCsJkasOYxYXLKnxu2g6Cpne1zGiBXU9ngaIxZnGwqq7OcyYjUxYnGOtZx9NKfsmxixgqpfnLYJZz02MWL9F/qJFUxY8hnPYbPhK8bIVy8mvjixpDshxsdXb0a+uGQv3cmMWJw6gdfSs8HKYcKSjksnpDuJEWs6IxanfnHyxaWrQe4LOzPyxamrnPXI2a8GVV6cuorXVoPStjn7r5WMWJz212xGLM41BU6bnHOuwLn2qOx7tY7dF4SF4r9m3wG4LX4H0NcMP9p3AH0JuVL7YRn5qfdTz5BfVZdrEmEKS73Lh3v7YfwBoIwwPnxW6aHfgnjFFSNM6fDe/jWJ8kA/JV+5t392TmrZYN1gPTVTD/7vhlT5FzhG201Ypxf9CTlSeqHSFhNh2Kb3W19U3eO9b9lgLWLEmsGINYsRa2lAseYxYi1kxJrDiDWFEWsxIxZnG+Ksx+WMWE2MWMsYsTjbNqd+cbYhzn71vyD7BYxYnH206gup76gY7Q+X+s6JET/xzcFAjSxg/ngvjgqnfhUWDlN5FSAs5rKFdWXTzd2gHY739lJYAzPEor6NM1Gna2rKDfM3+y1gecTst4DlFWa/BSxrVDpfCuQZQrIbbKQuq3yfpaLyL0C8mmpTgxE/WD54PrQWwWsxEYb37q1F5LMWkU8xEYbH7WywljNiNTFizWfEmseINZMRawoj1mJGrCWMWJyyD6quLmPEmsWIxalfnH3OIkas/4LsFzBicZZxaUCxmhix5jBicclePuN9uUHR1SZGLE4bgBOrbdxuG7dtGTvaxu22cbtt3P53yj6ounoaIxanvDj7HE7Zz2XEamLE4hy3g9pHNzFiBVW/OG1fznpsYsT6L/QTK5iwQk7z/TnZYK3JiMW1Ti6fBzJhSYf3HmfDV2dGvmIxPqyTGbFOYsKSzyUOH9a/XfbyGX87kQ1WL0as3kxY0nHKaxATX5y6Kh1nGwqq3ge1jP/2vpCTL+naxg77xw7pTmTCks+cex645CWf+zDyNZ2RL66xVjrO8ZFTXkEcO6RbyYjFOeebzYjF+U6Hcx2Ac32Cc3+OWlNQe70Gg7BQ/Jc6L17mMzz+v5udqw+h/FQ5oB/MvwDxysxPWCfXwYRcqfPuGfmpCyF8yM/ahHxUXa5LhCksdU4m/L4Nxl8blBHGh88qPfT7InfVbzHClA5/30adlQ79lHzl920f5aaWDdYN1lMz9RDx/X2byr/AMdpuwjq9oNo/pRcqLVVfeNz3W18U1jxGrKWMWDMYsRYxYi1nxJrFiLUkoHzNZMSawoi1ghFrGiPWSkYsTnktZMTibI/LGLE49Z6zL+Ssx9mMWJx9DqdOLGDE4pR9EyMWJ1+LGbE4dYLTNuEct5sYsYLaf3HqF2d7DGofzYnVxIg1hxFLyV7NV+D8JhT/NXwHXFkI5afKAf1g/gWIV15+knM9Sq5rE3LN5H4xxat6hmEwn9a+x0u6RYxYMxixZjFiLQ0o1jxGrIWMWHMYsaYwYnHdjSRdEyMWZ3tcxojFqV9NjFjzGbE49YuzDXH2q5w6wdmvBrVtc7ZHzja0nBGriRHrv6BfCxixOG0ANdYWxcOgvQ3PI4FhMB+dzQ/Tq3iFRLpQ/NfsHb7Vvs/rUPkXEDIxYfOv51OuSnbrE7wWE2F478r6RD7rE/kUE2F4bMoGazkjVhMj1nxGrHmMWDMZsaYwYi1mxFrCiMUp+6Dq6jJGrFmMWJz6xdnnLGLE+i/IfgEjFmcZlwYUq4kRaw4jFpfs5TM+ryMoutrEiMVpA3BiBXXcbmLE4rQBOPtoTnuiiRErqPrVNm7/O9p2m03epl84rM0uXH36FUS7UDpOeQVVV09jxOKUF2efwyn7uYxYTYxYnGNHUPvoJkasoOoXp+3LWY9NjFj/hX5iBRNWyGm+xykbvk5g5GtNJr7kc2dGLM73Q5zy6sPI18kxPqyTmLDkc4nDh8WlE9Lhb5uDIHvOts3dHrnakHweyIQlHWd7/C/oFz5vKBusXoxYvZmwpOOU1yAmvjj7Quk4++ig6n1Qy/hvH2s5+ZKuzTaxf+yQ7kQmLPnMaZNzyUs+c9rk0xn54hprpeMcHznlFcSxQ7qVjFicawqzGbE431txrjNxrn/NZMRSa1Zqr2pnEBaK/+Y7zfs6mc/w+P9uds73OS4q/wKn+VjFyE9in293p7lcOxNyVfLpYYaf2hDCh/z0IOSj6rInEaawVD8MzxuC8XuAMuJ+uxfgIw/5Pdp+1W8xwpRu51gqDz2J8kA/JV8JeX/71LLBusF6aqYewr7PxVL5FzhG201YpxfdCTlSeqHSFhNheA3Hb31RdY/3JmSDtYgRawYj1ixGrKUBxZrHiLWQEWsOI9YURqzFjFicbYizHpczYjUxYi1jxOJs25z6xckXZz1y8sXZT3DqBGc9LmDE4uzvVb+qbCtsEwyP/+9m5crLlW0CbRllU+U7tG3Ck3e4KoTycxzarlP5FyBeeflJ2nVUvUH5YLuuF8FrMRGG67AXkU8vIp9iIgy3zWywTmXE4uRrEROWfO7g8GBxl3EKI9YCRqyljFhzGLE45bWMEesMRqzFjFizGLE4ZT+PEWsmIxZnGVcwYk1jxFLr0di2kG54/FcMh9GqimikqiISqW9wa+orKhuro5VutLY8Wl1XG3aj5ZGq+sqaqOs2RBvqytz6iury+oaa6vJoY21NdaVZ26G8Ot+hx1ce/HBE4fc2gx9V+H3M4Jcp/DXN4Jcr/IFm8CsUfokZ/IR+mjlDI1yl8Nc3g5/Q/w3M4Nco/CFm8OsV/oZm8BsU/kZm8BsV/lAj+BFX4Q8zg5/o31wz+In+LWwGP9G/RczgJ/q3qBn8RP9WZgY/0b+Vm8FP9G8VZvAT/VulGfxE/1ZlBr9W4VebwU/0nxubwU/0n5uYwU/0n5sawY8m+s/NzOCHFf7mZvAT/fMWZvAT/fNwM/iJ/m1LM/iJ/m0rM/iJ/mdrM/iJ/mcbM/iJ/mdbM/h1Cn+EGfxE/7adGfxE/7a9GfxE/7aDEfyyRP/zPzP4if5nRzP4if5nJzP4CftwZzP4CftwFzP4if5zVzP4if5zNzP4CftwdzP4if55DzP4if55TzP4if55LzP4if55bzP4if55HzP4if55XzP4if55PyP45Qn7c38z+In+/wAz+In+/0Az+In+/yAz+In+/2Az+In+/xAz+In+/1Az+In+/zAz+In+v8ZJuiR2tKFWvEoor6moqg031lQ0urVllVXRmsbKyvqa+uqyhspytz5cVxGui4Qbq6pqystr6sqrw+HGhuryxqoE77UkdjYunGhXdSbkEm5M9Av1AD/Exn9VAr/BSL0m8RuNyKc+0S+PJOo2UlZfUVvjVjZW1tRUNYpBNFIvfiqE1jSWR2qqo3U1QovqaxtqaqN11ZG6+kh9tKFK9DUN0eqKhobkmHU4t96EXVdukz45vslAnRF+BJBRHqrvUfH/1T5w6Y6KJeMcAcJh/NsKVv3K/GbG8ysE9eCAfKRTZc41UV/iPUQI5ec49B4elX8B4pWXn+QenlzED5YP3sOTR/BajMKkw+9084h88oh8KKyVjFhTGLEWM2LNYsRayIg1kxFrHiMWZxnnMGIFVb+aGLGWMGItY8Ti1K8mRqz5jFic+sXZhhYxYnHqBGe/qvb65TvNx0K+sbkiosZaaLcrp8Kg3R1CYfUg/raxZDzsctD/sEwdBe3WNYmL42F+oN1UB/C9bAbplBzbg3BOG0fh55vBjyrZd3RSZYrLlO8hKxVO/SosHKbyKnCay92EfUiVDfKP20tHwA+UgRdWxwyx8okwE3XaXlNumH+hhleqHHh+Q/VHlP2t4udr+ILxi4i8VVolwwIQxijDiE6GsC2q/DsDPusbao8dudNYOK1NpIdyUHLrjeJtF0vKAetgRw8sB/3fG/nlADzozM4ZV+84oMqU6TgAZVuHwlra70mH+wYsc+lkXX+I1hZyiDJhHfJaW8gB4TD+Zx2S+X0af+4E8izU5LkG4hvGl267WGr8IlC2HCJOIeJRxf86zpesv8Pi9UfJTvGTj9L/m3RZlSlTXYb1iHlTmPB8Ali3XvXyO6iXuq5JnnF+azje5VD/1xD5Kd67oLjSqTruCvwZ17h834en8i9AvDKPQwkbpiviB8tH9S1yHOoUfx49tqZ+65pxxxw7uqEdEmUxeIbwxQhOxYFxoSsGLDke8XC1S7drrHk67JQo8xDPxfExUHYnefHnIqd508fHbEEecgg/3D13Jvinll+PjKWGQXNoZxTWXhPWUROWT5RLhRWAdEehdJ0ITMnDPh2TeFC2jkOrl+quKTl76ZIX1giEBdN3RVjd0mDtgrBg+m4Iq3sarN0QFkyPj3bpkQbraIQF0+Mro3qmwdoBYcH0+IjOXmmwxiMsmB4fG9Y7DdYEhAXT4yM6+6TBOhZhwfT42LC+abAmIiyYvi/C6pcG6ziEBdP3Q1j902BNQlgwfX+ENSAN1t4IC6bHV9SumQbrCIQF06u0hQQWHpLNfB7k/+gqlX8B4tXUkDzQaS5XKB/82qmE4LWYCMP9VgmRTwmRD4XVnRGrByNWT0asXoxYvRmx+jBi9WXE6seI1Z8RC/db6cbrvWKrfnXjtUoHdRfGywFxqDEaYnjZAzmOf7tgV8QzlSdlY46JpYbBJThsm8LlomIUBpfSuqIwaGPifh8us3VDYZ1AmCoPtDHzUHn2j/ubna67LrQFvWSF5y3Ur+P4W86hluQKUb4c+UB54TGmmDEfbNfDfLow5gOxto2l5tONyMfwUZmNfsoB8y9w6H5lOA8/YXykICULM5/Gl/leDumFZGHmKICk7UXNJ6Cu4FcO1JyBOp4JLp+MbJggFvG3mrxXzcgOICrsOjE7a6B4+ATNHh5sDUfxeqH/lVmC+YBY0GE+dMszVP5Ut6ie8wh/6ajpFjZlqWqDfrhrgOn7aPLpmWU+PYl8VNOCppeJN7v9zeAn3gJSU1xYJpV/ISGnTLp2mFeB07yOTHQDVNl09QxNXz9LAf0yxMonwkzUaV9NuWH+hRpeqXLAt0mwn/sDLLnO6JiKTfUVZneXRCv86qPKv7V2ovp9E06Z6iptMQqTDt+mQL2Vbk/kQ2EtYsQ6jRFrISPWTEasKYxYnGXkrEfOMs5gxOIs4wJGrMWMWPMZsWYxYi1jxJrHiMWpE5ztkbMNceoEp7zmMGItZcTilP1sRixO2S9hxOKUF2df2MSIxSmvoPaFTYxYnH3Of8Fm4tQJznGbS/byGZ+kHBS955T9XEYsTr3nLGMTIxanDcAprxWMWH6+1qTm9So+tcOdWpf6r+xwL0fxtosl5YD7HL873MuRX45D73CX2B+ir6f7obTSmV2PjUZCKD9cRgflX4B4Za7/xJoVtW2JWvdUshtA8FpMhA0CzzAM5jOAyKeYCMPjdjZYCxixFjNizWfEmsWItYwRax4jFqdOLGTEmsKIxakTnPKaw4jFKa/ZjFic8jqNEYtTV2cyYv0X6nEJIxanvDjHoSZGLE55BXUcamLE4uzvOfWLs8/hbI+cOsFpM3HJXj7jNZig6D2n7OcyYnHqPWcZmxixgmp/rWDEUmsw1CcueGs9NYftr8kHpu/vA4uaD6v41GcgurUe+FmKSmv2BpzkWg9VH/CzHZV/S9Z6lNzCKB5e64F925oeWA76P4z8vNZ68L6lsfGFLLM3MNFbzfF+Rd2nidQnk9AP6y9M39UDy+tEgO4OLatj47KS9d7YNRUz3XZbVcdUWfF+wj4e+cO6z0NxpwDejujqnZcJuVL5dM4yn85EPoVEupDHr8oH++F8KJ5VPnAPodIPuVZ6Sn4yDa6vHCKt+kQS19nF4PTKWXFM6jNKL/0NgfzgPuoRsdT4qm9u7yRlAuNgfVfxTwU6dRjS9+6ozLCcFM8KE55KAXlWn4hjHhaj/snQXmCyf1J5UZ8i5Tu0PByHrhOsd/mEHKh8BmeZz2Ain0IiXbbtiOJZ9y6hpflALNUmzepG5qeaYDnD043xvuMGEIZPEGsEYfAdF3Y56H8oC9l2R/s4DcXsu7TWk2FfFAZliNs4dJQMlSz8yrDIaS5D3La7EuWg2j3+XiPTdt9TwwPMpwiF4U8NYRhsnwWIvxyCvxwNfwVEPma/DchcB3uiMKiDvVAY1MHeKAzqINbrkSAMf3p5OAhrj8KOAGH4lLpRIKwAhR0JwjJtD6peZH7nMp0WBu2cehTWkcA1+2ljNOpnXIL5FyBeeflJvoOm2j91qqKSXS+C12IUJt30WDIeDssh/NppsDhvsV7KiDWDEWsRI9ZyRizOm82XBJSvmYxY/6WbzYMmr4WMWJztcRkjFqfec/aFnPU4mxGLsx45+y9OeS1mxGpixOKUF2cb4rQnmhix5jNitfWrq69f5ZK9fMbvoIOi95yyn8uIxan3nGVsYsSaw4gVVHv1eEYsZa/i9S35DN+nqDUAeBQd57vg1XnuCCwTPncEyirk8auwcBg+d6SXmbJpzx3R6QFc88NHDGZz7ojCaq1zR3pryg3zL9TwSpWjO6NM/NxOQa0tZVq31FG1Kq3hNpbYz9FdIyeYfzbf7kRQPPVutZ3TvO56e2A56P8I8vPaz0GdSQTfVe9UQPMM31VTx//i2xCawLvqXePP1HuBYic1DOqaOsbO7O0uma/z56AwuM7vdZaX49Br5KpMmd5CAL/vgrxBTK9bCNqDcBj/oIIkL4cMpDFDABN+56b2q6j46t0k3EMA42AeVPzDAA94D4GKk+tRro4emBOBLtYV0JgOgUmVqwCVC/OQj3hQ8UeCctWADW4wjvof9q9jY6m8dSLycjz8IDZMi8N0+aZLK5/hDRU4DOsKlhdM7yVTrCsq/jiNrrQneIDlxfWKecBxCjx4mEDwAI88rBs7bnL8xggHOXzxTQ76H1clroL2BI6XU/gyzcQCGkf9r1M/uA2lI5FHRw8eYVopHiW++obRDRMaPATUjigAlVk7h3bUFRGqLzV8Y5jvb1PxzW3tzfCjvbmN+oabOqZYpaXeyeP9TX7z6ewk99EdM2HseC9dwHWP/8/zyD9EpHdQ2hDh5zip3zlT9gkuc6a3SOYT/FP5FGSZT4HPfLplmU83n/n0zDKfnkQ+GIuyV6UbGUuGw/hLQD9eP5DGbOeBqa5MUfGpOQS1t0XFp9ZAuhNlpM426OWkzxvKEo97vTPkNd0aBN47RM1l/fI6opV5zcuQ1wIibzj2i8HtiIkN43cZO6EBdjGYDQc943Efn3SOh7OOHqx2RvHwNmi8PJSH/u+B/u9E8Ec5xQd0mJccJ71TTVTJ6gLQREd6NFHHoZuoUns8/YVpqekvtU0fLi16bZ326n7UzTB42/Llmu6H+nxGdzI39UkK9akPdWvOABQG5QS31f+DHWuOmZiigTBGM6ZOymfUwCQfWD55Mf+ykA7LjrrZB35eg4/6hZ8e9UNhcLsc/iQqnV5hfYXb3lRa+GmBqq9jQDw8NE4A/+eg+DBPFf9YkA81JVJp81D8u4kpUTHBk+InH6Xn1ZnKCiXDiU5zp8KOc1LLDsMmgfjbxJLxsKOWd1SZpCyGZ7C8A+sR86YwYR8D69arXh4H9YIvmYT5TXC8y6H+zyHyw7JU4dKpOp6EMIbH/3ezcuU1IZSf49DTLZV/gdNctiamW5MQP1g+lNmguWRyIniG8PsjOBUHxoVuf8CS4xGPqvaeRDrslCjzEM8fglW4F9CKMGz6+G5cyEMO4YdnB7kE/1Q+7bPMpz2RD95tLR2+zHIUUVa821o6fPHkaBCGL7M8ymleLhU2RoM5VoM5ThN2tCZsPBEmedqnc5JH3B1TTUMNNVTdebUDL6wRCAumn4SwJqfBwhdkwvSTEdaUNFj4gkyYfgrCmpoGC1+QCdNPRVjT0mDhCzJh+mkI6/g0WPiCTJj+eIR1QhqsCQgLpj8BYU1Pg4UvyITppyOsWBosfEEmTB9DWCemwcIXZML0JyKsk9Jg4QsyYfqTENbJabDwBZkw/ckIqykNFr4gE6ZvQlinpMHaC2HB9KcgrBlpsPBlcjD9DIQ1Mw3WPggLpp+JsGZpsOSzmqoXEelV2kICKxT/VebXbODPZ+6EfX8Fo/IvQLzy8pM0v2Y7zeUK5YNXu+cQvBYTYXAsgmEwnzlEPhTWREasSYxYkxmxpjBiTWXEmsaIdTwj1gmMWNMZsWKMWCcyYp3EiHUyI1YTI9YpjFgzGLHwWKaz6+WzWs7V2fUqHezP8PJQDkoD40MMr3lDDuB5Uhqe8ZJpS+cP8nlNhNXS+YN8HoiwWjp/kM8lCKul8wf5vB7Caun8QT6vj7BaOn+QzxsgrGzmD5NjqVjZzB8ORlgtnT/I5yFOKhZMj/vck9JgbYiwYPpM5g/yeSOE1dL5g3weirCymT9MjaVitXT+IJ+HIb5aOn+Qzy7C0s0fZqfBCiMsmH42wpqTBiuCsGD6OQhrbhqsKMKC6ecirHlpsMoQFkw/D2GdmgarHGHB9KcirPlpsCoQFkw/H2EtSINVibBg+gUIa2EarCqEBdMvRFiLNFjSbR1LxYLpFyGsxWn4qkZ8wfSLEdaSNFgbIyyYfgnCWpoGaxOEBdMvRVjL0mBtirBg+mUI67Q0WJshLJj+NIS1PA3W5ggLpl+OsE5Pg7UFwoLpT0dYZ2iwpNsvlooF05+BsFakwdoeYcH0KxDWSkdfxuFOKhZMvxJhnZkGa0uEBdOfibDO0mBJd3gsFQumPwthnZ2Gr60QXzD92QjrnDRYWyMsmP4chHVuGqxtEBZMfy7COi8N1rYIC6Y/D2GdnwZrBMKC6c9HWBekwdoOYcH0FyCsC9NgbY+wYPoLEdZFGizpRsZSsWD6ixDWxWn42gHxBdNfjLAuSYP1P4QF01+CsC5Ng7UjwoLpL0VYl6XB2glhwfSXIazL02DtjLBg+ssR1hVpsHZBWDD9FQjryjRYuyIsmP5KhHVVGqzdEBZMfxXCujoN1u4IC6a/GmFdkwZrD4QF01+DsK5Ng7UnwoLpr0VY16XB2gthwfTXIazr02DtjbBg+usR1g1psPZBWDD9DQjrxjRY+yIsmP5GhHVTGqz9EBZMfxPCujkN1v4IC6a/GWHdkgbrAIQF09+CsG5Ng3UgwoLpb0VYt6XBOghhwfQqbSGBFYr/qvdPtwN/vvc9ZeEQyk+VA/rB/AsQr7z8JN8/3e40lyuUD37/dAfBazERhtcc7yDyuYPIh8KazIg1hRFrKiPWNEas4xmxTmDEms6IFWPEOpER6yRGrJMZsZoYsU5hxJrBiDWTEWs2I9YcRqy5jFjzGLFOZcSaz4i1gBFrISPWIkasxYxYSxixljJiLWPEOo0Razkj1umMWGcwYq1gxFrJiHUmI9ZZjFhnM2Kdw4h1LiPWeYxY5zNiXcCIdSEj1kWMWBczYl3CiHUpI9ZljFiXM2JdwYh1JSPWVYxYVzNiXcOIdS0j1nWMWNczYt3AiHUjI9ZNjFg3M2LdwoiF1xzT7ZM7OP6s2yen0sF1J/yJYQ5KA+NDDK99eDmA53T78Q5BPGezH+9QhJXNfrzDEBZMn+l+vJ4Ii9qPR30HNyaWGjYKpMPfMMBbR/C3daNB2EQUBr+Dw+vSY0DYJBQ2FoRNRmHjQNgUFHY0CJuKwsaDMCUj+B2c+j5SyWj/uH8+KpvSweHx/90sHXVzGZYjrLeQx6/jNF9jlw73AfDmmRDKZyJjPhBrm9iqX6WjUH/xcRnHoXywH84Hpj/OA8vrpsgjQTiM3xCve+qmSGpv8ijgt13M8SyrSqt0Cvdrw+P/u9m5sMKfagY/qut/YZlwG4Syy0S/YF4FjkOOK8OZZKcrG+Qf6yEcD/zsG5+SIVY+EWaiTidryk31uRSvVDm82ibMR3dq7VQNXzC+bnxWMoRjJKMMIzoZUmN8S06tVXLrh+Kpfqed43jaOhjLQf/3Q345Dn1qLdW35XvwqfJN14/D9Cqe7ggLP/0GlQ/Fs8oHni8AT+E9GX0rr/QOHvkB06pvTfNQ/O5dk5gz4pjUdzdebSUE8oNnE6i6x/x5HRWDxz0Vfy4Y9/AJnkeiMsNyUjwrTHj+A+RZncOAeViI7C5DYyRpd6m8ihC/uH5wWag6wXp3LCEHnWyhnQLtGBj/tAztFKij2E6BPKm01FwPy4HKRzdOHuszn4Is8ykg8snWDqHyoXjGcyrpYH9yAepPlN7B/gSmVd/B56H47UB/crGmP8H7U7DthPtY3J+o/Lz6E6yfKv4Vmv6Ess13jXnzrDBhfwJ5xv2Jin8t6k8M2U9kf6LyosbLTg4tD8fxN152IuRgerzshPKZzJgPxFJthbLlcP+TqW0N02Nb1qu93t2ZzpNqr9g+gPEf75LEvA+1V6jvSuaU3uAxajKRL24zjtN8fiadri+b7IHld4xS8R/TjFG6uYZ0urm0bs0RxoNxdOt/OZo8oN6m9L9O87HzSBR3Coo7WRPXa94on2vjz2bn9pV1qi3ANUzlVNjxBM8qDH7zu28sGQ+7HPQ/LJPUlRg4VhLHw/xAOR3vgUn1F/hUfVXmdgTuVIQL+wAsL3XOFm7/n8bbgmz/b3Wm8bCeSHdAHM/s/LWyHtcvdLh+sXywo+pX8S3r95oM6hfW4QkoDPbZ+Gw32NcrDCn775FNELS21JL2ck2W7YWSJ35HQI2dUJ55CKNnYTLOj0jfVRw8Xkin2o9qs0p+uUR66bDtp+L/Csae3wfS+evam+PQ/QKUAz6T8XiH5oUqs4rbLS4npY+wjfHpY1lY1eN0xDPMO2Yo7xDKz3HodV6VfyHBj+K7gAjLzYLX8nBlZaSirL68sbaiqry8IYTwFa/YD69RnkjELyLiK1mfBNLzyTpaTx0JfSKQq3S5ICyGwvJAmOJRtqG/Bqbyf6Ih/v3IH+ZfTMQfAcqQSV0WE/ngOUc2WJNbiNXVSW0D1FgIbRs8FkL7BZ4DGgEDBtUv6vo61bfhfh+WE/eDw1BfB8c/Rh0qo+xR3NdNN5S3375O5V/oeNdtARGWTV9XX14WLmusLq+tb4w21Fc2hpzmY0IO4Yf7uhgRfw0ivuG+wqX6uhiQq3S5IGw6CoN9neKR6utihvj3I3+YfzERH/d1fuuymMgH93XZYE1uIZbq66AdhO1U2NdhO3UqUR7Y1+F5WTnqk8wcfU+vEeI+FfIrHZxDTwVywvLFONAP2s0wDV6zUfE3A3b7xoU0f6oMOxP8UXuKYLm2KPSON5WIJ814ZUeNbJiw5+E14xvq92yoG98wIceh2cNFxMXH0ykHxZMO3wg3Dv2Pl29GIRw1BPu9EU79Qiyq6iA2Hnq3jotMdmH5Jaue8xG/Kq/h8V83S0dNHfFQa+Y1XsT3tELlX+A0VzkT20eopU0oHzw8mnktEXHlijNe+pZuVKy5bDAfSl+o4/BDHr+qvNgPDxNQF7He6LpAry7rMNBl7V6YjI/7AD9btvy8iod+MH49CoOvzkIafLwMsi9oxzVoaQeaOqocZm/6iYSpm36gPkEzykv/qesbVHzdVjLp1KsG3dYiSregLikdoepZpaFehxciXjN99V9I5GO6TRWi8kA9xiZepq8eKf1N9wpttEeb9HqFNhSEw/h3gFdoY33UJ9VmVDzDbSZCtRkoVz9thqoHP20GyrCYiL9/LDUM6g5+/UiFtbQtwPRebU66xljL88HpVTyztkhlDTU1UY6amuC2A18TqGNQqVcy8LUrdtRrAlVeqY+dS5K4OB7mFdY7Nu1hW1N8U30N3uqUaV+j073jAA41xqjrXHD7yvPI22ubzQIwFuPbAKk2SOmlik9tY6XGMur1Pt7Gamh7d5nidRrgE8sX5w91tB2IP00TH9u8GP94D9mp+NLBOsav9OFnHtTWEJUWL1GuAPV9GLqZ7XhNeagy4+VN3XbgECL82km6Y2LN86deG0kaHv/fzdLh+s0FeZxAyAO/3roIjf0xJ1Wm6fRkOpGvwoAyyUPxLwL1OLckFVPx1smhx05cJ3g5G7flcbHU8MQWODAvucxj2UM6aCtdV0jnXeDQeoh5nUrwCseWKbHUcBX/GiCv+SU0r5AfileqjcILmTNto7sgXlX8mzRtVKdLVJ+Lt1NQbRTzjfswv3qh4t8F9OIOpBfUvEfGewLJGm8ZkU7XP+D+dHj8fzdLh+sStlOqv8R1+RAql2q/OURZqTo9gcgXLivj/uEElC/VP6g8YJtrAPl66XEewbN0uM2p+I9p2hw19lN6QH1uSrVXXCftPeLjsqj4T/tck4D2tnS5IIzPTgmTaxKwT82LpZbb75oclhOMTy2fFzvp+2S8xV/6QVtVHRGNt/h/DPqJV9F8l1pDw/lB3nXzMpjezxqF4Vcl1SGUnyoH9IP5FxAyMbGuS11LqtOh4wj+1dyUik/pKFVvchkEr3sUAyyVL/w8djLyo7aD4bqHYxkci75CfRClb9TnJlgu7R3a9vf6NPdzjz4I97dKxtS8+0ineTmoNSTcx2d6JS21bZ3KZ1SW+VCv2VT7xJ+ODY//72blMt/aOAqFUfMGanuaWgcJEflQax1Q7xeVJHFxPMwrNe/Uvdfy0z9Jhz9LhfUB2yvVV2A/XO9Uezf9CUgxKo9uS32mnx9QnxLrPjUxvA7iewyCtiKWiYkxiFpD0r1boezDKZr4OrsHxodjkOIJ6iTc7u0g7I4gPu7DcN1T13DLvrvbGql8KxlAGwumnRBLhsP4C8A7hZ5xTN3aN9WHd3FoXhzHXx8O0+MjVvCeBupX5YP9dO9uuqDyHKcpT6Z9E0zfWn1TF5SP1/rK2khvWvr55TigN+tp9EY39us+9TKxdq47lqSl+fj9dO3frFNVTDp1CNCpTZBOUXPPf6ucpzDmA7Hwp6XQdsDrJNQ4O1WTj+7oGy+9+d8adJ5+9UbFHwH0ZmcfekPVgdfxLTDf1tpPsLreJUIsyuZR8an3fjobjNIlal5PzauUbpvdMh/2vZdO5V+AeOXlJ2nvUtfITiNk19lJzvVqGo4JR6q2aagbP3ncBFwZCrDYSRXy8QhQxXfQ/zidZCoXxTmOyEM6eMYBVCQ8GcQGNcb3w1O6uOnCqUY4zaOcjuOvEcL0mZ7Xhr+tS5zXFu/w/H5jDpUHb/7TfWM+2YP3HKIMBQ7dkcAXNDAMlnk7TZlV/NGaMk9JU+YRqMxeZ0XB/3G8HKIMHZ3mOgAxKBnDPfEt0SeYvrWMla4oH6/BfRIa3NOdG9EIwmH8KBjcp6LBnTK+TZff6zwZWK5GEMfrXINcAlM6vLldxW+Kl93wwg/5nYbu2wb4QnzGGullo6tzFX9tUOezfdS5rv1Q5yTp+gqrDZlwg+tHx2H+1hsyb4dShezXkMHpdIYMjuvVqLM1ZCievOJmasjAGYDXG1rH8ffGFKbHO0zNvBWNuLhO4G4V2Ji8DmmDO/N0Mzj8FhXj4wEAfmhGyU4Ninjl9SxgxGxbuuqZqqtuHvw5jr+6gulbawd+N5SPiVVc6fCKRmsb6146qHafpzOSrsxwwISTBBj/xeIk5jVowPSz6xzK1c+XQJmu8Ovam9/2g2WUS2BK53W45hPIgDLzpqrc1a3imTXeyn0P/tigo3b7FRBhWR00UtkYdisqKqONkZqqhvIKPEYqXrGfnzd6/Yj4ZleMysiDRqYBuUqXC8KmorA8EAbfDOKP780YZmX1fuQP8y8m4uOdLZmuGnNgqQ/mqcn66urL/B66r+I/q1nQoA5/heMWXsShDj/FkyFcRtwnSjc8/ptOkxrTOJWfqp8OBC94h7mK+wqQy/alqWWhDgBQfVSOJg+H8As53rLDeVAHEKiTy6mFIy/eqIUniHGsB58SgzocFOt1poeD6hatYD59s8ynL5GPyTdfMM909thnGb6R2juWDIfxHwD22JfIHoP2HN41RC2s6g47hwfRUQuouL9R8b8D7crPYed7A0wvPfN72LmK/3MAFrRwmXOd5E562D/+L5ZaBhX/o/jJHFL+v62RGeaOHpjrAsw/M8TcyQOzN8BUp4lQ+tjDSc0P6jql/7jNwfTw63zIC3P9Ji58OcoMfuJykNGELGCZVP7Z7pyEebXWiR1U2XT1DC++wm+mKazRGWLlE2Em6vRITblh/oUaXqlyYLuCyqcHIRMVf4yGLxhftWGo+yqtkuFYEMYow4iuvuEFZyr/llz4ouTWC8VTY1w7p7nsj/LActD/vZBfjkNf+CL7zLr4eE6tm3T34FnxgP2w/sP0WP/N9JmV1dTOYuWoLyMgj9jloP8h37K+N+yaxMXxIAbWY6/LE6k+1wuDWstN1+6lgy8jVNmPmTB2fMNu44+YWDOhYduJDWMmEPrbEZUP69049P9RKC4+uUOF4ZeZo9H/R6P/xxP8YIdlAl0hEc/LUe0Dtse1wXNLxgeYXsWj8hmQZT4DiHx0WGsTWCr+WCL+ACK+KgfVX6o+AF7saKL/ptoQHDNU/i3pv5XcBqN4as7VzvEev9L134ORn1f/TenKKA8+Vb7pdIWyETAWnD+pTSewLeeh+DvF7XKz9mx1VPXv0MZQMjNrM1RHQyg/JW/oB/MvJPhRfBcQYdmsT0eqouFwlXiF3uCWuTX1rq4tQz/c9o8m4q9LxFeyHm9G1uThsEcDuUqXC8LGorA8EAbHE7w+baZ/qvYlf5h/MREfr5f4rUsKa0QLsdT6NOzjVdturb7JbJ+SuT2Jv4j0ezJUpqc/qfJKvd2xNImL42FeYX3gtdCjiHLoxlLop6srFU/VFdQXG+sKtj3sqLpS5c20rmB94LoaQ5QjhMIUP9hPV1djNPl0zjKfzkQ+ujHbz5hK5UPxnO6rw7FFyTSwv/P66vC4WDIcxn8erEeO16xHQh4hdsih34XhPlqlh+vjOltMxT8uzhO1Pj4GlRmWE/MIy5xLlEs6vD6u4k9D9qCheQC5Pq7yMmsPZt4XhVAYfB+8bSwZDzuqv1FlknW8m481CtwGIW+UXTKGwMLz9BqCH1XO8U4q/7BtSIff+8L04xFWupM78KZ4mN7PF04QaxeEpXv3nu5Umt0QFvWBgsKakgbraISl+3p/ahqsHRCW7oSmaWmwxiMs3el4x6fBmoCwvE7jk3RCGqxjERZMj0/bm54GayLCgumnI6xYGqzjEBZ1UQS1lg/HJT+n+8SAP1+fF874MqjWOt0nhvjB8sGb208keC0mwvAa54lEPicS+VBYoxmxJjFijWXEGs+IdSwj1nGMWJMZsaYwYk1lxJrGiHU8I9YJjFjTGbFGMWKNQ1jUPgaqb+vsJOdC/7zv2bpm3DHHjm5wkIP2pMoD/n+0R/7FRHpHgwXT6MoCbU285gVP/KLez+KLGVX8R8EcSJ02Rr2Dg/zo9j4YfqcfCaH8FL/QD+YftL0V1HqGSltMhOF5ZibvNLPVcem2jdH5h4j0Thos9T98l6jiUeussKx4zq/aHlyTgBh4z56K/zLQd3zSebq5GH4HQM234Liu+ClymvcX+DsMak5Jre3D94bS5YIwRr2uo04ehfLJi/mXhXRYdrrbU2DdUyeP4HcBsJ/DdlU6vVL9KJ4rwLRwTYyqy/4oT+rdEPTDY1p/omxUPgOyzGcAkY8Oqz+Bpas/3btvap+z2Zuhku++qXZNrQu05N23kls/FA+/+6bWWjCWg/7vh/zSvfuGdXqUB58q33S6AtPrdHJUlvmMIvLx6uOlg3YPXtdV8deIjy1m371WRXXfPZr9/qzK9zt2r1MmId/UqY7ZvGNvrIq4ddHGBrc8Wltb59br+oxMTyAqJeKb3VteRb5jh980SJcLwiajMDhWwgvt8Tt2M/1gletH/jD/YiI+nm9kevIpB5Z6xw7HEtW2W6tvMtunBPcdO9wbksl7W1gf+L3teKIcujGbsiepuhqvyWdwlvkMJvKh7OOQx6/KB/vhfCie0723XRvNqdKdFjsplgyH8a8D3zWtp9kTjW1t3CagDkqH2z28udDP+K7ibxTniXpvS32bOSnmzbPKw+935ip+BNkYhk5EJt/b6r57xesFmX73Sp0VELRb5fA3OHANFu+lgGuqeL8hXCPF6zN4zROGxUDY0SjsRBA2CYWdBMLwGR0ngzCoo9hRfTM8nOzcDN5xUzed4YO1oHypvVFrgWcYpnjFfljfYPqjPNLhfsTwNy9hw2068V0S9c03LBO23Vu6LwjmVYCwuGWnK5tuPxR8T4ffs1FYkzLEyifCTNTpWE25qT6B4pUqB57PU+1sLUImKv5kDV8wPnUAW2uv11Ay5FqvUXIbguIpu6Od01wHJ3lgOej/IcjPa70m3ffphxbTPPs9L0jFPx3YcbXgGX/HA7GOcFLDjgBhE+PPZt/xVJZT6ypYdhNB3ngOdBxRHr9jqSqT1KvhGYyl0G6CvEFMWH8TQBz8/b6KPw7YuYcMpDFDjn5dG+uQ3zMEVPwJGltbxcn1KNdoD8w5QBeP89B1h8CkyoX3fmIejkI8qPhTQbnUe0/Hcchx9gjw/9hYKm9jibwcDz88Foz1CNPlmy6tfD4GPFNjPdbXCSi+eq/uJVOsKyp+k0ZXqD29uvfZmAccZ4wHD7MIHuQ40SkeXjd23GSPV6G54Bl3z1RV4io4ksDxckoMsnhzimkc9b9O/ajXyI6HH64GlRaexVnfMLphgte74nYIbJRHZu0c2vnZjxe0fQOm9+PpzpuAsqT2JeN9A9S3R5nm09J9A1gXjvDIP0Skd1DaEOEnnWwsJ3dY9UzNRfHaR6ZzUapxYCyvM4JGxpLhMP7ZoD/C+w2OAnxQmGqPtYpP2cW6g4zTzS/x92nUPEWXN5SlnzV9Ha/Uux5o8+O9FJC/KRnyOqKVeT0qQ1692qUaw0QnfcTEhvG7jJ3QAJsKZsNBz/nID8fBny2M8WC1M4qHl73xkWp43MRj0jiCP8pRXQPmJcdJ7/A9A1eDJjrSo4k6Dt1E8fYR6lM/akpHLcvqzHfqsiWIgbc7qfg3abqfdJ9SYLWnPpfQXQBKXRZEfUoBX6P8gx1Lhql4hrc71VPbnWB582KpsqA+99AdZ0p90kEdr12M4kM5Uq+G8LIttXxPvRpK9+nLdh7lzfMo7xGxZDiM/4hG/yiZUEc1q/jUpyzU5evUZzEnoDCYDr/Kh/qn4hnWvwZK/2B5sf5Rn+LA+Fh2MSI+fMUBty7D+FCO1JGLKk+q/4MXuqsjF6nX2yGPX8Ur9tNtLdg5lpqPqUvW1GtB3J4oU04+D3VS408H+eL2RMVXcoZLLVT95aH474D2N7dk1TNeepYOLj++V0znDdv+JIJXnPdfYJnnQ7TkSJlv+CjvTwDv+5Z6p8evQ+G4g49C9zqyFcoflhPWOe7jVPyvAJ8HxPmk+hK4jC5dLghj7EsaMx3LqH5VN5bp+h4os2KnuZ563asDsaDMveyg9g5tg8Cj9WH8X4nlPmraNxXxfmyGvPu1DSeBclyJjo6FssSfF1F1RfX71PUGJ/jAmqop73TAMxUf9hMwfl78nh8oe4yZ59C6dLwHZkeAiY/STofZ6IHZCWBiWyXmJB2236TDbeREIn4MxMH2CGwjJ6IwyDseN2Mgfxz3cJQ/9TmuQ+TraPiltuPr+MV9uwobBC+kjj/nIzzmfjGqq8t1iPL4rctJmvJjLJUu12mur1QbihHyGtCFxszLELME6LsaXylbZ0wsmfcglDfVh8B+EfeBkwi+oM1BjdNe16GsR7TX1TaHDDe41LgLZYHHXWoOprvHTDfnhONLMRF/dCw1zM9ddzCfloxrMzzuBvTC3SeWGl9nj8nnOhAO41dq+nFKhjqZp5u34y2tsD6OR2GUTgdNX6F8sL7qZCFdpvN1rK+w38R2mO7Kp3R6pdNXeLT+JGSHUVupqbUFvKSbTmfwVmfYD1LxsQ2k4u/kw66CPOg+tYgR8an5JTXGxRw6b9huoUzwBd8q/h4++3NVL2bnUeEw1T6gXHH7iIGwHCJ+pjaikpnu836qfUxHYVA/cdvxuw6Ybn0HX/Ke7sgfPK+j7o2FNibu61X8Wk1fzz2+4nUGSq66viNouhyUvh6vF1B9PaV/cC2gyoetcaSG/3TvNnD/5/fdxrGA/3+wY06zcq+Oum/Ndxu47nXvNqgt6X77lF1ROdL1KXjdUsWPZdin6PSKs0+h7mZffeuMwdYrXZ+SqV7pxkDYB62N7MfJBK86PdLZZ+n0SLfOPc0jHxhPOuozWumGx3/dLJ3unYzZaxDd8hDKT8kD+sH8Cwg5mtj+RdUrda2a2Wsu3TLZ5VHv00bFmssG8+HVntS7MOl2Azj40yfqql/Zns5Ba03UegBMq/LA6wEXgbWz8xGm330Y6d6vd/O4Ug7iel1lCGXb3iM+LDuMf5lmDkj1n5RuqfjpbDi8v8Pv+/XjPPKh9hJQ47KKf63P+WHrvLOPhFf3O3u8RhIDYfidPawD/B6I0lXYLnAboGw0qr1yb6vDNrjuKkvqHfDqs5UiEUpXYHmxrujmI9JxrQ1DOVLvQ72uroT5+LWVVFqpK6PjlUH1JV59I8yTmotScwi4bwmW52nN+0Nq3kDNMzDmcxmuO+vagl/bl7L3jteko+w9mNfw+G/6C3/9XQes+poOjrcNgfv514Ac1XXAlP2Tym92jloTCSE5wX6TsW/wfZ27yr+AkKUJ25SyB6h2p+Qz3Qg/4UZom0L9hbap11HTSl+o+Sm0NT9AYxfVB8D+dCMQDuN/BmzNjz0wHSe79xR3d07F5V6r061n+bHzdPsWsC3ktUejDoTD+N+BvkG316pVbMBw42p/R4DfA5wIwvDYTekf1AW8Jq9k2N7R7/PKQ/H/JOYkft5TTM6Q96kE77id47bzgQ8btaXvKaRT77Bxv9A+bmP4XVPU2Qam3lPAown+wY4lw9reUzRfU4T7Jvy+p7gA9d3UXgtq7oX11Wsvbi8QDuP31ugf93cgeD+U33clq31PhBuOrO41bVX3ft6VUGva1Bwd7sk5Oa5/JuVYWeUmbFpVh/A4LuhyQTiMPySurwWgHOo3q6MpK2vCjdGaxprymvr6sroafLyWdKrO5Od2Uh/W6ZqUmZITt8ykU/h5ZvAT+x/h9+k5RJlU/kqX8Gff1K/j0HMWlVcBwmIuW1hXNsg/XivIRfyoZy+s3Ayx8j3ChvOUO1GnOZpy4/y94lNtQPm31+DD+KpfhzrcHsmigxlZRHT11h7kqfJvyfFB6v/+KB4+7hnKO88Dy0H/90d+OQ59fBDulwqd5uVWaQz3Kb6PVVD5FzhG20OiH8hD/Hi1XfhZ9eixNfXx0w5wl4erDooTwuFi46pLDIvID6sDPkFDmYHUEIr5DBEYlAgUZpGTygNMS3UlOR75Ok5SXXH3kQ5LPedoePHCCCGMQg1GW9NpazqEa2s6/poOtzUeqaqqqI7UumWV9XWN9WXRdNY4d/51tRW1ZQ21dRXhsopomVvf2vk31JZVV9ZW15W79W51uLrVy19ZUyVyry6rKatw69zKikxmQ0r3oWWF2zplNbYnsIuJ9CoelQ/W4Q6afHCXGXKSVl97R28h5qH4x4JVFLzboj1Io8oBD57u4MFDLlFm6fDB0yr+ZMDDwaWrnlW7hV03fLsxtaueV9wv5zqpeav4J3VNYp6A9ICybosdup+BYbAulYw6Of7qXcnEceh6zEPx1aqHV713ROVW8WcS9V6E4lAyyCf4g346/c/3wKLqTDp8CbeKf6pm5a+A4C+H4E/F70TEh32S4oeSTScUVoCwqXxgWWFd44PrVfylRFmp1USV9+o4VQbKMC+WWm54mlEOER/XRyERH14sr2RWjOLDuqHaaCcUBvNtj3ig+niol/jNDLUyAPsoyjyHMlB85hPl5au7Ot8X+Kr8CxCvzLoUzlRHlHwKzcjH1elgISEfxc8aRvhxE5cxFRN5K17jL/9S+hUYvxDIEMaHzyo99LsJ6WsRSKfwi1GYdOq0mhARlkP4tVtNWMUEFpSbqlPZji9HssAntFG/Chf7YR5hfSqd1/URLc0HYik7impPkobH/3ezctGIKscaRDlU3lCv+NpOeaXfvk7lX+AYbcthnQ5D+ah6o9q+SlvsNNfhE2LJeOn0G+ZDYS0LKNYsRqwFjFiLGbE45TWPEWshI9YcRqwpjFicZVzEiMXJ1wxGLM72yFmPMxmxONvQUkYsznrk1NXljFic+rWEEesMRixOvQ9qn8NZxhWMWNMYsVYyYnHKi9M24dSvoNqFnHofVFuuiRFrPiPWf8GWC6rec9ombWNaZlhBteWC2hdy2nJNjFic9cgpr6DaX8czYgXV/prNiMXZtjnbEKe8OMchzjYUVNk3MWJxrssFdW2IU784bd+g2phBHDvkM35nxTF2FHlgw2fdu2EqnxDBM/VOuR3AyHeal5fzvbLC72oIX5W7CyErWCaVP37HrMKpX4WFw1ReBQiLuWxhXdl076Lhe3coAy+sLhli5RNhJuq0WFNumH+hhleqHIWMMsljxMJ7g6j2T72/VfG7EvEpPSki8lZpVd12A2GMdRvR1S3sI1T+LfnKSMltHxRPXQjZzmneNrp4YDno/32QXw7Ag661+nf8v9pbA/f04ludWn+PREU0hPJTZXZQuf4teyRisWS8bG2G0xmxONfoOe3uoK5ncJaR811xUN/bNDFicerEqYxY/wWdaHunsfpkzykvzjVBzjJyrmcE9Z0s5xoXp97PZcQK6no/p0602V//jj6ac6w9mRHrv9AXBvWd2SmMWKcxYgV1XZ1zTGt7D5EZVhMjVlD7e8421MSIxdlHt40d/46xo22/xerTibY1hdVXRs5vEoI6H+KUPed+6qCuF3LaOW39xOqzJ9r6idUn+6D2E8r+0u2dMbyPyPdxfyr/1tqbQ8mV2nOR6R4V3fldsEwwDPKgOyesiMgnn0g33GGRVQSXF+9RoPjows5HtFzVAdwng/XX5L4XmJ/j0Pqr8i9AvJrS326IHywfrL/dCV6LiTCvvVkq3DEu82htS2VuaF+bVubUHrFMZC7dibFkPByWQ/i102A1MWLNY8Saz4g1ixFrJiPWFEasZYxYixixOMs4gxGLs4wLGLEWM2KdxojFqV+c7ZFTv5oYsTj5WsiIxan3/wWdmMuI1cSItZQRi7OMnLKfzYjFqfdLGLHa+ol/Rz/BWcYzGLE47Ymgyn4FI1ZbG8oM62RGrLY2tPpkzzl355wj4+9o4RoSXh+l1lu6afKB6WE8+D/1ndXYWCpP3UG6roinTMsO06t4VD5FWeZT5DMfE+XJJ9INj/+62bnEd8g9sscuxx4Kuyc/32VqDRDeNQDvpvixe2o9wLsnclDaEKiHPBT/wB5JzF/imPg+Gwc85yO8kMO5Vur/VneVfwHilZef5NptO8QPlg9eu80heC1GYdJNjyXj4bAcwk+HNY8Raykj1gxGrEWMWMsZsWYxYi0JKF8zGbGmMGI1MWJx8rWMEYtT7zn5amLEms+IxVmPnLKfzYjFWcYVjFjTGLFWMmJxymshI1ZQ2zbn2KHsCTWngPajup+EuhMN338F732DGDAM8qe7eRqmz/VIh8uB98uo8OHx/93sXFjhdzSDnzhjJ93dfyp/6o68kMevwsJhKq8ChMUtO13ZIP9YD6j9SDqsDhliGb7BO1GnujvFYP6FGl6pcuB7IKl2FiJkovw7aviC8YuIvFVaJUN8b+Dw+P9udi6ikyFsiyr/lpxPpOQ2EMXbLpaUA9bBDh5YDvp/IPLLAXjQ6e7eDRH4uvot9kgvne5O3EIinSofvMOyFwjviPLoRfDYS8MjTK/iUfmEsswnROSDsag1GulGxpLhMH59fI2GuouyN8Gfri32IeL3BnEUP5Rs+vhIJ10hkZfiSbXjvsCfuy+E+Sl+oR/MvwDxampM6ov4wfLBbaMfwWsxEYb7hX5EPv2IfCis3ogHqFutVH+RltZfbzP8aOuvNyHXTOsP2wj9jJQjXKf46u80dypsAMgb68KaIAy2Fexy0P+wTLL/Oqw0iYvjYX6gjine8gleGeXUgMvrEHzBsfbMWHP+HY0sBgBZTMhAFlC/B6IwWB8lKAzqUykK6w/CBqGwAQQ/ftqmdLiP0elVb8Z8oIz6oHz6MOYD5d0P5dOPMR9Yd6quipzmdQfbCW7jOYQfzqcvkY8qD7T14funlT3oPKFtA9OqMzjzUPwdByYxz45jqjY+EPDF18YjripbidPcqbBSkPcAFDYIhGF9HgzCsA6uBcJg3WJH9RtKFrLfWJxBvwH7bdz+deO7IXvI9/iu8m+t8V1nF0unG99VWqrdqnfDRYRcYZm8eKBsxJb2d2ZtDP91q/JvLdu7n0+5UnZQPyRzGIb3SVC2tI4HnV3em+CByqdPlvn08ZmPzeVRY47qL1fEA+SY80iP1DjqW8UbeifjPIbiqL1AT4O9E0/En6mx5chYalgpCMNnNA8iwiR+5zg/SmZwLMFrI2sBjBzCT7c2spYHVi7AygdYeFxX8b9AY/naAJevjVdUKrmtA3jC/d26hvL229+p/AsJfhTfBURYbha8NtZVuVG3oqK+oaKstrysMYTwFa/YD68XrUfEp87JVrJe3zEi60jiXotYEn89IFfpckHYuigsD4QpHqXe/zUwlf/1DPHvR/4w/2Ii/i6gDJnUpUks2B9wYHVoIVZXJ7U9wT7HbB8UqaD6IOWoNo/frcE2puZYIQKLmheoMknMK0qTuDge5gf285A3XA5q/FDvK4qc5nJdB2GtmwZrBMJah+CrkMDCfbyZduvfplX5U/24CZuW6pepdqFktz7BazERtk6ryDVSjfmCToVtAPKG8sSOaheKb9ku3s6gXUD9g/l7yRzqsupTixzvfh2nw+3Njz1jSNfLWqrr65jhR6vrUD4t1XXYb2FdzCH82mmw1mLEUnpD2fp4n3+mtn4RwbNZOzlSRY1zylF1tg4K28Cj/NhR/YAqk+wHPi5N4uJ4mB8o8/VR2GoYhyr+S+OQdOqbmmzb038Ni2prIY9flQ/2w/lAncY22WCQDr4fiPZMpoHp4PsBmHa3WDIcxj8PrMNUxDGpflHxqNrhEBDG2Jcl3qNu6DR3KmwjkHcP8Iwd1V8pvjN9Pwjb+UYoDNbfUBQG2+MwFAb7XReFDSH4aal+wbryY/O3NB/KHjPdXvDYsT5jPrDuVF0VOc3rDtsmG6B8sB/OZy0in3Ttf4+edJ5e7f/oWDIcxl8E2v/eccx8ooyrs40PQWFDQRjW52EgDOugC8Jg3WJH9RtKFpm+H4R1q8pkdi0vUoP7F4fgC/YveP18Q8AXfL+JHSUnuPb3dwv7V1zfsL0r3oqc5jLEayOZjvfrEOWg8inKMp8iIh/Dba6WqnflqHrHc4SNPMqPXbq2k8kcAcp8QxSmm7+bkaH/OYLKv7Xm79R4o5u/DyF4xbaCdNh+HkLkM4TI57+ORfW/IY9flQ/2w/lAncZt08tGmINsBJXO7xxBxZ8ObIRT0RyBWs9T7RD2GYx9WQO2A6Cj7IBM5wiK70znCNna+vI5jMJgnxxBYRsR/LRUv2BdtbZNbbq9YHvC1NwK2ybUeBpCYSof7KezTfBY6NX+L+tJ5+l3jqDijwXt/0o0R4BlXJ1tHM/JKVtfhYVBGNbBCAiDdYsd1W8oWWQ6R4B1C8sEec8FfnDOvkds1W8ein9HvJ5knd3WMzW/wSAPlfc/a0q9UuNR7dHs+o//70tU/gVO8/Zuwsai7AJqTk/12yptMREGvx9sSb9A9TFBW6PDe3jh/B3WG3bp1u8y+dYBtjE8D4f8MMqpEfdTDsGXC/wy/dZhKJBFJnaKSVtEPkdR2FCCHz/tXDqs75Tu/NvsB6p9ZZsPrDtVV0VO87rDdspGKB/sp7NT8JgM7Uhop3zck84T2ikwLd4TqeIfBOyUz5CdYmguklEbh/rbUltEhUVBGKxb7NLNbzKxU6DtDssEefdrp6j4v6B6MmRXuF1RuSiZttk75u0duJaL+7hM7R28dhoUewd/K7I67B3YVtvsnWRYm71D5/NftXdgO4FhKp909g7Vzqh3FNDeWasXnSe0d2BaL3tnB2DvrBvHNPxu0Up7B76TbOm6DO430q2hhFDeXnbRnrFVv3j9pqpXErOilzdfg0He17at32Bn1fqNqsu29Zvm/MD21mbPJMPa7Bk6n/+qPQPbCQxT+aSzZ6h2lm79pt6HPeNn/aYC2DMjkT3Ttn6TjLM61m+wnaLiH4vqaXWu3+i+GzBkX/i2d/CeINPfDVB7gnTfDfjZEySf8fpNS/fLQH0M0n5I+YzXb2D7zPQ7OTj3yMTegXJWvBl+516PbQGH4AvaApnaO/D9eEv33nPvr4d9uOlxu7X23v9b9+8UOfz9EdXO8JxDOmjvnNeLztNrXw22d1T8wcDeuRCNo4a+C86ojUP9xXYSpc+Z7rnx22/Ab40zsXegLYv7jXRrKKoeoJ3GVw/RxP1DZU5zp8LKQd7wW1rsKJkpvqXMHh+UxMXxcJ6wHylHYVAnK1AY7BcqURis7yoUBttyNQqDfefGKAzOBzZBYVB/N0VhUH83Q2FQfzdHYVB/t0Bh0M4fHn8Omv7gtloBwvB3MpUgLNPvZKDe9VkriYvjYV6hfiu+OzvJ85FHNkzYsWHyPjWjj6ivmXDE2DF7NBx9bMMxE3IRLB5S8Wdn63uwC3EcDbvStUNha6PwnWPN40FXSKRTeSi1KQP+q2O6ovIvcJpXj4npShniB8sHT1fKCV6LiTC8naWcyKecyIfCUrpCbX3H1/ZRR7yso8mnK8Fz0LqQrigMdiHZDE8t3caneMsn+GGUUyXuFh2Cryrgl+m0qALIIpNpEZQ5HlahzuBhFfYteFiF9Y2H1QqCHz/9iXRY3ynd0fWLLc0Hyggva0cZ84HyLkP5lDHmA+tO1VWRw9/vUe0s3bTodzQtSnckAZ4WqfjFYFr0FzLHzXxKl1kbh/qrwqpBGNbnjUEY1sFNQBisW+yofkPJIptpEe43SkD8MbHUsFKQbi2UbhAIg9MpdaymigePIi1BGPDo11IUBo+qHgTwv4+frY11qCvQoZLeybSS/B53pOJTn/euR5SXOpYKL3GamdYHS39V2KYgLJvjxep8TCOoeqaOxoP9z3axVH4HE/zCfg0v36wNdCyK8t6IyBvqHdaxoUR86rUetQSm0gbts0u8dASn13g6CqfXeOkITq/xkiMcdzP9XAu+RvOrY7ieqeVGvzo2BOCeh3RM8VYFdGwEyntYmryxjrlEfFhf+MgDqEcqbT6RjrEfcwsJXpWjdAUv62WqK5RNjPUW2lVQJthROqbklImOjfDRl8AxCesYtSURvqbHOrYj0LH9fegYdbSFXx1T42ybjqWGtbaO7e9Dx6BNhHWM+swHbm3FOnYI0LHRPnRMZ4+19WPJsCDr2GhD/Rj+XIyynXT6Q+kbfGWAbS34GkKlDdLWQygfE/aUTrf86g/c6uhHf0IoH4UL60c6nX2l0lJHIazjE1fHh24cpHSd2upL2fMboTCYbgOPfLw+HcBHOqj4M+NtE155qeoDXgGg8s6P/+aCMMb3ABWSj1GADyzDvFhquXXzJekybfNKZsVO83EBb/+GdYDb3WACkzqKh9KntTT8Z6pPFI9B2j5E9S9+txbg15WZ9nV++yy4XSmTPovaeue3z1JpqSMe/a5n6PjQ6ZjuEwlKx+D4jLfowHReW3RgnwXLhvssFf8yn30WPIZKulwQZrrPgjLEfRbV5qmtSX7bfGK9HMWHdZPJNieICY8YVnVaCuJ1RLyWOs15LSXKRl2JVOqB5fdKJBX/mbh+qH4Orknz1XvySiTY9lQ/oPJey1DeIZSfkjf0g/kXEvwovguIMBNXIvk9Ql/FX5uIr7sSycw7IfpKJLg2Ll0uCFsLhcH2D9/V4CuRDF3dFfEjf5h/MRF/F1CGTOrSJBbsDziwOrQQS12JBPtP1ee0Vp9ptq+LRKm+Tjmqb8FXL8G2rN4Vhwgsyv5SZcr06iUoc3w092CUJ5a5sqGKnOZyHYyw1kqDNQJhDSb4KiSw8FhiaO+V76uXVP7UeMHIT1jX/1Ptj1qLxH0Ztc3XrFwzv64MyhM7ql3AK8kyuXqJsvN0Moe6jK9eosYPnA63Nz92kyFd9331Etb1wWb40eo69Q4vU12H/RbWRd0aKYVVyoil9IYaH/Gx6qVEPrrxsYjg2aw9HimnxjnlqDobjMLW9Sg/dlQ/oMqU6bHqUOb4KOnVMA75Plb93zAOSYePHG9pe/qvYVFtLeTxq/LBfrr9odgmKwHp4D7Hvn2SaWA6uJ4F0+Jj1VX8WeCa7AFxTKpfxNesBuXKyEyPVYd7ujLZ56y7HgfWH17X0h2Z7ec6J8hPS/UL1pUfm7+l+VD2mOn2gseOdRjzgXWHr2uEdVcKnmGYygf74XxKiXzStf/qPnSeXu0fr2er+JNA+980jpnvNC/j6mzj+F0LfE+J9RmuTWMdhGvTsG6xo/oNeMVkJvucYd3CdwKYB0b5VuL+xSH4gv0LvnoJvlPJ9OoluMaYydVL1DV/VP+K99VQdm1Lx3vqvSmVT1GW+RQR+Rhucxlfz4rnCKvjelYoc/xOVTd/N3Ssie85gsq/tebv6d7J4jkCddUnthWkw/Yz9c0CtZ/8v45F9b8hj1+VD/bTHa2B22YJSAdthKORjaDS+Z0jqPiNwEaYgOYI1Hqe2eOOMr9GLtM5ArwqLpM5Qra2vnxuydEykJ+W6pfuai/TNrXp9tLa18BSe1OwbZLpdY2DiXzStf+Ffeg8/c4RVPx9QPtfguYIho7LyriN4zk5ZetT+7/8XN3qt99o6RG/sG5hmSDvucAPztnxlQYq/vnxepJ1dm6f1PxKQB4q73/WlPqmxtMdZWdm/cf/2RAq/9Y6yo6yC3RH2a1P8EodX5UHnlvSL1B9TNDW6PDRvdRV4H7bGFy/a+nRvXgeHoQjjqXL9MyGtmvk6XJx5PNfvUYe2ymZXiNPtTPKjoR2ylN96Dz9XkWg4m8N7JRnkZ3Sdo18Mk5Lr5GnvrcLId792ikq/tuongzZFeTRvVimbfaOeXsHruXiPi5TewevnQbF3sFH964Oewe21TZ7JxnWZu/Q+fxX7R3YTmCYyiedvUO1M+odBbR3OvWl8/R7RpWK7wJ7Z404puF3i1baOxxnVOF+owSEUWsoIZS3l12ErzRQ8Qf2TWIO6OvNVwnIe3nb+g12Vq3flMSf29ZvmvNTAsLa7JlkWJs9Q+fzX7VnSsAzDFP5pLNnSoh80q3f7OjDnvGzfjMA2DO7IHumbf0mGWd1rN9gO0XFPwjV0+pcv9F9N2DIvvBt7+A9Qaa/G6D2BOm+G/CzJ0g+4/Wblu6XgfoYpP2Q8hmv38D2mel3cnDukYm9A+WseDP8zj2jK6qky9Tege/HW7r3nnt/PezDTY/brbX3/t+6f6fI4e+PqHaG5xzSQXtnVl86T699NdjeScx9gb0zF42jhr4LzvgaOmzTwv0pWJ+hTeFnz43ffgN+a5yJvVMCwnTnzah4cA1F1QO00/jqIRpWfISd5k6FwXOjBoFn7CiZKb6lzDK5egn2I/h6Xt09BrBfwGdw/xevcwqa/uC2Cs9YxN/JwDMWM/1OBupdJlcvQf1WfLfg6iU8pOLPztbxYDebq5cGofCdY83jQVdIpFN5KLWBx8mtjumKyr/AaV49JqYrYcQPlg+erkQIXouJMLydJULkEyHyobCUrlBb3/HVS4OJfAZr8ulK8By0LgRfvQS7kGyGp5Zu41O85RP8MMopoyuqpMt0WgSvocpkWgRljodVqDN4WIV9Cx5WYX17XecE+fHTn0iH9Z3SHV2/2NJ8oIzwsrbLmA+UN77JN8yYD6w7VVdFDn+/R7WzdNOi99C0KN2RBHhapOL/DF59fojMccjX6mrjUH9VGLxKDOszvMkS6yC8DgfWLXZUv6Fkkc20CPcb/UB8fPWS36uRSuLPsv6+R6+kc0G8fgijLwgbgML6g7CBAP+JeESsQ78CHerQL5lWkt/jjlR86vPetYnyUsdS4SVOM9P6YOmvCoPXOWVzvJjfo/5xPVNH45UAv+1iqfyWEPzCfg0v33QGyzd9Ud7UazfqKlEVP92xxyXxZ2oJTKUN2meXeOloIxCGp6PUMejU9NrPkdx+dQy+RvOrY7ieqeXGEuCn07H1AO4spGOKt4FAxzZCeW+YJm+sYxsR8WF94SMP2o5vT7V/sEywo3Qs0+PbqXqm+hI4JmEdo7Ykwtf0WMciQMeG+9Ax6mgLvzqmxtk2HUsNa20dG+5Dx6BNhHWM+swHbm3FOrYt0LE9feiYzh5r68eSYUHWsT0N9WP4c7F01x9i/dFdgUDZWvA1BLyKBqdbnduS8FYtTntKp1t+9QdudczkGhNqO20J8NPZVyotdRTCYJ+4Oj504yCl69RWX8qex9v7YLp1PfLx+nQAH+mg4o+Jt01ZH7prTFTe+fHfXBDG+B6AvMYEyjAvllpu3XxJukzbvJJZsdN8XMDbv2Ed4HZXQmBSR/FQ+lSq4T9TfaJ4DNL2Iap/8bu1AL+uzLSv89tnwe1KmfRZ1Na7EuCn67Pg1TfVHke8psPV8aHTMd0nEpSOwfEZb9GB6by26MA+C5YN91kq/kKffRY8hkq6XBBmus+CMsR9FtXmqa1Jftu8kpnuCKdMtjlBTHjEsKpTuP7bEfE6wGnO6wCibNQ1IgM8sPxevaTi3xLXD9XPwTVpvnpPXr1UAnhS/YDKu9RQ3iGUn5I39IP5FxL8lMSfC4gwE1cvlSJe0/VDg4j4uquXzLwToq9egmvj0uWCsFIUBts/fFeDr14ys7ciefWSTv4w/2IiPr4uyW9dmsSC/QEHVocWYqmrl0pAetXntFafabavi7hUX6cc1bd0RGGwLat3xSECi7K/VJkkZiZXL1HvKUNEOSiZKxuqyGku1xKEVZoGawTCKtHwNSgNFr76hmq/hUQ6PC4Z2sfl+2oblX+B07yuTOwrSydXvK9sMMErtScC6gUMg/no9ntBrBJGLKUXlP7iY6sHEvkM1OQD06t4Zu2dSITqR5Sj6gzvG1jLo/zYUf2PKpPsfzI5thrKfDAKKyXSGm6bvo+txm3TTJ3q2yY1zmbSNqXDRzq3tD3917BM779TdUvtNYL7yL5D7w1UOrheANPiY6tV/OqBScwf4wmoflHxaPjTm4yv5Mv02Gq4ZyaTfaSwneP3AbD+8LoBbI/4XZOf63IgPy3VL1hXpR7l4sgHyqi19qvisWMwYz6w7vB1eLDusJ2T6RW3A4l80rX/Lv3pPL3aP14vVPHXB+2/exwznyjj6mzjeC0bvgfC+gzX/rAOeh3hiR3Vb8Ar/DLZRwrrFh/9b2ZNJlKG+xeH4Av2L/hqG7hmnenVNnANJ5OrbWDfgesbtne8b4Gya1s63g8gykHlU5RlPkVEPobbXMbXX+I5wuq4/hLKHL+z0s3fDR0b4XuOoPJvrfk7Nd7o5u/UVYrYVpAO28/UnnBqv+5/HYvqf0Mevyof7IfzgTqN26aXjbADshFUOr9zBBW/F7ARdopjUmu3ikezx8lkfk1XpnMEeBVXJnOEbG19+dySozsgPy3VL93VSaZtatPtpbWv2aTe/WPbJNPr8AYQ+aRr/4f3p/P0O0dQ8TuA9n8kmiMYOo4o4zaO5+SUrU/tr/FzNabffqOlR6jCuoVlgrzDI8dKAQY+Ml7FnxKvJ1lnk/qn5tcP5KHy/mdNCcVbDVeM+/72/t9wxbh8zgPPLekXqD4maGt0+GhUOH/P5pu3w1rYxvA8PAhHyEqX6Tfx8JjYtmu6267p1uVDHUlG7UPEdkqm13RT7YyyI6GdcnF/Ok+/R72r+D+smcS8DNkpbdd0J+O09JpuaLvDMkHe/dopKv4tqJ4M2RXk0ahYpm32jnl7B67l4j4uU3sHr50Gxd7BR6OuDnsHttU2eycZ1mbv0Pn8V+0d2E5gmMonnb1DtTPqHQW0d973Ye9Q+xqxvfMusHc+QuOooXeLVto78J1kS9dlcL+Rbg0lhPL2sovwkfEq/s9g/ebH/t589QN5jx2QGq/NnrFr/UbVZdv6TXN+YHtrs2eSYW32DJ3Pf9Wege0Ehql80tkzVDtLt34zeACdZ6brN08Be2adOGbb+k2qg7JozfUbbKeo+GWonlbn+k0pUX7De4J82zt4T1CpGX60e4KgfFqyJ0g+4/Wblu6XgfoYpP2Q8hmv38D2CesNu3Rzj0zsHShnxVuQrgCSLlN7B74fb+nee+799bAPNz1ul3qUiyMfKKN/6/6dIoe/P6LaGZ5zSAftncMG0Hl67avB9o6Kfwewd+rQOGrmO7fMr/nCNi3cn4L1OdM9N377DSWLTO0daMvifiPdGoqqB2inMdZDg+JjqNPcqTB4Lk8JeMaOkpniO9OrbWA/gq8/hTrpojDYL+Azjv+L1+UETX9wW4Vn2OHvZOAZdrBesUund5lcbVMCwhTfLbjaphT9Pwj9P9iD3WyutilB4X6vtikh8lBqA4/rWh3TFZV/gdO8ekxMV4YifrB88HRlGMFrMRGGt7MMI/IZRuRDYSldoba+46ttMj22pCvBc9C6EHy1DexCSsAzdum6iZZu41O8BekKIOkynRbBa34ymRaVgDA8rEKdwcMq7FvwsArr2+u6HMiPn/5EOqzvlO7o+sWW5lMC4uBl7Y0Y84HyxjelDmXMB9adqqsih7/fo9pZumnR7WhaVBqP43dapOJfCqZFdyFz3MyndJlf84XNX3hVUwkKgzcFYh2E143AusWO6jeULLKZFuF+A9pB+GobePXMQJQOXj0Dp1P46hmF/07r1GviiPGBhExU3iWG8vbTxnX9H+SbssOyOYYw0lBbV1FT0xita3TrahobQk7zvldnh+E2DuN3IeKbXdaI1ii9h8cQlgK5SpcLwkpQWB4Ig8sN+BjCUkP8+5E/zL+YiL9dLBkvk7qkxsoOTsuw1HF/8NgD/LkqnrNJZ7Yf8D/vUfkXIF6Z+UnMe6h5Qi4h10KNXKljRPC2lEyPMYNYqt+n5j29UT6Zznt6E+UJ2nGNePsL7MOgfmBHjdnwuMaWznsUb0E6Vk66TOc9pUAWmcx7oMzxMjPUJ/x6AuoTXuovAWF4ybuU4MdPfyKd7jVNrke5OPKBMsL625sxHyhvbBMOZMyHOmKUOjIUz3tKUD7pxsABRD7p5j1Fa9J5+p33qPjLwLyna/zZrI2a+dGRpSgMLu1jfYZL+1gH4dI+rFvsqH6jJP6czXZe3G/obBKo46vDJlH5t5ZN0hvxg+Wjs0lUWqrdwqOkcP+QqU2i6rLIaV5HfVA+VHl6a/LpQ5THrH0abqT6TOWoMQpvUSkFYZnaJHAdIRObBMq8JP5suL8KU2My5gv2ZZnaJCVOUhYttUnw6zSoT7jfoY7PycRegfz46U+k0837WssmwfrbhzEfKG889xzAmA+sO3ykPdUntrTf09lYXjbJjmvSefq1SVT8k4BNsguySeA64upq41B/KXsF6zO0V7AOQnsF1i12VL+hZJGpTQLrFr+rVrznEXF7oTAV90BQX9Pjz0VO8/bX2UkN6wXCOoFnmC/UnV5O0o2M0XweFs9fyuSAUhqznQem0kdqXU+Vw+zVRXVh6uoi2E/lxVLLBNtTDhEfr51SayWwTWFbCuoktqVyCSxo46i1QUqeisfVIU/Iox95UnabX3kqGVHy7Iuw+hBYUMY6eUKbUbpcEGZanpBHLM++acqE5UnJH8pJyYj6dKQ/wqJscNje8dq1wm5PxMd9Eow/DfQ5NQNT+esM0mNd6ERgwz5U184KiHIUojCY9p9POrun8q/G2ybQfy9GeZcSeevawyAifimIo+rLz3HvMN3qXH8oQWF+1x90W/p1R91mujah5JTJFcCLPWw1lQdui1jH+hH8QhsQrzMtBzp2Ecqb0hlq/V7FH0zEh7YZ1rESEKbSGt7yHKXWqpWj9KgUhUE9wjoG9QivcVF6pMLgFtUS8Ixduu3QfnXsIo81SpVHJjpWAnCLkI4p2V0OdOzWVtYx2Fe1jo4Fa/+ICqsAYVAm2HHp2K0+xiu/OlYKcG9He0hUe7wL6NgTKG/qs1eod1jH0l3rinUM9gkqbdCOPcbvseD2dtzHUdc8q7BMrxz2q2PwM1a/Oobrmfrcx6+OrQ1wD0M6pnh7BujYWyjv9dPkjXUs3VW1Su5t11OnhrXm9dRUPVN9CRyTsI4NJviFn8ljHXsf6Ni3PnQM5p2pjuH3Jm06tnp07FsfOkZduUm9N4A6po6Wwjr2E9Cx3IGpea+fJu+2fiw1zBYdw/XM1Y/h41op20mnP7or3ilbC86xVNogHf0D5WPCntLpll/9gUcN+dGfEMpH4cL6kU5nX6m01FUEA3zi6vjQjYOUrlNHbVH2PD5eB6ZbyyMfr6P78JUKKv7AeNuU9VEP1nD/4TeWzEPlbXYt2a2g1pKhDPNiqeXWzZeky7TN472scFzAx6/BOsDtzutYvh08rsKA/AzU8J+pPlE8Bun4Dqp/8ftpP97fkGlf57fPgseFZNJnUUff+O2zVFqpM/iKxVKfuDo+dDqmO6KQ0jE4PuMjMmC6QR75wD4Llg33WSr+lj77LHgNlHS5IMx0nwVliPssqs1TR4P4bfNKZrorlDI5ZgRi/nOUaDxA1YN6p7YzuI7nQGTjqffCkOe+mjJS7xrgu2W13l2EeIBp84l0q3NvHH6fUwrCdHv58Tsi2L76oTDYvqBMsKP6NSWnTGx5XM/9UR6wrqTDfVwuwa/EXRm/G60A5avSDI//72boIvX1DeGycGV1VUNZWX11OT6+TTqli50M5F9WXlNZV1MZDleXhRvKwq2ef115RW2dYMJtCP8jjtbOv7y+tsqtjNRU19dV1EfL69Llr670bB9LhsM+XboO8f8lXzlEfIWXh+KPAf3VODRu5BH5/fPeXRMv5PH7DwbhlxtL9cuPNY+fE2seX+VdEGvOowrrBMLgeCNd5/j/UF4QS/GRh+JPi5dd1UlHkEalLyby74jyT+Gb8INjAcbKIfxUfFk/x8Z5VHoLy844xocVb+0RPvTDvCndkXot+9h14spP7ZHJVJe89rRKp67/VONhe8eITCIKvwPijwk/8S4zz2kuJ5V3RyNla2z0Uw8w/wLEqwn9g/kpfrB88HfO+Wbk0yC/rVa6B9tve0I2mI8OiMcCQzxScwLFkwrLBWGKDxnnrLVSeWxniEezbbQxce4AtP/g/uxlyJ5TdQPnZFDv4dgK468AY+vpYNxQuCq96qc6gfAORLj6X9VXOyIu/ja8A5IhJVcYX+lke4+ytkdlVfHPBfPPw7rSmFB+kK92HpgXEHNahQn39enavIrfiYgP25jip8hp3jY7oXSQ93wn1UE/qn5g34l5kA5eed0BxcX/5xM4Xjx0JHCobz/yEa8wT6wP0uG5TA6RD2xTcMzPJ/JnHB/KqbFSORXWHpUXhsGyHxhLxsOOmkeqMsnyxpC9DONhfqi2xmkbKf884I/zzUFx26O4+PwCyGMeA4/FRD7tEW4HDf8hhJNLpCt06PZI/frlN0TwS4012eYDsQ6KpeYD6xmOaY+h/hP24zlE2smxZDiM/xQY0/7P55iG+xJYhoNjST/cZ2M7FrdJvKaLxy4cB47jMP7zxNiF+weIJf1e9GEjUHYfthF+BPJ8BcmTsgGKnOaywTqcj/KC9rEaX7AM3gF8vDnQOy8l10JNGaXfewPpeJAHGA9jUGOnwqDatUpXRPCF2x7uO9pr8qDGMyqPPBSWbf1Q4za0NSgbhgqH4znMB/u1I+Knsz8KPLAp3PYEDtXPd0RhISIM92GwvLAPw7YJNSeDfSPV7rzqTmd7U7z7savaa3in5Af7Ie41SrfKDbt1leWNjeH6iprasnRrlMpfrSuqcv3zC/zyQLmkg+tneP0OrgXmxlLzV2tlcP0OYik+8lD8jiWrfqk1VZW+mMgfrnHhvKj88fodta6ZT8SXdRoqWfVsYu05Ul5dVVNd64YjjZFItKoiXb1Sa3S6tSczc/ZwOETwSa09qfxba+2J6oN0a08dzMjH1fUr1Biq6rIjEYbtKWjTUPNIauyAYxG2NfqVrPotdpqPHcpmDRFhOYQfbDc9SlLLhucM1K/CxX7Y5qbG+hD6n7KlQwA/D8WPlCR5Ly1JxUw37x4ZS40PbS9q3Qbbvir+2iWrfuE3mRjTq1xemBuUJHlZL/5M9R2qDDKeW0KXP+ToZeq3/O08eB1a4iTKf5hHP4fHXBeVCdqheSBemUc86eDcTMULIV5zHPr98W4xmk+FQf0qPOynm3PjvsvMewW3DPc3VLlx/pIKQBl09q5OpyB+AYqv0uc69PxT1SHWqW1LVv3Kut2ihObBcfQ2q06v/bTBrUtW/VLfWnvpteKbsoNVmnTrDNuXpPKfrm/E/Kv4u5QkMXdEfFHjPWXjwzUIPN45TvZtRTduwXkCVc+7ofhwjRnrMhVf6SrUTfidPO7vVPx9Slb9St7nxp+pfgTW6X4ldN6wTvMIXnHeR5YkMQ+MPxc5zXUSz+UztVGgnHeNpfKi4h9Wsuo33X45lbfZ/XJh8ryIFBsqllpu6v0HjJ/p+w+s21CX8lAYrAM8r80j8vE7J4djJ+5HOmnKi/VHUmeARcVXeHko/tiSVb+UPdQZpKHaXK4H5oSSJC/jS1LLD+txdCwZL1ZC5w3Ln0OUR8UvJMoP43dGvKr4k0ocz/J3IsoP+ZoaS8VU8acCTPwer5AoF9XnKv81iPiFRLmKnOZyUWmx7GE8KHsKA9sUKr8Cp7lOSHdMLJVXiIXf8evadmeCV11ddybywXU9s2TVL2UjdPTg04s/2O5xG88jsOC4wr3GUVFWEa6qqqmqq6hrrC6rq231/YXVFY3V0WhtOFpd31AdbtEai6mz/VS81p47mFn3SM4dOgI+dXYmthugfdZREx+va2F8r/VdaJ/B9Qg8d1Dxny5Z9SvjnlOSiqkro3TYRsT7nHAcbEvBtknx7GXXXViy6pfa+0G9Z4R2M7bPVPxLAKafvR+6MSOd7aN7d4T3fsC+F9c5hQ3j5zjpx4EQUU61viadGk8ghmpjhQhnePx/N0uHxzp4DXkhUVZs/9xUkspXEZKpTmZw3M4lMKBM8lB8lS+c6+CydHKa6zpVJ3jfE9arcbHUcBX/jpJVv/L/2+LP1P4SON+6r4TOG9oYnTW8diJ4hW1mSiw1XMW/p2TVr5TXfA9eIT+QV2rupHR2dcydYL+Vh3ii+g8Yv6X9BzV30u21wv1viMhHN8bAeqDiKzysk0+WrPpNtzYUAvhqXCoi8vFaD083TuE9ODCtzPP5klRcuKZB9ftHxFLLq+JXlCYxX/LAVHaAdBNiyTiJd3VO8zpjtGNcLDvKboD84PWyt0pSy5XOHsLr55S9AsdpJRNsr6h8YR+rW393gCyh3kg3PP7rZumoNcoQyttQPVaHUH5KHtAP9+lU3Qzn4Uf7nhLKp5Xs9Sq4Rx6+zxoVay4bzAdeg4YyhuPnpyXJNLjNUP3GiFgyHMb/qiSJ+UX82e9eN4XRziNPbKvjdTPpjkBx4DNlV0N54vaq4n9fsuqXsqvTvZvw2p8H41N7/Ci72uvdjONRHj/vRfy87/ytxEmU38/7TsgXlqmK/yfAxDKl9mTpZKpb14X8UGvj2A5MJ1Ol95hXvzJN2HWlTqL8NR7l9ytTFb8DwPQz/9PJlGPvv1+ZqrPRMa9+Zarir6GRKdWf6WSq4ndZjTKl1qqpPoNaZ8HjJVVmvM4KMTt6YFL9l9fY41WXuj2+Kn4/TV1S5eros1z5TOXKz7BcKn6poXLleJQrJ8NydUxTLmxLq/jrEuWixjC8rkrtAYfjOl7rUvGHEO2Smk+rvFfHfBq2tbxYarl1doB0uO+gxkTYRvH7RmodU/dth05fQsAPv6cIEflAe5Ka+2IdoPY7wDyxDqj4G/vUAWinS5cbS+V5eNzfzcrROgB1GeuA332QuK3A+Hg9RLpiIr6y9SkdwGsR7Yh8/OoA3Fuo1iK43xU1lEVrG8ON1ZW10UY3WhVu9bMoatxIQ1m4trY83FBTXd2YybuqkJMqf2ouAuWYh+LvCnS+EWG202BKt3csFVPF34NoR5hPx/H33oDay4C/VZROtyam0ysT9dkQDocbK8pqqyrqIm5jfV2rn+3SWFlT0Vjplkfqyxoi9TWtnX9tfUWdWx0N19fUVLqVFVXZ6LN0uj6Dsm3xeEBhtdNghTRY6fbWjEBYVL/oZ23M0J75shDKT5XDQeVOfLPhNG9XJtbG0sm1HZIdtRec2huF11ipMZJ670BhhRix8D0ZXn0TtS9BpzfYbh8e/9/NzvnWG+XXWnpD2Zc6vaHGDuqsmp1jyXhefQh1N1RrYem+aTb9Tb9fXVD5FzhGdTOsk2sOIVdqTxS+7wr2R7j+qL6KsrNtwYL9j64/ovaL5qAwKG81R6D2Ux0ZD8N9HLUXGY/Bqh+lxlaIjdfdTy9d9Wv4/YqL7R2Yl+HxvYJ6964ctY8A1ztcA8D1Tq0BUPs4Yb1gl4P+h7KQeV+7VhIXx1OO0pEQCmtPlIP6pgKPAZQNpDtPSveNOtV/j4ml8kzNjalvkCnbtCU2NMwPr5PD9/44PsTD6ybXlq76pdYg8VqMdJNizTExz37btop3I+DhE6BDWA54jAyanW1ozNba2ZTtkYmdLR0ei1pqG5vCMr3XFtvz1Dgo+XqwNJkGtynduyys74+VJjEfiT9TfYTisZOj7xeotSIsf6/3Z7hfSOxx0vQL1LtzyNekGI35DMD08+6cqj/ln+7dOT7vhXofk26e/w92rDmm2bVjt2x1vz/A4yq0HfDYCdsRtk3S2fR47ZjSS9juqHHS7zsKao0xx4M3Kh7G9sobyxrGzWS9QCdDXfl0a2l5abD8rH/p+nWItQvCgunb+8Dyu8bn9f2q4zS3FwztWfM9pw7qnjXdHuViIgyvy+nOzID5UFi5jFh5jFiq3jJps5gP/G5FOmXT5CHcewat+v1nnB6UGicxxwJx8gbR/Em3Ryw1jJpPSb874xjUebSShsf/d7NylTWUvc6HH6mnxkjc9s2cvVBW57ftq/wLHLo9DWfhR3+mM6X71PoA3o8P7YWTYsl4OCyH8Pv/9r4+RrLluqvu9PTOTM/s7uzO87PzheO84IQAUn9N9wwBaZ88+/Y9v7z1vm9/2zPT3esNz+8lb9fEToRoJJOEYPERSAgQCUVRPogUQQIBIiNwECiRLSxCjByEjZXIxpGxkCUH5R8E2Zp3T/evf/O71bd3qmZ6dqekUd+5de6pU6dOnTpVderUQgDX34mI6yci4vrRiLh+MCKuvxER10cj4vp7EXHF5NdHI+KKRZfSs/Miq383Iq6YfTumTPztiLjO9NeZ/kpZx5i8/+GIuGLK/U9GxBWzb89rf4ypo+d1rI3Zjj8SEdeDMA49CHWMSVdMvTqP47Z/5nn7vMhXTH79VERcH4uIK6ZtMq9j2ll/PLk6fjQirpjt+CDM02LKxF+LiGte5f7HI+Ka17WOvx8RV0odbbDKL9An85XiPZBf/7bXflfcYdsi4rp8LxSvdsUdtnFilp1Rec7pPQErP7QGXxN5Rzrf0Ri0+vW9vXZzr7fZ6XRmlQ2DV+ed1f6C8Xo1Da/3lJ9GDfjq0yLkrVBeFfKMRs/7//fGSfrT3CfZ3ivDfyxf9c0PDsdws7TlZTcpa9gf1b6ixVdVfqpP5Xm4r6j8OjLCr+I5HfhFfduYVvwOacT6KV+3DMpX7/E5o/dYLpb37HDyO/ZJY1q4vhVBp+LFguBF6JzttPjd6ixKhWj3aUXQEnF/sl9WN87r+QMfN87uuL/Zv3PjQ3sv3dp/sv+R24++3Lux++qdW7svPdrrvdq/fZslDL0MubbIDQXDcAyvpFHVgj1pZvXwQVyPEa6Qh0/ZqB/KW2+JviuKZo4wKnoF5hdFPUCaV6bQfINoRrpWCFdtCq7vJ1xK8xuu1Sm4niBcKjKkfVcUBRFhcORWUbSLIk8izeen0PzqcJJmpIujcl6YgusO4cLvLxCui1NwfYhw4fcchXO9oByEuQjv10XZCj/z8tIUmv/ScJJmpOsS4bo8BdcPEC78/jLh2piC68OEC7/foO8eKigHYTbg/UOibIWfefm6KTQ/TzQjXfZtmdH0dfA+4uhVeqZh5R/XaDqNr+x99LCgdV3ksbfgw6Kch0U5Clc1Iq6liLiWI+JaiYhrNSKutYi4zkfEdTEirvWIuC5FxGW60HQT2mZX8t/6kVKrbf0abRXWicjrk5hhWPk1d1i+U+hEZWsgf3jFZCMNPb3QeL0h+GNt+TqRx/KIJ4IQfgPqyPKIcluld4888trvusDJOleNOfgOZ9Tf8shk3ZTncBk5QrzKi9zad9qtX9/5yGRd1E0x+C2fsDL4pW8f4/zTOU51MoRPNEfQAT1+YbixrePJcaNrPH29O5ws7w2izpmAr9D/SLcfj++8aYyX4bhM1CNvoDzsN99Aedj3vpHyUO6/ifKOS3ZXI5aDPGI9czFiOcjvDSpnI2I52HbWVhfd4bbjldCyOkudVOf5R5FuefwRXWaRbuHIYAb/R4+McT6ZP6ed3zQ6PD/AxP0f5Vf1f5bnb4A8lsFvhDyeO2JSesN44fXGj79pjJfhuB7Ytq+nvNDJlkR2S6tMX8Dyj+tki1r/Cp1suShoVfqB+6ay1y6KchQuWydYIdwuHj8GJ2hjN8vKxrza2GrMtW+VTq8cC18bLTU2OaIZ16BYpxXZx5yU3rI6HdxC9aYxXoZjerDdWe6R1oh82uT6OkEXjhk/PTxMvwvw4iHgxSy2H/L8YcpD2Wf9jvLENiPKIduMDwl6yvRNn1h/YVstFdQrRjkPgo150RXrkMwd7uMV8S5k+7EtW2T7/fVHdJlFth9HLDH4L4Lt9zGy/dKsU8zWx1F+U9iFZfWG8eIott/DgF+Nmfasbi/gPuQEDsbDawHKVmm0Wo27U/xuY9AbtDa72829RqfV6Qzag25nq90bbLZ3e91+o73bam73u/VBY6vf72629rudwXZvvzOwsoyfC4G6zWAzNfcHjdbm3ZLqnd32Zq/Tavaa3XqvvTloNLYaze32Vqs12G9v9baarUGz29wvYzMlWncrHVXKyj8um0npoZDN9JCglccQn14ZjuE4ryLehcYj1p33issn81Iss2+XSBZa9yoLqfftpu3h3osssH46qizwWB6aGyea/5Tuyzz/ST03npM9hlaonSsBehLtkzeNHrVvptYO/H7bOVds37FMIt04fts7bgdV9rXha7+hG39C7Yy42DdL2cKhPo+42DdL8aNKef8F7MV//8gkjPkLfRpg/gPtx6i12bRzyvJ92sqvuaR9qBHqQ2qe4GV2yYVlB9uuyF+tJupaRpaRpjKyrObMBudl4j8/cm9w6AG7BHCfCcAtCzguiyM2IQ6+KeyzOQ6P939RRFPkBUcvQ7/EGuVhu6xTHtLE0SwXRT1VxODzlIf8YU9l9J0JnWK4QHkoi5coD9t3jfLQX8T8ulbd4Xnq/wSd8ocF+x4+hcai0FiBet7g1Vzfvp23/RGeI6v9UTUP5j6L+yNsj30T5B1l72Qf+g3DWVLtrMYzXOMw3aTkfAPw8tqJkoeQ/LxewON6BcsPyoh9O6976ClkxPK+GfKQJ5ym7dmXkZ+QbigrM/at2mtdLYk3JLshGVN0Y59jGbso6Fb6q8i3BtecsG5Fe8YX8zaYdisb+qT5tAh5EW2qvoqsizysDifrHRoDfJq1z/P+I+pm3n/CNija60ec6EeEp32MDj5p6QhnaB0kUeTU0jY3R05NvQ4y7ewLr4OUjZya0fNRIpQuRMRlsrEi8iLyd4vtTkxsP/o0676d0T3rvh22C9uzyGe2ybFP8fiHfYbt2VT7aVlBvWKUg9+x/C9ELKfMvCNGOeq8mjp/xnPfWW80CM338NQh7ts9+u26zKKI+7xvZ/A3wB90J39OfMJzpj6O8qvmuSzPOH9kGcQ5IrYtJ6U3jBdH2bdjvYFyaXA4Z7U2egba6P3U7ursYsgeVGcWl0U9lZzbtyviu4jysa30vCPeqZvQlQywfKAMsHzgORHWK3jujs+UYlKyY3yaZc76/oL+bWVw/+b5R9Gp+UfB3uZbucrcvK3w+sQ39xj8LdIpiWRG3srFt3iEdDbWT+ns6wX1+yj0zQ9++/Ty1C1VGeWpW7rUuV9uI+sT1ZJ1MPg7Jedg6Afg0+Jwsn5X8vf1oyV5uwmej64OJ+ut5tAIzzpQnVFGncH2edG4gf8jLnXDF8vZOQGP+FjO/gq0kd22o+wujgKi1rCV3cG3P6FsrQDNP039OdG8r6vsYEtqbZr1PPYT1vMcqQXzUA5mvenOeDHrTXcqGojSE6wL1Lit+q3hP4l+i2M491sV8yAUUWhaPzf7WPn3sXxjn1mhPLU/xH3Gp2tUntpHwT6zCmWdG45hY+9j+2S8rgDNi8Mx7Va+ycsy5BncyN5LQ2vdaK3l+PEWwRWgx+qyQPD8XKV3/xRsKKwjtiPWG9vdp1XIM/gKvDMabV3uHOStDmfDtUy4lo6Ay+haF/BL90iXwnWOcK0IXPgOz1f+DPQJFXkIx1Wc9/7zEvNe/LZo3vtJsNv+JdltOMazzg1FkZp13q/WF86L70b8dYfHhIj9sfQtVVZ+zSW1ARpsMyFf1c3HiecYbaNHzaFVO/v96wvucJspvwqcy3HcoNBNuMrnIWQfqPEv9k24WPaqm23+pfox93OE/zT04y8F5l9sS4RiPjk3+7qJ0araZYXylN0asomWA3SFbCJFF9rF7ONco/9DdQjJnZqjnqBduqnsUqw726Wh+aFP3AbnBbyaM64TPPJc9Uuer6k9vVn7Jc7lvlRijQn1LK8xqf6JYzTHCzNaruT/12dMu93+drvTau63Btu7W/UtXvNxwKPVBOV3m/ubu63N7fp+f7O72+lOKx99fDAv9ji5IuoZC/9Wvb3J67CR6W/ZuJ2lwT+KM5GI/3XrbzvDMX6si5Xr+/MaPKM/XdH3KWm/27ZtPksTWzY3Cuj3yWx/m1t43tg6+83+nWd2X+698sHHbvVf6mEPY+6GEs64F4fxa9jdGs9ibWTDWSymRchHeIy8ZvTZ71G01aC72xi0dge7m7u9Xnt/d5q2Mi+uU66tOselrVLyJ2GPlNpK9U7lIWDfoPbyz+jF69NVwH1MmmxzHjSZ9TGvycyTdv8D/f2/eP1DL710a3Cr/+rVD9+6fec26zNeecLnsrpP7Spj/553PWiebietB8+stlLpTA+6YosupUWLui6VRbvhwrqErTbrMy+/cufW4CNvebW/e6ffG+k8R6msRjuz3sprrWb+fMq11t5xaa1U+9aJ1+il1iqKhe/TW4djXr51OElTSLMpv02z6lJqZrPgE/KwVWaPJeUeApbnnN5j4dt9Uu+xlF0PV+u4FcpbHB6uh+VVIQ99sb8Z4Fi2Qj6xTwwn83C90uTd4/8OKOs78+fEo/TeSY7S9g73kdX+bhX4d8AfhKc83MtdHE6WY3vu5j/HuIwO3qN/c/6/2kPnvWcsn/eeJ+gW75gvs+xV51sHB+OsWT9/BvBxX7H+g3aE4fPWkp1rnbSWXrnTd5TU1UH4/0IBERWCW6T/qwK/C5TFOBHOvz8Nhloj//+kDbU/yP853Yba5uBsehlONri9fTjGX3Z6ad/gkhIOXKaQ3wG4M8p7pyjX8t411HT49G7I483b90BelfLeC3m4sZvKkLsrg9uJjbXOhqB/Germ01uGScpuGv6dNPhH+uFqGvyjZfjHcvwuHu664b6WhvaW4X88Df624X8C8GcJ2vatafCP+PNkGvwj2f8ewJ9Cfp5KQ/8I//U08jPC/7Y0/BnJz40k/GmO6H86Cf7OiP5n0uAf9d9n0+AfLd0/lwb/tuF/Pg3+vuF/IQ3+ke35YhL83bZN8n4m71i8KGFlql/nDi/o+GQ22LxdV6ou+mTnTIVrUeBSzmhFwaYsX/06V46HiQ4oj3hYLVlv5ajLPFS4lBNz6HBWCJdq21kXJwx+aUZ4tXi4GIBfmRF/bUb41Rnh12aEP18Sng8PGw6f5vUChgtp6Gmcp/IUL9bTlN0ty4t14kWitmkkru9If6mLYC+I+q4TPNcdYRUun3CB0/TBzf4dv6x5e6EAF7YHlsnw/GzpXAGeCtGrvmXbn9dCle7E90sF75cL3q8UvK8VvF8teL9W8J4PmlraGU7+f53+f2IYhr+a/7/uDqeM/vh9qv/dMZYVg1aTSfWcBWBCQXoSr1+W1pn2rlZQnytx6BnptArRw/zhsVfZtXwwwidbp8pEXhmbVwXbiYErJl0xcT2VgK6Y8yxlRxtcyuBXPln7Jw6ktKmcNKxsP27ddJN1x32/Cn3rny9CPsJ3sjHO783fhQJuJXay2SqrmzgoYDUNPcGggGqOx8Et8FsO2uYTroNyXkW8WwjgeiwirutzSldMXE8loCvkgHSv+kcdTA+tS8waiIjXINScfzlAH37PQcaL9NePUJnT9BceIkb4L7oxzh+jOip9UdbW2BlO4lL7u0x7Ea63EK7Q+s+5KbiuES51UDMkz4jrccKlnA1DMoH85eByRYfip+Hy6epwEpc6fJ54f7hrNNWm1JsDkanLFJQzWhaN1rFT5XIS/J39FapPZPxddXCb7Y21JO3cKB0Yw8o/rou5yh5UVwEO7Vt1KJ1lUK13nhflrIs83uM7Ci7eD7tXXKofHIWuZyPR5dMzEXHdiIjrxYi4XoiIK1Ydle6aF5mIyfuYMhGzb8ek6/mIuGLKasx2NPkyW9dgP5//pnRux4tl0E7j8biWqOyMyjP+Oapv6IIkPmCBeUfxB97e7vc3m4PdRn2z1Wn12yEb8V6DlCK88fp8Gl631YEPDFbv0yLk1SivCnl4ZPwXskn6E9lupfiv7CGE53WOsm152Wlbw/iD/dY/hy7RCl3axQGwuc9jHvaToqBz/tnmKBjAK7SOoOqo5js8l1W+ACoIqFpHWCFc09YHliEf4b+a//r6282rs9Y5xfoI41oU9fKJgxwa/NfzX///r2aTOBXfcY1iZ+gK68p8r03BxWsbav5ruFan4OK1DfyeA7+vTcHFaxv4/RrhOh/Ahf3xovie51YXptB1dTiJC7+/QOUUBZE8wD0c5+EFLj4tQl7MtXkvJ7+Wjeng+uJ4kDl9UanyKzB45YeAOKwvrAt485dV/LlwgvypzsgftadQlj87Qyf5g3183uRnOcAf1ZdCAROnydtbiD/oB4MXeDB/lk+QPyH5mabnmT+Kn4jjGvEH/YlqAf7Mq/yEAnsq/kwLWv448UeNT/ez/IT4g+Ok4s9agD8PivzY2K/4Y3xRe34YcL5Ftp7ae0L7cWfoJuqr5iS4H8f2s23Iexo+VVB2WdvV4L8bcLLtqva/Loj6hGyk4wrobbimBbFmmmfdZwvZ26F9tmn9m+1tNQ9Q82mEQxhl+2N+0TzDueTrSnWTf7ShLFke+sjyfP2yO8y3TOCq0P9YJ1//T4P+YTimB3mEtJXRNTvD135VPykzL0NcLHNF4x7j4rZNsw5U3h/+ftnDqx0LX2fvM8hPTqpfYHi1hYUxXobjMlH+uF8onisbN7QukHjddWa+sk8NxqFA/c9J8RzXaWsz8FzpIstD+TPaZr3EIKPn0fqz07YX2xYGfxtsiy9Q/U7gwrPurDanWosK2ZxqTeC84JNaE+A4DycwZ+nOOmcpe2FIiJ+IY2foJvij9OwJzlkkf5YC/FmeUt8ycxbEwWsmZee8J9m/qjPyZ9Y5L+K4FuDPHKzZSv6cC/BH9a/Q5SnT5I3XTNQcQPHnmC4QSa5/Qvzxz7xmgvxhG1D5jaozCjvDyfqo9QA8QzDv8b1+Pkdw0vG97P3ScJxfIVoP6M+fR7YWwlPeyvBw/a2cew289ys5gnkOvPdL+UcpLnPZ3+zs7bc3d+v9hv+3Oa1dFZ9QF/lkvMa2OCfqViX4X8/Gdf446JkDWFGeh/tkAC4r+D3AId4tDiffqTZC2TV4K7smaLQ8vDAQ9aRPa/n/yC/EZXRUCf43SXZR3ux7dWEhXgDJZanyWXbVZYmrAt63zydIH2HdY68jHJRJ+PEd0/bJhP2qv9fe7u5t72/We/XtxnZrWr/COCuZmxzvnNNrxri2huPcOaf9PgwfrzH/Tl6up+H3FzROHIeuDg/jZJrxPY75doarSvCfBRq+BHNR5sOobxLuyPJUOkDxaDwR/EixTlY2FovyZWI7CG3Vx4ZjOM4rs+afGpeyN2fV76F9CvYrQ5sLz2J9uaCPoq8Vfmt9lOX9qzDWfQX0uOF1ROOqC+sFrC/b1XgpnYJnvWDwXwvoBXXhLNJ1dahxfh1w8n7WtDNY9zpfUHtJfBZJ6Ss11zK4xHOtduq1jNB+LcrHOsEjH1U/4j26afG3doZuoo5KLrHfqXGyIsrIRBmh84nT+lFF4C4qm3mNsMo3tcgOsHwcgxHeJ9OPVcL7mRzI8+7CwiSM4dsAmHUac5F/Fj9TjSloT/12/o+KWez/ruT/14+U2n019sfD39lS8Xrj4e+20p5B7O4a/pU0+JuJzziO+LOahv5NtRcYD3+zp/bEItI/ks8LafjfVDHZItJfV3G/IuLv8L6gleGTlY3zsXjjdns/o/Kc0/MGK79GtEa2I0bzhstED/OH5w0bgtZ1kcc6fkOUsyHKWRd5fMbsKLhejIjr2Yi4bkTCpca/o9D1dES6liLSFYtfMesYky5lB8yDrCr7YV76dkyZeD4irjP9daa/UtYxJu9rEemKJff+eTUiXTH79jz2x9g6el7H2pjt+ExEXA/COPQg1DEWXbH16ryO27xuMi/yFVOv8trNUeh6LiJdMedW82pjnvXHk6vjvI7bD8I8LaZM8Nrw/Sj3vD49L3Z0zPnQekS6Uupog8X9XvP18cliTvAe5qdpzzCNP0+7p/bQMzdZ9nKisjMqzzm9J8Bnl5Aeo7sm8o7ip7bXGLT69b29dnOvt9npdDLCb7TyuzL+BGp/Ie3Z1fae8tlg3/lFyAtdzI5nUTlO10oi+svwH8tfF/Acp6tsW1qcLrQx+WwvyrDFBFdnJcwvAf0ClI9HRvjRDwf9lj63MKYVv0MasX6h8+yVgvf4nNF7LBfL47s/2T+NaeH6VgSdihcLghdl4pxhPzV8Kfxd24PubmfQrW82e+1+szf1fED08jd3u/u73UZju93otxubx13+bre/3e60mvutwfbuVn1rWvmD/PmU33/eRb2fgP775v7zJ4Zj/FwXn5R+tW+8rv4GN37+VvjGJ77fGPOeFOVa3vcMNR0+4X0PfP85ji/sK4l38fKZPrT9lygP5508JuOaLY/laNPyGVRcd+Hzl2i/crwdtN9HZ4/y/1PcC7hVb+8qn5uIctjbEPRfhLr59JZhkrLvuzvcU+g4n66lwd9OfI97z/xW35/jU2cpTS8l1rf9jMpzTs+17F3NpR1fMirP6GH+2LPXRX8if77Zv3PjQ3sv3dp/sv+R24++3Lux++qdW7svPdrrvdq/fZstVtbgnI+JYRiO4cvWYmf42q86ycBW/7TTTaGbYPjU0bTIXo8RLuXtr2YOCIcwKsIV5iv83B7nptB8jWhWZSa+YWzTaF0O0Irl3+uNNljvq1RvdWrDvlOnErit1KwZ888V0Orcyd6csyDoKnNzTiJat4zW1RlpVVEwEtO6bbSuzUirinBUof8ZDmFURALMXxVlH5Os7RpPzs/IExXBOTGto1WwCzPSqiJEJ6Z132i9OCOtyhKv0P8MhzDL4nvMvyDK5jEoRLNPHBlclalWmnhWq8ZutcoVivzP0f1xjFmhPNSPRVH3UF5UVLnQanzoRo01ysP+Y22y6uY/kkg///+kI4mYNXy6V8raZytlU5L1553hGH/ZlTL7xvdR62P+GXWUT1cBd0Z5j4lyU9b5rkxsJr4ZubnhivWvzdrfkP9fEbDYF/Ckt2oXJ95lAg/zFtvxSv7baLUadxcWuo1Bb9Da7G439xqdVqczuLvL0Nlq9wab7d1et99o77aa2/1ufdDY6ve7m639bmew3dvvDLiuC4G6hU7kTttFmXcd/i35/yetw9+UP5/p8GBqJdaxzcT6RurwkO2ndLhaPTS9PU2/ow433CnHxS24UTZRmzU2XLHONR3+TW6ckM8cFQDxcESSh/Nfvx6yUYDvnJuuKysF39kO1orA4SLyK+RlgHSEds9Pg27/1vz/k9btb8yfT7lu3z3T7eF0HLrdPMb882XA55PS7ZaHO2e8y827XpiHu/IY2cfsXfzuSv5//QgJx4tEa/btDUG/lWXjhelAvzbx+vz57m7T3X2mF3ZfutXbvXPrlZef6X//h/q373DwtQr9z/nsAGVFIxynjP7njcOM/l8QcJjKOEaFHK+UuR9yUDsNw4Uto5z0cIFmAOadTQUmUiuxOm+lVHM+qeGiaNvVJ1Pv+Gw03euQooL5GW6cPvjnUZBfp3XHFXd0vpjcpJqO+LThik10U/9m3q/B88uv3Lk1+Mj1D7300q3BrX7v+it3+o4Sq/4itYzV4u84GdxpUKG2UnamQo+O/2w1ZXo6W02JL9NlVlN49cPyy6x+ZAV4z3RbOd1mGadbt3X3Trd52Dw28xBn7iHz0OD4G+xnjwPM4wUwTwDMEwUwbwWYtxbAPAkwTxbA4PnH7ymAeQpgniqAuQ4w1wtg3gYwbyuAuQEwNwpgngaYpwtgngGYZwpgngWYZwtgngOY5wpgngeY5wtgXgCYFwpgXgSYFwtg3g4wby+AeQfAvKMA5p0A884CmHcBzLsKYN4NMO8ugHkPwLynAOa9APPeApj3Acz7CmDeDzDvL4DZBZjdApg9gNkrgNkHmP0CmB7A9Apg+gDTL4AZAMygAOYmwNwsgPkAwHwAYCoAcwtgbhHMcU090+j0ZqPMfQ1pVj2bpe81tfKP676GkHe4T7xajeeWM8pbHB6uhzq3bO3rbdkdgGPZ4vkDzhFMftUSismtx/82KOs5N0k7flOh8p077AmSoi226p3dtHL/2h2lB3UcTuI3/vm0CHl8nq5M2/n0gwB3PB5KY96l6SeNRshDyWRlaehGabSmBO+Mfyd1h9j1/P95vkPsWv6Mc9FE5/0aac/7NeqJz/u10573a9dtneF3rc1cSv1Ur6v4DDwuLyUpu9EoOy5zfJNEu6Ojcbns3Z1pTw806hnhR3pU/Bfl4c4x4UZ3rQEuhF+GOiI8Ptv3+K6X/6o7YTiWhjpphe9QN72X6qZi9JSRI8S77g7zhuNwqDuM1Log32H0Q0D79xJO1Y5oB/Ga6grgYnjEVyX4l/Nfn/8/nMZZVK8inLeBlu/Pn6fFdvmI0/XPXJinZeu/UEDrD7hx/X+vgFakB2mdFmvmLwfgqgIuI1orTtv6Nl6F9PG9yrm6kydtrKLX7shD/aDqzeX7v1WoQ8Ud1kEMr2QK8XPM6NFau9O6lO9TMvi/mf96Xv5oAQ3OHZZrn9CWKpLrMn3wY/kv9mvVxijXRrc6pRU6KezTlfy3frTUSCtrzYaKG5bFo390J02aO4fqW8q1CHXJT1C5dmqsrA43+H8EOH8qf1an8dmeUC5Pq+7wyTjnjq6r8JQd2w0X4BvVz0yHGvw6lFshHAre5mioGzDGIo83Bv+z+a/n+xfzZ3XCD9v055wuG9t0TdDKZf9rwPmL+XPodK46Dcs24gVBC/J5ZzhJi8H/cv7r+fDl/Fmtf+BJYZ8WIS/m/MLT8RWgg9u/Opysd+ikrHOH4xquC3g8ncuyjbLEd9JjG3B81tBJdZ9sfFH91b5VemQ9UF+WH/93CXApeMNXJfh/k/8qe/QSfKP63GIBzt8AWv6dm6w/tkEN4P5TQdlY/4qoj8FfFvVH+EtEq8H/R1dc/3VRf7zva4VwGvxvAc4vF9CJ9VI6196rWK+XRb0uusN8sW8V7w0Oea9wnCd6rLya0zKxSrRiHsfICvXtS4LWUFtfEuVwW38m/1U22vkCOovow37PfXxN4MJxZd59Sj6f/3/SPiX3W6zJ5tZWZ7u5d3dHr7c/6LVbx11+p91pbG3tbu139gfb7f294y5/f7Ozt3+3Eer9xgE7ppWv1uXRVvHJ1vZx7R/h0S5E+P9tsHf/vpY/874Olufh/n8ALiv4PcAh3i0OJ9+pPQHcKzF4K7s2PEyj5a1CHtpRPq3l/yO/EJfRUSX4/5v/P3K9hm/s+3VR/jKVP0G3eMd7JasCflXA+/b5P4Yv/8W6x16LPiiT8OM7ps1kx8v1d+UITrevXGf/dPvKNZrH5SuHvmghX7ki/7UKwBT5ryFMkf8awhT5ryFMkf8awhT5ryFMkf8awhT5ryFMkf8awhT5ryFMkf8awhT5ryFMkf8awhT5ryFMkf8awhT5ryFMkf8awhT5r/n8xH5Mx+LPgX3MQV3S+jGV3y990PyYmgDHshXyYzL5VX5MJrce/1+Asq66SdoRX2iundYXZ3M/8Tgm/Zi4XReHk2VjHrbdIvCzSfxJc3ZkzJ8U/Pf8CZ0d4XmEc9r+Nh6dlK/Sn8//n2dfpc38+Rh8lU57bPJWWl+lsa/VtTT0p45N3jf8T6TAf3f5wXy5cE5fZDuUGdt94j0FjnaN5VQjloP2FI9pafzDxj4EGNlZ7Xfy/hXOedUeP8Ozvcb4V46nvof8vXAf8pygX+2rOxdXP3mcifbVt6pUX/Or8HV9gcrENX9uI59QB/m/NWojhmF/r/NQNvMcv60S/LvyX1+HajaJU/mQYYTsxwinwb8XcC5nmk7nwvamvVdRknEfwuhREdUv0HehvUGFm+9DUXh474fruQDvagK3ySjv31zJ/68fMRk+9A3IRJm4Z47wLxFdl4mnIZ75v0uiXFzTrlG5l6hcL0OrJENG26rT+gX351VfuZL/Xz9aajMfMSId8uEc5Rt8yCdR6XsP94NUF5wrqz185sWFJLxoHpIz5IWSD5azD+e/B+f2s2JenBO8CM3Lj8NH4xLRi3q3SjQp/ad8s2fVf+vucPsuU57yCUWdxeUoPwyWuyIfQMPHY8MP57+etu/IJumriu/RX/GiKIe/wfXi0Dir1lrQv+ljhBf3yNS4ZTY+3wH7NcD5t/LnlGsFdbjNwuqj/M2sTKQn0S0CdZaZIt/VipvkocH/lJtsC7y9ouIOy0GF4FdFuSjP7Be3SuXiGFQRZeA8JbEvaj00N0rcjtsZlWf8wHdYfs3ptrkSh57R+q3yX0b+8HxvNQ09W952WXeT8uETzs+xbZAOXCtmvYTj/8/Ce+4zSi/Z2lKV4H8RcP58/qx8adFflstcKCiT5zK8vu4Tx7DA5yVRJ5Qz7q8G/8v5r5p3lJUR1hkIr3SVuhWK/aynnZvZGeqyy56bMfh/kf/i2Mo4qwX1KdKB/wpwMk+VX2eIp8r2WRP1UjcW8TxrGk/5zAL6kZbhqcH/Wzeu/3cU1L8sTw3+NwBnmflxiKfT7MPQjUc8F5jG06tDTWtZnhr8b7lx/ZmnSp+FeGrwnwKcx81TrDOvORSt26HexPOh6rtaAOdqAU6lv0I316m2VDqN2/K/5r+qLVW9VkvWay1SvdZmrJfB//dE9aoU1KsyY71Wp9SLbWmD/z1RLzWG8bo89mU1b+W1QIP/EpRn/VLN13FN2KfF4WRdruTv60dKer6Oeq86nKx3yA7wiXXHtJvxjGfrTss55mEbcPsrecng3c7QTdQxE+WgPanm1kU3kRbZmiwDBv+H+e80GUA73afF4STNV/L39SMlLQM4HrAMKP+Q0PihxlFeb/Fp3RWPEUoGeK1jmu/GztBN1BFlAPekba1j3n3uF3ME95vP/Un7vM/qc37f+dxvdwbbrdZeo7Xd6283Oifpc/+6HIHvl68nXVkV5Xm4NwfgsoLfAxzi3eJw8t28+9w/AjaMT/Poc//NpLew7rHXww7KJPz4jmkz2ZmHs0T/MH8+3T7/m73j8vnP0uCvpw7jbzbO1eEYv7JN8KYc//w6Nwk/zf7hdd9KkvZOfdNlYyuV7+r3EX/S+K6O+ZOC/54/Id/VUx0PDnzwfijQVlm8+tSVL3lGZSeS89L7S1Z+zaWUq/H+0iLRw/xhPZPo7MahfV2kpyr4w/4I3HY431TrOoh3geDx2b7Hd38y/w3FcMoozzm9toT2yhupbql8UStUTiVCOSwfPl3Jf+tHSs067ztiOcovhft0Gp/Q5lmMxDB/TlWMxD+X/6oYidynZ4mR2Ka6oV131D6NdIXihaWwnxPFHd1imXQurj3DbRtT3pVPdkz61Von+qrtwHvMU2vaPD4i/BOA81r+PM1/Qvko87iyWlAe6nPe03kKaHlH/uz3FWwv8mb/zjO7L/de+eBjt/ov9TIqkT2VipK13BrBX8l/60dM56lWWIaVjbuwJzFKjVa5iNZUo5TauUb+8Ch1IQ1/6ujZhKPkzvAwb5gOjhSGGpm9V5X3AEq16kELlMdtgrxbE2VnbrLnj2bNBd9xRCuDf1/+6+n+qwCP/EBaQl6/oUhuSI+KhneR8pT1r1YUcHT0aRHyYs7yPH8+CnRgfXyqDid5oXiH8LPyzvrzOsEjH9WMAMvk9mN5Ys/rivguE3jUKhZHziozsvlkOwqG9+AX3lUBr0/HfVrXvPfn+bSundA4Dbfc5T/33e7oPEXE+lGDvfv3Y/nztN25fxCAywp+D3CId4vDyXfzvjv3k/n/87w7Z6cy5nF3zmTn/tkd67TPdsfC6Wx3bJbUGJztjoX5c7Y7dj/sjjXrZWwELP8B2x0bZIQf6TnbHZvd1jzbHTvbHTN6imTubHfsbHds1pR4d2xwtjtWTP/Z7thr6Wx3rHw62x2bwp+z3TGAPdsdO5osne2OTdJytjv2WjrbHctpyvGf7Y69ls52x8ZpcTj57mx37LX0IOyO/dkcweneHWsf29mxRKvCzbSr4Pq+GKwLr+6ifrBv1EqK3RNzEH/SjZ8fBnw+4V0xPP9KtEOUOPZ/vTFPO0QuHu766Y5PP44ffw3wp+BPovj0dRWfPiL9Ddv928vx+TmI7YDcXdV54uVe/8P93nO7N2/eevnms/39V/t3Hr39bP/u61d5EZU3SnBjh5OxiXFk9P9CAIdzekENNz/KhHpMtEjbLmNyYfnHFeqxbCgW492SoFVdWVy08YflLIlyFK6FiLi4vbE9ruS/9dlSi1+kDhvKmzKYLK8m6pwJeJ7yId3+9wOAl+G4TGynGuWhPKxSHva5NcrDtjtPeawf1K9z5TZu8LuFgnrFKAd5xKZVqs1lDoV6LmI52HbWVir8GYdamrUPV0U5arPchl5P15WCMlUYVJ/MrGHngre5Mc635M9pnS/qXZZ/TBxmDeVXbdiyPKNuYBlUodXK6g28gu2HAS/DcT3UMrxafhxNrd3hNno6//U0vw++QZxGN9LqU5nN5LKhavlqmHkbA1Q7s3zg9gPLBy79s17BZW/kCadpY84/BrwMZ0m1s9IpWBYvbVcEvag35n0J9mb+/0kvweKUITRmJp52l7axR0t67vCYnMLGrhA9zB/uf8oxjMd1n3aGYzjOq4h3C8eM6+ScO+ubZWVhXp07ea6K37JN5NPOcAzHeaEx77Tgsu99CoXfVHORkHOl2YvKBrdlItZxF11x2xhdeDWHc4frabjZ8QZDh/I4GnMpiXU6lpXYtu2oeYglNe/jdlfhy5Xdy+2u7N5M0DDNtv1vgJfhLCkZySgv5FbC7e6TmqtWKU85ICq3gKKwuD7h8iLidE67k5hdpRzSiuyEkLsI23NqLusT9yGD/7n8N7ENLvvQcqB+lUD9FF+vDnX9PpH/eth/UqI8JVMsi6pPWR72KW4j5fwbqoPB/7P8l0NH+3T8YczrbU/HQ0AH0npA/3Cy3iqMOcLznPIoYcxZh6gxVPVHlrNzAh7xsZx9PP/1vPmubJI+lPka0Y51D7kmse5C2VoBmn83f068Rn9say48LqEczDouGS9mHZfYLQzz1Nq70hMn796n+y2uiXC/xT5aEfDcb6f1c7Mf193htmT5xj6zQnlYLo/Nag0jdKUB9pmi+XlV1MF/9znAh+2I+h2/Zf1u8F8HWr6QPyubiOVL6SWmxTmt90JzhzJr4Ilt7tJz0nk4nKTmZIntqdH1r2r9VbWzdxO/4A63GdI30j/wvbkXlLHRlR0e0oXHYaNj2dMOenAbq37M/Rzh/yj/9fl2jWxo/pIRfc6F2zDU5shfozW05q7aJaPnWqAcRVdI/yu60AbgoyU1+j9Uh5DcKXv8BMfgTTUGY915DA7Zwj5xG6hjKco+Xid45Lnql2ybYrmhoyKhfol2q/WX0PiFepb3J1T/xDH6fnZ9fkM2ru83gmwdwIryPNyfCsBlBb8HOMS7xeHku3l3fX4z6Gaf5tH1+Y35R/Po+myyMw/Xdrw+fz7lrtedM9frcLJxZGc4id+5w2M7jl34jdpvvZrnLTs4buXG+/Ps+5ai3Xk8jcm3DUE/rzNfyv/3dsKb8+dbL++/2v9g/+U7j37f9004sR44tponq6PEO9kZ/T/NK/U0HOYyp/yT9iT4g/yf0635NgfHpflS8iehZh1pvrcPx/hDO7YoL/YNh2v7TvjGp3cA7ozy3inKtbx3DTUdPr0b8njm9R7Iq1LeeyGPw4KkWG26K4PbiVdrOhuC/mWom0+JDrk0+ZBLKv1wNQ3+Dh90cfFw19Uhl9i6x6dEh1za6pBLlqBt35oG/4g/T6bBP5J9PDiXQn6eSkP/CP/1YRL5GeF/Wxr+jOTnRhL+NEf0P50Ef2dE/zNp8I/677Np8G8a/ufS4N82/M+nwd83/C+kwT+yPV9Mgr/bthnWz8BqG9pKVqb6dU6vtpkNNm9emBedXgFAvs7qKRua4cc4AVRzSVctRjyslqy32mVjHs7qFaq8SEK4VNsa/LkZ4ZdmhFc7YYsB+JUZ8ddmhF+dEX5tRvjzJeH51Ijh8MnmLhgsKeb8oUyfwvJrRGvsPnWeylO8WE9TdrcsL9aJF4nappG4viP9dYnqy+1r5a8TPNcdYRUun0zmfV8yfXCzf+f6K3f6txcKcGF7YJkMz8+WzhXgqRC96lu2/auUr3Qnvl8qeL9c8H6l4H2t4P1qwfu1gvfsEWdpZzj5/3X6/4lhGP5q/v+6O5wy+uP3qf53x1hWDFpNJtVzFoAJnQJPvH5ZWmeOdlAL6nMlDj3Bk2ZII4+9ZU+a2TpVJvLK2LyYdz0irph0xcT1VAK6Ys6zlB1tcCmjK/hk7Z/6BKDaGbWy/bh1k+qOXvAV+tY/X4R8hO9kY5zfm787wUgzW2V10/0QacYnDiB2r9FhfHosIq7rc0pXTFxPJaArdZQS9thU6xKznpjiNYjQ9QqKPvyeI2AU6a8foTKn6S/0AEb4L7oxzh+jOip9UdbW2BlO4lL7u0x7ES4+YRha/5kW4Pga4VJeliF5RlyPEy4VDSckE8hfGweV7C3PgMunq8NJXMpzPPH+cNdoqk2pN5+YRN+MGtGaER+uRKF17LG0nAR/Z19dQxERf1d5XbO9sZaknRulT7VY+cd1mUFZL3MV2YYvEcA8lkG13nlelLMu8niP7yi4nouES/WDo9D1bCS6fHomIq4bEXG9GBHXCxFxxaqj0l3zIhMxeR9TJmL27Zh0PR8RV0xZjdmOJl9m6xrs5/PflB7Qd4egDp8Wd+7weFxLVHZG5Rn/HNWXI3QiPUZ3TeQdxR94e7vf32wOdhv1zVan1W+HbMR7jaaA8Gkvcmq01ak7jGDq0yLk1SivCnnoqf8L2ST9iWy3UvxX9hDC8zpH2ba87LStYfzBfuufq5QXuoIU5zscLZT7POZhPyk6Me6fbY6Cp29D6wiqjmq+w3NZ5QugohWodYQVwjVtfWAZ8hH+q/mvr38rm6S9bJ1TrI8wrkVRL59MPqsEbxEK/P+/mk3iVHxXUc1UXZnvtSm4eG1DzX8N1+oUXLy2gd+vEq61Kbh4bQO/XyNc5wO4sD9eFN/z3OrCFLquDidx4fcXqJyiCBAHuIfjPINLfFJ6y8vJr2VjOri+OB5kLny5mE9FvgMIjzisL6wLePOXVfzBk2PHzZ/qjPwJRfadxp+doZP8wT4+b/KzHOCP6kuhaAfT5I2jz6AfzEqAP8snyJ+Q/EzT88wfxU/EcY34g/5EtQB/5lV+QlE5FH+mRVfiaElqfLqf5SfEHxwnFX/WAvx5UOTHxn7FH+OL2vPDyFgtsvXU3hPajztDN1FfNSfB/Ti2n21D3tPwqYKyy9quBv/dgJNtV7X/dUHUJ2QjHVc0LsM1LQIV0zzrPlvI3g7ts03r32xvq3mAmk8jHMIo2x/zi+YZziVfVxpdmI02lCXLQx9Znq9fdof5lglcFfof6+Tr/2nQPwzH9CCPkLYyumZn+Nqv6idl5mWIi2WuaNxjXNy2adaByvvD3y97eLVj4evsfQb5yUn1C6Pb94uFhTFehuMyUf64XyieKxs3tC6QeN11Zr6yTw3GoZj1phJcp63NwHOliywP5c9omzUCYUbPo/Vnp20vti0M/jbYFl+g+p1AZOburDanWosK2ZxqTeC84JNaE+A4DycwZ+nOOmcpG+0zxE/EsTN0E/xRevYE5yySP0sB/ixPqW+ZOQvi4DWTsnPek+xf1Rn5M+ucF3FcC/BnDtZsJX/OBfij+lco8uk0eeM1EzUHUPw5puifyfVPiD/+mddMkD9sAyq/UXVGYWc4WR+1HoBnCOY9vtfP5whOOr6XvV8ajvMrROsB/fnzyNZCeMpbGR6uv5VjkSsxmibiMjqqBP8rOQIV4dS+Xxfln6PyJ+gW71DWGVdFvDN4L3u/lH+UImLlPEWC/fVsXOePg545gBXlebhPBuCygt8DHOLd4nDynWqjeYoE+5sku/MYCfYTpI+w7rHXEQ7KJPz4jmn7ZMJ+1d9rb3f3tvc36736dmO7VeZmRYuzkrnJ8c45vWaMa2s4zp1z2u/D8PEa8+/k5Xoafn9B48Rx6OrwME6mueg2NDvDVSX4zwINX4K5KPNh1DcJd2R5Kn3D5Gg8EfxIsU5WNhaL8mViOwht1ceGYzjOK7PmnxqXsjdn1e+hfQr2K0ObC89ifbmgj6KvFX5rfZTl/asw1n0F9LjhdUTjqgvrBawv29UYUV7Bs14w+K8F9IK6LQbpujrUOL8OOHk/a9oZrHudL6i9JD6LpPSVmmsZ3HHcdpRyLWPaLRwmH+sEj3xU/Yj36KbF39oZuok6KrnEfqfGyYooIxNlhM4nTutHFYG7qGzmNcIq39QiO8DycQxGeJ9MP1YJ72dyoIPbKRYmYQzfBsCs05iL/LP4mWpMQXvqt/N/VMxi/3cl/79+pNTuq7E/Hv7OlorXGw9/t5X2DGJ31/CvpMHfTHzGccSf1TT0b6q9wHj4mz21JxaR/pF8XkjD/6aKyRaR/rqK+xURf4f3Ba0Mn6xsnI/FG7fb+xmV55yeN1j5NaI1sh0xmjdcJnqYPzxv2BC0ros81vEbopwNUc66yOMzZkfB9WJEXM9GxHUjEi41/h2Frqcj0rUUka5Y/IpZx5h0KTtgHmRV2Q/z0rdjysTzEXGd6a8z/ZWyjjF5X4tIVyy598+rEemK2bfnsT/G1tHzOtbGbMdnIuJ6EMahB6GOseiKrVfnddzmdZN5ka+YepXXbo5C13MR6Yo5t5pXG/OsP55cHed13H4Q5mkxZYLXhu9Huef16Xmxo2POh9Yj0pVSRxss7vear49PFnOC9zA/TXuGafx52j21h565ybKXE5WdUXnO6T0BPruE9BjdNZF3FD+1vcag1a/v7bWbe73NTqeTEX6jld+V8SdQ+wtpz66295TPBvvOL0Iex/qoQh6eReU4XSuJ6C/Dfyx/XcBznK6ybWlxutDG5LO9KMMWE1ydlTC/BPQLUD4eGeFHPxz0W/rcwphW/A5pxPqFzrNXCt7jc0bvsVwsj+/+ZP80poXrWxF0Kl4sCF6UiXOG/dTwpfB3bQ+6u51Bt77Z7LX7zd7U8wHRy9/c7e7vdhuN7Xaj325sHnf5u93+drvTau63Btu7W/WtaeVb/7Xf1wF8zP1fw/9QGvx1vv8J64LlrhAPXEQaDJ/JftUdTguUZ7B8djOLT1/DUaqIsiyZjfUQvDN+XiJaE/k+j+6lTXRvyUgml9LgbymZnPCdzH9VO7Au5X4amdbdTNBXoTKZRoRZdIfTAv2/SO8rJWCVbOL5O6aPv2N7kN/xeU8n4A0XxqtUuPC+C4Tnc7Wp2nBD0MS0W14au3d8V3iiOB1Sz+N5X76nT80HmTf8/wL9hmCzAF4lU4bT2grptXr8MbfvxzpFy0EA",
      "debug_symbols": "7L3Bji29jp35Lndcg6AoUqRfpQdGtV02CihUGXa5JwW/e+9gBLmUmTeVyr33aaCB3wOf7/51zloRsUWGQqKk//jbf/2n//t///f//M//+t/+7X/97T/9X//xt//7f/7zv/zLP//3//wv//Zf/vHf//nf/vXxX//jb8f5/1GTv/0n+ofHn3r/Oe4/7f7Trz/5uP+k+892/8n3n/3+89bjW49vPb71+Nbrt16/9fqt12+9fuv1W6/fev3W67dev/Xk1pNbT249ufXk1pNbT249ufXk1pNbT289vfX01tNbT289vfX01tNbT289vfXGrTduvXHrjVtv3Hrj1hu33rj1xq03bj279ezWs1vPbj279ezWs1vPHnrt/NPuP/3604/7T7r/bPefDz05/3zojfNPuf/U+89x/2n3nx5/tuO4/6T7z3b/yfef/f7zvL52giaMBEvwG+hIoISWwAk9IZUplSmVKZUplVsqt1RuqdxSuaVyS+WWyi2VWyq3VOZU5lTmVI7YkRN6giRowkiwBL8hQiiAElpCKvdU7qncU7mnck/lnsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKI5VHKo9UHqk8Unmk8kjlkcojlUcqWypbKlsqWypbKlsqWypbKlsqWyp7KnsqeyqfcUd2Qk+QBE0YCZbgF/AZfhdQQkvghJ4gCZpwZol2giX4DWcMXkAJLYETeoIkaEIqUypTKrdUPmOwyQktgRN6giRowkiwBL/hjMELUplTmVOZU/mMweYnaMJIsAS/4YzBCyihJXBCT0jlnso9lXsq91SWVJZUllSWVJZUllSWVJZUllSWVNZU1lTWVNZU1lTWVNZU1lTWVNZUHqk8Unmk8kjlkcojlUcqj1QeqTxS2VLZUtlS2VLZUtlS2VLZUtlS2VLZU9lT2VPZU9lT2VPZU9lT2VPZb+V+HAmU0BI4oSdIgiaMBEtIZUplSmVKZUplSmVKZUplSmVKZUrllsotlVsqt1RuqdxSuaVyS+WWyi2VOZU5lTmVOZU5lTMGe8ZgzxjsZwwyneA3nDF4ASW0BE7oCZKgCSMhlXsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKo9UHqk8Unmk8kjlkcojlUcqj1QeqWypbKlsqWypbKlsqWypbKls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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdBZgUx9bdsCywFliSEAgEiUISoKqnZ6Y7CXF3d5uZno4rcSXu7u7u7u7u7u5CXMlfN+l99A497EKfO+/W/7beV29mm03tPVdO3VPdOztD3b/jgznr6mYc8e/7Gcysj157mDm84lr7a/x9Q8L3NSdca0241jfhWlvCtQFmLlZxbVjC9w1PuDYi4docCdfmja7FxwzR62LRa0blXLecd8o6owvK8YteVrnZYs7Tns562cDxMpmy53p5v+jnla/dTFmHWT8Tqn9Ha/3ktVSq4ZQ47ZwRZqdSnHb2nX47ncoLZFt/M3vGbKV4TYrej6yb/H7G2PW+0fv2/66f+brNzP5mzlQ/+Xr76FHhA5Vu6HmB/pwZF3cdry1ad3jMRz3qphwzgP0yQx1PDtdh7fST1oYXyiw44skkFcossYKg0ZVCGWC+ntXMgWYOigqF5qyxdTgTZACQ5OL2zlbPaPB/FgcmR8+6ybu6TU7vFbNzcOSXIdHr7NHr0Oh1WPQ6vLKVGVI/ZStA39ynwhE9wE4H0pMeasl2PQK4vXDaOcf025mtvJDEliNirDg49n5I7P0cFWw5p/l6LjPnNnOehLaivsIHKt3QswNjNWc9LjbzMuU62n9AotNzAf03ErzrVeb2vPGWOfZ+7tj7eSpye5T5ej4z5zdzgf9CJzAM4N9y+M8ox+0dXc9oMC2O2pTajR8NTNoxwKTl8iHZiNo82n04xpLNeCzOTpfTTjX9dmYqLyQR1tgYMdFsfz8qdl1VEJY2XztmZsx06zuu152juNhncXYmytZsLMbDY+/1VGKfM1/nzfTM9GtwvjMzkEcXZDrfWTB2vmPhph3G7V2Ic9NeCL9phwsBg7qwBZv2wnhCDBcGEyL6tGBUtBGg/Ehr5erxZDUKmD/jmJVKtY1/3FTIfxHz9aJkl5mLM2/80vN8WjbURabi0yXM10uauZSZS8fUX4+62mwkg4E+aY3ZuUy0kSwbvS4XvS4fva4Qva4Yva4Uva4cva4Sva4ava4Wva4eva5ReZS5XP2Ud2dXTLi2SsK11eundDa6m1sT5ugMq+JYa/rtDCovJBXJmrFiWCb2ftnY+7UqimRt8/U6Zq5r5nr1/Md/ywE3m7WBm8L6TMoF7b/lgf5bB+i/DSzx3wpA/60L9N+GzBvo+jEO2CD2fsPY+/UquGEj8/XGZm5i5qY14IYVgbHZCBibzSzJ7ZWA/tsY6L+CJf5bGei/TYD+KzJzw2YxDijE3hdj7zet4IaS+Tows2xmWANuWAUYmxIwNptbkturAv0XAP23hSX+Ww3ovzLQf1syc8PmMQ7YIvZ+y9j7sIIbtjJfb23mNmZuWwNuWB0Ym62AsdmOOTbbxWKwdez9NrH321bEZnvz9Q5m7mjmTgmxQWve8TgfhEk+GB/Dun3s/Rr11Q+GdjZf72LmrmbuFjsYqq+rzcHQzsC86BGzc/eosPaoPMChf5hQcW2P6Fp8oAtzZ2Ax7d71tUqdrKX3AAYgfqpYbXT1Z3Vmdx1jUu4OJqv2sWdlMu6ZcCJYmXjIZOnEVt3Jv6s9gUm8Vz0sGVTcp3t1oZjT2r4H0A9In+49DT7t7GfFfbp3jDT7xPwZ96lKN/Skqa/nlEKdyZbzWZUruNkgl3ECJ68CNxtqY7Dju8Y1Ycn1As/JhE7eKU3C2vdPjrUTW/tG0r6r7hG938e87mvmfnEHMeQf8uRzH2D+TQBvJrV6zmECE+HvX89o8P71+HUPACYDF+4DYsUFWneqcjmtH5DH7PsC43OgpcV6IFOxHlTPaPBBDMV6sPBiJdwH17hYVbrRYTdU6QaUTA8BJ31jFO9DYl3MvvUdf6mw/fmF5WPXV0j4nkPN62FmHh593b72PlXW3i+2dmffc4R5PdLMo+p5avOAKEfRZz1Hg89y0fZx4T4GWD91sYF+2G8/YG0eC8aMfmCQ6hMZF6rJoxly57h6nj0CnTsrAnPneOG5s3ykZlHrUa0cx5A7J4BzhyNn9gHnzQkMPSXyQc2kexTVnsVbrr76PYoTzdcnmXmymafUT/uvLqb19YkxnziFbFB28+Ugo1TBnDMV8+Y8qlDQbj7nmOOnnBdmS2FJ50qBp3WuXMwVlV9UoZNzM6WCU/Tj9p5az2gwLV6ZxGmNPxVIBKcxixeED09LKLC0PjwNrLrpo6F61HVeBCrd0Ccybc51WDtV/Cbu6VGBnRG9nhm9nhWLKzxxgAHu8PtfZ8ZUUyWrnh5jzzNi78+cCquebb4+x8xzzTyvfsrPDUJhaC8kpH/Prsfv0MAE12czFQs6V8+H2ZnJJuVOWvvoV2mAv6L0z6/eLVGPz/FxwPy+QPjJAdXfWQw+PAvowwuZu9jzY7x6Qez9hVPh24vM1xebeYmZl9bz/07zgkB/Xsa0p9G6wyMf9arreF+5LuZvpF8uEl5f9GujFzAouwtqtCepdEMvyGEnJVjvun+7Ze4EG8Dk6Dqwne2FyOmLwQy+QNs4xAIbZ7ekeEdZYudlzDUK380vA+7mlzPt5pdHu/nUApfW9itgtmud1NldUT/tH7J6pfn6KjOvNvOa6TifVOmGvhLc7baPa+sZDb42tvUsBkoOcvrAutqch81cJ3qX/8+jvHFfXBf5/Pr2im1/pX94p+La9QnVXM/oxOkMvtP+QPh1QIa83pI7kUjMNyRgnt4143l0Q5Rbtbxjcx0YS/u4sZ7R4BuncqgyvevfCNzqbxJ+x4Z8eNNUhPP0rn8T861llW7o6yPcyDjfhDzgiz4QEZk/N4Nbnnayujl2IFX5iw7tA91JzFDHs9lIbjM57URu3vFPqL8lSoZbo9fbotfbo9c7otc7o9e7ote7K7utW6Iki1+7NeHabQnXbq+ffBew/dodCd93Z8L33ZXwfXcndHm9wQG5bVoDMpXfQ7t92taa6m+03TH9iTLFundO71oJFt6VPoH/s+rdQNK9h/muyj0xjX1L7P2t9dXvqtxrvr7PzPvNfKCe/3e4H8SdP+TjdqKbgiuBcX8IF/fETwh+sD75QyIfmkrcHzZfP2Lmo2Y+FjtzaayrjfznUohoOx8G2hn/WzCPR5vbE9Hrk9HrU9Hr09H+MzL6/mfM18+a+ZyZz5v5gpkvmvmSmS+b+YqZr5r5mpmvm/mGmW+a+ZaZb5OCNPNdM98z830zPzDzQzM/MvNjMz8x81MzPzPzczO/MPNLM78y82szvzHzWzO/M3Oimd+b+YOZP5r5U+UG/XSsC6zVId4TYHJtHz/XMxr8cz1+3V+YZaZKN/7B/Uv9ZAeD1q3pr9A9yZRsv9YzGvwrQ7L9JjzZCPdvlifbU0zJ9ns9o8G/MyTbH8KTjXD/wZBsHLb+EhUGur//s97OInuaqcj+qmc0+C+GIpskvMgI9yRLiozI4E+GIvu7RuIpdfx7TredbuWFJOH7REzgPhl7/3TsPf0HceE7g3nTw8x6M3v25P9AQeDurWfoiYtNQ08s4VXGpqHn5Bj0iL2vj73vWRGbXuZNbzP7mNnYs/pfrkiLnfjjb4a6bML5VBP2QXW1uYPyOBOf1EHtdDy+tZUzQ8y37YcuzSYILWa2mjmjmX3N7Gdmm5n9zZzJzJnNnMXMAWbOauZAMweZOZuZg80cYubsZg41c5iZw80cYeYcZs5p5lxmzm3mPGbOa+ZIM0eZOZ+Z85u5gJmjzRxj5lgzqSui5HB61nU8dCFjK+9YtCRca024NmPCtb4J1/olXGtLuNY/4dpMCddmTrg2S8K1AQnXZk24NjDh2qCEa7MlXBuccG1IwrXZE64NTbg2LOHa8IRrIxKuzZFwbc6Ea3MlXJs74do8CdfmTbg2MuHaqIRr8yVcmz/h2gIJ10YnXBuTcG1swjWVcE0nXHN6TibJ9jEqel0selXpRgfSTLtxNAM29vY/n9SCWytoxa3lz4hbS/eFrVXW/WBrlXQbbC1P94etpfRMqLXKSs+MWquk9CyotTylB6DWMrU9K2itsllrIGitkllrEGgtz6w1G2gt4sLBmLXKtNYQzFolWmt2zFoerTUUs9Y/e8cwyFrlf9YaDlmr9M9aIyBref+sNQdkrX/32jkRa5X/XWsuxFqlf9eaG7GW9+9a8yDWinqTeQFrRX8mTo8ErFWM1hoFWCsfrTVf+rX+8+z7/OnX0u1rLZB6LS9sX2t0+rWK7WuNSb/Wfz48fmzqtfL/WUulXiv7n7V06rX0f9ZycIc5rL/DgNAO7WtlcJj/+TQ19EEVHRA29cQf3LngWKOfRqOnf5qBsaE4uwx+zFrgR2SONzP5MQf04z/ncXUVfwK55+RD+FzPrv2WZt688cz0zVywJ9+flaan3FoYfPrs7Lw3C9PaR5jzDLifm51nH+sJjnseuI8tBKxxYN5oW2LxLPBsc+GePDUsqS6SOHahGK8u3EWOHWfeLGLmouQzRo6lp4hbGbjmeeEcS5jHMeB+wZK6HgesxcWBHAvMG21LLJ4DcuwSPXlqWFJdJHHs4jFeXaKLHLukebOUmUubuQwjx9JvaczIwDUvCudYwrwkA+6XLKnrJYG1uCyQY4F5o22JxfNAjl2uJ08NS6qLJI5dNsary3WRY5c3b1Ywc0UzV2LkWPotuL4MXPOycI4lzMsz4H7FkrpeHliLKwM5Fpg32pZYvADk2FV68tSwpLpI4tiVY7y6Shc5dlXzZjUzVzdzDUaOpd8y7sfANa8K51jCvCoD7tcsqetVgbW4JpBjgXmjbYnFi0COXasnTw1Lqoskjl0zxqtrdZFj1zZv1jFzXTPXY+RY+hSHNgaueV04xxLmtRlwv2FJXa8NrMX1gRwLzBttSyxeAnLsBj15alhSXSRx7PoxXt2gixy7oXmzkZkbm7kJI8fSp+T0Z+CaN4VzLGHekAH3W5bU9YbAWtwUyLHAvNG2xOJlIMdu1pOnhiXVRRLHbhrj1c26yLEF86ZoZsnMgJFj6VPIZmLgmreFcyxhLjDgfseSui4Aa7EM5Fhg3mhbYvEKkGPDnjw1LKkukji2HOPVsIscu7l5s4WZW5q5FSPH0qc8zszANe8K51jCvDkD7vcsqevNgbW4NZBjgXmjbYnFq0CO3aYnTw1Lqoskjt06xqvbdJFjtzVvtjNzezN3YORY+hTdWRi45n3hHEuYt2XA/YEldb0tsBZ3BHIsMG+0LbF4DcixO/XkqWFJdZHEsTvGeHWnLnLsePNmZzN3MXNXRo6lTykfwMA1HwrnWMI8ngH3R5bU9XhgLe4G5Fhg3mhbYvE6kGN378lTw5LqIoljd4vx6u5d5Ng9zJs9zdzLzL0ZOZb+CsSsDFzzsXCOJcx7MOD+xJK63gNYi/sAORaYN9qWWLwB5Nh9e/LUsKS6SOLYfWK8um8XOXY/82aCmfubeQAjx9Jf2RnIwDWfCudYwrwfA+7PLKnr/YC1eCCQY4F5o22JxZtAjj2oJ08NS6qLJI49MMarB3WRYw82bw4x81AzD2PkWPorZoMYuOZz4RxLmA9mwP2FJXV9MLAWDwdyLDBvtC2xeAvIsUf05KlhSXWRxLGHx3j1iC5y7JHmzVFmHm3mMYwcS38lcjYGrvlSOMcS5iMZcH9lSV0fCazFY4EcC8wbbUss3gZy7HE9eWpYUl0kceyxMV49rosce7x5c4KZJ5p5EiPH0l/hHczANV8L51jCfDwD7m8sqevjgbV4MpBjgXmjbYnFO0COPaUnTw1Lqoskjj05xqundJFjTzVvTjPzdDPPYORY+ivnQxi45lvhHEuYT2XA/Z0ldX0qsBbPBHIsMG+0LbF4F8ixZ/XkqWFJdZHEsWfGePWsLnLs2ebNOWaea+Z5jBz7Xv3kv4MXXzetTycK51jCfDYD7u8tqeuzgbV4PpBjgXmjbYnFe0COvaAnTw1Lqoskjj0/xqsXdJFjLzRvLjLzYjMvYeTY9+sn/13R+LppffqDcI4lzBcy4P7Rkrq+EFiLlwI5Fpg32pZYvA/k2Mt68tSwpLpI4thLY7x6WRc59nLz5gozrzTzKkaO/aB+8t9pjq+b1qc/CedYwnw5A+6fLanry4G1eDWQY4F5o22JxQdAjr2mJ08NS6qLJI69Osar13SRY681b64z83ozb2Dk2A/Nzx3OwDW/COdYwnwtA+5fLanra4G1eCOQY4F5o22JxYdAjr2pJ08NS6qLJI69McarN3WRY282b24x81Yzb2Pk2I/Mzx3BwDW/CedYwnwzA+7fLanrm4G1eDuQY4F5o22JxUdAjr2jJ08NS6qLJI69Pcard3SRY+80b+4y824z72Hk2I/Nz52DgWv+EM6xhPlOBtx/WlLXdwJr8V4gxwLzRtsSi4+BHHtfT54allQXSRx7b4xX7+six95v3jxg5oNmPsTIsZ+YnzsnA9f8JZxjCfP9DLgnWVLX9wNr8WEgxwLzRtsSi0+AHPtIT54allQXSRz7cIxXH+kixz5q3jxm5uNmPsHIsZ+anzsXA9f8LZxjCfOjDLjrhtpR148Ca/FJIMcC80bbEotPgRz7VE+eGpZUF0kc+2SMV5/qIsc+bd48Y+azZj7HyLGfmZ87NwPXzDBUNscS5qcZcPewpK6fBtbi80COBeaNtiUWnwE59oWePDUsqS6SOPb5GK++0EWOfdG8ecnMl818hZFjPzc/dx4GrqkXzrGE+UUG3D0tqesXgbX4KpBjgXmjbYnF50COfa0nTw1Lqoskjn01xquvdZFjXzdv3jDzTTPfYuTYL8zPnZeBaxqEcyxhfp0Bdy9L6vp1YC2+DeRYYN5oW2LxBZBj3+nJU8OS6iKJY9+O8eo7XeTYd82b98x838wPGDn2S/NzRzJwTW/hHEuY32XA3ceSun4XWIsfAjkWmDfallh8CeTYj3ry1LCkukji2A9jvPpRFzn2Y/PmEzM/NfMzRo79yvzcUQxc0yicYwnzxwy4myyp64+Btfg5kGOBeaNticVXQI79oidPDUuqiySO/TzGq190kWO/NG++MvNrM79h5Nivzc+dj4FrmoVzLGH+kgF3iy29E7AWvwVyLDBvtC2x+BrIsd/15KlhSXWRxLHfxnj1uy5y7ETz5nszfzDzR0aO/cb83PkZuKZVOMcS5okMuGe0pK4nAmvxJyDHAvNG2xKLb4Ac+3NPnhqWVBdJHPtTjFd/7iLH/mLe/Grmb2b+zsix35qfuwAD1/QVzrGE+RcG3P0sqetfgLX4B5BjgXmjbYnFt0CO/bMnTw1Lqoskjv0jxqt/dpFj/6LvM/NvutDAx7HfmZ87moFr2oRzLGH+iwF3f0vq+i9gLc7QgLMLmDfallh8B+TYHg08NSypLpI4lnKwnUt7NHSNY+uJV81sMLMXI8dOND93DAPXzCScYwkz+Ri97syW1HU9sBZ7AzkWmDfallhMBHJsnwaeGpZUF0kc2zvGq326yLGN5vuazGw2s4WRY783P3csA8fOIpxjCXMjA8cOsKSuG4G12ArkWGDeaFti8T2QY2ds4KlhSXWRxLGtcV7tIsf2Nd/Xz8w2M/szcuwP5ucqBo6dVTjHEua+DBw70JK67ovsd4AcC8wbbUssfgBy7MwNPDUsqS6SOHamGK/O3EWOncV83wAzZzVzICPH/mh+rmbg2EHCOZYwz8LAsbNZUtezAGtxEJBjgXmjbYnFj0COna2Bp4Yl1UUSxw6K8epsXeTYweb7hpg5u5lDGTn2J/NzHQaOHSycYwnzYAaOHWJJXQ8G1uIwIMcC80bbEoufgBw7vIGnhiXVRRLHDovx6vAucuwI831zmDmnmXPFOLZ99ADHuV8dzp8jGnhyux6M+WFgbj8BXGtuoP8ob2atm7yXxAd6v0baHbd3ngZGg+dpwK87L5DouHDP2zDZwaB1/0m2prrJ5MSZbPHiVSkHp51P1PMUxchY3uI/zQXYNZFt9ZGN7Ub3jF3jThRkAOKJPSoqoPkIE0cARjIw00jw1syFuwcj7tS/WsPsQ5VuaErM+Rnk4wLg7b2dAGjdCdG6aF/Mx+SL0Uy+GD0VX6T+aAMmXwz97x6nlDqxjy0Hhg2VzQO08c3PwKXAeGukD6mpoJnUfdZNow86y6n4mhz8jfJJvMEaM7WOUaUben4mQowbPY02685+Dtk8hoEYhgs525uWRib1820NMglm+FCevBwb26inNz6d+RwZHxVbS2cypjaCvA6DMJPN+05R5zK5XOiG+ZznBmHWLQT5snYLGccv51WovXI5n82U8rnQD0q5ME7aOshk3MAvlnTWyRWKygsyBRW6+YyjCkEmHwQZL5crZDJBzgs933OcQpjxVDaf91XOyfgOV3xUFJ9aKs2HmZSmjpSmYwuBc9mnGcg6w7RxZRhVDfnCYfCFy+QLl1HVcOXFHMJVDVcOzClc1TzMpGqA8dZzdquayqE1k6rJ2qhqssyqJstADHP9D6qaXINMgpmLqWvOWaZq8kBVMydQ1XDFJx9TNdU2BcnHUZx2cm0wno0bjMe8wXgMG8zcTBtMA9hOJIH5wLWQx2bIzWpuJjL0u7BZpfXpgg24TaHDsZmgzYorPgv+PzqCWygikYWTHvZQ6Yau9tAD8ime1H97BNgJcwS+3Yf1lvgw7VrjhMeDCmYcQ5OwCFPDtAjjce3CTL5YlMkXizIe13LlxUjhx7VcOTDKguPacRwP9AEb1FHdx7WV4x/+Rvkk3vgtxqmmxzER4mKMavofmxmIYT5LjmvHAZuixRtkEsx8TApr8Roc1yLjswTwuHYUUAFzxWeJ/4IC5vp1hyUjBbyULQTOZd+SDGS9NNPGtTSjqiFfLMXgi2WYfLEMo6rhyosFhKsarhwYbcGj9RyqBhhvPbpb1VQOvSSTqlnWRlWzLLOqWZaBGMb8D6qa5RpkEswYpq55OctUzfJAVTMaqGq44rP8f+EhlIUaeOrelg1mBRs3mBWYN5gVGDaYsZY8hIIksBWR9ziHytysxjKR4Yo1eAhlJeBDKKOGytysuOKzUkJ80M8IAB860U8BP0dqZSCv1/JzpFZm2kRXaWA0eJUG/LqrAomZC/eqDZMdDFq3pp8j9ZQlnyOFfLItXhSrNTB+jtSqQOkaZ/V2o/8/PFq4elRAazQwfI4UBWA1BmZajflGDQp3D0bcaW1cU/jNLkrMNRkk1lpMcnMtxptdazD5Ym0mX6zNeLOLKy8c4Te7uHIgY8EjfGsycCkw3jrTfbOrcvzD3yifxBusdTjPItdkIsR1GM8iyeZ1GIjBteRm15rApmjdBpkE4zKdT61bg5tdyPisB7zZlQGeH3LFZ73/wiN8TzEpzfUjpbmBLQTOZd/6DGS9IdPGtSGjqiFfbMDgi42YfLERo6rhyouccFXDlQN54armKSZVA4y3znermsqh12dSNRvbqGo2ZlY1GzMQg/c/qGo2aZBJMB5T17yJZapmU6CqyQNVDVd8Nv0vPMK3egNP3duywWxm4wazGfMGsxnDBuNb8ggfksAKwLWQx2bIzcpnIsNCDR7hKwIf4csMlblZccWn+P/oCK4UkUiQ9LCHSjd0tYcekE/xpF0L+OAIy+cWtfsQ/Ywolw/TrlUWHg8qmDJDkxAyNUwh43FtwOSLzZl8sTnjcS1XXiws/LiWKwfGWXBcW2Y4rgXGW4/rPq6tHP/wN8on8cZvC041XWYixC0Y1TTZvAUDMSxiyXFtGdgUbdkgk2AWYVJYW9bguBYZn62Ax7XjgAqYKz5b/RcUMNevO2wdKeBtbCFwLvu2ZiDrbZk2rm0ZVQ35YhsGX2zH5IvtGFUNV14sJlzVcOXA4hY8Ws+haoDx1ot3q5rKobdmUjXb26hqtmdWNdszEMMS/4OqZocGmQSzBFPXvINlqmZHoKpZHKhquOKz43/hIZRSA0/d27LB7GTjBrMT8wazE8MGs6QlD6EgCWw8cC3ksRlys1qSiQzH1+AhlJ2BD6GMGypzs+KKz86MJyB/mB8yqR7PQbswn4IhuGeXhGctVLqB3If0LkBO21V4POgzBXdl2At3Az9jgn6+iU5hkDY+Ea1Xh81rlhOoJyNb0THfHZjrtfzsud2ZGu89GhgN3qMBv+6eQOLjwr3n/3iR7cWkZtEEi8ylvYVvJveaWCNtpBjvXaM8T4v99vp/axJ9OwOZP/tYujHdwfT5j/s2MBq8L8PGtJ/wjYlw72fJxkQFuw/DxjRB+PMXFJ8JDES1DzA39xeuFu+0gOwPsJTs72Ii+wMbGA0+kIHsDxJO9oT7IEvIngr2AAayP1g42VN8DmYgqgOAuXmIcB/eUm+P2r7VIltvs8hWam72Z+CPQ4XnPsXnUAbcewrHTfx2CAPuwyyI92H/g/G+m4mLqHEeWJf8fA96T74e+Odz7k7fhP/n8ZME6LC14349PIrfEQ1RgrTfvz48Suj4Nfqm4RVGTesDcp0ZyRWQ6VzLaX86+HBg83ZEAzZROBr/wxkI7UjhJxTXR7jRzxcgcxqZh0cBbzvEeeKoGE9wEDbSB3dH66Gfnbq+HrvRotZC+u5o4Frx/Dk6lj8ct5wOZxD3twNr/BgLTnI5fHgn0IfHgn3IgfVwIP/SwSJhRj/vi9y77mTiREl76nGWPGKBxHw8+BELdD9LMTmeoZ89gen3F06I9r8kIYzmIcqD24F1SXsX3dFGfx7a7f9/671dy3X4DdQ6TJwTRf+J0SZxUqXoPzFB9J80lWZMpRv/PPpwDENhriz817hvZxLY78/Js/mgxZENxZx2rQ+YYgFq8P5zsHUiEPNJwEYAWMMaWBcaENf/EH5XNnhEfaDFadIGr9INfTvTIYdKNzSioQ+jUZcwQLnUYYM/OSKJUyo3+JMTNvhTEk710SRzMpBkTmngaRSQm6+EzSOedOgGhtTUiQwNzKmWqGdkPp8mXD1TTE5jOO07FejD04XfKiespzPUyxkAH5Yjnqjl86pngE9O2seZDYwGn8nwvOpZwp9XJdxnNUx2MGhdFluPj2xFF9nZwm/HtONGE/TxwNw8R/jtmNvBt2PaT7b+V45BzwU3MeiGjeN225ENPMfxKMznCa85UtZAbtXEMecy8P/5QD/a+mzjbRY+23hB1LdcWHkKckHCKciFlj3beBvw2cYLgKRzYQM2UdBNIhHseQwksZbwW07UzJ3PgHttIR+M2smA1t5FwE0LmDd6beE5SDxzEUMOXsz0HMbFjM8hEn9fwPCs8W312Hih8F7C9KzoJZbt25f+j3BH+0ALOWROXib85J1y5TIGvryciS8vn8pza9XyQaUb+jZhtVnrW71XRCLnykqRc0WCyLmyBmTJFZC0IucKIHFcCUyUaSkWASq+fehLcUKvZg8+XhUVy9WVxXJVQrFc3YVikRqQtMVyFbBYrgYnCnqXpR32CoZd9hpLnmVAxvpa4R0VxeRahmP7a4A+vE74swyE9TqGerne0mcZrmd6luGGBkaDb2B4luFG4c8yEO4bGyY7GLQui62XRbaii+wm4c8ytONGE/RlwNy8uUYbu0o3oErsFnBto7FS8wvMbU0xvoWh/m5lyh348TTMTscl2/rXTRZP9DWtPylmd/v7Gesnv+8bvW//726n3zww804z72qY/HfAarXR38600d/dwGjw3QkbXtrkIKc319nn9F4xO++J/HJv9Hpf9Hp/9PpA9Ppg5VHBvdGxQPwafXOfCkegZdoMQKfeD87kyuoeEavie2KVfm/s/RwV1f2Q+beHzXzEzEcbJl9vH+gbZfcBd4uHgLvjY0w7BPz3tYD+exjov8eZc/uxWA4/Hnv/SOz9ow0dc/sJ8/WTZj5l5tP/hZ3rAZy0LsftfaaB0eBnGnAk2m78M8CkfVa43CUfPgtsYdt9+CxzgY2NbR40298/ESswVbF5PGf+7XkzXzDzxYaO63X7tK4uG/PpgzE/PjcVn75k/u1lM18x89WEDRkt4S4HytXXgHUeb/Rei93htpC8w7i9r3OS9+t48g5fBwb1DQvI+w080YRvgLtLtMp5IiJYlB9prZcYzhOfAObPm/+lDfXNqZD/W+bf3jbzHTPfZd5Qpef5tGyob03Fp++Zf3vfzA/M/LCh49+xr8VGcg/QJ60xOz+KNpKPo9dPotdPo9fPotfPo9cvotcvo9evotevo9dvotdvo9fvKo9gPmmY8mmNzxOufZVw7dvYtcqgrhkL6kexQH4ce79WRVAnmn/73swfzPyxBscWnwDJcSKQxH6y5NjiU6D/vgf672dL/PcZ0H8/AP33CzPh/xTjgJ9j73+Jvf+x4tjnV/P1b2b+buYfNeCGz4Gx+RUYmz8tye0vgP77Dei/vyzx35dA//0O9N8kZm74M8YBf8XeT4q9/6OCG/6mpsbckJrBzB69+LnhK2Bs/gbGpr6XHbn9NdB/db2A92It8d83yBM5oP8aevFyA+V3Owf0jL1viL3v0asjN/QyX/c2s4+ZjTXghm+BsekFjE0Tc2yaYjHoHXvfJ/a+sSI2zebrFjNbzZwxik3S2uNjWrI5tt53Uzkg6Gu+r5+ZbWb27zX5gKBdu1YO9AFBX6C/e8TsnCl68GLmXnUdxTj9w4SKazNH1+IDnfB9gUk6U9fXKnWylp4ZGID46VK10dWf1ZnddYxJOROYBNrHLJXJSBdm6CTxkMnSia26MzCzAJN4QC9YMnT4jdABXSjmtLbPDPQD0qezToNPO/tZcZ/OGiPNPjF/xn2q0g09aerrOaVQZ7LlfFblCm42yGWcwMmrwM2G2hjs+K5xTVhyvcBzMqGTd0qTsPb9k2PtxNa+kbTvqjNH7wea10FmzhZ/7I8h/5AnigOB+TcYvJnU6n73YCbCH9KL0eAhvfDrzg5MBi7cs8eKC7TuVGVoWj8gj68HAeMz1NJiHcpUrMN6MRo8jKFYhwsvVsI9vMbFqtKNDruhSjegZDoCnPSNUbxHxLqYQb06/lJM+z3rT2PnB581TPk9c5j/bk4z54pyvH3tgVXWnq3X5LU7+565zes8Zs7bi6c2Z49yFPUwSHu8RoLPSNH2ceEeBayfuthAP/Q1G7A25wNjRj84RvWJjAvV5EiG3Jmf6b4COnc+B96LWkB47hD3zwa0kWplfobcGQ3OHY6cQSptypvRDD3lPcz3ras94/bJVO5RjDE4x5pJv0ype1V/MDT1X8UxP/f0enwNnQ78LQNHeF9BPjyDwYdnAH2YscCHZzL48EygD13m+6ROTAtkYu/dXtV5Imv+LWdm3kyvV+f3sNP6YAxwX8wC9wbf0oMdH5xT7WPBXowGL8iwCS8k/GCHcC/EcLBDyUbPqPWo40+2MeBNoHIgfdI+Fo58Pi56XSR6XTSWg/DdaCEgy8XvKS7Sq/pvRSwcY/lxsfeLTIX9FzP/triZS5i5ZIz90bvomCj5of7thVccyN1pMfCOUu3DZzk6qbR2R7/dVbMPjF0qKuqlKx8WWarXlL9aRN80vMIodJtzGvDPviwFLJyle2GDy7GLL8Vw1LEUs3xR6YY1uNsHinj//T3QQJ8GlFnLwDBnaL+sW9fM1aL1SGKRtCJJdaH5R/pZdEune3Zttg9w/WQpf6iGUDwe/X5yCZGX7WshG6BlcXWd7RHleOUAra+YYq6X7SXfxuXQNnIolYUZNp7iUPkb7nK98M9CLAws8uWBagQZD2bC0FzFaANhLM9NGCrdsGGnLSJ32hVwAcnZutOuYEHhrGjDTjuOYacNLNhpV2TYaccBi3wl4E4bdO+0VhDGSt07beq1CsiddmVcQPK27rQrW1A4q9iw0y7CsNOGFuy0qzDstIsAi3xV4E4bdu+0VhDGqt07beq1fOROuxouIJ6tO+1qFhTO6jbstIsy7LRbWLDTrs6w0y4KLPI1gDvtFt07rRWEsUb3Tpt6LQ+5066JC4hv6067pgWFs5bwwvlnx1mrF/7BG2Syrw188MbWXcKGZF8baaOtrDRjvXwb1+kOlNIjLAjUukyPWcKF1Xo4Qx1bE2o9Cyh6/e7KVzprQeVv0B0opcdaEKgNbaHojbof7dUbWUDRG9uSUJt0P8GmN7EgoTa1JaE2635QQ29mQUIVbEmoYvf9SF20IKFKtiRU0H3srgMLEqpsS0KFOEMLtiZUaEFCbW5LQm2BM7Roa0JtYUFCbWlLQm2FM7Rka0JtZUFCbW1LQm2DMzSwNaG2sSChtrUlobbDGVq2NaG2syChtu++paH0eAtuaexgS+XvCDNUK1sTakcLKn+n7spX+goLKn+8LZW/M67yrX3eZGcLKn8XWxJqV1xCZWxNqF0tSKjdbEmo3XEJ5dqaULtbkFB72JJQe+ISytrnd/a0IKH2siWh9sYllLXP7+xtQULt062elH7QAvW0ry2Vvx+u8q19LmY/Cyp/gi0JtT8uoax9LmZ/CxLqAFsS6kBcQln7XMyBFiTUQbYk1MG4hLL2uZiDLUioQ2xJqENxCWXtczGHWpBQh9mSUIfjEsra52IOtyChjrAloY7EJZS1z8UcaUFCHWVLQh2NS6jQ1oQ62oKEOsaWhDoWZqhj7fM7x1qQUMfZklDH4xJK25pQx1uQUCfYklAn4hLK2ueMTrQgoU7qvkem9CwW3CM7uTtQSt/WIN/GU2yh6FNxFG3tczGnWkDRp9mSUKfjEsra52JOtyChzrAloc7EJZS1n2tzpgUJdZYtCXU2LqGsfX7nbAsS6hxbEupcXEJZ+/zOuRYk1Hm2JNT5uISy9vmd8y1IqAtsSagLcQll7fM7F1qQUBd1n+8o3WrBQdzFtlT+JbjKt/a5mEssqPxLbUmoy3AJZe1zMZdZkFCX25JQV+ASytrnYq6wIKGutCWhrrLnD16xBesqCxLqalsS6hpcQln7XMw1FiTUtbYk1HW4hLL2uZjrLEio621JqBtwCWXt5+/cYEFC3dh9vqP0mhac79zUHShzBG9BoG62haJvwVG0tc/F3GIBRd9qS0Ldhksoa5+Luc2ChLrdloS6A5dQ1j4Xc4cFCXWnLQl1Fy6hrH0u5i4LEupuWxLqHlxCWftczD0WJNS9tiTUfbiEsva5mPssSKj7bUmoB3AJZe3n2jxgQUI9aEtCPYRLKGuf33nIgoR62JaEegSXUNY+v/OIBQn1qC0J9Rguoax9fucxCxLqcVsS6gmYoa61z+88YUFCPWlLQj2FSyhrn995yoKEetqWhHoGl1DWPr/zjAUJ9awtCfUcLqGsfX7nOQsS6nlbEuoFXEJZ+/ezXrAgoV60JaFewiWUtZ8T9JIFCfWyLQn1Ci6hrH0e6hULEupVWxLqNVxCWfs81GsWJNTrtiTUG7iEsvZ5qDcsSKg3bUmot3AJZe3zUG9ZkFBv25JQ7+ASytrnod6xIKHetSWh3sMllLXPQ71nQUK9b0tCfYBLKGufh/rAgoT60JaE+giXUNY+D/WRBQn1sS0J9Qkuoax9HuoTCxLqU1sS6jNcQln7PNRnFiTU52gbe4AT6Y2Guro3cX/rQtN67zVMaadKN3TcxrSYvwAHBf4hovV1dQv1wpPGNkN52K0nGP+ivXCYv8TFWm+B859GxoLypH8sDvQ1fazCpOg95Xv7+y9j71X0Pe3/3Vfm37428xszv+01+Xr7QNf0a8Ca/g4YZ/JNfeQjWnd45KNe0fXKga7/r5j5Ka2vn234N6fQuL9g6r7gN8AY/jbUPwnW28yGOv4Eu72Bx9F1WDud9kLk9MU9Fvyhr3stsPG+BjuK9wlL7PyuF2+Nwnfz74Bd20Sm3XxibDefNRY0zkAOAX7AVdze73sxGvw9w/b+AzBBuHD/0Guyg0Hrsth6i7H1sgZ8a7ftUNm4bzW4L2DAvZ0l0vheoGT6EUiywLzRXLFAH50h+ewnYCw46o5y5SeGI6mfe2E3x/aN/udoo+eIO+0TyHhx+fYXJt/+EmuiWuomj3hz8muv6ELludQmsfOnAbEzqhlj7/tWnEv9Zv6b3838w8w/o3Mpmq11tengfuvF08H91e6kds/+FWUBgZvRQnCVNsJT+i9mmkToFrKxHhykib14fJh2rUlMOm1SjL7bRz04Vn//D7Q/SQw8Isa0I+smv/87xsxzVDAwnUzOYGYPM+t7T3lnAJ3vvyLrvDcuZ3r25mlN0f4bUA+sS6D/Gnrz5jbFpz2HG2Lve8Te1/fumNu9zNe9zexjZmPvyd1FrQ7jB9Tz5FQd2M5aHMaPrONrRlA2/t1Lvo2/9uLJKbSdvXrbYedEcN8Zt7G7SWYI0vTaWA7/HcgmuQmX5E68SaZ1h9d1HOizDqQfmnvji6iuDi8MTqvHrbUQ0H8twDzqGeVQLU4YkA1O7PZMXWvvf19njF77Rq/9ote26LV/76mQrUo39F/gs6H24p4xKu74NQLUJ/pZ6EJvP35C+qU9EEB/d6poW2Od/oy9qyvamcy/zWzmLGYOqIGi7Qskv5mAimzW/0FFOzPQfwOZFe2ssRweGHs/S+z9gApFO8h8PZuZg80cElO0tXrioa03rBErx+2dvTejwbQ4ilTbjZ8dWPRDgUnL5cOhvXFqod2HQ5kLbGxs8+gXK6pBvas/KD2MNmczR5g5R++O6yF9Spso0qft8Z8TTPocuTQnQy7NyZxL2Vgu9Y/lz7Cp5NJc5t/mNnMeM+edSi4hlNzQ3vjH/pAKcaTwvGw/uZDsw1HgHG8XH6Nipw0cPNfCwHPjhT/NRiciLb3xYm4+YN+B9iG6dmifBvKGpj1iLoZcnB9Yl5Y282Hc3gU4m/kF8M18uAAwyUZb0MyPxjdg4ej/UjM//1QasDHm38aaqczUzM38aAZicSxo5h2GXHKYc6laMz9mKrmUMf/mmpk1M8fczI8W3sznwRtej7rabHitQLtbY3Z60YbnR68LRq8LRa8LR6/jotdFotdFo9fFotfFo9clotclo9elelt4m2PB3pPvQ7VfG5dwbbGEa0vGrlUW75qx4vViBevH3q9VUbxLm39bxsxlzVyuN/8tgQWBDcXSwIZiefCGwuW/hYD+WwbovxUs8d/CQP8tC/Tfiswb+/IxDlgh9n7F2PvlKm6prGS+XtnMVcxctQbcMA4Ym5WAsVnNktxeBOi/lYH+W90S/y0K9N8qQP+twcwNq8U4YPXY+zVi71et4IY1zddrmbm2mevUgBsWA8ZmTWBs1rUktxcH+m8toP/Ws8R/SwD9tzbQf+szc8O6MQ5YL/Z+/dj7dSq4YQPz9YZmbmTmxjXghiWBsdkAGJtNmGOzSSwGG8bebxR7v3FFbDY1X29mZsHMYhSbpLXHx7TkprH1lprKQVDJ/FtgZtnMsPfkR3DatWvlQOv1EtDfPWJ2bh4dNmxhy2EDl32bM5zkbgkukvZko3UnMMZqCwZfbMXki62m4gvEqSxHXuzOfBu7E/tKndjHlgN7CL99T7hLDKfwwHhrpA/bN7H4hlA5uvqzOsup+JrouG0O5pb2sbWNJ/Bxo6fRZt3ZzyGbt2Yghj2FfFpTLX97apveMgkGGYt4Xm4T26inNz6d+RwZn21j8dGZjKmNIK/DIMxk875T1LlMLhe6YT7nuUGYdQtBvqzdQsbxy3kVaq9czmczpXwu9INSLoyTtg4yGTfwiyWddXKFovKCTEGFbj7jqEKQyQdBxsvlCplMkPNCz/ccpxBmPJXN532VczK+wxWfbaP40Ps+dR1/NRyVW5Omvp5TCnUmazyncgU3G+QyTuDkVeBmQ22C5viuCVlYcr3AczKhk3dK7WqtOeKk9o2M3m8eU3NbRO+3M6/bm7lD77oOA/0bh8g7WdsBVfuOvbHNQ62eWduRaYPfqTejwTv1xq87HpgMXLjHx4oLtO5Ujz/T+gF523R7YHx2trRYd2Yq1l16Mxq8C0Ox7iq8WAn3rjUuVpVudNgNVboBJdPdwEnfGMV7t1gXs33sfXvHQ3Oh2PWFE75nd/O6h5l79uapH+q6d2A4NmkGxmcvpvhsVyU+e8Xi09n37G1e9zFzX6b4jI/qHK3a9wPf3+TIy/0YcE9gxo04tt6vt+yHifcH+xB+ZGvsA9qoqcYnMOTiARbU4A4MuA+0oAY5cB8EzEmOuiHcwJz8pwfYncGPB1tQN+MYcB9iQd1w4D5UeN1QDw/kNE08cTCDHw8Tvm9Trw3McU15cxiDHw8X7keqw9be2Lo+nOGsIen5rmq/H7Rg7+rPdx1h/u1IM48y8+jefL/odxrTn4I9BsxvHPvZMQx1dKzwfdzpxRPvg4XcMe9k6IWBmvE4YI4XgXfMDxb+WFOGKQcPsSQHxwFz8HhgDgbAHDxEeA66TDl4qCU5uAgwB08A5mAIzEFbYoH8c/QnAmMh9c/Rc/AB9W3HMfSDJwnvBwn38Qy4T7YA9wkMuE8B39er1JInxTTjybH3p0xFS55q/u00M08384zenf+OWFofHAHkoFOBmv9MSx9gOROcU+3jrN6MBp/F8ADL2cIfYCHcZzMcKlGy0V+K6lHHn2xH9OZpmjh80j7OiXx+bvR6XvR6PuUgmuEpwH/14jmRQjkn/hz1ebEnPyp3k3Niu8a5sffnTWU3ucD824VmXmTmxYwnk+SPs4U/NXAJ86k5YicG2qgviNarw8bkn2IeWFcbgkP8lZvoEwI5CO4/v/MU98Wlkc8v6x05pL24L40Vd/s1+qbhFUahH3tsSb8TO+2/iXcpcFe/DBxcNKlR8VzKUEActtLx2DoMf0ZtHSABXw4kN+5jc0Q81mWIx7rAeFwBjMchFsRjfYZ4rA+Mx5XIRw8siMcGDPHYABiPq4DxQB+pwh8hMn5bphc2vhsy/HGMDYE2Xi38cTby4cYMPtwY6MNrLPDhpgw+3BTow2st8GGBwYcFoA+vs8CHJQYfloA+vN4CH5YZfFgG+vAGC3y4OYMPNwf68EYLfLglgw+3BPrwJgt8uDWDD7cG+vBmC3y4LYMPtwX68BYLfLg9gw+3B/rwVgt8uAODD3cA+vA2C3y4E4MPdwL68HYLfDiewYfjgT68wwIf7sLgw12APrzTAh/uxuDD3YA+vMsCH+7B4MM9gD682wIf7sXgw72APrzHAh/uw+DDfYA+vNcCH+7L4MN9gT68zwIfTmDw4QSgD++3wIcHMPjwAKAPH7DAhwcx+PAgoA8ftMCHhzD48BCgDx+ywIeHMfjwMKAPH7bAh0cw+PAIoA8fscCHRzH48CigDx+1wIfHMPjwGKAPH7PAh8cx+PA4oA8ft8CHJzD48ASgD5+wwIcnMfjwJKAPn7TAhycz+PBkoA+fssCHpzD48BSgD5+2wIenMfjwNKAPn7HAh2cw+PAMoA+ftcCHZzH48CygD5+zwIfnMPjwHKAPn7fAh+cx+PA8oA9fsMCHFzD48AKgD1+0wIcXMfjwIqAPX7LAhxcz+PBioA9ftsCHlzL48FKgD1+xwIeXM/jwcqAPX7XAh1cy+PBKoA9fs8CHVzP48GqgD1+3wIfXMvjwWqAP37DAh9cz+PB6oA/ftMCHNzL48EagD9+ywIc3MfjwJqAP37bAhzcz+PBmoA/fscCHtzL48FagD9+1wIe3M/jwdqAP37PAh3cy+PBOoA/ft8CHdzP48G6gDz+wwIf3MvjwXqAPP7TAh/cz+PB+oA8/ssCHDzL48EGgDz+2wIcPM/jwYaAPP7HAh48y+PBRoA8/tcCHjzP48HGgDz+zwIdPMvjwSaAPP7fAh08z+PBpoA+/sMCHzzL48FmgD7+0wIfPM/jweaAPv7LAhy8y+PBFoA+/tsCHLzP48GWgD7+xwIevMvjwVaAPv7XAh68z+PB1oA+/s8CHbzL48E2gDyda4MO3GXz4NtCH31vgw3cZfPgu0Ic/WODD9xl8+D7Qhz9a4MMPGXz4IdCHP1ngw48ZfPgx0Ic/W+DDTxl8+CnQh79Y4MPPGXz4OdCHvwJ9SH+zYTszV4vWo7/rQn9LhP5+Bf3NBPpcffpcePpcc/pcbvpcafpcZPpcX/pcWvpcVfpcUPpcS/pcRvpcQfpcPPpcN/pcMvpcLfpcKPpcI/pcHvpcGfpcFPpcD/pcCvpcBfpcAPq9dvq9bPq9Yvq9WPq9Tvq9RPq9Ovq9MPq9Jvq9HPq9Evq9CHqun55Lp+eq6blgeq6Vnsuk5wrpuTh6roueS6Lnaui5EHquge7L031lui9K9/XovhTdV6H7AnSuTeeydK5I52J0rkPnEqSrSReSrqG+nPpK6otoX6d9iXiVeIHymuLSPsB/PCtLf/eJ/oYROt9/A+ZSjyiXKgdqfSbfaqQPuGz8HW0j2sBzmBL0OOF//IYwU3DQf/wmHvC0Nv6BSx6NjAczYeg6pmK0gTD+EE4Y/9nR0J3WJcDC+bN7d9R/WpDsf0nfHc9l2h1PsGB3/Ithd/wLWOSTgLvjCd27oxWEMel/dHd0kLvj3927o/7bgmSv6yN8dzyPaXc8yYLdkYKD3h3jAU9r4wy45NEnde+OVhDGDMIJg2t3zCB3xx59unfHHn3k21gvfXc8n2l3PMWC3bGeYXesB+6OPYG74yndu6MVhNHzf3R3dJG7Y0P37qgbLEj2XtzJjtglesF3iYy6pDePE9Pi7W1P4bDtEjYUTm/pbaUN99/6AJ1I/quP/EjrDq/rOCr9gCAm1FqNfbBFic6lib3MbZ5eeHI/HSxRejDgbgbEuRz+O/6K1usJtvOvXrg7CM3AvG4C5vXpzHJWpRv/xGB+Bhnf3Ec2bi5uaOlWEHrGevk2tiLz09ZAjbAgUDN2B0rp9XrJt7Fvd6CUzlpQUf26A6X0WAsC1dYdKKU3soD6+ncHSulNLAjUTN2BUnozCwI1c3eglC5aEKhZugOldGBBoAZ0B0rp0IJAzdodKKW3sCBQA7sDpfRWFgRqUHeglN7GgkDN1h0opbezIFCDuwOl9HgLjpCGdAdK6R0tqKjZuwOl9BUWVNTQ7kApvbMFFTWsO1BK72pBoIZ3B0rp3S0I1IjuQCm9pwWBmqM7UErvbUGg5uwOlNIPWtD1zdUdKKX3s6Ci5u4OlNL7WxCoeboDpfSBFgRq3u5AKX2wBYEa2R0opQ+1IFCjugOl9OEWBGq+7kApfaQFgZq/O1BKH21BoBboDpTSx1oQqNHdgVL6eAsCNaY7UEqfaEGgxnYHSulZLDjrU92BUvq2Bvk26u5AKX2qBdTndAdK6dMtCFSmO1BKn2lBoNzuQCl9tgWBynYHSulzLQhUrjtQSp9vQaDy3YFS+kILAuV1B0rpVgsEr98dKKUvsaCiFuwOlNKXWRCohboDpfQVFgRq4e5AKX2VBYEa1x0opa+xIFCLdAdK6essCNSi3YFS+gYLArVYd6CUXtMCHbV4d6DMEZIFgVqiO1BK32IB9S3ZHShzK96CQC3VHSil77AgUEt3B0rpuywI1DLdgVL6HgsCtWx3oJS+z4JALdcdKKUfsCBQy3cHSumHLAjUCt2BUvoRCwK1YneglH7MgkCt1B0opZ+wIFArdwdK6acsCNQq3YFS+hkLArVqd6CUfs6CQK3WHSilX7AgUKt3B0rplywI1BrdgVL6FQsCtWZ3oJR+zYJArdUdKKXfsCBQa3cHSum3LAjUOt2BUvodCwK1bneglH7PgkCt1x0opT+wIFDrdwdK6Y8sCNQG3YFS+hMLArVhd6CU/syCQG3UB2wj2sDm3nV185nZo2LdjMq5bjnvlHVGF5TjF72scrPFnKc9nfWygeNlMmXP9fJ+0c8rX7uZsg6zfiaMFt4YB1yPH4p1ItqHvYz/yI8zgH24SR/ZuCf2+hd3D4acRPlwU+E+/K0XT+5sZknuoHEXhOP+y+A+mwF3UTjuYw3mExlwl8C40Vw2v8Gc741bzzFrZRj8GAjPH8pvijW6TykD+5RTgH0K+a+/mT2j9ehr+tWwSdF7ilf7+3LsvYq+p/2/C82/bW7mFmZu2afjesj4EJ8Tt4Hrx/mrFy7WW/XBxqc+8iOtOzzyea/oeuVA+zsUXq8je/+bo3XYdRWnTyfiBKWutJGlkQCtpShxTbzqGur4E3dAPU8ygBNNtxc4py9G1uF9gbbxbwtOWX7tZQfB9Or9P0eETqWNoomQy5kMnVEG2RltzdQZbR11Rlx+vYRBCZ0r/LSx0fi0qc/kzQm17iXAU7dtgKoKHQ8OhX9Jb2x8m/vg83pb4YqBcLcwKPzt/ndy8Z89oRGH16ET2sY+eDuRXLO98BPAFgZ+2BgfEyj/72AB12zGwLE7WoC7wIB7J0tOo9C4x1sQ700YcO9sAe5NGXDvgn6cIxoNYPyX1afHXA7/HUidGb8bn3atXYFrnQ7s6+gwddZYTscHOs93Bev29rFbH0aDd+uDX3d3YDJw4d6d+XYImkS+6/X/n0T26CYRvQcTiezZh9HgPRlIZC/hJEK492IiEY7nSndhOM1BFv/efews2L2ZCnafPowG78NQsPsKL1jCvW+NCjYt/t0jckHfVti9j0yC3q+P7Hi03zasB60rvRObYCkZT2Ai4/37MBq8PwMZHyCcjAn3AZaQMW0a+zGQ8b5AMt4PGO8DhZMx5c2BDPE4ABiPA4HxOMiCeBwkPB4HAeNxsAXxOFh4PA4GxuMQC+JxiPB4HAKMx6EWxONQ4fE4FBiPwyyIx2HC43EYMB6HWxCPw4XH43BgPI6wIB5HCI/HEcB4HGlBPI4UHo8jgfE4yoJ4HCU8HkcB43G0BfE4Wng8jgbG4xgL4nGM8HgcA4zHsRbE41iGZ4aR8TgWGA+6ATCorja/iW3HL7Q6fGvryTcu6HV49P44E8/jzTzBzBPNPMnMk808xcxTzTzNzNPNPMPMM808y8yzzTzHzHPNPM/M8828wMwLzbzIzIvNvMTMS828zMzLzbzCzCvNvMrMq828xsxr+0TGtP8iGhlTee34hGsnJFw7MeHaSQnXTk64dkrCtVMTrp2WcO30hGtnJFw7M+HaWQnXzk64dk7CtXMTrp2XcO38hGsXJFy7MOHaRQnXLk64dknCtUsTrl2WcO3yhGtXJFy7MuHaVQnXrk64dk3CtWuja/ExInpdLHpV6UYH0klLlscBiPffu8tKHw9aizCeAFnrX3+dmH4tJ/KXPintWu5/fK9PTreWisVRn5JmLadDTuhTp38tVZFf+rTpXCsXTpGr+vTpW8tLyHt9xvSs5SXWkD5z2tfKV6lHfda0rpWvWtv67Glby5kKT+hzpmWt/FQ5R5/b9bVKnfCXPq+ra+U75UJ9ftfWUl3gVX1BV9ZSXeJofWHna2W7yPf6os7Wcru8d+iLp7qWG07DPqQvmdpa+Wna0/Sl1dfypnF/1JdVWcsPp3mv1Zcnr6WmY9/WVyStpaarB9BXTrmWns5+Ql9VuVYw3b2JvrrjWpkUfY6+JraWE6bqmfS1fex8Wu1aWK8X6Li91/VhNJgWrzy5SGv8dbgA6usBTuV88o18SDaiTpXafXg9uAgG1k2Oc62KQKUaAeupStwXN0QFdmOl2rwhCmz82o0JChR9FItjEqVvABbQjeDgopOPiuYGYDG2477B0h3pGlge+UHc3pv6MBp8E3xH8oObgDvSzcJ3JPLhzfAdyQ9utnRHugZmt19KMJdlR7olKrBbK3ekWxJ2pFtrsCNdA9yRbgEW0K1MwUURULudSMy3Acmsrg6/W14fERD6hihSCtwOJLMkH6p0Q1OMb2foZG63tJO5GsY/xUzc3jv6MBp8B7yTKWbuABb/ncI7GfLhnfBOppi5k7n4EQR6u3ACvQvsw/aB3niROX43sPZq2QFfDbO76CSYy9IB3xMR872VHfA9CR3wvTXogHE7kNL3AJPyXqbgogsRifk+5g5YpRuayPFuhu7tfuFdK8Xlfgtwc+X4/cAcf0B4jldrUhDND2qtB8Ebdq3UzlWwvcYL4/Y+1IfR4IfgascLHwIG8GHhaod8+DBc7Xjhw8LVDhHdg31kk/EjYDJuH2jMyBx/1FK1cxXMbq+cYC6L2nksIubHK9XOYwlq5/EaqB3cDqT0Y8CkfJwpuOhCRGJ+QngnSOT4KEPX/6RwtUNxedIC3Fw5/iQwx58SnuPVmhSVbmhkk/K0pfd2roTtNU6HT/l7pg+jwc/A1Y6jngEWwbPC1Q758Fm42nHUs8LVDhHd031kk/FzlqgdZI4/b6nauRJmtw4TzGVROy9ExPxipdp5IUHtvFgDtYPbgZR+AZiULzIFF12ISMwvCe8EiRyfZ+j6XxaudiguL1uAmyvHXwbm+CvCc7xak6LSDY1sUl61VO1cAdtrgg5q57U+jAa/Blc7gXoNWASvC1c75MPX4WonUK8LVztEdK/2kU3Gb1iidpA5/qalaucKmN2lmqmdtyJifrtS7byVoHberoHawe1ASr8FTMq3mYKLLkQk5neEd4JEjm8ydP3vClc7FJd3LcDNlePvAnP8PeE5Xq1JUemGRjYp71uqdi6H7TW5Dp+J8UEfRoM/gKudnP4AWAQfClc75MMP4Won1wG3SjmScCOI7v0+ssn4I0vUDjLHP7ZU7VwOsztXs89S+SQi5k8r1c4nCWrn0xqoHdwOpPQnwKT8lCm46EJEYv5MeCdI5PgxQ9f/uXC1Q3H53ALcXDn+OTDHvxCe49WaFJVuaGST8qWlaucy3L0dL27vV30YDf4Kf2/H+wpYBF8LVzvkw6/x93a8r4WrHSK6L/vIJuNvLFE7yBz/1lK1cxnM7iCfYC6L2vkuIuaJlWrnuwS1M7EGage3Ayn9HTApJzIFF12ISMzfC+8EiRy/Zej6fxCudiguP1iAmyvHfwDm+I/Cc7xak6LSDY1sUn6yVO1cCttrXD9u7899GA3+Ga52XP9nYBH8IlztkA9/gasd1/9FuNohovupj2wy/tUStYPM8d8sVTuXwux2vQRzWdTO7xEx/1Gpdn5PUDt/1EDt4HYgpX8HJuUfTMFFFyIS85/CO0Eix98Yuv6/hKsdistfFuDmyvG/gDk+SXiOV2tSVLqhkU3K35aqnUtge02xw5NsdY2MBtPiWLVT1LQmysYZGmWrHfIh2Qj+BOoOuFXKkYQbQXR/95FNxj0asWTcPtCYkTleD8RcS7VzCYz0izV7kq1nRMwNjXUdlU3PxinVDn0Tt9q5BKh2egKTsqGRJ7joQkRi7gUmH3TBETnWN+I3ht7MG5dKNzTFpbcFuLlyvDcwx/sIz/FqTYpKNzSySWkE5k0t1c7FOLVTitvb1MhocBNe7ZSagEXQLFztkA+b8Wqn1Cxc7RDRNTbKJuMWS9QOMsdbLVU7F+PUTjHBXBa1M2NEzH0r1c6MCWqnbw3UzsVAtTMjMCn7NvIEF12ISMz9hHeCRI6tDF1/m3C1Q3FpswA3V463AXO8v/Acr9akqHRDI5uUmSxVOxfhnmQrxu2duZHR4JnhasctzgwsglmEqx3y4SxwteMWZxGudojoZmqUTcYDLFE7yByf1VK1cxHuYadCgrksamdgRMyDKtXOwAS1M6gGaucioNoZCEzKQY08wUUXIhLzbMI7QSLHWRm6/sHC1Q7FZbAFuLlyfDAwx4cIz/FqTYpKNzSySZndUrVzIWyv8Tp8AvXQRkaDh8LVjqeGAotgmHC1Qz4cBlc7nhomXO0Q0c3eKJuMh1uidpA5PsJStXMhTO3ka/YJ1HNExDxnpdqZI0HtzFkDtXMhUO3MAUzKORt5gosuRCTmuYR3gkSOIxi6/rmFqx2Ky9wW4ObK8bmBOT6P8Byv1qSodEMjm5R5LVU7FzCpnZGNjAaPZFA7I4FFMEq42iEfjmJQO6OEqx0iunkbZZPxfJaoHWSOz2+p2rnAQrWzQETMoyvVzgIJamd0DdTOBUC1swAwKUdbonaQmMcI7wSJHOdn6PrHClc7FJexFuDmyvGxwBxXwnO8WpOi0g2NbFK0pWrnfNheU+jwmWxOI6PBDlztFHwHWAQZ4WqHfJiBq52CnxGudojodKNsMnYtUTvIHM9aqnbOh6mdQs0+ky0XEXO+Uu3kEtROvgZq53yg2skBkzLfyBNcdCEiMXvCO0EixyxD1+8LVzsUF98C3Fw57gNzfEHhOV6tSVHphkY2KQtZqnbOw6kdN27vwo2MBi+MVzvuwsAiGCdc7ZAPx+HVjjtOuNoholuoUTYZL2KJ2kHm+KKWqp3zcGonk2Aui9pZLCLmxSvVzmIJamfxGqid84BqZzFgUi7eyBNcdCEiMS8hvBMkclyUoetfUrjaobgsaQFurhxfEpjjSwnP8WpNiko3NLJJWdpStXMu7q+Ldri3s0wjo8HLwNVO4C8DLIJlhasd8uGycLUT+MsKVztEdEs3yibj5SxRO8gcX95StXMu7g9Q1uzezgoRMa9YqXZWSFA7K9ZA7ZwLVDsrAJNyxUae4KILEYl5JeGdIJHj8gxd/8rC1Q7FZWULcHPl+MrAHF9FeI5Xa1JUuqGRTcqqlqqdc2B7Takct3e1RkaDV4OrnVJ5NWARrC5c7ZAPV4ernVJ5deFqh4hu1UbZZLyGJWoHmeNrWqp2zoGpnVKQYC6L2lkrIua1K9XOWglqZ+0aqJ1zgGpnLWBSrt3IE1x0ISIxryO8EyRyXJOh619XuNqhuKxrAW6uHF8XmOPrCc/xak2KSjc0sklZ31K1czZsr9Ed7u1s0Mho8AZwtaP9DYBFsKFwtUM+3BCudrS/oXC1Q0S3fqNsMt7IErWDzPGNLVU7Z8PUjq7ZvZ1NImLetFLtbJKgdjatgdo5G6h2NgEm5aaNPMFFFyIS82bCO0Eix40Zuv6CcLVDcSlYgJsrxwvAHC8Kz/FqTYpKNzSySSlZqnbOwv110Q5qJ2hkNDiAq52iHwCLoCxc7ZAPy3C1U/TLwtUOEV2pUTYZh5aoHWSOb26p2jkL99dFa6Z2toiIectKtbNFgtrZsgZq5yyg2tkCmJRbNvIEF12ISMxbCe8EiRw3Z+j6txaudiguW1uAmyvHtwbm+DbCc7xak6LSDY1sUra1VO2cifsEai9u73aNjAZvB1c7nrcdsAi2F652yIfbw9WO520vXO0Q0W3bKJuMd7BE7SBzfEdL1c6ZMLXj5RPMZVE7O0XEPL5S7eyUoHbG10DtnAlUOzsBk3J8I09w0YWIxLyz8E6QyHFHhq5/F+Fqh+KyiwW4uXJ8F2CO7yo8x6s1KSrd0MgmZTdL1c4ZsL3G7aB2dm9kNHh3uNpxvd2BRbCHcLVDPtwDrnZcbw/haoeIbrdG2WS8pyVqB5nje1mqds6AqR23Zmpn74iY96lUO3snqJ19aqB2zgCqnb2BSblPI09w0YWIxLyv8E6QyHEvhq5/P+Fqh+KynwW4uXJ8P2COTxCe49WaFJVuaGSTsr+laud02F7j67i9BzQyGnwAXO34+gBgERwoXO2QDw+Eqx2/A26VciThRhDd/o2yyfggS9QOMscPtlTtnA5TO75KMJdF7RwSEfOhlWrnkAS1c2gN1M7pQLVzCDApD23kCS66EJGYDxPeCRI5HszQ9R8uXO1QXA63ADdXjh8OzPEjhOd4tSZFpRsa2aQcaanaOQ221+RV3N6jGhkNPgqudvLqKGARHC1c7ZAPj4arnbw6WrjaIaI7slE2GR9jidpB5vixlqqd02BqJxcmmMuido6LiPn4SrVzXILaOb4Gauc0oNo5DpiUxzfyBBddiEjMJwjvBIkcj2Xo+k8UrnYoLidagJsrx08E5vhJwnO8WpOi0g2NbFJOtlTtnIr7lIIOn0B9SiOjwafA1U6xfAqwCE4VrnbIh6fC1U6xfKpwtUNEd3KjbDI+zRK1g8zx0y1VO6fiPqWgZp9AfUZEzGdWqp0zEtTOmTVQO6cC1c4ZwKQ8s5EnuOhCRGI+S3gnSOR4OkPXf7ZwtUNxOdsC3Fw5fjYwx88RnuPVmhSVbmhkk3KupWrnFNhe43S4t3NeI6PB58HVjqPOAxbB+cLVDvnwfLjacdT5wtUOEd25jbLJ+AJL1A4yxy+0VO2cgvsE6prd27koIuaLK9XORQlq5+IaqJ1TgGrnImBSXtzIE1x0ISIxXyK8EyRyvJCh679UuNqhuFxqAW6uHL8UmOOXCc/xak2KSjc0skm53FK1czJurynF7b2ikdHgK+BqR5WuABbBlcLVDvnwSrjaUaUrhasdIrrLG2WT8VWWqB1kjl9tqdo5GaZ2VDHBXBa1c01EzNdWqp1rEtTOtTVQO8AdSF8DTMprG3mCiy5EJObrhHeCRI5XM3T91wtXOxSX6y3AzZXj1wNz/AbhOV6tSVHphkY2KTdaqnZOgu01uQ5Pst3UyGjwTXC1kyvfBCyCm4WrHfLhzXC1kyvfLFztENHd2CibjG+xRO0gc/xWS9XOSbjf26nZk2y3RcR8e6XauS1B7dxeA7VzElDt3AZMytsbeYKLLkQk5juEd4JEjrcydP13Clc7FJc7LcDNleN3AnP8LuE5Xq1JUemGRjYpd1uqdk6E7TW6w2ey3dPIaPA9cLWj9T3AIrhXuNohH94LVzu6A26VciThRhDd3Y2yyfg+S9QOMsfvt1TtnIh7kq1mn8n2QETMD1aqnQcS1M6DNVA7JwLVzgPApHywkSe46EJEYn5IeCdI5Hg/Q9f/sHC1Q3F52ALcXDn+MDDHHxGe49WaFJVuaGST8qilaucE3MMYHX5v57FGRoMfa8Sv+7hwhUK4H2+c7GDQuiyqggjl0UbZpPeEJaoCmZdPMhM9IiZPMuR4LQn1eCZCfaqR0eCnGAj1aeGESrifrhGhqnRDU2E83chTcCjctSyy4/rgfBC395lGRoOfYdgRnwEy+rPCC5Z8+CxDETwr/IyWivRZBvnzBDDezwk/LqDceY6J7NsHurafA8bneeESv5piUOmGRiqGF4TnOMX4BYZGDpmH1CQMqpt8ZB4faLtH1vHUeR3UTof1PscMMd8Oj96/aOL5kpkvm/mKma+a+ZqZr5v5hplvmvmWmW+b+Y6Z75r5npnvm/mBmR+a+ZGZH5v5iZmfmvmZmZ+b+YWZX5r5lZlfm/mNmd+a+Z2ZE838vvIey4vR/ZT4tZcSrr2ccO2VhGuvJlx7LeHa6wnX3ki49mbCtbcSrr2dcO2dhGvvJlx7L+Ha+wnXPki49mHCtY8Srn2ccO2ThGufJlz7LOHa5wnXvki49mXCta8Srn2dcO2bhGvfJlz7LuHaxIRr3zdOee9uRPS6WPSq0o0OpJOWLF8EEG/7fcCXQGsRxpcha/3rr1fSr+VE/tKvpl3L/Y/v9Wvp1lKxOOrX06zldMgJ/cb0r6Uq8ku/OZ1r5cIpclW/NX1reQl5r9+enrW8xBrS70z7Wvkq9ajfnda18lVrW783bWs5U+EJ/f60rJWfKufoD7q+VqkT/tIfdnWtfKdcqD/q2lqqC7yqP+7KWqpLHK0/6XytbBf5Xn/a2Vpul/cO/dlU13LDadiH9OdTWys/TXua/qL6Wt407o/6yypr+eE077X6q+S11HTs2/rrpLXUdPUA+psp19LT2U/obyvXCqa7N9HfdVwrk6LP0RNjazlhqp5Jf2/pifb3sF4v6PDU8Q+NjAb/0Ih+6jjQP+ACqH8EOJXzRJt8+CPwRLvdhz+Ci6BWT4/iijeo2dOjP0UF9nPlycZPjVM+PfpzI//TozgmUfonYAH9DA4uOvmoaH4CFmM77p8s3ZEmwvLID+L2/tLIaPAv8B3JD34B7ki/Ct+RyIe/wnckP/jV0h1pIsxuv5RgLsuO9FtUYL9X7ki/JexIv9dgR5oI3JF+AxbQ70zBRd8IRmL+A0hmdXX43fLHiIDQN4KRUuBPIJkl+VClG5pi/CdDJ/OnpZ3MdzD+KWbi9v7VyGjwX/BOppj5C1j8k4R3MuTDSfBOppiZxFz8CAL9UziB/g32YftAb7zQHG/CxaKWHfB3sFgVnQRzWTrgGZqifGiq69jt0j9UdsD0Tdwd8HfADniGJlxS9mjiCS66EJGY64GF+E+ygXOFyLGuCb8x9Gzi3bhUuqEpLj0twM2V4z2BOd4gPMerNSmI5ge1Vi/whl0rtfMtbK/xwri9vZsYDabFsWrHC3sDA9gHWJxcPuzThFY7XtiHedNAEF2vJtlk3Agm4/aBxozM8SZL1c63MLXjlRPMZVE7zRExt1SqneYEtdNSA7XzLVDtNAOTsqWJJ7joQkRibhXeCRI5NjF0/TMKVzsUlxktwM2V4zMCc7yv8Byv1qSodEMjm5R+wLyppdr5BrbXdPy7421NjAa3wdWOo9qARdBfuNohH/aHqx1H9Reudojo+jXJJuOZLFE7yByf2VK18w1M7dTu747PEhHzgEq1M0uC2hlQA7XzDVDtzAJMygFNPMFFFyIS86zCO0Eix5kZuv6BwtUOxWWgBbi5cnwgMMcHCc/xak2KSjc0skmZzVK18zXut8Q6qJ3BTYwGD4arnUANBhbBEOFqh3w4BK52AjVEuNohoputSTYZz26J2kHm+FBL1c7XMLVTqpnaGRYR8/BKtTMsQe0Mr4Ha+RqodoYBk3J4E09w0YWIxDxCeCdI5DiUoeufQ7jaobjMYQFurhyfA5jjcwrP8WpNiko3NLJJmctStfMVbK/JdfhMjLmbGA2eG652cnpuYBHMI1ztkA/ngaudXAfcKuVIwo0gurmaZJPxvJaoHWSOj7RU7XwFUzu5mn2WyqiImOerVDujEtTOfDVQO18B1c4oYFLO18QTXHQhIjHPL7wTJHIcydD1LyBc7VBcFrAAN1eOLwDM8dHCc7xak6LSDY1sUsZYqna+xN3b8eL2jm1iNHgs/t6ONxZYBEq42iEfKvy9HU8JVztEdGOaZJOxtkTtIHPcsVTtfIn7cMF8grksaicTEbNbqXYyCWrHrYHa+RKodjLApHSbeIKLLkQk5qzwTpDI0WHo+nPC1Q7FJWcBbq4czwFzPC88x6s1KSrd0MgmxbNU7XwB22tcP26v38RosA9XO67vA4tgQeFqh3y4IFztuP6CwtUOEZ3XJJuMF7JE7SBzfGFL1c4XMLXjegnmsqidcRExL1KpdsYlqJ1FaqB2vgCqnXHApFykiSe46EJEYl5UeCdI5LgwQ9e/mHC1809cLMDNleOLAXN8ceE5Xq1JUemGRjYpS1iqdj7HfQJ1hyfZlmxiNHhJuNop6iWBRbCUcLVDPlwKrnaKHXCrlCMJN4LolmiSTcZLW6J2kDm+jKVq53PcJ1DX7Em2ZSNiXq5S7SyboHaWq4Ha+RyodpYFJuVyTTzBRRciEvPywjtBIsdlGLr+FYSrHYrLChbg5srxFYA5vqLwHK/WpKh0QyOblJUsVTuf4dROKW7vyk2MBq+MVzullYFFsIpwtUM+XAWvdkqrCFc7RHQrNckm41UtUTvIHF/NUrXzGU7tFBPMZVE7q0fEvEal2lk9Qe2sUQO18xlQ7awOTMo1mniCiy5EJOY1hXeCRI6rMXT9awlXOxSXtSzAzZXjawFzfG3hOV6tSVHphkY2KetYqnY+xT3JVozbu24To8Hr4p9kK64LLIL1hKsd8uF6+CfZiusJVztEdOs0ySbj9S1RO8gc38BStfMp7km2QoK5LGpnw4iYN6pUOxsmqJ2NaqB2PgWqnQ2BSblRE09w0YWIxLyx8E6QyHEDhq5/E+Fqh+KyiQW4uXJ8E2CObyo8x6s1KSrd0MgmZTNL1c4nuL8u2uETqAtNjAYX4GrHUwVgERSFqx3yYRGudjxVFK52iOg2a5JNxiVL1A4yxwNL1c4nMLWTr9knUJcjYg4r1U45Qe2ENVA7nwDVThmYlGETT3DRhYjEvLnwTpDIMWDo+rcQrnYoLltYgJsrx7cA5viWwnO8WpOi0g2NbFK2slTtfMykdrZuYjR4awa1szWwCLYRrnbIh9swqJ1thKsdIrqtmmST8baWqB1kjm9nqdr52EK1s31EzDtUqp3tE9TODjVQOx8D1c72wKTcwRK1g8S8o/BOkMhxO4aufyfhaofispMFuLlyfCdgjo8XnuPVmhSVbmhkk7KzpWrnI9heU+jwmWy7NDEavAtc7RT8XYBFsKtwtUM+3BWudgr+rsLVDhHdzk2yyXg3S9QOMsd3t1TtfARTO4WafSbbHhEx71mpdvZIUDt71kDtfARUO3sAk3LPJp7gogsRiXkv4Z0gkePuDF3/3sLVDsVlbwtwc+X43sAc30d4jldrUlS6oZFNyr6Wqp0PcWrHjdu7XxOjwfvh1Y67H7AIJghXO+TDCXi1404QrnaI6PZtkk3G+1uidpA5foClaudDnNrJJJjLonYOjIj5oEq1c2CC2jmoBmrnQ6DaORCYlAc18QQXXYhIzAcL7wSJHA9g6PoPEa52KC6HWICbK8cPAeb4ocJzvFqTotINjWxSDrNU7XyA++uiHe7tHN7EaPDhcLUT+IcDi+AI4WqHfHgEXO0E/hHC1Q4R3WFNssn4SEvUDjLHj7JU7XyA++uiNbu3c3REzMdUqp2jE9TOMTVQOx8A1c7RwKQ8poknuOhCRGI+VngnSOR4FEPXf5xwtUNxOc4C3Fw5fhwwx48XnuPVmhSVbmhkk3KCpWrnfdheUyrH7T2xidHgE+Fqp1Q+EVgEJwlXO+TDk+Bqp1Q+SbjaIaI7oUk2GZ9sidpB5vgplqqd92FqpxQkmMuidk6NiPm0SrVzaoLaOa0Gaud9oNo5FZiUpzXxBBddiEjMpwvvBIkcT2Ho+s8QrnYoLmdYgJsrx88A5viZwnO8WpOi0g2NbFLOslTtvAfba3SHeztnNzEafDZc7Wj/bGARnCNc7ZAPz4GrHe2fI1ztENGd1SSbjM+1RO0gc/w8S9XOezC1o2t2b+f8iJgvqFQ75yeonQtqoHbeA6qd84FJeUETT3DRhYjEfKHwTpDI8TyGrv8i4WqH4nKRBbi5cvwiYI5fLDzHqzUpKt3QyCblEkvVzru4vy7aQe1c2sRo8KVwtVP0LwUWwWXC1Q758DK42in6lwlXO0R0lzTJJuPLLVE7yBy/wlK18y7ur4vWTO1cGRHzVZVq58oEtXNVDdTOu0C1cyUwKa9q4gkuuhCRmK8W3gkSOV7B0PVfI1ztUFyusQA3V45fA8zxa4XneLUmRaUbGtmkXGep2nkH9wnUXtze65sYDb4ernY873pgEdwgXO2QD2+Aqx3Pu0G42iGiu65JNhnfaInaQeb4TZaqnXdgasfLJ5jLonZujoj5lkq1c3OC2rmlBmrnHaDauRmYlLc08QQXXYhIzLcK7wSJHG9i6PpvE652KC63WYCbK8dvA+b47cJzvFqTotINjWxS7rBU7bwN22vcDmrnziZGg++Eqx3XuxNYBHcJVzvkw7vgasf17hKudojo7miSTcZ3W6J2kDl+j6Vq522Y2nFrpnbujYj5vkq1c2+C2rmvBmrnbaDauReYlPc18QQXXYhIzPcL7wSJHO9h6PofEK52KC4PWICbK8cfAOb4g8JzvFqTotINjWxSHrJU7bwF22t8Hbf34SZGgx+Gqx1fPwwsgkeEqx3y4SNwteN3wK1SjiTcCKJ7qEk2GT9qidpB5vhjlqqdt2Bqx1cJ5rKonccjYn6iUu08nqB2nqiB2nkLqHYeByblE008wUUXIhLzk8I7QSLHxxi6/qeEqx2Ky1MW4ObK8aeAOf608Byv1qSodEMjm5RnLFU7b8L2mryK2/tsE6PBz8LVTl49CyyC54SrHfLhc3C1k1fPCVc7RHTPNMkm4+ctUTvIHH/BUrXzJkzt5MIEc1nUzosRMb9UqXZeTFA7L9VA7bwJVDsvApPypSae4KILEYn5ZeGdIJHjCwxd/yvC1Q7F5RULcHPl+CvAHH9VeI5Xa1JUuqGRTcprlqqdN3CfUtDhE6hfb2I0+HW42imWXwcWwRvC1Q758A242imW3xCudojoXmuSTcZvWqJ2kDn+lqVq5w3cpxTU7BOo346I+Z1KtfN2gtp5pwZq5w2g2nkbmJTvNPEEF12ISMzvCu8EiRzfYuj63xOudigu71mAmyvH3wPm+PvCc7xak6LSDY1sUj6wVO28DttrnA73dj5sYjT4Q7jacdSHwCL4SLjaIR9+BFc7jvpIuNohovugSTYZf2yJ2kHm+CeWqp3XcZ9AXbN7O59GxPxZpdr5NEHtfFYDtfM6UO18CkzKz5p4gosuRCTmz4V3gkSOnzB0/V8IVzsUly8swM2V418Ac/xL4TlerUlR6YZGNilfWap2XsPtNaW4vV83MRr8NVztqNLXwCL4RrjaIR9+A1c7qvSNcLVDRPdVk2wy/tYStYPM8e8sVTuvwdSOKiaYy6J2JkbE/H2l2pmYoHa+r4HaAe5AeiIwKb9v4gkuuhCRmH8Q3gkSOX7H0PX/KFztUFx+tAA3V47/CMzxn4TneLUmRaUbGtmk/Gyp2nkVttfkOjzJ9ksTo8G/wNVOrvwLsAh+Fa52yIe/wtVOrvyrcLVDRPdzk2wy/s0StYPM8d8tVTuv4n5vp2ZPsv0REfOflWrnjwS182cN1M6rQLXzBzAp/2ziCS66EJGY/xLeCRI5/s7Q9U8SrnYoLpMswM2V45OAOf638Byv1qSodEMjm5S6ZjvVziuwvUZ3+Ey2GZoZDabFsWrHGI8LoO7RLFvtkA/JRqza0R1wq5QjCTeC6OqaZZNxfTOWjNsHGjMyx3sCMddS7byCe5KtZp/J1hARc6/muo7KpqF5SrVD38Stdl4Bqp0GYFL2auYJLroQkZh7g8kHXXBEjj2b8RtDH+aNS6UbmuLSxwLcXDneB5jjjcJzvFqTotINjWxSmixVOy/jHsbo8Hs7zc2MBjc349dtEa5QCHdL82QHg9ZlURVEKE3Nskmv1RJVgczLGZmJHhGTGRlyvJaE+hITofZtZjS4LwOh9hNOqIS7X40IVaUbmgqjXzNPwaFw17LIXmzE+SBub1szo8FtDDtiG5DR+wsvWPJhf4Yi6C/8jJaKtD+D/GkFxnsm4ccFlDszMZF9+0DX9kzA+MwsXOJXUwwq3dBIxTCL8BynGM/C0Mgh85CahEF1k4/M4wN+bNSLp87roHY6rPc5Zoj5dnj0foCJ56xmDjRzkJmzmTnYzCFmzm7mUDOHmTnczBFmzmHmnGbOZebcZs5j5rxmjjRzlJnzmTm/mQuYOdrMMWaONVOZqc10zMyY6ZqZrbzHMiC6nxK/NmvCtYEJ1wYlXJst4drghGtDEq7NnnBtaMK1YQnXhidcG5FwbY6Ea3MmXJsr4drcCdfmSbg2b8K1kQnXRiVcmy/h2vwJ1xZIuDY64dqYhGtjE66phGs64ZqTcC2TcM1NuJZtnvLe3YjodbHoVaUbHUgnLVkOABBv+33AWUFrEcaBkLX+9deg9Gs5kb/0bGnXcv/jez043VoqFkc9JM1aToec0LNP/1qqIr/00OlcKxdOkat62PSt5SXkvR4+PWt5iTWkR0z7Wvkq9ajnmNa18lVrW885bWs5U+EJPde0rJWfKufoubu+VqkT/tLzdHWtfKdcqOft2lqqC7yqR3ZlLdUljtajOl8r20W+1/N1tpbb5b1Dzz/VtdxwGvYhvcDU1spP056mR1dfy5vG/VGPqbKWH07zXqvHJq+lpmPf1ippLTVdPYDWU66lp7Of0E7lWsF09yY603GtTIo+R7uxtZwwVc+ks5aeaGdhvV7Q4anjXDOjwblm9FPHgc7hAqjzAKdynmiTD/PAE+12H+bBRVCrp0dxxRvU7OlRLyowv/Jkw2ue8ulRv5n/6VEckyjtAQvIBwcXnXxUNB6wGNtxe5buSC4sj/wgbu+CzYwGLwjfkfxgQeCOtJDwHYl8uBB8R/KDhSzdkVyY3X4pwVyWHWnhqMDGVe5ICyfsSONqsCO5wB1pYWABjWMKLvpGMBLzIkAyq6vD75b5iIDQN4KRUmBRIJkl+VClG5pivChDJ7OopZ1MBsY/xUzc3sWaOQ2GdzLFzGLA4l9ceCdDPlwc3skUM4szFz+CQBcVTqBLgH3YPtAbLzLHlwTWXi074AzM7qKTYC5LB7xURMxLV3bASyV0wEvXoAPG7UBKLwVMyqWZgosuRCTmZZg7YJVuaCLHJRm6t2WFd60Ul2UtwM2V48sCc3w54TlerUlBND+otZYHb9i1UjsObK/xwri9KzQzGrwCXO144QrAAK4oXO2QD1eEqx0vXFG42iGiW75ZNhmvBCbj9oHGjMzxlS1VOw7Mbq+cYC6L2lklIuZVK9XOKglqZ9UaqB3cDqT0KsCkXJUpuOhCRGJeTXgnSOS4MkPXv7pwtUNxWd0C3Fw5vjowx9cQnuPVmhSVbmhkk7Kmpfd2NGyv6fh3x9dqZjR4LbjacdRawCJYW7jaIR+uDVc7jlpbuNoholuzWTYZr2OJ2kHm+LqWqh0Ns7t2f3d8vYiY169UO+slqJ31a6B2cDuQ0usBk3J9puCiCxGJeQPhnSCR47oMXf+GwtUOxWVDC3Bz5fiGwBzfSHiOV2tSVLqhkU3KxpaqHQXba4IOameTZkaDN4GrnUBtAiyCTYWrHfLhpnC1E6hNhasdIrqNm2WT8WaWqB1kjhcsVTsKZnepZmqnGBFzqVLtFBPUTqkGage3AyldBCZliSm46EJEYg6Ed4JEjgWGrr8sXO1QXMoW4ObK8TIwx0PhOV6tSVHphkY2KZtbqnbGwvaaXIfPxNiimdHgLeBqJ6e3ABbBlsLVDvlwS7jayXXArVKOJNwIotu8WTYZb2WJ2kHm+NaWqp2xMLtzNfsslW0iYt62Uu1sk6B2tq2B2sHtQEpvA0zKbZmCiy5EJObthHeCRI5bM3T92wtXOxSX7S3AzZXj2wNzfAfhOV6tSVHphkY2KTtaqnbG4O7teHF7d2pmNHgn/L0dbydgEYwXrnbIh+Px93a88cLVDhHdjs2yyXhnS9QOMsd3sVTtjIHZHeQTzGVRO7tGxLxbpdrZNUHt7FYDtYPbgZTeFZiUuzEFF12ISMy7C+8EiRx3Yej69xCudigue1iAmyvH9wDm+J7Cc7xak6LSDY1sUvayVO2Mhu01rh+3d+9mRoP3hqsd198bWAT7CFc75MN94GrH9fcRrnaI6PZqlk3G+1qidpA5vp+lamc0zG7XSzCXRe1MiIh5/0q1MyFB7exfA7WD24GUngBMyv2ZgosuRCTmA4R3gkSO+zF0/QcKVzsUlwMtwM2V4wcCc/wg4TlerUlR6YZGNikHW6p2FoDtNcUOT7Id0sxo8CFwtVPUhwCL4FDhaod8eChc7RQ74FYpRxJuBNEd3CybjA+zRO0gc/xwS9XOAjC7izV7ku2IiJiPrFQ7RySonSNroHZwO5DSRwCT8kim4KILEYn5KOGdIJHj4Qxd/9HC1Q7F5WgLcHPl+NHAHD9GeI5Xa1JUuqGRTcqxlqqd+XFqpxS397hmRoOPw6ud0nHAIjheuNohHx6PVzul44WrHSK6Y5tlk/EJlqgdZI6faKnamR/XEBcTzGVROydFxHxypdo5KUHtnFwDtYPbgZQ+CZiUJzMFF12ISMynCO8EiRxPZOj6TxWudigup1qAmyvHTwXm+GnCc7xak6LSDY1sUk63VO3Mh3uSrRi394xmRoPPwD/JVjwDWARnClc75MMz8U+yFc8UrnaI6E5vlk3GZ1midpA5fralamc+3MNOhQRzWdTOORExn1upds5JUDvn1kDt4HYgpc8BJuW5TMFFFyIS83nCO0Eix7MZuv7zhasdisv5FuDmyvHzgTl+gfAcr9akqHRDI5uUCy1VO6Nge43X4ROoL2pmNPgiuNrx1EXAIrhYuNohH14MVzueuli42iGiu7BZNhlfYonaQeb4pZaqnVEwu/M1+wTqyyJivrxS7VyWoHYur4Hawe1ASl8GTMrLmYKLLkQk5iuEd4JEjpcydP1XClc7FJcrLcDNleNXAnP8KuE5Xq1JUemGRjYpV1uqdkYyqZ1rmhkNvoZB7VwDLIJrhasd8uG1DGrnWuFqh4ju6mbZZHydJWoHmePXW6p2Rlqodm6IiPnGSrVzQ4LaubEGage3Ayl9AzApb7RE7SAx3yS8EyRyvJ6h679ZuNqhuNxsAW6uHL8ZmOO3CM/xak2KSjc0skm51VK1My9sryl0+Ey225oZDb4NrnYK/m3AIrhduNohH94OVzsF/3bhaoeI7tZm2WR8hyVqB5njd1qqduaF2V2o2Wey3RUR892VaueuBLVzdw3UDm4HUvouYFLezRRcdCEiMd8jvBMkcryToeu/V7jaobjcawFurhy/F5jj9wnP8WpNiko3NLJJud9StTMPTu24cXsfaGY0+AG82nEfABbBg8LVDvnwQbzacR8UrnaI6O5vlk3GD1midpA5/rClamceXEOcSTCXRe08EhHzo5Vq55EEtfNoDdQObgdS+hFgUj7KFFx0ISIxPya8EyRyfJih639cuNqhuDxuAW6uHH8cmONPCM/xak2KSjc0skl50lK1Mzdsrwk63Nt5qpnR4KfgaifwnwIWwdPC1Q758Gm42gn8p4WrHSK6J5tlk/EzlqgdZI4/a6namRtmd1CzezvPRcT8fKXaeS5B7TxfA7WD24GUfg6YlM8zBRddiEjMLwjvBIkcn2Xo+l8UrnYoLi9agJsrx18E5vhLwnO8WpOi0g2NbFJetlTtzAXba0rluL2vNDMa/Apc7ZTKrwCL4FXhaod8+Cpc7ZTKrwpXO0R0LzfLJuPXLFE7yBx/3VK1MxfM7lKQYC6L2nkjIuY3K9XOGwlq580aqB3cDqT0G8CkfJMpuOhCRGJ+S3gnSOT4OkPX/7ZwtUNxedsC3Fw5/jYwx98RnuPVmhSVbmhkk/KupWpnTtheozvc23mvmdHg9+BqR/vvAYvgfeFqh3z4PlztaP994WqHiO7dZtlk/IElageZ4x9aqnbmhNmta3Zv56OImD+uVDsfJaidj2ugdnA7kNIfAZPyY6bgogsRifkT4Z0gkeOHDF3/p8LVDsXlUwtwc+X4p8Ac/0x4jldrUlS6oZFNyueWqp05YHtNsYPa+aKZ0eAv4Gqn6H8BLIIvhasd8uGXcLVT9L8UrnaI6D5vlk3GX1midpA5/rWlamcOmN3FmqmdbyJi/rZS7XyToHa+rYHawe1ASn8DTMpvmYKLLkQk5u+Ed4JEjl8zdP0ThasdistEC3Bz5fhEYI5/LzzHqzUpKt3QyCblB0vVzgjYXuN5cXt/bGY0+Ee42vG8H4FF8JNwtUM+/AmudjzvJ+Fqh4juh2bZZPyzJWoHmeO/WKp2RsDs9vIJ5rKonV8jYv6tUu38mqB2fquB2sHtQEr/CkzK35iCiy5EJObfhXeCRI6/MHT9fwhXOxSXPyzAzZXjfwBz/E/hOV6tSVHphkY2KX9ZqnaGw/Yat4PamdTMaPAkuNpxvUnAIvhbuNohH/4NVzuu97dwtUNE91ezbDKua7FD7SBzfAYg5lqqneGwfHdrpnZ6tPz7Wt9S11HZ0D9Uqh36Jm61g9uBlO7RgkvK+hae4KILEYm5J5h80AVH5DhDC35jaGjh3bhUuqEpLg0W4ObK8QZgjvcSnuPVmhSVbmhkk9IbmDe1VDvDYHuNr+P29mlhNJgWx6odX/cBFkEjsDi5fNjYglY7fgfcKuVIwo0gut4tssm4yRK1g8zxZkvVzjCY2vFVgrksaqclIubWSrXTkqB2WmugdoYB1U4LMClbW3iCiy5EJOYZhXeCRI7NDF1/X+Fqh+LS1wLcXDneF5jj/YTneLUmRaUbGtmktFmqdobC9pq8itvbv4XR4P5wtZNX/YFFMJNwtUM+nAmudvJqJuFqh4iurUU2Gc9sidpB5vgslqqdoTC1kwsTzGVROwMiYp61Uu0MSFA7s9ZA7QwFqp0BwKSctYUnuOhCRGIeKLwTJHKchaHrHyRc7VBcBlmAmyvHBwFzfDbhOV6tSVHphkY2KYMtVTuz4z6loMMnUA9pYTR4CFztFMtDgEUwu3C1Qz6cHa52iuXZhasdIrrBLbLJeKglageZ48MsVTuz436RvWafQD08IuYRlWpneILaGVEDtTM7UO0MBybliBae4KILEYl5DuGdIJHjMIauf07haofiMqcFuLlyfE5gjs8lPMerNSkq3dDIJmVuS9XOENhe43S4tzNPC6PB88DVjqPmARbBvMLVDvlwXrjacdS8wtUOEd3cLbLJeKQlageZ46MsVTtDcB9SXLN7O/NFxDx/pdqZL0HtzF8DtTMEqHbmAybl/C08wUUXIhLzAsI7QSLHUQxd/2jhaofiMtoC3Fw5PhqY42OE53i1JkWlGxrZpIy1VO0Mxu01pbi9qoXRYAVXO6qkgEWghasd8qGGqx1V0sLVDhHd2BbZZOxYonaQOZ6xVO0Mxn0qRzHBXBa140bEnK1UO26C2snWQO0AdyDtApMy28ITXHQhIjHnhHeCRI4Zhq4/L1ztUFzyFuDmyvE8MMc94TlerUlR6YZGNim+pWpnNthek+vwJNuCLYwGLwhXO7nygsAiWEi42iEfLgRXO7nyQsLVDhGd3yKbjBe2RO0gc3ycpWpnNtzv7dTsSbZFImJetFLtLJKgdhatgdqZDah2FgEm5aItPMFFFyIS82LCO0Eix3EMXf/iwtUOxWVxC3Bz5fjiwBxfQniOV2tSVLqhkU3KkpaqnUGwvUZ3+Ey2pVoYDV4Krna0XgpYBEsLVzvkw6Xhakd3wK1SjiTcCKJbskU2GS9jidpB5viylqqdQbgn2Wr2mWzLRcS8fKXaWS5B7SxfA7UzCKh2lgMm5fItPMFFFyIS8wrCO0Eix2UZuv4VhasdisuKFuDmyvEVgTm+kvAcr9akqHRDI5uUlS1VOwOBfyIlbu8qLYwGr9KCX3dV4QqFcK/aMtnBoHVZVAURysotsklvNUtUBTIvV2cmekRMVmfI8VoS6qxMhLpGC6PBazAQ6prCCZVwr1kjQlXphqbCWLOFp+BQuGtZZAOQf+wrZudaLYwGr8WwI64FZPS1hRcs+XBthiJYW/gZLRXp2gzyZzVgvNcRflxAubMOE9m3D3RtrwOMz7rCJX41xaDSDY1UDOsJz3GK8XoMjRwyD6lJGFQ3+cg8PtB2/9qLp87roHY6rPc5Zoj5dnj0fn0Tzw3M3NDMjczc2MxNzNzUzM3MLJhZNLNkZmBm2czQzM3N3MLMLc3cysytzdzGzG3N3M7M7c3cwcwdzdzJzPFm7mzmLmbuauZuZu5eeY9l/eh+SvzaBgnXNky4tlHCtY0Trm2ScG3ThGubJVwrJFwrJlwrJVwLEq6VE66FCdc2T7i2RcK1LROubZVwbeuEa9skXNs24dp2Cde2T7i2Q8K1HROu7ZRwbXzCtZ0Tru2ScG3XhGu7JVzbvWXKe3cjotfFoleVbnQgnbRkuT6AeNvvA24AWoswbghZ619/bZR+LSfyl9447Vruf3yvN0m3lorFUW+aZi2nQ07ozaZ/LVWRX7ownWvlwilyVRenby0vIe91aXrW8hJrSAfTvla+Sj3q8rSula9a2zqctrWcqfCE3nxa1spPlXP0Fl1fq9QJf+ktu7pWvlMu1Ft1bS3VBV7VW3dlLdUljtbbdL5Wtot8r7ftbC23y3uH3m6qa7nhNOxDevuprZWfpj1N71B9LW8a90e9Y5W1/HCa91q9U/Jaajr2bT0+aS01XT2A3nnKtfR09hN6l8q1gunuTfSuHdfKpOhz9G6xtZwwVc+kd7f0RHt3WK8XdHjqeI8WRoP3aEE/dRzoPXAB1HsCnMp5ok0+3BN4ot3uwz3BRVCrp0dxxRvU7OnRvaIC27vyZGOvlimfHt27hf/pURyTKL0XsID2BgcXnXxUNHsBi7Ed916W7ki7wfLID+L27tPCaPA+8B3JD/YB7kj7Ct+RyIf7wnckP9jX0h1pN5jdfinBXJYdab+owCZU7kj7JexIE2qwI+0G3JH2AxbQBKbgom8EIzHvDySzujr8brlnREDoG8FIKXAAkMySfKjSDU0xPoChkznA0k5mVxj/FDNxew9sYTT4QHgnU8wcCCz+g4R3MuTDg+CdTDFzEHPxIwj0AOEEejDYh+0DvfEic/wQYO3VsgPeFWZ30Ukwl6UDPjQi5sMqO+BDEzrgw2rQAeN2IKUPBSblYUzBRRciEvPhzB2wSjc0keMhDN3bEcK7VorLERbg5srxI4A5fqTwHK/WpCCaH9RaR4E37FqpnV1ge40Xxu09uoXR4KPhascLjwYG8Bjhaod8eAxc7XjhMcLVDhHdUS2yyfhYMBm3DzRmZI4fZ6na2QVmt1dOMJdF7RwfEfMJlWrn+AS1c0IN1A5uB1L6eGBSnsAUXHQhIjGfKLwTJHI8jqHrP0m42qG4nGQBbq4cPwmY4ycLz/FqTYpKNzSySTnF0ns7O8P2mo5/d/zUFkaDT4WrHUedCiyC04SrHfLhaXC146jThKsdIrpTWmST8emWqB1kjp9hqdrZGWZ37f7u+JkRMZ9VqXbOTFA7Z9VA7eB2IKXPBCblWUzBRRciEvPZwjtBIsczGLr+c4SrHYrLORbg5srxc4A5fq7wHK/WpKh0QyOblPMsVTvjYXtN0EHtnN/CaPD5cLUTqPOBRXCBcLVDPrwArnYCdYFwtUNEd16LbDK+0BK1g8zxiyxVO+NhdpdqpnYujoj5kkq1c3GC2rmkBmoHtwMpfTEwKS9hCi66EJGYLxXeCRI5XsTQ9V8mXO1QXC6zADdXjl8GzPHLhed4tSZFpRsa2aRcYana2Qm21+Q6fCbGlS2MBl8JVzs5fSWwCK4SrnbIh1fB1U6uA26VciThRhDdFS2yyfhqS9QOMsevsVTt7ASzO1ezz1K5NiLm6yrVzrUJaue6Gqgd3A6k9LXApLyOKbjoQkRivl54J0jkeA1D13+DcLVDcbnBAtxcOX4DMMdvFJ7j1ZoUlW5oZJNyk6VqZ0fcvR0vbu/NLYwG34y/t+PdDCyCW4SrHfLhLfh7O94twtUOEd1NLbLJ+FZL1A4yx2+zVO3sCLM7yCeYy6J2bo+I+Y5KtXN7gtq5owZqB7cDKX07MCnvYAouuhCRmO8U3gkSOd7G0PXfJVztUFzusgA3V47fBczxu4XneLUmRaUbGtmk3GOp2tkBtte4ftzee1sYDb4XrnZc/15gEdwnXO2QD++Dqx3Xv0+42iGiu6dFNhnfb4naQeb4A5aqnR1gdrtegrksaufBiJgfqlQ7DyaonYdqoHZwO5DSDwKT8iGm4KILEYn5YeGdIJHjAwxd/yPC1Q7F5RELcHPl+CPAHH9UeI5Xa1JUuqGRTcpjlqqd7WF7TbHDk2yPtzAa/Dhc7RT148AieEK42iEfPgFXO8UOuFXKkYQbQXSPtcgm4yctUTvIHH/KUrWzPczuYs2eZHs6IuZnKtXO0wlq55kaqB3cDqT008CkfIYpuOhCRGJ+VngnSOT4FEPX/5xwtUNxec4C3Fw5/hwwx58XnuPVmhSVbmhkk/KCpWpnO5zaKcXtfbGF0eAX8Wqn9CKwCF4SrnbIhy/h1U7pJeFqh4juhRbZZPyyJWoHmeOvWKp2tsM1xMUEc1nUzqsRMb9WqXZeTVA7r9VA7eB2IKVfBSbla0zBRRciEvPrwjtBIsdXGLr+N4SrHYrLGxbg5srxN4A5/qbwHK/WpKh0QyOblLcsVTvb4p5kK8btfbuF0eC38U+yFd8GFsE7wtUO+fAd/JNsxXeEqx0iurdaZJPxu5aoHWSOv2ep2tkW97BTIcFcFrXzfkTMH1SqnfcT1M4HNVA7uB1I6feBSfkBU3DRhYjE/KHwTpDI8T2Grv8j4WqH4vKRBbi5cvwjYI5/LDzHqzUpKt3QyCblE0vVzjawvcbr8AnUn7YwGvwpXO146lNgEXwmXO2QDz+Dqx1PfSZc7RDRfdIim4w/t0TtIHP8C0vVzjYwu/M1+wTqLyNi/qpS7XyZoHa+qoHawe1ASn8JTMqvmIKLLkQk5q+Fd4JEjl8wdP3fCFc7FJdvLMDNlePfAHP8W+E5Xq1JUemGRjYp31mqdrZmUjsTWxgNnsigdiYCi+B74WqHfPg9g9r5XrjaIaL7rkU2Gf9gidpB5viPlqqdrS1UOz9FxPxzpdr5KUHt/FwDtYPbgZT+CZiUP1uidpCYfxHeCRI5/sjQ9f8qXO1QXH61ADdXjv8KzPHfhOd4tSZFpRsa2aT8bqna2Qq21xQ6fCbbHy2MBv8BVzsF/w9gEfwpXO2QD/+Eq52C/6dwtUNE93uLbDL+yxK1g8zxSZaqna1gdhdq9plsf7cTc2tdR2Xzd4LaoW/iVju4HUjpv5HE28oTXHQhIjHP0IolH3TBETlOYuj6e7Tyblwq3dAUF7JROm6uHI/bmXateuE5Xq1JUemGRjYpPYF5U0u1syVO7bhxextaGQ2mxcFqx20AFkEvYHFy+bBXK1ztuL2YNw0E0fVslU3GvcFk3D7QmJE53geIuZZqZ0uc2skkmMuidhojYm6qVDuNrVOqnaYaqJ0tgWqnEZiUTa08wUUXIhJzs/BOkMixD0PX3yJc7VBcWizAzZXjLcAcbxWe49WaFJVuaGSTMqOlamcL2F4TdLi307eV0eC+cLUT+H2BRdBPuNohH/aDq53A7ydc7RDRzdgqm4zbLFE7yBzvb6na2QKmdoKa3duZKSLmmSvVzkwJamfmGqidLYBqZyZgUs7cyhNcdCEiMc8ivBMkcuzP0PUPEK52KC4DLMDNleMDgDk+q/Acr9akqHRDI5uUgZaqnc1he02pHLd3UCujwYPgaqdUHgQsgtmEqx3y4WxwtVMqzyZc7RDRDWyVTcaDLVE7yBwfYqna2RymdkpBgrksamf2iJiHVqqd2RPUztAaqJ3NgWpndmBSDm3lCS66EJGYhwnvBIkchzB0/cOFqx2Ky3ALcHPl+HBgjo8QnuPVmhSVbmhkkzKHpWonhO01usO9nTlbGQ2eE652tD8nsAjmEq52yIdzwdWO9ucSrnaI6OZolU3Gc1uidpA5Po+laieEqR1ds3s780bEPLJS7cyboHZG1kDthEC1My8wKUe28gQXXYhIzKOEd4JEjvMwdP3zCVc7FJf5LMDNlePzAXN8fuE5Xq1JUemGRjYpC1iqdsqwvabYQe2MbmU0eDRc7RT90cAiGCNc7ZAPx8DVTtEfI1ztENEt0CqbjMdaonaQOa4sVTtlmNop1kzt6IiYnUq1oxPUjlMDtVMGqh0NTEqnlSe46EJEYs4I7wSJHBVD1+8KVzsUF9cC3Fw57gJzPCs8x6s1KSrd0MgmJWep2glwn0Dtxe3NtzIanIerHc/LA4vAE652yIceXO14nidc7RDR5Vplk7FvidpB5viClqqdAKZ2vHyCuSxqZ6GImBeuVDsLJaidhWugdgKg2lkImJQLt/IEF12ISMzjhHeCRI4LMnT9iwhXOxSXRSzAzZXjiwBzfFHhOV6tSVHphkY2KYtZqnZKsL3G7aB2Fm9lNHhxuNpxvcWBRbCEcLVDPlwCrnZcbwnhaucfomuVTcZLWqJ2kDm+lKVqpwRTO27N1M7SETEvU6l2lk5QO8vUQO2UgGpnaWBSLtPKE1x0ISIxLyu8EyRyXIqh619OuNqhuCxnAW6uHF8OmOPLC8/xak2KSjc0sklZwVK1U4TtNb6O27tiK6PBK8LVjq9XBBbBSsLVDvlwJbja8TvgVilHEm4E0a3QKpuMV7ZE7SBzfBVL1U4RpnZ8lWAui9pZNSLm1SrVzqoJame1GqidIlDtrApMytVaeYKLLkQk5tWFd4JEjqswdP1rCFc7FJc1LMDNleNrAHN8TeE5Xq1JUemGRjYpa1mqdgqwvSav4vau3cpo8NpwtZNXawOLYB3haod8uA5c7eTVOsLVDhHdWq2yyXhdS9QOMsfXs1TtFGBqJxcmmMuidtaPiHmDSrWzfoLa2aAGaqcAVDvrA5Nyg1ae4KILEYl5Q+GdIJHjegxd/0bC1Q7FZSMLcHPl+EbAHN9YeI5Xa1JUuqGRTcomlqqdzXCfUtDhE6g3bWU0eFO42imWNwUWwWbC1Q75cDO42imWNxOudojoNmmVTcYFS9QOMseLlqqdzXCfUlCzT6AuRcQcVKqdUoLaCWqgdjYDqp0SMCmDVp7gogsRibksvBMkciwydP2hcLVDcQktwM2V4yEwxzcXnuPVmhSVbmhkk7KFpWpnU9he43S4t7NlK6PBW8LVjqO2BBbBVsLVDvlwK7jacdRWwtUOEd0WrbLJeGtL1A4yx7exVO1sivsE6prd29k2IubtKtXOtglqZ7saqJ1NgWpnW2BSbtfKE1x0ISIxby+8EyRy3Iah699BuNqhuOxgAW6uHN8BmOM7Cs/xak2KSjc0sknZyVK1swlurynF7R3fymjweLjaUaXxwCLYWbjaIR/uDFc7qrSzcLVDRLdTq2wy3sUStYPM8V0tVTubwNSOKiaYy6J2douIefdKtbNbgtrZvQZqB7gD6d2ASbl7K09w0YWIxLyH8E6QyHFXhq5/T+Fqh+KypwW4uXJ8T2CO7yU8x6s1KSrd0MgmZW9L1c7GsL0m1+FJtn1aGQ3eB652cuV9gEWwr3C1Qz7cF652cuV9hasdIrq9W2WT8X6WqB1kjk+wVO1sjPu9nZo9ybZ/RMwHVKqd/RPUzgE1UDsbA9XO/sCkPKCVJ7joQkRiPlB4J0jkOIGh6z9IuNqhuBxkAW6uHD8ImOMHC8/xak2KSjc0skk5xFK1sxFsr9EdPpPt0FZGgw+Fqx2tDwUWwWHC1Q758DC42tEdcKuUIwk3gugOaZVNxodbonaQOX6EpWpnI9yTbDX7TLYjI2I+qlLtHJmgdo6qgdrZCKh2jgQm5VGtPMFFFyIS89HCO0EixyMYuv5jhKsdissxFuDmyvFjgDl+rPAcr9akqHRDI5uU4yxVOxviHsbo8Hs7x7cyGnx8K37dE4QrFMJ9QutkB4PWZVEVRCjHtcomvRMtURXIvDyJmegRMTmJIcdrSagbMBHqya2MBp/MQKinCCdUwn1KjQhVpRuaCuOUVp6CQ+GuZZGt34LzQdzeU1sZDT6VYUc8FcjopwkvWPLhaQxFcJrwM1oq0tMY5M+JwHifLvy4gHLndCaybx/o2j4dGJ8zhEv8aopBpRsaqRjOFJ7jFOMzGRo5ZB5Sk9BSN3nEN9+zqD7pG+rratNFnAUMaI+YnWdHRHNO5Q0F+ocJFdfOia7FB/qGwlnACJ7d9bVKnaylzwG3nzST7nLVTaM/O7O7jjEpzwb6JF5E51Ym47mtU1ZZZeIhk6UTW3VnYM4FJvF5rbBkUHGfnteFYk5r+zlAPyB9ev40+LSznxX36fkx0uwT82fcpyrd0JOmvp5TCnUmW85nVa7gZoNcxgmcvArcbKiNwY7vGteEJdcLPCcTOnmnNAlr3z851k5s7RvJpLrJGwi9v8C8XmjmRa3/EmGttPiFsbhrL+M4+Qzlhxco7QZmC3CcoOiqkiqUnLLvaj90HTdTCkpFk0sFHaqwUPJD79+14vZe3Mpo8MUJvWZa4y8G9tiXCNfi5MNLEnrNtD68BNwRNNXV5rmXC5luG9dh/duhI7g03gCgDy2AgdTx3SBu9DTaXOpK8l06HSK0M6dfCizmy8DtYbtfL4t1LtOaC6Z10yWtQuU7qqDypVy+6AdO0SuEmTCbCTLT69fOkh3p18uZ/Hp55Nda6lokGcXJ84poR76SapCDMC5lOL24VPjp7vQWh5oG3GltvEr4yRcl5lUMdwauZiKFq6dCtird0Fcy+eIaJl9ck2Lj6cxmrrz4dOh/lVM6PVfjyoHPhsrmgQsj3GguBcZbI334/+XM8wqmM89rp6ZwVLqhr2IixGunonA6WabTM1Sy+VoGYvgcTAzto+c0xmxaGpm0mK9rlUkwyFjE8/K6hLPtaY1PZz5Hxuf6+LlkJmNqI8jrMAgz2bzvFHUuk8uFbpjPeW4QZt1CkC9rt5Bx/HJehdorm9PeTCmfC/2glAvjpK2DTMYN/GJJZ51coai8IFNQoZvPGPEbZPJBkPFyuUImE+S80PONYDUy2FPZfN5XOSfjO1zxuT6mNFGbQmcnG/E1bdkUbrBxU7iBeVO4gWFT+ELIplA1ifP//I5ciCSdG4VuCl8wkc6NgE2hs2M+ZHxuEropcMXnpv9Hx483R8ePtyQdP6p0o+rZP/I+SNq1gEeZLA/xtfsQ/cQDlw/TrnWr8HhQwdzKsLHfxtTk3MZ4LHoLky9uZ/LF7YzHolx58ZXwY1GuHPjagmPRWxmORYHx1l93H4tWjn/4G+WTeON3B6cCvpWJEO9gVMBk8x0MxPCNJceitwKbojtbZRLMN0wK684aHIsi43MXUAF/DVTAXPG5KyE+6Ae8kPG5m4k/7wb4obOTGqQf7mHywz1dOCaXvJEnmAvL43iTcK+NTcK9zE3CvQxNwrc1ahJSPh0LJbn7gGshm4RvmTah+7rQJKR9yhYZn/tbcRs7skngis/9jCdPI80aI+vwvPGA8IcyCfMDDHz5ICDP//10zJAFN9n3IAPuh4THmzA/xID7YeG4yb6HGXA/Ihw32fcIA+5HheMm+x5lwP2YcNxk32MMuB8Xjpvse5wB9xPCcZN9TzDgftKCfexJBtxPCcdN9j3FgPtpC+L9NAPuZ4TjJvueYcD9rHDcZN+zDLifE46b7HuOAffzFtT38wy4XxCOm+x7gQH3i8Jxk30vMuB+SThusu8lBtwvC8dN9r3MgPsVC3jtFQbcrwrHTfa9yoD7NeG4yb7XGHC/Lhw32fc6A+43LKjvNxhwvykcN9n3JgPutyyI91sMuN8Wjpvse5sB9zsWxPsdBtzvCsdN9r3LgPs94bjJvvcYcL8vHDfZ9z4D7g8sqO8PGHB/KBw32fchA+6PLIj3Rwy4PxaOm+z7mAH3JxbE+xMG3J8Kx032fcqA+zPhuMm+zxhwfy4cN9n3OQPuLyyo7y8YcH8pHDfZ9yUD7q+E4yb7vmLA/bUFef41A+5vhOMm+75hwP2tBfH+lgH3d8Jxk33fMeCeaEG8JzLg/l44brLvewbcPwjHTfb9wID7R+G4yb4fGXD/JBw32fcTA+6fheMm+35mwP2LBXz+CwPuX4XjJvt+ZcD9m3DcZN9vDLh/F46b7PudAfcfFtT3Hwy4/xSOm+z7kwH3XxbE+y8G3JOE4yb7JjHg/ls4brLvbwbcdTPKxk320UTjnkE4brJvBgbcPYTjJl7rwYC7Xjhusq+eAXdPC+LdkwF3g3DcZF8DA+5ewnGTfb0YcPe2IM97M+DuIxw32deHAXejcNxkXyMD7ibhuMm+JgbczcJxk33NDLhbhOMm+1oYcLcKx032tTLgnlE4brJvRgbcfYXjJvv6MuDuZ0Hf0o8Bd5tw3GRfGwPu/sJxk339GXDPZEGez8SAe2bhuMm+mRlwzyIcN9k3CwPuAcJxk30DGHDPakF9z8qAe6Bw3GTfQAbcgyyI9yAG3LMJx032zcaAe7Bw3GTfYAbcQyzI8yEMuGcXjpvsm50B91AL4j2UAfcw4bjJvmEMuIdbEO/hDLhHCMdN9o1gwD2HcNxk3xwMuOcUjpvsm5MB91zCcZN9czHgnls4brJvbgbc81jA5/Mw4J5XOG6yb14G3COF4yb7RjLgHmVBno9iwD2fcNxk33wMuOcXjpvsm58B9wLCcZN9CzDgHi0cN9k3mgH3GOG4yb4xDLjHCsdN9o1lwK0s2McUA24tHDfZpxlwO8Jxk30OA+6McNxkX4YBtyscN9nnMuDOWsBrWQbcOeG4yb4cA+68cNxkX54Bt2dBnnsMuH3huMk+nwH3ghbEe0EG3AsJx032LcSAe2HhuMm+hRlwj7Mgz8cx4F5EOG6ybxEG3ItaEO9FGXAvJhz3P/Yx4F5cOG6yb3EG3EtYkOdLMOBeUjhusm9JBtxLWRDvpRhwLy0cN9m3NAPuZYTjJvuWYcC9rAV5viwD7uWE4yb7lmPAvbxw3GTf8gy4VxCOm+xbgQH3isJxk30rMuBeSThusm8lBtwrC8dN9q3MgHsV4bjJvlUYcK9qwf69KgPu1YTjJvtWY8C9ugXxXp0B9xrCcZN9azDgXlM4brJvTQbcawnHTfatxYB7beG4yb61GXCvIxw32bcOA+51heMm+9ZlwL2ecNxk33oMuNe3YP9enwH3BsJxk30bMODeUDhusm9DBtwbWZDnGzHg3lg4brJvYwbcmwjHTfZtwoB7UwvyfFMG3JsJx032bcaAu2BBvAsMuIvCcZN9RQbcJeG4yb4SA+5AOG6yL2DAXRaOm+wrM+AOheMm+0IG3JtbwOebM+DeQjhusm8LBtxbCsdN9m3JgHsrC/J8KwbcWwvHTfZtzYB7GwvivQ0D7m2F4yb7tmXAvZ0F8d6OAff2wnGTfdsz4N5BOG6ybwcG3DtakOc7MuDeSThusm8nBtzjheMm+8Yz4N5ZOG6yb2cG3LtYUN+7MODeVThusm9XBty7CcdN9u3GgHt3C/J8dwbcewjHTfbtwYB7T+G4yb49GXDvJRw32bcXA+69heMm+/ZmwL2PcNxk3z4MuPcVjpvs25cB934W7GP7MeCeIBw32TeBAff+FsR7fwbcBwjHTfYdwID7QOG4yb4DGXAfJBw32XcQA+6DLajvgxlwHyIcN9l3CAPuQy2I96EMuA8TjpvsO4wB9+EWxPtwBtxHCMdN9h3BgPtIC+J9JAPuo4TjJvuOYsB9tAXxPpoB9zHCcZN9xzDgPlY4brLvWAbcx1mQ58cx4D5eOG6y73gG3CcIx032ncCA+0ThuMm+ExlwnyQcN9l3EgPuk4XjJvtOZsB9igV8fgoD7lOF4yb7TmXAfZpw3GTfaQy4TxeOm+w7nQH3GRbU9xkMuM8UjpvsO5MB91nCcZN9ZzHgPls4brLvbAbc5wjHTfadw4D7XOG4yb5zGXCfZwGfn8eA+3zhuMm+8xlwX2BBvC9gwH2hcNxk34UMuC+yIN4XMeC+WDhusu9iBtyXWBDvSxhwXyocN9l3KQPuy4TjJvsuY8B9uXDcZN/lDLivsKC+r2DAfaVw3GTflQy4r7Ig3lcx4L5aOG6y72oG3NcIx032XcOA+1oL8vxaBtzXCcdN9l3HgPt6C+J9PQPuG4TjJvtuYMB9owXxvpEB903CcZN9NzHgvlk4brLvZgbctwjHTfbdwoD7Vgvq+1YG3LcJx0323caA+3bhuMm+2xlw32FBnt/BgPtO4bjJvjsZcN9lQbzvYsB9t3DcZN/dDLjvsSDe9zDgvlc4brLvXgbc9wnHTfbdx4D7fuG4yb77GXA/IBw32fcAA+4HpfOase9BBtwPWcDnDzHgflg4brLvYQbcjwjHTfY9woD7UeG4yb5HGXA/ZkF9P8aA+3HhuMm+xxlwPyEcN9n3BAPuJ4XjJvueZMD9lHDcZN9TDLiftoDXnmbA/Yxw3GTfMwy4nxWOm+x7lgH3cxbk+XMMuJ8Xjpvse54B9wvCcZN9LzDgflE4brLvRQbcLwnHTfa9xID7ZeG4yb6XGXC/YgGfv8KA+1XhuMm+Vxlwv2ZBvF9jwP26cNxk3+sMuN+wIN5vMOB+Uzhusu9NBtxvWRDvtxhwvy0cN9n3NgPudyyI9zsMuN8Vjpvse5cB93vCcZN97zHgfl84brLvfQbcHwjHTfZ9wID7Q+G4yb4PGXB/ZAGff8SA+2PhuMm+jxlwf2JBvD9hwP2pcNxk36cMuD+zIN6fMeD+XDhusu9zBtxfWBDvLxhwfykcN9n3JQPuryyI91cMuL8Wjpvs+5oB9zfCcZN93zDg/taCPP+WAfd3wnGTfd8x4J4oHDfZN5EB9/cW5Pn3DLh/EI6b7PuBAfePFsT7RwbcPwnHTfb9xID7Z+G4yb6fGXD/Ihw32fcLA+5fLajvXxlw/yYcN9n3GwPu34XjJvt+Z8D9h3DcZN8fDLj/tKC+/2TA/Zdw3GTfXwy4J1kQ70kMuP8Wjpvs+5sBd11f+fEmG9G4ZxCOm+ybgQF3Dwvi3YMBd71w3GRfPQPunhbEuycD7gbhuMm+BgbcvSyIdy8G3L2F4yb7ejPg7iMcN9nXhwF3o3DcZF8jA+4m4bjJviYG3M3CcZN9zQy4W4TjJvtaGHC3CsdN9rUy4J5ROG6yb0YG3H2F4yb7+jLg7iccN9nXjwF3m3DcZF8bA+7+wnGTff0ZcM8kHDfZNxMD7pmF4yb7ZmbAPYtw3GTfLAy4BwjHTfYNYMA9q3DcZN+sDLgHCsdN9g1kwD1IOG6ybxAD7tmE4yb7ZmPAPVg4brJvMAPuIcJxk31DGHDPLhw32Tc7A+6hwnGTfUMZcA8TjpvsG8aAe7hw3GTfcAbcI/oC7zGaNWaNYY8PtD9GAOMVt3eOvowGz9EXv+6cwABy4Z6z72QHg9ZluynJcTN2LjC5tI8elfhzjue6npMpFvKOLrjFfC70g1IhdLyiExRU2VO5IO8UMl7Bc3WxVPBUMSg42XxQcMs57SBzae7YWuYnlpQfqkLWK+TLZiFVVuZN0SuHOadQLLnKCbTWZdf8n1MOXL8Y5HQxZ356tqjNf5cUa6dY8nP5vPkvS0HRdXXWdwpBUec1gXdDL58p6mLGmJrJZ0OnHLrKN84wMEPjgkyx3DvKyyl86PqFslm2mMllykVjbOhkcwXf/FelXDmTc4vk32zGCXNuxvjNURm3EJbcrKd8xyu5bm+gD+cRvimRffMw1Mu8wnGTffMy4B4pHDfZN5IB9yjhuMm+UQy45xOOm+ybjwH3/MJxk33zM+BeQDhusm8BBtyjheMm+0Yz4B4jHDfZN4YB91jhuMm+sQy4lXDcZJ9iwK2F4yb7NANuRzhuss9hwJ0RjpvsyzDgdoXjJvtcBtxZ4bjJviwD7pxw3GRfjgF3Xjhusi/PgNsTjpvs8xhw+8Jxk30+A+4FheMm+xZkwL2QcNxk30IMuBcWjpvsW5gB9zjhuMm+cQy4FxGOm+xbhAH3opbe1F2U6abuYn05DWa4qbu48Ju6hHvxvjEHY9ZlsZVuvs7NUGRL1OimbtobnchcWrIv7kZpUqx1GJbCfJAvhxnHKeXzxXymlM0WSyVzw7pY1OZS4PnGAeaqypuf4uRzXsbLlEqqqHNB+M8N08UTbupqlctnc34hND/A+MQxR0KZchga/Ga9wC3kVLaYdYq5TJDzQgNLl4wHgmzeCd2y72hnHqAPlxK+KZF9SzHUy9LCcZN9SzPgXkY4brJvGQbcywrHTfYty4B7OeG4yb7lGHAvLxw32bc8A+4VhOMm+1ZgwL2icNxk34oMuFcSjpvsW4kB98rCcZN9KzPgXkU4brJvFQbcqwrHTfatyoB7NeG4yb7VGHCvLhw32bc6A+41hOMm+9ZgwL2mcNxk35oMuNcSjpvsW4sB99rCcZN9azPgXkc4brJvHQbc6wrHTfaty4B7PeG4yb71GHCvLxw32bc+A+4NhOMm+zZgwL2hcNxk34YMuDey9ObmRkw3Nzfuy2jwxgw3NzcRfnOTcG/Sd7KDQeuy2Eo3IZdkKLJNa3RzM+0NP2QubdYXd8MwMdbZUIVhMV8ol8rZcqagc8Ws62Tdgpcru0XPKwQqyJjvKBdDxy87TjavzQ/KZjN5L18qlb2loryc4gZxIZ9xy8VixsllXF0OC9ovqkxOB77OqFLg5otOrph3Pc/cmA2cXLlcMhdDc8/WyxuP6MJSQB8WhG9KZF+BoV6KwnGTfUUG3CXhuMm+EgPuQDhusi9gwF0WjpvsKzPgDoXjJvtCBtybC8dN9m3OgHsL4bjJvi0YcG8pHDfZtyUD7q2E4yb7tmLAvbVw3GTf1gy4txGOm+zbhgH3tsJxk33bMuDeTjhusm87BtzbC8dN9m3PgHsH4bjJvh0YcO8oHDfZtyMD7p2E4yb7dmLAPV44brJvPAPunYXjJvt2ZsC9i3DcZN8uDLh3FY6b7NuVAfduwnGTfbsx4N7d0pt8uzPd5NujL6PBezDc5NtT+E0+wr1n38kOBq3LYivdjNuMocj2qtFNvrQ3vpC5tHdf3I2zpFibO5VuwSkUs+Zb3TCbz5j7mtr8CBWa25lkTCbIBgVfucVMzvXDopMvllSmqOjnhcVCvhDl5RQ+LPlhoVjKe242yCoDM+uUnYLK5HXJOESH2s2WVVD0nLJn4Pg5XXKyoS5nzC3TIjmoAPThPsI3JbJvH4Z62Vc4brJvXwbc+wnHTfbtx4B7gnDcZN8EBtz7C8dN9u3PgPsA4bjJvgMYcB8oHDfZdyAD7oOE4yb7DmLAfbBw3GTfwQy4DxGOm+w7hAH3ocJxk32HMuA+TDhusu8wBtyHC8dN9h3OgPsI4bjJviMYcB8pHDfZdyQD7qOE4yb7jmLAfbRw3GTf0Qy4jxGOm+w7hgH3scJxk33HMuA+Tjhusu84BtzHC8dN9h3PgPsE4bjJvhMYcJ9o6c2uE5ludp3Ul9Hgkxhudp0s/GYX4T6572QHg9ZlsZVuSu3NUGSn1OhmV9obQMhcOrUv7gZSUqydcjaTVSr0cvlSYO6SuXTTLOdmS9lsUMw7mUCbe2uO8rK5oBjk89or+25RecYx+TBj7vDtE+XlFDe7HK3Cci6TLRTdUt4NzF24YinMq2LJMXcPM3425yljtXKcIPB9HZrbiYGbVblC0VzP+sE+QB+eJnxTIvtOY6iX04XjJvtOZ8B9hnDcZN8ZDLjPFI6b7DuTAfdZwnGTfWcx4D5bOG6y72wG3OcIx032ncOA+1zhuMm+cxlwnyccN9l3HgPu84XjJvvOZ8B9gXDcZN8FDLgvFI6b7LuQAfdFwnGTfRcx4L5YOG6y72IG3JcIx032XcKA+1LhuMm+SxlwXyYcN9l3GQPuy4XjJvsuZ8B9hXDcZN8VDLivFI6b7LuSAfdVwnGTfVcx4L7a0ps+VzPd9LmmL6PB1zDc9LlW+E0fwn1t38kOBq3LYivdnDmVociuq9VNn5Q3QpC5dH1f3I2UpFgbI4o6dEpOmPFKxqpyoRDmc2EYZgsqyLn5TEn7Jd/NmJtKBc8Nsr75wTqfCdygnCsWPfe0KC8rfagLge+Ebs4s7gV+wTiyoEplg7tYVp6js+WSLuhQGUf75XKxaG6V5YKgnM0VHO0bP5ZPA/rwBuGbEtl3A0O93CgcN9l3IwPum4TjJvtuYsB9s3DcZN/NDLhvEY6b7LuFAfetwnGTfbcy4L5NOG6y7zYG3LcLx0323c6A+w7huMm+Oxhw3ykcN9l3JwPuu4TjJvvuYsB9t3DcZN/dDLjvEY6b7LuHAfe9wnGTffcy4L5POG6y7z4G3PcLx0323c+A+wHhuMm+BxhwPygcN9n3IAPuh4TjJvseYsD9sHDcZN/DDLgfsfTmxyNMNz8e7cto8KMMNz8eE37zg3A/1neyg0HrsthKNymuZyiyx2t08yPtDQFkLj3RF3dDISnW2snnSm7oZDIqW8oog9MpZ1QhHxbLXrYYqFKYKZedQBXCbKgzxgCt/XyggjBjLCkE4Q1RXk7hw6AceL6nCmWnGAS64DqOsVCZRX0vLHmlrBdmVTafLxWyhWypnCk6JS/vedmwFKhi1sncAPThk8I3JbLvSYZ6eUo4brLvKQbcTwvHTfY9zYD7GeG4yb5nGHA/Kxw32fcsA+7nhOMm+55jwP28cNxk3/MMuF8Qjpvse4EB94vCcZN9LzLgfkk4brLvJQbcLwvHTfa9zID7FeG4yb5XGHC/Khw32fcqA+7XhOMm+15jwP26cNxk3+sMuN8Qjpvse4MB95vCcZN9bzLgfks4brLvLQbcbwvHTfa9zYD7HUtvArzDdBPg3b6MBr/LcBPgPeE3AQj3e30nOxi0LoutdFj/BEORvV+rmwApD8aRufRBX9zBemKsC1lz3yDQQd5xSmEp59NftymEpTzd+Mhm/XzRmGh+ih+USpliaL7XN/9YLvilklm8UHwyystKHzo57WSDglYFVQ5ULuPks8orFAsqF2jjzEyhlNM5czkoloOM64fZjEETFPxsJpPJe9n8k0Affih8UyL7PmSol4+E4yb7PmLA/bFw3GTfxwy4PxGOm+z7hAH3p8Jxk32fMuD+TDhusu8zBtyfC8dN9n3OgPsL4bjJvi8YcH8pHDfZ9yUD7q+E4yb7vmLA/bVw3GTf1wy4vxGOm+z7hgH3t8Jxk33fMuD+Tjhusu87BtwTheMm+yYy4P5eOG6y73sG3D8Ix032/cCA+0fhuMm+Hxlw/2TpYfhPTIfhP/dlNPhnhsPwX4QfhhPuX/pOdjBoXRZb6dD6A4Yi+7VGh+FpD4iRufRbX9wBc2KsyyqTy7tlc3ieDbJBPpcrBUXHnP4XQnMbwM2H+bL2lcqFuZzj+NlcOV9y/ZJ2vXJJ+Rk3+2GUl1Mchjs5ZWC7nusWzeG8k9We42eyGT/nlV1fZ819BifrudrLZPNuPmMO73VgPBvmdCbMlYrBh0Af/i58UyL7fmeolz+E4yb7/mDA/adw3GTfnwy4/xKOm+z7iwH3JOG4yb5JDLj/Fo6b7PubAXddP9m4yT6aaNwzCMdN9s3AgLuHcNxkXw8G3PXCcZN99Qy4ewrHTfb1ZMDdIBw32dfAgLuXcNxkXy8G3L2F4yb7ejPg7iMcN9nXhwF3o3DcZF8jA+4m4bjJviYG3M397DwUbgbGK25vSz9Gg1v64ddtBQaQC3drv8kOBq3LYisd3v7GIAZnBJNL+5jiUDjlQSkyl/r2wx20JsVa57ycr0uZQq7gZs1C2ZJbLpWLhVKxlA8LKsw5pUw2dP2c+QffnDWbM/BiJls2ZmScTOg4dJhJeCt9qP0gMEaGmYIXuLmSzpaUzufCYjFb9LNlNyhl88rzwtCY5ga6GHhuKVcMC9l8UApKJgC/Aw+F+wnflMi+fgybUptw3GRfGwPu/sJxk339GXDPJBw32TcTA+6ZheMm+2ZmwD2LcNxk3ywMuAcIx032DWDAPatw3GTfrAy4BwrHTfYNZMA9SDhusm8QA+7ZhOMm+2ZjwD1YOG6ybzAD7iHCcZN9Qxhwzy4cN9k3OwPuocJxk31DGXAPE46b7BvGgHu4pYejw5kOR0f0YzR4BMPh6BzCD0cJ9xz9JjsYtC6LrXSI2ZehyOas0eFo2gNDZC7N1Q934JgUa20WcpSXz/hZ841OzvyXYdErh34h75jD34KBpMKiHzoZgyP0MrpkvtVAdnReFfI66Bfl5RQ+LIaeExin5YO86yvjMWNbqWQOklU5p80hc1Y75VLBHC1ns45WZSefKxt/eKWyF2a9crYf0IdzC9+UyL65GeplHuG4yb55GHDPKxw32TcvA+6RwnGTfSMZcI8SjpvsG8WAez7huMm++Rhwzy8cN9k3PwPuBYTjJvsWYMA9Wjhusm80A+4xwnGTfWMYcI8VjpvsG8uAWwnHTfYpBtxaOG6yTzPgdoTjJvscBtwZ4bjJvgwDbtfSQ0KX6ZAw24/R4CzDIWFO+CEh4c71m+xg0LosttJh3lwMRZav1SFhyoMzZC55/XAHb0mxdsJ81jcrevlCWHTKbjZTzHq50DNnoWG+mC1rnSt6nmMW9dzQ0Zm8kw9zfqh11nxnyS3OHeVljylyqFwuOqVi1vd0OXCzOdcvFMvFoKw8HZTMQWau5OWUDspuxs2X80Ggc45XLDhBoVByM8X83EAf+sI3JbLPZ6iXBYXjJvsWZMC9kHDcZN9CDLgXFo6b7FuYAfc44bjJvnEMuBcRjpvsW4QB96LCcZN9izLgXkw47n/sY8C9uHDcZN/iDLiXEI6b7FuCAfeSwnGTfUsy4F5KOG6ybykG3EsLx032Lc2AexnhuMm+ZRhwL2vpYdmyTIdly/VjNHg5hsOy5YUflhHu5ftNdjBoXRZb6VDLYyiyFWp0WJb2AAmZSyv2wx1AJcY643oFT2W8fDksZXyvmAvoGcGSzvtZp+QFTk75xbIuZrxCJjAHiH6hEPglP1fQga8zKu9HeTmFDwNdLORyBoprbPO1yQrzv7CQ88slpxiY20lOwfwvcI3XCuY8q0C/p+2FgVt2cuWSOYoE+nAl4ZsS2bcSQ72sLBw32bcyA+5VhOMm+1ZhwL2qcNxk36oMuFcTjpvsW40B9+rCcZN9qzPgXkM4brJvDQbcawrHTfatyYB7LeG4yb61GHCvLRw32bc2A+51hOMm+9ZhwL2ucNxk37oMuNcTjpvsW48B9/qWHhqtz3RotEE/RoM3YDg02lD4oRHh3rDfZAeD1mWxlQ53VmQoso1qdGiU9iAFmUsb98MdxCTG2ikFoedoncnmi8WC5/tKh5mwnM8UXHNk5uYNyIKfyytzUlXK0ttMPswE2it7GV/ng5WivJzy0MjPZXNZXQoCv+x6WoduOauLngqCUsF4t+ga68plnXcdVSiUcwVzsqV0ycnpfClX9rIrAX24ifBNiezbhKFeNhWOm+zblAH3ZsJxk32bMeAuCMdN9hUYcBeF4yb7igy4S8Jxk30lBtyBcNxkX8CAuywcN9lXZsAdCsdN9oUMuDcXjpvs25wB9xbCcZN9WzDg3lI4brJvSwbcW1l6eLIV0+HJ1v0YDd6a4fBkG+GHJ4R7m36THQxal8VWOuTYmKHItq3V4UnKAwVkLm3XD3cgkRRrJwzdQsbxHa+UD3UpX/QyTrZQLiuvVA51WWezOh+6uWy5aF4MhNDPBOZkJpd1XfqTuM4mUV5O4UOVCwtF1+DN+cYUh3rKcqHk5b2ik8vli0FGF8NM2fHKGXPck8+5hQJ9c+AXi4H5tw4HHml9uL3wTYns256hXnYQjpvs24EB947CcZN9OzLg3kk4brJvJwbc44XjJvvGM+DeWThusm9nBty7CMdN9u3CgHtX4bjJvl0ZcO8mHDfZtxsD7t2F4yb7dmfAvYdw3GTfHgy497T0EGFPpkOEvfoxGrwXwyHC3sIPEQj33v0mOxi0LoutJPa3YyiyfWp0iJBWWCNzad9+OGGeFGsnn3HyXlBSGXPcEOpCMZd38lnX8VwnZ5Bnitp18mVPq0IxG7iB5+T9gqccXQ6LgVMsedtHeTnFIYKfoT9RmAvKThhoFRpTg0DlM6HxlK8Kfj4X6pxfMi8qY+zzdcnN57N5g8l1AjdT2B7ow/2Eb0pk334M9TJBOG6ybwID7v2F4yb79mfAfYBw3GTfAQy4DxSOm+w7kAH3QcJxk30HMeA+WDhusu9gBtyHCMdN9h3CgPtQ4bjJvkMZcB8mHDfZdxgD7sMtFdOHM4npI/oxGnwEg5g+UriYJtxH9pvsYNC6LLaS6N2XociOqpWYTikwkbl0dD+cQE2KtWPkuPbKZTefK/nFsKxc+utUQTkoucWwUC7mwryBZJR41nHzYSmXzwR5v+QX8n4uG2jnH6F6ZJKYdvKFTNZzfb9kADvFomuuhEG+kM1ks0FeF72Sdko6n3d9N1SlQqBUIeuFBoNfcMplZz+gD48RvimRfccw1MuxwnGTfccy4D5OOG6y7zgG3McLx032Hc+A+wThuMm+ExhwnygcN9l3IgPuk4TjJvtOYsB9snDcZN/JDLhPEY6b7DuFAfeplorKU5lE5Wn9GA0+jUFUni5cVBLu0y0RlST+jmYosjNqJSpTCi1kLp3ZDyfUkmLt+MZ8t6jzWvthif6oia893zP/beiXc3m/XDaoyl4+UOWc75VzGV32smHRyWQCXTDq9ZgoL6cQlTmje31jjNL5guuocrFYLpaMzcrL53U5k6FPrvRLquAF5mZyoah16PvZsjbfU8762jkG6MOzhG9KZN9ZDPVytnDcZN/ZDLjPEY6b7DuHAfe5wnGTfecy4D5POG6y7zwG3OcLx032nc+A+wLhuMm+CxhwXygcN9l3IQPuiywVVxcxiauL+zEafDGDuLpEuLgi3JdYIq5IBJ3JUGSX1kpcpRQcyFy6rB9OsCTF2tFuLqezmXLBLeRVKSh6vtJGJxYy5VxWl/OuUpliWeXygWts08VioWDuAoZOwQvLBS/jnhXl5RTiKtRGjZqbmDkDPswWQ+NIp6TKQeAXzWrZspdRTsHVYSnvGWOznp8p5MOCdg24bL5UPgvow8uFb0pk3+UM9XKFcNxk3xUMuK8Ujpvsu5IB91XCcZN9VzHgvlo4brLvagbc1wjHTfZdw4D7WuG4yb5rGXBfZ6nIuI5JZFzfj9Hg6xlExg3CRQbhvsESkUFi4DKGIruxViIjZeONzKWb+uEa96RYO14x4/laZ4o60CXHLeVLBSebK5Yd19z9KZRKOYMuG7rayXn5ck7li27ZpztHxWyB/kT95VFeTiEy8kVVyuaM6NKu5ypzR8nLOcot+GEmF4bGXJ33XSfrGrNV6GRUyRib077Omx+bL+RzlwN9eLPwTYnsu5mhXm4Rjpvsu4UB963CcZN9tzLgvk04brLvNgbctwvHTfbdzoD7DuG4yb47GHDfaWmzfSdTs31XP0aD72Jotu8W3mwT7rstabapKb6JocjuqVWznbIBRebSvf1wDWxSrLWfD7TKZzNGQfg584VnFnO17/uOZ7r0QBVynu+UMyWnlHdccychF2QK5m5GJptzyvnwn0bx7oRmWxtBkAnCoECfpOH7OgizpbK5HWHuffgGo9JBqZjN5txiLiQH+765PWJEQalY8APjGn0z0If3Cd+UyL77GOrlfuG4yb77GXA/IBw32fcAA+4HheMm+x5kwP2QcNxk30MMuB+2tOl8mKnpfKQfo8GPMDSdjwpvOgn3o5Y0ndQc3stQZI/VqOlM24ghc+nxfrhGLinWuuSWMqalNu2r76usOT1WmVzBVZm8uVzIFcraC3TguFknMAsHps12S2HBKwflvAqDkndflJdT+NA1P9F1g2xReSosFah3D4r5nOsXjf3GvlwhVyo6rpMrZxy3WA6Kvmv65qzWXqicTOE+oA+fEL4pkX1PMNTLk8Jxk31PMuB+Sjhusu8pBtxPC8dN9j3NgPsZS5uvZ5iar2f7MRr8LEPz9Zzw5otwP2dJ80VN0uMMRfZ8rZqvlA0JMpde6IdraJJi7eT8UBcLJXOWmDPHiXlHB56TLfgZehY4a04+S7qoM04pzDnmNDNP54zmiNFVRdctlIOM80SUl1PcXvdLWfOf5Qz+op8J6LFoz1EqcPMlVXQKvl8yTqQ/4pPxymVzspoplwPX/CeZYjGrnaBDw5TWhy8K35TIvhcZ6uUl4bjJvpcYcL8sHDfZ9zID7lcsbUJeYWpCXu3HaPCrDE3Ia8KbEML9miVNCDULLzAU2eu1uu2YcmNG5tIb/XAbe2KszSmSwadKhVy2rEzbUjQ/P5dX5ZLpusxhl1cuZculXD7n5Ap5NzQnX6VSuVgy/0FoLA7zL0Z5OYUPtfIcc7dWm7aoGLplXcqVjZvMUVUQZJVX8v1cEJqfZe6JlsOi7xW1zhp8pn0yDsup4otAH74pfFMi+95kqJe3hOMm+95iwP22pZvx20yb8Tv9GA1+h2Ezflf4Zky437VkM6ZN8w2GInuvRptx2g0KmUvv98NtcImxzmZUYH6u9vLm6EDRym4h7+XKhUDnfCcXZANazlhbcHI5L1cIs67rueZulOsUtOe8GeXlFJtxMZPJB8ZE07m4oeOUSwZg2Ql9s0LZ3N3KOjknn8nlQk/nVUGZXsYzpxpuwfQ5QbbsddhA0/rwA+GbEtn3AUO9fGjppvQh06b0UT9Ggz9i2JQ+Fr4pEe6PLdmUaPN4n6HIPqnVppSSqJG59Gk/HNF3JdbFTMkN8n7g6oKv81mvVHT9Uiar8yWzrbmFrGN23lA7mZzywpJfKn0Q5WWPTmKtXK+YK2sDLPBcbVxQKhccN8yFgbG4WC45Ge0oN29WzZt7ApncB0AffmYpOX/GRM6f92M0+HMGcv5CODkT7i8sIWci0U8ZyPnLWpFzxZhWwkLm0lf9cISXFGtETL5iiPXX8XunXsYxuw59nxco7QYlx3OcoOgqc5xacsq+q/3QddxMKSgVzZoFHaqwUPJD79+1akmoXzMR6jf9GA3+hoFQvxVOqIT7WwZCpWRrqptMKkmj/WelTWwOv7QXNNov8WT+LpZvcOb4FleBmmyrj2xsN7pn7Fo1DCrdYAtCPCknRut/T7g4gvAdA6t8x3z4g8LdWUsxjaMD7rQ2/iD8AI0S8weGluJH8NbcTgK07oRoXbQvvmfyxU9MvviJ0RdcrebPwjmFqx6+G/pfxV3qxD623J84VDb/EeafOfaQoUCOBvqQGiqaXemYO1urs5yKr8mxb6F8Em8uf5lat6zSDf0D00YQN3oabdad/Ryy+RcGYvgBTAzto+c0xmxaGri0mH/tJ5NgkLGI5+WvsQZleuPTmc+R8fktfg6WyZjaCPI6DMJMNu87RZ2jezFumM95bmBuERWCfFm7hYzj068z0B+Kymcz9Kd8/aCUC+OkrYNMxg38YkmbWzqFovKCTEGFbj7jqEJgbgEFGS+XK2QyQc4LPd+cShTCjKey+byvck7Gd7ji81tCfKZ1I+zs2AQZn9+Z+PN3gB86O15C+uEPJj/8Eflhak2C5I08wVxYHsebhD9tbBL+ZG4S/uQ4RahRk9CZeqolyf0FXAvZJPzItAn91YUmoTM/mATVJa1C5ZsdVeVLuXzRD5yiZ/bRMJsJMsj4TOqH29iRTQJXfCalOGXqrG7aT3DrsfU4LffDOl0LeRr8dz/shtQeo79TxKizxmU6Y9RpTU7LPcvO1kLGqK4N57t4jGjdCXXJt7TqpjN2nZmHPG2NN4MztP372qMt4XaWSjd0tds6yHuVqTdWoJLnCPz0Fu1/y4dp16pvkx0PKhiyEd0g92zj2fR7tvHdWurB5IsGJl80TMUXaW3myoufhd9u4sqBX4TfbqINmXCjbzcB461/6b7dVDn+4W+UT+KNX682xpOkeiZCjBuNPkkim3sxEMOvltxuiscsLebebTIJ5lemk4rebfy3m5Dx6dOGu930C/AkiSs+fdo6v71QN43x6spTu+3Dlk2h0cZNoZF5U2hk2BR+E7IpVE3ifPjPQJJOk9BN4Tcm0mkCbAqdHfMh49MsdFPgik9zbFOo1e8N/Yz7fScdt7eljdHglgTZmNb4FiAZtAKLgMuHrQmbSFoftrZhNxGODZ9sRB8FI0kPmTszgo+C2wf6dsTPwOPvvsw5iMiVpBxU6QaymYXyVz9wPODHhSb3gDZqqrm+DA16G1is9KmbnIP09UgzJ0Xv6WdNwvr5n5/ZI/bzzm6d/PPOid73Nz93JjNnbm8eYt+PjPnMQF9SszYo5ktOu/uDa6lyYNZ2+NbWk08H6HV49H4W45cBZs5q5kAzB5k5m5mDzRxi5uxmDjVzmJnDzRxh5hxmzmnmXGbObeY8Zs5r5kgzR5k5n5nzm7mAmaPNHGPmWDOVmdpMx8yMmW5bZEx7F0/G9Km4NiDh2qwJ1wYmXBuUcG22hGuDE64NSbg2e8K1oQnXhiVcG55wbUTCtTkSrs2ZcG2uhGtzJ1ybJ+HavAnXRiZcG5Vwbb6Ea/MnXFsg4drohGtjEq6NTbimEq7phGtOwrVMwjU3uhYfI6LXxaJXlW50IJ20m9gsgLXK/5wDKT0AtBZhnBWy1r/+Gph+Laf9Pt6gtGu5k+8JzpZuLRW/vzg4zVpOx3uVQ6Z/LVV533P26VzLHBJNcQ916PSt5SXdjx02PWt5yfd2h0/7Wvlq94lHTOta+er3nOeYtrWcqd2/nnNa1spP/V74XF1fq9NnNebu6lr5TrlQz9O1tVQXeFXP25W1VJc4Wo/sfK1sF/lej+psLbfLe4eeb6pr0SfYdn2t+ae2Vn6a9jS9QPW1vGncH/XoKmv54TTvtXpM8lpqOvZtPTZpLTVdPYBWU66lp7Of0LpyrWC6exPtdFwrk6LP0ZnYWk6YqmfSLlD0Ud+4a91k4eRGIsaJRI2KRM6YSPQsEImg+SJRNDISSfNEommuSETNEYmq4ZHIGhqJriGRCJstEmUDI5FGvRv1gjRqebfDhfWfQYe7Hdk2RoNpcdSJa7vxWVxS6RxQIHD5kGxEnci1+zAHLEwqgoF1tfk1UxyhBKwnPXFf5KMC8ypPW/JRYOPXvARVjD5uxzGJ0nlgAXng4KKTj4omDyzGdtx5cDHWakfKwPLID+L2+m2MBvvwHckPfOCOtKDwHYl8uCB8R/KDBS3dkTIwu/1SgrksO9JCUYEtXLkjLZSwIy1cgx0pA9yRFgIW0MJMwUU/hIDEPA5IZnV1+N0yFxEQ+mY6UgosAiSzJB+qdENTjBdh6GQWsbSTcWD8U8zE7V20jdHgReGdTDGzKLD4FxPeyfwTdHgnU8wsxlz8CAJdRDiBLg72YftAb7zIHF8CWHu17IAdmN1FJ8Fclg54yYiYl6rsgJdM6ICXqkEHjNuBlF4SmJRLMQUXXYhIzEszd8Aq3dBEjkswdG/LCO9aKS7LWICbK8eXAeb4ssJzvFqTgmh+UGstB96wa6V2NGyv8cK4vcu3MRq8PFzteOHywACuIFztkA9XgKsdL1xBuNoholuuTTYZrwgm4/aBxozM8ZUsVTsaZrdXTjCXRe2sHBHzKpVqZ+UEtbNKDdQObgdSemVgUq7CFFx0ISIxryq8EyRyXImh619NuNqhuKxmAW6uHF8NmOOrC8/xak2KSjc0sklZw9J7Owq21zgdPt5nzTZGg9eEqx1HrQksgrWEqx3y4VpwteOotYSrHSK6Ndpkk/HalqgdZI6vY6naUTC7dZhgLovaWTci5vUq1c66CWpnvRqoHdwOpPS6wKRcjym46EJEYl5feCdI5LgOQ9e/gXC1Q3HZwALcXDm+ATDHNxSe49WaFJVuaGSTspGlamcsbK8JOqidjdsYDd4YrnYCtTGwCDYRrnbIh5vA1U6gNhGudojoNmqTTcabWqJ2kDm+maVqZyzM7lLN1E4hIuZipdopJKidYg3UDm4HUroATMoiU3DRhYjEXBLeCRI5bsbQ9QfC1Q7FJbAAN1eOB8AcLwvP8WpNiko3NLJJCS1VO2Nge02uw2dibN7GaPDmcLWT05sDi2AL4WqHfLgFXO3kOuBWKUcSbgTRhW2yyXhLS9QOMse3slTtjIHZnavZZ6lsHRHzNpVqZ+sEtbNNDdQObgdSemtgUm7DFFx0ISIxbyu8EyRy3Iqh699OuNqhuGxnAW6uHN8OmOPbC8/xak2KSjc0sknZwVK1Mxp3b8eL27tjG6PBO+Lv7Xg7AotgJ+Fqh3y4E/7ejreTcLVDRLdDm2wyHm+J2kHm+M6Wqp3RMLuDfIK5LGpnl4iYd61UO7skqJ1da6B2cDuQ0rsAk3JXpuCiCxGJeTfhnSCR484MXf/uwtUOxWV3C3Bz5fjuwBzfQ3iOV2tSVLqhkU3KnpaqnQVge43rx+3dq43R4L3gasf19wIWwd7C1Q75cG+42nH9vYWrHSK6Pdtkk/E+lqgdZI7va6naWQBmt+slmMuidvaLiHlCpdrZL0HtTKiB2sHtQErvB0zKCUzBRRciEvP+wjtBIsd9Gbr+A4SrHYrLARbg5srxA4A5fqDwHK/WpKh0QyOblIMsVTvzw/aaYocn2Q5uYzT4YLjaKeqDgUVwiHC1Qz48BK52ih1wq5QjCTeC6A5qk03Gh1qidpA5fpilamd+mN3Fmj3JdnhEzEdUqp3DE9TOETVQO7gdSOnDgUl5BFNw0YWIxHyk8E6QyPEwhq7/KOFqh+JylAW4uXL8KGCOHy08x6s1KSrd0Mgm5RhL1c58OLVTitt7bBujwcfi1U7pWGARHCdc7ZAPj8OrndJxwtUOEd0xbbLJ+HhL1A4yx0+wVO3Mh2uIiwnmsqidEyNiPqlS7ZyYoHZOqoHawe1ASp8ITMqTmIKLLkQk5pOFd4JEjicwdP2nCFc7FJdTLMDNleOnAHP8VOE5Xq1JUemGRjYpp1mqdkbhnmQrxu09vY3R4NPxT7IVTwcWwRnC1Q758Az8k2zFM4SrHSK609pkk/GZlqgdZI6fZanaGYV72KmQYC6L2jk7IuZzKtXO2Qlq55waqB3cDqT02cCkPIcpuOhCRGI+V3gnSOR4FkPXf55wtUNxOc8C3Fw5fh4wx88XnuPVmhSVbmhkk3KBpWpnJGyv8Tp8AvWFbYwGXwhXO566EFgEFwlXO+TDi+Bqx1MXCVc7RHQXtMkm44stUTvIHL/EUrUzEmZ3vmafQH1pRMyXVaqdSxPUzmU1UDu4HUjpS4FJeRlTcNGFiMR8ufBOkMjxEoau/wrhaoficoUFuLly/Apgjl8pPMerNSkq3dDIJuUqS9XOvExq5+o2RoOvZlA7VwOL4Brhaod8eA2D2rlGuNohoruqTTYZX2uJ2kHm+HWWqp15LVQ710fEfEOl2rk+Qe3cUAO1g9uBlL4emJQ3WKJ2kJhvFN4JEjlex9D13yRc7VBcbrIAN1eO3wTM8ZuF53i1JkWlGxrZpNxiqdqZB7bXFDp8JtutbYwG3wpXOwX/VmAR3CZc7ZAPb4OrnYJ/m3C1Q0R3S5tsMr7dErWDzPE7LFU788DsLtTsM9nujIj5rkq1c2eC2rmrBmoHtwMpfScwKe9iCi66EJGY7xbeCRI53sHQ9d8jXO1QXO6xADdXjt8DzPF7hed4tSZFpRsa2aTcZ6namRundty4vfe3MRp8P17tuPcDi+AB4WqHfPgAXu24DwhXO0R097XJJuMHLVE7yBx/yFK1MzeuIc4kmMuidh6OiPmRSrXzcILaeaQGage3Ayn9MDApH2EKLroQkZgfFd4JEjk+xND1PyZc7VBcHrMAN1eOPwbM8ceF53i1JkWlGxrZpDxhqdqZC7bXBB3u7TzZxmjwk3C1E/hPAovgKeFqh3z4FFztBP5TwtUOEd0TbbLJ+GlL1A4yx5+xVO3MBbM7qNm9nWcjYn6uUu08m6B2nquB2sHtQEo/C0zK55iCiy5EJObnhXeCRI7PMHT9LwhXOxSXFyzAzZXjLwBz/EXhOV6tSVHphkY2KS9ZqnbmhO01pXLc3pfbGA1+Ga52SuWXgUXwinC1Qz58Ba52SuVXhKsdIrqX2mST8auWqB1kjr9mqdqZE2Z3KUgwl0XtvB4R8xuVauf1BLXzRg3UDm4HUvp1YFK+wRRcdCEiMb8pvBMkcnyNoet/S7jaobi8ZQFurhx/C5jjbwvP8WpNiko3NLJJecdStTMHbK/RHe7tvNvGaPC7cLWj/XeBRfCecLVDPnwPrna0/55wtUNE906bbDJ+3xK1g8zxDyxVO3PA7NY1u7fzYUTMH1WqnQ8T1M5HNVA7uB1I6Q+BSfkRU3DRhYjE/LHwTpDI8QOGrv8T4WqH4vKJBbi5cvwTYI5/KjzHqzUpKt3QyCblM0vVzgjYXlPsoHY+b2M0+HO42in6nwOL4Avhaod8+AVc7RT9L4SrHSK6z9pkk/GXlqgdZI5/ZanaGQGzu1gztfN1RMzfVKqdrxPUzjc1UDu4HUjpr4FJ+Q1TcNGFiMT8rfBOkMjxK4au/zvhaofi8p0FuLly/Dtgjk8UnuPVmhSVbmhkk/K9pWpnOGyv8by4vT+0MRr8A1zteN4PwCL4UbjaIR/+CFc7nvejcLVDRPd9m2wy/skStYPM8Z8tVTvDYXZ7+QRzWdTOLxEx/1qpdn5JUDu/1kDt4HYgpX8BJuWvTMFFFyIS82/CO0Eix58Zuv7fhasdisvvFuDmyvHfgTn+h/Acr9akqHRDI5uUPy1VO8Nge43bQe381cZo8F9wteN6fwGLYJJwtUM+nARXO643SbjaIaL7s002Gf9tidqB5nh/O9XOMFis3JqpnRn6R/nQv66jsqF/qFQ79E3cage3Ayk9Q39cUvbozxNcdCEiMdf3x5IPuuCIHOv64zeGnv15Ny6VbmiKS08LcHPleE9gjjcIz/FqTYpKNzSySekFzJtaqp2hsL3G13F7e/dnNJgWx6odX/cGFkEfYHFy+bBPf7Ta8TvgVilHEm4E0fXqL5uMG8Fk3D7QmJE53mSp2hkKUzu+SjCXRe00R8TcUql2mhPUTksN1M5QoNppBiZlS3+e4KILEYm5VXgnSOTYxND1zyhc7VBcZrQAN1eOzwjM8b7Cc7xak6LSDY1sUvpZqnZmh+01eRW3t60/o8FtcLWTV23AIugvXO2QD/vD1U5e9Reudojo+vWXTcYzWaJ2kDk+s6VqZ3aY2smFCeayqJ1ZImIeUKl2ZklQOwNqoHZmB6qdWYBJOaA/T3DRhYjEPKvwTpDIcWaGrn+gcLVDcRloAW6uHB8IzPFBwnO8WpOi0g2NbFJms1TtDMF9SkGHT6Ae3J/R4MFwtVMsDwYWwRDhaod8OASudorlIcLVDhHdbP1lk/HslqgdZI4PtVTtDMH9InvNPoF6WETMwyvVzrAEtTO8BmpnCFDtDAMm5fD+PMFFFyIS8wjhnSCR41CGrn8O4WqH4jKHBbi5cnwOYI7PKTzHqzUpKt3QyCZlLkvVzmDYXuN0uLczd39Gg+eGqx1HzQ0sgnmEqx3y4TxwteOoeYSrHSK6ufrLJuN5LVE7yBwfaanaGQxTO7pm93ZGRcQ8X6XaGZWgduargdoZDFQ7o4BJOV9/nuCiCxGJeX7hnSCR40iGrn8B4WqH4rKABbi5cnwBYI6PFp7j1ZoUlW5oZJMyxlK1MxturynF7R3bn9HgsXC1o0pjgUWghKsd8qGCqx1VUsLVDhHdmP6yyVhbonaQOe5YqnZmw32iRDHBXBa1k4mI2a1UO5kEtePWQO0AdyCdASal258nuOhCRGLOCu8EiRwdhq4/J1ztUFxyFuDmyvEcMMfzwnO8WpOi0g2NbFI8S9XOINhek+vwJJvfn9FgH652cmUfWAQLClc75MMF4WonV15QuNohovP6yybjhSxRO8gcX9hStTMI93s7NXuSbVxEzItUqp1xCWpnkRqonUFAtTMOmJSL9OcJLroQkZgXFd4JEjkuzND1LyZc7fwTFwtwc+X4YsAcX1x4jldrUlS6oZFNyhKWqp2BsL1Gd/hMtiX7Mxq8JFztaL0ksAiWEq52yIdLwdWO7oBbpRxJuBFEt0R/2WS8tCVqB5njy1iqdgbinmSr2WeyLRsR83KVamfZBLWzXA3UzkCg2lkWmJTL9ecJLroQkZiXF94JEjkuw9D1ryBc7VBcVrAAN1eOrwDM8RWF53i1JkWlGxrZpKxkqdqZFfgnUuL2rtyf0eCV++PXXUW4QiHcq/Sf7GDQuiyqgghlpf6ySW9VS1QFMi9XYyZ6RExWY8jxWhLqACZCXb0/o8GrMxDqGsIJlXCvUSNCVemGpsJYoz9PwaFw17LIZgH+7ZC4vWv2ZzR4TYYdcU0go68lvGDJh2sxFMFaws9oqUjXYpA/qwLjvbbw4wLKnbWZyL59oGt7bWB81hEu8aspBpVuaKRiWFd4jlOM12Vo5JB5WMsmYaZYk6C9jOPkM2STFyjtBiXHc5yg6KqSKpScsu9qP3QdN1MKSkVjf0GHKiyU/ND7d624vev1ZzR4vYQiSGv8esDiX194k0A+XD+hCNL6cH1wp9xUV5sbcjMx/f34Oqx/O3ThG8TiB++mgIHU8RuDcaOn0eZSV5Jvg+nYHTtz+gbAYt4QWCBxv9K6E6YzF8yNXl3SKlS+owoqX8rli37gFL1CmAmzmSAzvX7tLNmRft2Iya8bRX7tGbtWOSSTUZw8N4525E2oBjkIYwOGtmoD4bJzeotDTQPutDZuKrwlp8TclOHIYjMmUthsKmSr0g29CZMvCky+KKTYeDqzmSsvWob9Vzml1Il9bDnQOkw2D9DGtykDlwLjrZE+pKaCZpLCqZtGH3SWU/E1Ofgb5ZN4g1WcmsJR6YbelIkQi1NROJ0sozv7OWRzkYEYZgQTQ/voOY0xm5ZGJi3mUn+ZBIOMRTwvS7GNenrj05nPkfEJYmvpTMbURpDXYRBmsnnfKepcJpcL3TCf89wgzLqFIF/WbiHj+OW8CrVXLuezmVI+F/pBKRfGSVsHmYwb+MWSzjq5QlF5QaagQjefMeI3yOSDIOPlcoVMJsh5oecbwWpksKey+byvck7Gd7jiE8SUJmpT6OxkI76mLZtC2cZNocy8KZQZNoW+QjaFqkmc/+fh/RBJOqHQTaEvE+mEgE2hs2M+ZHw2F7opcMVn8/9Hx49bRMePWyYdP6p0o+rZP/I+SNq1gEeZLE8XtPuw3hIfpl1rK+HxoILZimFj35qpydma8Vh0SyZfbMPki20Yj0W58qJN+LEoVw70t+BYdCuGY1FgvHX/7mPRyvEPf6N8Em/8tuVUwFsxEeK2jAqYbN6WgRhmsuRYdCtgU7Rdf5kEMxOTwtquBseiyPhsD1TA/YEKmCs+2yfEB/2AFzI+OzDx5w4AP3R2UoP0w45MftixC8fkkjfyBHNheRxvEnaysUnYiblJ2ImhSZi5Rk1CyqdjoSQ3HrgWskmYmWkTGt+FJiHtU7bI+OzcH7exI5sErvjszHja4kbqG/3xVS7s46s8jcydXWDc7nWIEa1LHwlGG/audVMOkF//w6HoPW/Gevk27opuVHowFRMKMK216/9Qce4GLE7mQtT/y4W4G7IQbWXMERYEavfuQCm9Xi/5Nu7RHSilsxZU1J7dgVJ6rAWB2qs7UEpvZAH17d0dKKU3sSBQ+3QHSunNLAjUvt2BUrpoQaD26w6U0oEFgZrQHSilQwsCtX93oMwNXQsCdUB3oMz5rgWBOrA7UEpvY0GgDuoOlNLbWRCog7sDpfR4C46QDukOlNI7WlBRh3YHSukrLKiow7oDpfTOFlTU4d2BUnpXCwJ1RHegzG1uCwJ1ZHegzN1TCwJ1VHegzE05CwJ1dHeglH7Qgq7vmO5AmXs9FlTUsd2BMrcQLAjUcd2BMifTFgTq+O5AmQNPCwJ1QnegzDmaBYE6sTtQ5njGgkCd1B0oo/otCNTJ3YEyYtKCQJ2CDBT9gm/fusm/W0bGjqgIWg8wAK7fO1OphqfQOMm2DPCv09J6u/eX/etBHD50wD7cg8GHewj3oQb7cE8GH+4p3IcK7MO9GHy4l3AfjgX7cG8GH+4t3IdjwD7ch8GH+wj34WiwD/dl8OG+wn24ANiH+zH4cD/hPpwf7MMJDD6cINyH84F9uD+DD/cX7sNRYB8ewODDA4T7cCTYhwcy+PBA4T6cF+zDgxh8eJBwH84D9uHBDD48WLgP5wb78BAGHx4i3IdzgX14KIMPDxXuwznBPjyMwYeHCffhHGAfHs7gw8OF+3AE2IdHMPjwCOE+HA724ZEMPjxSuA+HgX14FIMPjxLuw6FgH/4fe9cBH0X1/I/eIUBCGoHQpNh271LurNi7KE1ABJJcDlSs2BXFBkqVXhTsir33jr2jIs2u2Hvv+J8nt+FleTkS7jv3f+Pv9vP5kmX2bm7ezLx539nd25vG4MNplvuwAOzD6Qw+nG65DzuCfTiDwYczLPdhPtiHlzD48BLLfZgH9uFMBh/OtNyHuWAfzmLw4SzLfZgD9uFsBh/OttyH2WAfzmHw4RzLfdgB7MO57ey+W5HDh1lgH85rZ/mNhL4NozdUEjBsGN1Bl0/3xpxSMcuI788nfy8gLCQsIlxKuIywmLCEcDnhCsKVhKsIVxOuIVxLuK7dBh3Xt4sr9X5xQikt9MkWGGQLDbJFBtmlBtllBtlig2yJQXZ9XKY29EQL+X5oAXWDZV1/Gi+xlRt+ECJZG9UNr2EH+qtU1W78TNZ3S0F2qR9y0vNnqZY/AY48cqvbnqwfbgAWVd0PNzDOoyDDPFI3xKJ/sAR4k617A3C8NzLF/MYU5P6NQD/cxOSHmxhz32XI/TMYch94c7R7E3C8NzPF/Gbu3Cc/zLfUD0pHQ/BYt0f+KJX6HUrQvNnwRZ4NvOZM8Dw8Cz0PadzAG+yr3Wie7HhvYZqHt6RgDboF6IdbmfxwK+MatB3DGjSeYQ0C3tTv3goc721MMb8tBbl/G9APtzP54XbG3N+WIffPZsh94Jcx3NuB472DKeZ3pIB/LbDUD0oHmn9tDeZf2zDwr3PA83ACA/8CfqGn2hdbkh3vnUzz8M4UrEF3Av1wF5Mf7mJcg/owrEHnMqxBwC8RuXcBx3s3U8zvTkHu3w30wz1MfriHMfd7M+T+eQy5D/zyl3sPcLz3MsX83hTwr4WW+kHpQPOvnmD+1YuBf50PnocXMPAv4BcIq32RLtnx3sc0D+9LwRp0H9AP9zP54X7GNWgrhjXoQoY1CPilRfd+4HgfYIr5AynI/QeAfniQyQ8PMuZ+D4bcn8iQ+8Avm7oPAsf7EFPMH0oB/1pkqR+UDjT/6gbmX90Z+Nck8Dy8iIF/Ab+wXO2Lu8mO92GmefhwCtagh4F+eITJD48wrkFdGdagixnWIOCXpN1HgON9lCnmj6Yg9x8F+uExJj88xpj7XRhyfzJD7gO/3O4+Bhzv40wxfzwF/OtSS/2gdKD5V2cw/ypk4F9TwPNwKgP/Aj4godqDApId7xNM8/CJFKxBTwD9sIzJD8sY16BODGvQNIY1CPhQBncZcLxPMsX8yRTk/pNAPzzF5IenGHO/gCH3pzPkPvBhGu5TwPE+zRTzp1PAvy6z1A9KB5p/5YP5V0cG/jUDPA8vYeBfwAeyVHswSbLjfYZpHj6TgjXoGaAfnmXyw7OMa1Aewxo0k2ENAj4Exn0WON7nmGL+XApy/zmgH55n8sPzjLmfy5D7sxhyH/jwHvd54HhfYIr5CyngX4st9YPSgeZf2WD+lcPAv2aD5+EcBv4FfABUtQchJTveF5nm4YspWINeBPrhJSY/vMS4BnVgWIPmMqxBwIdOuS8Bx/syU8xfTkHuvwz0wytMfniFMfezGHJ/HkPuAx8W5r4CHO+rTDF/NQX8a4mlftDHXA885ssBYy4v26CL084rhPjzSiF2XiXEzquF2HmNEDuvFWLndUA7Ve+qHvqo/6h2RqD6hrZ/PoOf0TYuEGDjQgE2LhJg46UCbLxMgI2LBdi4hKnGI2wMlYRZ9HLZm9b739KL0x0MMup2vZqgc5XlNK9fI7xOeIOwgvAmYSVhFWE1YQ1hLeEtwtuEdwjvEt5rF6j+IOjl7TZ9OPRrBtnrBtkbBtkKg+xNg2ylQbbKIHvXIHsvLlOELiew8QSAvqGL6ep21iejevyjo/vi/XYb/n7gD7o64Ge+6DNTq0FXYZSu94FnZD4Q0vlIsXONEDvXCrHzLSF2vi3EzneE2Imol+WRf1l1tTOw/rPjydZP4BkNdzlTbNBjBp4hcV8TMmbgGRf3dSFjBp7Bcd8QMmbgGSF3hZAxA88wuW8KGTPwjJW7UsiYgWfA3FUpGrOzZZvr7bwL7JU+ZLqKr+sF+8Hb3PeAsf8QdUdhZSyij7keON/XAcZsOjOLtvNjgJ0lZU6ksqSklNPOTwB2lpeXlJZVhos57fwUEfeKkspYqDTIaednADvLiotiseJQGaednwPsLHadyuJgaYzTzi8AdkbKneKScLiC084vAXa6sXAoGikr57TzK0TcyyudiqgbUba1D2z6a5D6r0Dqv/6o/+qj/muP+q886r/uqP+q4zptv3WDLd/XT7a/p+1/rO1/ou1/qu1/pu1/ru1/oe1/qe1/Fd//mv5+Q/iW8B3he8IPhB8JP7XbcJI/N7Dx/HSi+DvJbe7X9p/kV1sRm253A0/zfOt92+Nn8ssvhF8Jv/kvJqiDTX2yXwyyXw2y3+IyfWuEdVa1oCZbIH5GEcGY4/4CvEDyK0TXBn/9Br7lKlWT95v05DVO3t/JL38Q/iT85Z+8vxsm5R8G2Z8G2V8pmLzfACfv78DJ+wdw8v4JnLx/CZ2836Ynr3Hy/k1+WU/4R01cj056E/Bvw6Rcb5D9Y5ApZdyT91vg5P0bOHnXAyfvP8DJq2IC8n1KJ+936clrnLz1KJ71CQ0IDf2Tt177TSdlfYOsgUHWMAWT9zvg5K3XHjd567fHTd4G7XGTt6HQyft9evIaJ28jimdjQhM11/yTt5FhUjY2yJoYZE1TMHm/B07eRsDJ2xg4eZsAJ29ToZP3h/TkNU7eZhTP5oQWhJb+ydvMMCmbG2QtDLKWKZi8PwAnbzPg5G0OnLwtgJO3pdDJ+2N68honbyuKZ2tCG0KGf/K2MkzK1gZZG4MsIwWT90fg5G0FnLytgZO3DXDyZgidvD+lJ69x8raleLYjtCdk+idvW8OkbGeQtTfIMlMweX8CTt62wMnbDjh52wMnbyZw8nrJdEUAnKi0NU3rS+tL60vrS+tL60vrS+tL67NZn+tx/9uabuwDbtX2b9H2b9b2b9L2b9T2b9D2l2r712v712n712r712j7V2v7V2n7V2r7V2j7l2v7S7T9xdr+Zdr+pdr+Im1/oba/QNufr+3P0/bnavtztP3Z2v4sbX+mtn+Jtv9Ds43732v732n732r732j7X2v7X2n7X2r7X2j7n2v7n2n7n2r7n2j7H2v767T9j7T9D7X9D7T997X997T9d7X9d7T9t7X9t7T9tdr+Gm1/tba/Sttfqe2/qe2v0Pbf0PaLW2zcL9L2Q9p+UNt3tX1H299e299O299W299G299a2++j7ffW9ntp+z21/a20/R7afndtv5u231Xb76LtF2r7nbX9Ttp+gbbfUdvP1/bztP1cbT9H28/W9jto+6e13Lh/qrZ/irZ/srZ/krY/Tts/Uds/Qds/Xts/Tts/Vts/Rtsfq+0fre0fpe0fqe2P0fZHa/sxbb9S249q+xXafrm2X6btj9L2R2r7I7T9I7T94dr+4dr+MG1/qLbfVDsPpF9K1S+16pdiW2r7+tUb/eqOfvUnQ9vXTxjrJ5T1E86Z2r5+jko/h6Wf4/pNu/FKv/1Zvz1av336L21fv+NSvyNTv2MzoH2WfpOXfhOYfpNYQ/28mrav33fi3Zdye2DDlkX/70DIJuQQcgl5hHxCR0IBoROhM6GQ0IXQldCN0J3Qg7AVoSehF6E3oQ9ha8I2hG0J2xG2JzgElxAkhAhFhGJCCaGUECZECDsQdiTsRNiZsAthV3UuirAbYXfCHoQ9CXsR9ibsQ9iXsB9hf8IBhAMJBxEOJvQjHEI4lNCfMIAwkDCIMJhwGGEIYShhGOFwwnDCEYQRhJGEUYQyQjmhghAlVBJihNGEMYQjCUcRjiaMJRxDOJZwHOF4wgmEEwnjCCcRTiacQjiVcBrhdMIZhDMJZxHGE84mnEOYQDiXcB7hfMIFhAsJEwmTCBcRLiZMJkwhTCVMI0wnzCBcQphJmEWYTZhDmEuYR5hPWEBYSFhEuJRwGWExYQnhcsIVhCsJVxGuJlxDuJZwHeF6wlLCDYQbCTcRbibcQriVcBvhdsIdhDsJdxHuJtxDuJdwH+F+wgOEBwkPER4mPEJ4lPAY4XHCE4RlhCcJT7WPz5NA9YdE9Y3/dZLcmkL1lTvpuvf/X/e852I9Tf9/hvAs4TnC84QXCC8SXiK8THiF8CphOeE1wuuENwgr2m+4INJWy7l62t+c+P6b9LqVhFWE1YQ1hLWEtwhvE94hvEt4j/A+4QPCh4SPCOsIHxM+IXxK+IzwOeELwpeEr9p7A47/fVN3QvzvSoNslUG22iBbY5CtNcjeMsjeNsjeMcjeNcjeM8jeN8g+MMg+NMg+MsjWGWQfG2SfGGSfGmSfGWSfG2RfGGRfGmRfxWUqydoFzEnWOb7/Nb32G8K3hO8I3xN+IPxI+InwM+EXwq+E3wi/E/4g/En4i/A3YT3hH5VQmaSbUJ/QgNCQ0IjQmNCE0JTQjNCc0CLTZ/TXhoF8Y5B9a5B9Z5B9b5D9YJD9aJD9ZJD9bJD9YpD9apD9ZpD9bpD9YZD9aZD9ZZD9bZCtN8j+MchU4PyyegZZfYOsgUHW0CBrZJA1NsiaGGRNDbJmBllzg6xFZu0nQ0t6bStCa0IbQgahLaEdoT0hk5BF6EDIJuQQcgl5hHxCR0IBoROhM6GQ0IXQldCN0J3Qg7AVoSehF6E3oY9/MrQ0DKSVQdbaIGtjkGUYZG0NsnYGWXuDLNMgyzLIOhhk2QZZjkGWa5DlGWT5BllHg6zAIOtkkHU2yAoNsi4GWVeDrJtB1t0g62GQbWWQ9TTIehlkvQ2yPnWYDFvTa7chbEvYjrA9wSG4hCAhRCgiFBNKCKWEMCFC2IGwI2Enws6EXQi7EvoSdiPsTtiDsCdhL8LehH0I+xL280+GrQ0D2cYg29Yg284g294gcwwy1yALGmQhg6zIICs2yEoMslKDLGyQRQyyHQyyHQ2ynQyynQ2yXQyyXQ2yvgbZbgbZ7gbZHgbZngbZXgbZ3gbZPgbZvgbZfnWYDPvTaw8gHEg4iHAwoR/hEMKhhP6EAYSBhEGEwYTDCEMIQwnDCIcThhOOIIwgjCSMIpQRygkVhCihkhAjjCaM8U+G/Q0DOcAgO9AgO8ggO9gg62eQHWKQHWqQ9TfIBhhkAw2yQQbZYIPsMINsiEE21CAbZpAdbpANN8iOMMhGGGQjDbJRBlmZQVZukFUYZFGDrNIgixlkow2yMXWYDEfSa48iHE0YSziGcCzhOMLxhBMIJxLGEU4inEw4hXAq4TTC6YQzCGcSziKMJ5xNOIcwgXAu4TzC+YQLCBcSJhIm+SfDkYaBHGWQHW2QjTXIjjHIjjXIjjPIjjfITjDITjTIxhlkJxlkJxtkpxhkpxpkpxlkpxtkZxhkZxpkZxlk4w2ysw2ycwyyCQbZuQbZeQbZ+QbZBQbZhQbZRINsUh0mw0X02osJkwlTCFMJ0wjTCTMIlxBmEmYRZhPmEOYS5hHmExYQFhIWES4lXEZYTFhCuJxwBeFKwlWEqwnXEK4lXOefDBcZBnKxQTbZIJtikE01yKYZZNMNshkG2SUG2UyDbJZBNtsgm2OQzTXI5hlk8w2yBQbZQoNskUF2qUF2mUG22CBbYpBdbpBdYZBdaZBdZZBdbZBdY5Bda5BdV4fJcD29dinhBsKNhJsINxNuIdxKuI1wO+EOwp2Euwh3E+4h3Eu4j3A/4QHCg4SHCA8THiE8SniM8DjhCcIywpOEpwhP+yfD9YaBLDXIbjDIbjTIbjLIbjbIbjHIbjXIbjPIbjfI7jDI7jTI7jLI7jbI7jHI7jXI7jPI7jfIHjDIHjTIHjLIHjbIHjHIHjXIHjPIHjfInjDIlhlkTxpkTxlkT9dhMjxDr32W8BzhecILhBcJLxFeJrxCeJWwnPAa4XXCG4QVhDcJKwmrCKsJawhrCW8R3ia8Q3iX8B7hfcIHhA8JHxHW+SfDM4aBPGuQPWeQPW+QvWCQvWiQvWSQvWyQvWKQvWqQLTfIXjPIXjfI3jDIVhhkbxpkKw2yVQbZaoNsjUG21iB7yyB72yB7xyB71yB7zyB73yD7wCD70CD7yCBbV4fJ8DG99hPCp4TPCJ8TviB8SfiK8DXhG8K3hO8I3xN+IPxI+InwM+EXwq+E3wi/E/4g/En4i/A3YT3hH5X8WfTZhPqEBlk+oz82DOQTg+xTg+wzg+xzg+wLg+xLg+wrg+xrg+wbg+xbg+w7g+x7g+wHg+xHg+wng+xng+wXg+xXg+w3g+x3g+wPg+xPg+wvg+xvg2y9QfaPQaYSxy+rZ5DVN8gaZG2cDOpamH5Hgbd5E6Nv/K+T3OYCdbH+ekkvoJ31NDsbZsUdnpl2eDU7kQ5ndWiLJnQmpummepP9fuXpnXkc0BA7/tDfjYGPYsnCxWVhJ5wuYCxcveKq8RbG99tpsVH/z6IXrY/vq8ng7bfW5G3i+977GpO+JqqKE5plbZArZAc25ifnXGicxVMlm2cxGlylPIBLZOX0lgZHq61FVg0RH9F4Y2SVYbWJeEt6XStCa0IbLeKtAqmJeEumiGf4Sa8S1IsPrrXAwflthK8XGVlYkoC2T9U6ZWMDcJD0NQPpw6Sfj5DFs2a0ja8Z+ob2aaAJkB8BfdqOYUJy+K9eE541NVn/tQdXa/8K1k5btdpr+/WbbNxv0KT6CpZJr8sidCBkaysYvazq+Sf6ZjNnMZgLrwGcvuBoutA2/tPYfhtbMOUU2s5MIXY2AnMb3cY0EWMIUnIPhIrFkEQsBxePoE7EcuJErGH8/9Ia7MaanbnxHjgv/jc//rdj/G9B/G+nrAQTx0luczPA7MQLVJ52lsWTFcTPdautvm8cST8NPLBhgiH90tFwksJJcjMxuC7auYZcjcHlaftdfecgOiv/EroQumZtlHsbutDkA33bGVhougnpToBFxC0E+q87c3fSTcvh7tp+Fz23s6rndg/6/1aEnoRe/w9nVAtwi2qlbm/vLEaDlXJUUfWM7w1M2j7ApOXyYZ8sHPPzfNiHeYJtry0eHbVJ1UPbd3yLx9Z0bBvCtoTtsqrrQ/o0A+xTL/7bg4s+Ry5tz5BL2zPnUrGWS520/Nk6QS45dMwlBAmhBLmE6PD6ZOF/0hvZ9RRZnpdeF2qzD4uZGpJirXNUj0rwfMDhZ3V7wnFN4XqrXfZ3tnCLN/scp01db0f3bUmc9JT6Ly6WZG1s4T1ZadbG6yxcQQEze8S9GMF48rslwIlUmoVNFo6CXsLQYXPlzjFN8YWzRVOcP8OWLz7Kh8cy+LAl0IcRoA9VnZkb2FjPdiZBJuEtusB2A/1V8VKfp+40SQW8DRzXoFdXwXEtQd7jtoPlc0PVwh0YGqUdgeOuH89n/4b0K4dvd8yy38ad0Daii6w6mwDsblzVyToMCb8z2JHoyxRqogOD/W/h2Jmho9sJSER3kVOEXK4JLqEI7YK28X+RaezKfCOCk9z2b8HYlaHw9k0zDbevgEm+m+WTvOocJTpBzwV/tYfjdMhuDHcI7QZcyXcHFjdkPKSyAgkFY3fbCwYTK4B+x24PAaxgD4aiuyfTxZw949cJpDIFdT7Odhv3Qk58qYHqIiBQe6cD5bhDBHxDYZ90oBy3WMCM2jcdKDpFKyBQ+6UD5bjDBZS+/dOBctwRAgJ1QDpQjjtKQKAOTAfKccsFBOqgdKAcNyogUAenA+W4MQGB6pcOlOOOERCoQ9KBctyjBATq0HSgHHesgED1TwfKcY8VEKgB6UA57jgBp5AGpgPluCcImFGD0oFy3BsFzKjB6UA57kkCZtRh6UA57ikCAjUkHSjHPU1AoIamA+W4ZwgI1LB0oBz3LAGBOjwdKMd9UgDrG54OlOOeI2BGHZEOlOOeKyBQI9KBctzzBQRqZDpQjnuhgECNSgfKcScJCFRZOlCOe7GAQJWnA+W4UwQEqiIdKMedJiBQUWSghD41N6bbW5nFaHBlFvypubFK4Jf9YsBv73L5MAb84qDnwxj4i4O1fWruzlk1P+l0NB0bQziScFQW71NzkT714n+05Q/BUrl0NEMuHc2cSzU9NXd0glwaS8eOIRxLOC6L96m5sSy7n/h6PDA+yo/1A6lZ8HKBdrfS7DwhvuCdGP87Lv73pPjfk+N/T4n/PTX+97T439Pjf8+I/z0z/ves+N/x2hxjKV4gXdW+8T0ua9OnxZ5ikJ1ukJ2lyfyTd4A2eU/QJuyJ2v5A3+Q9m46dQ5hAODeL/7c3xgEJxdnAiXseeEHh8t9JQP+dA/Tf+UL8dzLQfxOA/ruAeWE/T6sB52v7F2j752ZVrw0X0v8nEiYRLkpBbTgFGJsLgbG5WEhunwr030Sg/yYL8d9pQP9NAvpvCnNtuFirAZO1/Sna/kW+2jCV/j+NMJ0wIwW14XRgbKYCY3OJkNw+A+i/aUD/zRTivzOB/psO9N8s5tpwiVYDZmr7s7T9Gb7aMJv+P4cwlzAvBbXhLGBsZgNjM585NvO1GMzR9udq+/N8sVlA/19IWES4NGvjj4/6dY/TeskFmr7xCU4EXUbHFhOWEC7P2vhbd17v6t/Q/fplQH/X1+y8In6y4UopJxu47LuC4UzuVUwnWZTeCYyxupLBF1cz+eLqBL5AnJXlyIsL/n+fcVuxGfvYcuDCzvbXgcsYzsID4+0ifegtYvqC4N9q+1mbyyldJzpuV4Bri7ddI/EMvG50HW12N/c5yuZrGArDRHBh8LaGdYxZbRYE1JivzbKzwCBjoefltdpCvaXx2ZzPkfG5TtPlhkI0N6KlbiwaCxWXRoLlbkmopCRWFCstCRdFY8VFZdHSSreoLBSMVJY6MTdcWVlaHKooLYlFohUlMb1ou9FQqCgaKa9wi4MlZeVOOBoqc2JFpaGgUxYNlUajoXBJSVkoFC0Jx8KRcDBYFguFneLS0ohTEgxFglzxuc4QH9QtNxzz53rg/FHjbxrY2L3XJSc3p3t9Yn3BipgbKqZscUrKioqjJaFgNFjqRIuKYy45IhgpIjfEKorC0XAwFAuWBiu8DvX6eB32YqT2r9A62Cvj+0vp7w2EG7Oqx7YBOLbIq3dLgXlyUxaWMKXqPr2bmEjNzVmMBt+chdd7CzAZuMZ9iza5QHoTnvJN1g/IS8U3AONzq9DJeivTZL0ti9Hg2xgm6+2WT1Y17ttTPFmd5LZqq6GT3AYtpneAk75ZPN53aCzmBm3fYzwKJ2nykw2vuZP+3kW4O4tn/mTEGRX6VNH1wPjcwxSfpTXE5x4tPpt7zb309z7C/UzxuSU+z9FnKh4QcCnjAYZxP8g8bkRn+UCW3TdQPwT2IXqsqmYCbXTVHH+QIRcfFjAHb2QY9yMC5iDHuB8F5iTHvFHjBubkvxzgTgY/PiZg3pzCMO7HBcwbjnE/Yfm8URweWNNcVSceY/DjMsvXbcW1gTnuqrxZxuDHJy33o5qHuVnYef0kw7kG0z1tNX0nalxWzfe0PUXHniY8Q3g2i++LstObUO+I/+VX97omuFg9J2BtfI5hTj5v+bgvqSF3kh33C8B6eUknu304k8mHLwJ9OMtyH85i8uFLQB/OsdyHs5l8+DLQh/Ms96Gq1y8wrAOvWL4OqHG/yDDuVwWM+yWGcS8HXxvw89FXNN75qra/PAEffY2OvU54g7Aia/PfrUnWB08B68ZrwL7hTaEXwd8E55S3rcxiNHglw0XwVZZfBFfjXsXQmKpkaxQw30+OHsNT4MLt35A+8bbVcZ+vif9dG//7lspBdIVXAc7I4ulEUc7R7z9dmxWo8ekvq7VVY422vzbBavI2HXuH8C7hvSzeRzetsvzK4/vMZ94QKzHQRvftuL4ANib/TuacQPUCh477340DgeOb4vS1aLJBH8oX8ae1cRTNqu+f6P79IB7HD9VfvWB8oBUMT6ZeVBh/I7rweYFBF5D5ln8rzksg9LgXpOhLP1toZ9D75toHwEL8IbDIAfPGRcRCLwzoXFHF/AOGgq50cFyWaAUs4DfET5uhffqR5ZfjlB9bA/14I5Mf1wnwYxugH29i8uPHAvyYAfTjzUx+/ESAH9sC/XgLkx8/FeDHdkA/3srkx88E+LE90I+3MfnxcwF+zAT68XYmP34hwI9ZQD/eweTHLwX4sQPQj3cy+fErAX7MBvrxLiY/fi3AjzlAP97N5MdvBPgxF+jHe5j8+K0AP+YB/Xgvkx+/E+DHfKAf72Py4/cC/NgR6Mf7mfz4gwA/FgD9+ACTH38U4MdOQD8+yOTHnwT4sTPQjw8x+fFnAX4sBPrxYSY//iLAj12AfnyEyY+/CvBjV6AfH2Xy428C/NgN6MfHmPz4uwA/dgf68XEmP/4hwI89gH58gsmPfwrw41ZAPy5j8uNfAvzYE+jHJ5n8+LcAP/YC+vEpJj+uF+DH3kA/Ps3kx38E+LEP0I/PMPkx0MF+P24N9OOzTH6sJ8CP2wD9+ByTH+sL8OO2QD8+z+THBgL8uB3Qjy8w+bGhAD9uD/Tji0x+bCTAjw7Qjy8x+bGxAD+6QD++zOTHJgL8GAT68RUmPzYV4McQ0I+vMvmxmQA/FgH9uJzJj80F+LEY6MfXmPzYQoAfS4B+fJ3Jjy0F+LEU6Mc3mPzYSoAfw0A/rmDyY2sBfowA/fgmkx/bCPDjDkA/rmTyY4YAP+4I9OMqJj+2FeDHnYB+XM3kx3YC/Lgz0I9rmPzYXoAfdwH6cS2THzMF+HFXoB/fYvJjlgA/9gX68W0mP3YQ4MfdgH58h8mP2QL8uDvQj+8y+TFHgB/3APrxPSY/5grw455AP77P5Mc8AX7cC+jHD5j8mC/Aj3sD/fghkx87CvDjPkA/fsTkxwIBftwX6Md1TH7sJMCP+wH9+DGTHzsL8OP+QD9+wuTHQgF+PADox0+Z/NhFgB8PBPrxMyY/dhXgx4OAfvycyY/dBPjxYKAfv2DyY3cBfuwH9OOXTH7sIcCPhwD9+BWTH7cS4MdDgX78msmPPQX4sT/Qj98w+bGXAD8OAPrxWyY/9hbgx4FAP37H5Mc+Avw4COjH75n8uLUAPw4G+vEHJj9uI8CPhwH9+COTH7cV4MchQD/+xOTH7QT4cSjQjz8z+XF7AX4cBvTjL0x+dAT48XCgH39l8qMrwI/DgX78jcmPQaAf1e9WXUM4JK5P/SaL+j0R9VsY6ncc1G8QqOfnq2e/q+eWq2duq+dFq2cdq+f0qmfMquejqmd7qudSqmcqqucBqmfZqeewqWeIqedfqWc3qecOqWfmqOe9qGeVqOdsqGdEqOcbqO/mq++Vq+9Eq+/zqu+iqu9Rqu8Aqu+vqe9eqe8Nqe+8qO9rqO8aqPvk1T3e6v5kdW+tui9U3dOo7sdT95Kp+6DUPTzq/hN174S67q+uWavrrepaobrOpa7RqOsL6ty4Oq+rzkmq82nqXJA6j6F6cNU/qt5H8XbFORVfUmu9WqdUjVX1QeW2iot/Q/9kbAgX+2Lg7zcVL7D8N8TU7zcp36HnYhFwLtaPz0X/hvQrh2+RPuCysRhtI3rxWe37BUrED5apQaPt1B2ZrI0lciaPy5WYEiZPCYON/27o1bH0v786uhwBVsWilGF1DKdXRzcsYIJHbF8d1zCsjhGG1TECXB13SK+OIibPDlJWxx3/+6tjkCPAqljsyLA67pReHd2dBEzwnW1fHdcyrI47M6yOOwNXx13Sq6OIybOLlNVx1//+6hjiCLAqFrsyrI5906uj21fABN8NbSPawLfiqyM6QXct5L3kgVjFVXAaMAY8WRt3xyWPi4yHVEYgoWDsLoUR7PHfZwRFHAFWhWcPBkawZ5oRuHsKmOB7cTMCxMq4F3xlDDnvZ/E4Mdnx7p3ulUVMnL2lrIz7AGkbcGV0JVxn3YdhZdwXmDj14vmi/iq9hYHqW32w7cgTl/t1sDr+wQwaqwK6JWsE8GFl7N+tMgMYj/1x8WC5sqPGuhfDqYHdC+0+NbBzA548VHpRNh4AnMvc8XCS2/7Nw70Z8nDPQrvzMJMpDzOBeXggMA+54+Ekt/2bh/sw5OHehXbn4VuNePJQ6UXZeBAwD7nj4SS3/ZuH+zLk4b6FdufhDUz18AZgPTwYmIfc8XCS2/7Nw/0Y8nD/QrvzUI07zJCHYWBv0Q+Yh9zxcJLb/s3D/Rny8MBC+/MwwpCHEWAeHgLMQ+54OMlt/+bhAQx5eGgH+8d9IMO4+wsY90EM4x4gYNwHM4x7oIBx92MY9yAB4z6EYdyDBYz7UIZxHyZg3P0Zxj1EwLgHMIx7qIBxD2QY9zAB4x7EMO7DBYx7MMO4hwsY92EM4z5CwLiHMIx7hIBxD2UY90gB4x7GMO5RAsZ9OMO4ywSMezjDuMsFjPsIhnFXCBj3CIZxRwWMeyTDuCsFjHsUw7hjAsZdxjDu0QLGXc4w7jECxl3BMO4jBYw7yjDuo9LfCHFbN7DfxqOR+Sk1UF0EBGpsOlCOO6Sx/TYekw6U4xYLmFHHpgPluNsLCNRx6UA57nABpe/4dKAcd4SAQJ2QDpTjjhIQqBPTgXLccgGBGpcOlONGBQTqpHSgHDcmIFAnpwPluGMEBOqUdKAc9ygBgTo1HSg6jyYgUKelA0WnZwQE6vR0oIj6CjiFdEY6UNT1C5hRZ6YD5bg3CphRZ6UDRc2kgBk1Ph0o6lEEBOrsdKCI+goI1DnpQBGjEhCoCelA0UItIFDnpgPluE8KYH3npQNF9V/AjDo/HSgqKwICdUE6UJStAgJ1YTpQ5AQBgZqYDpTjThIQqEnpQDnuxQICdVE6UI47RUCgLk4HynGnCQjU5HSgHHeGgEBNSQfKcWcKCNTUdKAcd7aAQE1LB8pxswSc65ueDpTj3t9IwDqaDpTjzhdQ+i5JB8pxFwoI1Mx0oBz3UgGBmpUOlOMuFhCo2elAOe7lAgI1Jx0ox71SQKDmpgPluFcLCNS8dKAct5WAhnd+OlCOe52AGbUgHSjHXSogUAvTgXLcGwUEalE6UI57s4BAXZoOlOPeKiBQl6UD5bi3CwjU4nSgHPdOAYFakg6U4w4Q0Eddng4UnUISEKgr0oFy3HsFlL4r04GiS/ECAnVVOlCO+6CAQF2dDpTjPiwgUNekA+W4jwoI1LXpQDnu4wICdV06UI67TECgrk8HynGfEhCopelAOe4zAgJ1QzpQjvucgEDdmA6U474gIFA3pQPluC8JCNTN6UA57isCAnVLOlCOu1xAoG5NB8pxXxcQqNvSgXLcFQICdXs6UI67UkCg7kgHynFXCwjUnelAOe5aAYG6Kx0ox31bQKDuTgfKcd8VEKh70oFy3PcFBOredKAc90MBgbovHSjHXScgUPenA+W4nwgI1APpQDnuZwIC9WAHsI1+A0NOSVFRZWmw0g25ZU4wUh4udoqKy0vCbtgtDhdHg+FQqDJcFC6NlEdKnYhbFKp0Y8WRUCyuNCMrEMgk1AcPXOlE2fgQ2IloHzaisSo/NgD7sFEWNs4oXQ/j4uFyxKNlPB7onG4J9OEjQnIa7UNkTj/K7EMnuc1V/luVhY/NY5aP+3ka88sM434cPG50bu9MYz4+C6fvaNI1lsGPT1iePyq/Vazrg8e9DLhu7VqI86HyXztCw7g+9X/1NbD18X0VL29/mbbvxF/jve9JOvYU4WnCMx2q60PGh2ltCCI5yrMdsPFpEPej0lsY93njwEbOp29ofz9p+XwtytqQowGsXofTp42AddpvIwuRAOlyVOI2ITQK8Cdu4yyeZAAnmutNcE5f9ArgfYG28R8BZ1RaZMkoMJlC7AQWwqDfRqsLIZczGZhRCMmMnmNiRs/FmZHaOM4avA9csfcjW/fvgLfzfWCcnre8292LISYHdMB3uy9Y7se9Gfx4IIMfX7Tcj/sw+PEgBj++ZLkf92Xw48EMfnzZcj/ux+DHfgx+fMVyP+7P4MdDGPz4quV+PIDBj4cy+HG55X48kMGP/Rn8+JrlfjyIwY8DGPz4uuV+PJjBjwMZ/PiG5X7sx+DHQQx+XGG5Hw9h8ONgBj++abkfD2Xw42EMflxpuR/7M/hxCIMfV1nuxwEMfhzK4MfVlvtxIIMfhzH4cY3lfhzE4MfDGfy41nI/Dmbw43AGP75luR8PY/DjEQx+fNtyPw5h8OMIBj++Y7kfhzL4cSSDH9+13I/DGPw4isGP71nux8MZ/FjG4Mf3LffjcAY/ljP48QPL/XgEgx8rGPz4oeV+HMHgxyiDHz+y3I8jGfxYyeDHdZb7cRSDH2MMfvzYcj+WMfhxNIMfP7Hcj+UMfhzD4MdPLfdjBYMfj2Tw42eW+zHK4MejGPz4ueXfelHjfoRh3F8IGPejDOP+Usi3nNDj/kpAvB9iGPfXAsb9MMO4vwGP29sagce/tEHyY66Mbdi4nj6RrK5vgbrO7YyLq/qSXraW0/qGzvNvwd8H8bbvOjAa/F0HvN7vgcnANe7vO2x0MEgvaxH5rvF/v4j8kC4i7g9MReTHDowG/8hQRH6yvIiocf/EVETgX/VtEgic3BTPwOYU8hTPJtjxB//+HyieP+MKh7uwk5WF2EXmWyqL+s9MRf2XDowG/8JQ1H+1vKircf+aoqKe7Pi/jy9A6Iclft/BzkX8N8tPc1xPC4M6JVEfHGfkIvF7B5kF9HemAvpHB0aD/2AooH9aXkDVuP8UUkBVof+NoYD+CiygvwHj/VcHu+NR09N//6uM/W+hxfhvpmK8vgOjwesZivE/lhdjNe5/hBRjtWj8xVCM/wQW47+Q8c62Ox7/5k02Ph7/AOOh+zDZ8dYTEI96lsejHjAe9QXEo77l8agPjEcDAfFoYHk8GgDj0VBAPBpaHo+GwHg0EhCPRpbHoxEwHo0FxKOx5fFoDIxHEwHxaGJ5PJoA49FUQDyaWh6PpsB4NBMQj2aWx6MZMB7NBcSjueXxaA6MRwsB8VA21rc4Hi2Q/QfpyA2k5mdbZPz6RZBPt7vxRLn6Wxjfb0nxbEVoTWhDyCC0JbQjtCdkErIIHQjZhBxCLiGPkE/oSCggdCJ0JhQSuhC6EroRuhN6ELYi9CT0IvQm9CFs7V1t8J5ar4xp6pO1MshaG2RtDLIMg6ytQdbOIGtvkGUaZFkGWQeDLNsgyzHIcg2yPIMs3yDraJAVGGSdDLLOBlmhQdbFIOtqkHUzyLobZD0Msq0Msp4GWS+DrLdB1scg2zou07cu8b9943+d5LZqRSfp39EEFN4NVzMdtxVIlxpja4iuDf5qk7yuYNxfbkayuoqqfO+2TU6Xo8XRbZeMrmC1nHDbb7kux5dfbuYW6iqJbZKrbtaW6Qob8t7tsCW6wsY55GbXXVdpDfPRzamrrtIa57abWzddwQR1ws2ri67ShDXHza+9rorN1C+3Y211lW62FroFtdPl1KKuup1qo8upVY12O29eV3Et671buDldRbVeO9wuCXUVxeqwDrldE+kqrdOa5narWVe4juuj270GXZFYnddat4dZl7MF67a7lUmXs0UcwO25qS53C/mE28uvK7rF3MTtXV1XKAme4/bRdAVjSXEmd2tgw5/Ku6O2hnG9qKvbu002o8HbZOPuW/aM3wYXQHdbgFM577RSPlQ2os4qeT7cFjwJcgIb45yqSeAktUVZz6rovtguPsG295/Z2C4eWF22vaEDRZ+KxVUSx90OOIG2BwcXnXxq0mwHnIzeuLcTuiL1geVRJKrb62QzGuzAV6RI1AGuSK7lK5LyoQtfkSJRV+iK1Admd6TCYC7LihSMT7CQf0UKGlakUApWpD7AFSkInEAhpuCiCpBnJ3LMRcBiFgjgV8tt4wUIfUEU2QoUA4uZyYdOcpurYlzMwGSKhTKZ3rD6Ux7S7S3JZjS4BM5kykMlwMlfajmTUT4shTOZ8lAp8+RHFNBiywtoGOxDb0MvvMgcjwDnXioZcG+Y3eVBg7ksDHiHeGHe0c+AdzAw4B1TwIBxK5Dj7gBMyh2ZgoueiMgx78TMgJ3kNlcVxwgDe9vZctaq4rKzgHFz5fjOwBzfxfIcr4mkIMgPSteu4AU7Vd1OL9haE47p9vbN5jQY3u2EY32BAdzN8m5H+XA3eLcTju1mebejCt2u2XYX493Bxdjb0GNG5vgeQrudXjC7w5UGc1m6nT3jhXkvf7ezp6Hb2SsF3Q5uBXLcPYFJuRdTcNETETnmvS1ngqo47sHA+vexvNtRcdlHwLi5cnwfYI7va3mO10RSnOQ2F0lS9hN6bacnbK0JVnuq3P7ZjAbvD+92gs7+wElwgOXdjvLhAfBuJ+gcYHm3owrdftl2F+MDhXQ7yBw/SGi30xNmtxszmMvS7RwcL8z9/N3OwYZup18Kuh3cCuS4BwOTsh9TcNETETnmQyxngqo4HsTA+g+1vNtRcTlUwLi5cvxQYI73tzzHayIpTnKbiyQpA4R2O1vB1ppotW5nYDajwQPh3U7UGQicBIMs73aUDwfBu52oM8jybkcVugHZdhfjwUK6HWSOHya029kKZndFyrqdIfHCPNTf7QwxdDtDU9Dt4FYgxx0CTMqhTMFFT0TkmIdZzgRVcTyMgfUfbnm3o+JyuIBxc+X44cAcH255jtdEUpzkNhdJUo4Q2u30gK01JdWeiTEim9HgEfBup8QdAZwEIy3vdpQPR8K7nZJq43aS3EzjRhS6I7LtLsajhHQ7yBwvE9rt9IDZXZKyZ6mUxwtzhb/bKTd0OxUp6HZwK5DjlgOTsoIpuOiJiBxz1HImqIpjGQPrr7S821FxqRQwbq4crwTmeMzyHK+JpDjJbS6SpIwW2u10x13bCev2jslmNHgM/tpOeAxwEhxpebejfHgk/tpO+EjLux1V6EZn212MjxLS7SBz/Gih3U53mN3RUoO5LN3O2HhhPsbf7Yw1dDvHpKDbwa1AjjsWmJTHMAUXPRGRYz7WciaoiuPRDKz/OMu7HRWX4wSMmyvHjwPm+PGW53hNJMVJbnORJOUEod1ON9haUxTR7T0xm9HgE+HdTlHkROAkGGd5t6N8OA7e7RRFxlne7ahCd0K23cX4JCHdDjLHTxba7XSD2V0UNpjL0u2cEi/Mp/q7nVMM3c6pKeh2cCuQ454CTMpTmYKLnojIMZ9mORNUxfFkBtZ/uuXdjorL6QLGzZXjpwNz/AzLc7wmkuIkt7lIknKm0G6nK2ytKa92J9tZ2YwGnwXvdsrds4CTYLzl3Y7y4Xh4t1NebdxOkptp3IhCd2a23cX4bCHdDjLHzxHa7XSF2V2esjvZJsQL87n+bmeCods5NwXdDm4FctwJwKQ8lym46ImIHPN5ljNBVRzPYWD951ve7ai4nC9g3Fw5fj4wxy+wPMdrIilOcpuLJCkXCu12uuC6nQrd3onZjAZPxHc7FROBk2CS5d2O8uEkfLdTMcnybkcVuguz7S7GFwnpdpA5frHQbqcLjhCXG8xl6XYmxwvzFH+3M9nQ7UxJQbeDW4EcdzIwKacwBRc9EZFjnmo5E1TF8WIG1j/N8m5HxWWagHFz5fg0YI5PtzzHayIpTnKbiyQpM4R2O4W4O9nKdXsvyWY0+BL8nWzllwAnwUzLux3lw5n4O9nKZ1re7ahCNyPb7mI8S0i3g8zx2UK7nULczU5lBnNZup058cI819/tzDF0O3NT0O3gViDHnQNMyrlMwUVPROSY51nOBFVxnM3A+udb3u2ouMwXMG6uHJ8PzPEFlud4TSTFSW5zkSRlodBupzNsrQlXewL1omxGgxfBu52wswg4CS61vNtRPrwU3u2EnUst73ZUoVuYbXcxvkxIt4PM8cVCu53OMLtLU/YE6iXxwny5v9tZYuh2Lk9Bt4NbgRx3CTApL2cKLnoiIsd8heVMUBXHxQys/0rLux0VlysFjJsrx68E5vhVlud4TSTFSW5zkSTlaqHdTiembueabEaDr2Hodq4BToJrLe92lA+vZeh2rrW821GF7upsu4vxdUK6HWSOXy+02+kksNtZGi/MN/i7naWGbueGFHQ7uBXIcZcCk/IGId0Ocsw3Ws4EVXG8noH132R5t6PicpOAcXPl+E3AHL/Z8hyviaQ4yW0ukqTcIrTbKYCtNWXVnsl2azajwbfCu52yyK3ASXCb5d2O8uFt8G6nLHKb5d2OKnS3ZNtdjG8X0u0gc/wOod1OAczuspQ9k+3OeGG+y9/t3Gnodu5KQbeDW4Ec905gUt7FFFz0RESO+W7LmaAqjncwsP57LO92VFzuETBurhy/B5jj91qe4zWRFCe5zUWSlPuEdjsdcd1OkW7v/dmMBt+P73aK7gdOggcs73aUDx/AdztFD1je7ahCd1+23cX4QSHdDjLHHxLa7XTEEeKQwVyWbufheGF+xN/tPGzodh5JQbeDW4Ec92FgUj7CFFz0RESO+VHLmaAqjg8xsP7HLO92VFweEzBurhx/DJjjj1ue4zWRFCe5zUWSlCeEdjv5sLUmWu3azrJsRoOXwbudaGQZcBI8aXm3o3z4JLzbiUaetLzbUYXuiWy7i/FTQrodZI4/LbTbyYfZHU3ZtZ1n4oX5WX+384yh23k2Bd0ObgVy3GeASfksU3DRExE55ucsZ4KqOD7NwPqft7zbUXF5XsC4uXL8eWCOv2B5jtdEUpzkNhdJUl4U2u3kwdaaikrd3peyGQ1+Cd7tVFS+BJwEL1ve7SgfvgzvdioqX7a821GF7sVsu4vxK0K6HWSOvyq028mD2V0RNZjL0u0sjxfm1/zdznJDt/NaCrod3ArkuMuBSfkaU3DRExE55tctZ4KqOL7KwPrfsLzbUXF5Q8C4uXL8DWCOr7A8x2siKU5ym4skKW8K7XZyYWuNW+3azspsRoNXwrsdN7ISOAlWWd7tKB+ugnc7bmSV5d2OKnRvZttdjFcL6XaQOb5GaLeTC7PbTdm1nbXxwvyWv9tZa+h23kpBt4NbgRx3LTAp32IKLnoiIsf8tuVMUBXHNQys/x3Lux0Vl3cEjJsrx98B5vi7lud4TSTFSW5zkSTlPaHdTg5srSmv1u28n81o8Pvwbqc88j5wEnxgebejfPgBvNspj3xgebejCt172XYX4w+FdDvIHP9IaLeTA7O7PGXdzrp4Yf7Y3+2sM3Q7H6eg28GtQI67DpiUHzMFFz0RkWP+xHImqIrjRwys/1PLux0Vl08FjJsrxz8F5vhnlud4TSTFSW5zkSTlc6HdTjZsrQmHdXu/yGY0+At4txMOfwGcBF9a3u0oH34J73bC4S8t73ZUofs82+5i/JWQbgeZ418L7XayYXaHSw3msnQ738QL87f+bucbQ7fzbQq6HdwK5LjfAJPyW6bgoicicszfWc4EVXH8moH1f295t6Pi8r2AcXPl+PfAHP/B8hyviaQ4yW0ukqT8KLTb6QBba4qqdTs/ZTMa/BO82ykK/wScBD9b3u0oH/4M73aKwj9b3u2oQvdjtt3F+Bch3Q4yx38V2u10gNldlLJu57d4Yf7d3+38Zuh2fk9Bt4NbgRz3N2BS/s4UXPRERI75D8uZoCqOvzKw/j8t73ZUXP4UMG6uHP8TmON/WZ7jNZEUJ7nNRZKUv4V2O1mwtSbi6vauz2Y0eD2824m464GT4B/Lux3lw3/g3U6k2ridJDfTuBGF7u9su4uxouqoOAe0DT1mZI7XA445ld1OFizfI47BXJZup37Ohr8NcgLVOxt1wN/tqBdxdzu4Fchx6+fgkrJBDk9w0RMROeaG4OKDnnBqZtfLwS8MjXJ4Fy4nuc1VcWkkYNxcOd4ImOONLc/xmkiKk9zmIklKE2DepLLbyYStNaWObm/THEaDlXJst1PqNAVOgmbAycnlw2Y56G6n1GnGvGggCl2THLuLcXMh3Q4yx1sI7XYyYd1OScxgLku30zJemFv5u52Whm6nVQq6nUxgt9MSmJStcniCi56IyDG3tpwJquLYgoH1t7G821FxaSNg3Fw53gaY4xmW53hNJMVJbnORJKWt0G6nPWytKa/2BOp2OYwGt4N3O+WV7YCToL3l3Y7yYXt4t1Ne2d7ybkcVurY5dhfjTCHdDjLHs4R2O+1xX2RP2ROoO8QLc7a/2+lg6HayU9DttAd2Ox2ASZmdwxNc9EREjjnHciaoimMWA+vPtbzbUXHJFTBurhzPBeZ4nuU5XhNJcZLbXCRJyRfa7bSDrTXBatd2OuYwGtwR3u0EnY7ASVBgebejfFgA73aCToHl3Y4qdPk5dhfjTkK6HWSOdxba7bSDdTtuyq7tFMYLcxd/t1No6Ha6pKDbaQfsdgqBSdklhye46ImIHHNXy5mgKo6dGVh/N8u7HRWXbgLGzZXj3YA53t3yHK+JpDjJbS6SpPQQ2u20xa01Fbq9W+UwGrwVvNtxKrYCToKelnc7yoc94d2OU9HT8m5HFboeOXYX415Cuh1kjvcW2u20xX1PrdxgLku30ydemLf2dzt9DN3O1inodoArkNsHmJRb5/AEFz0RkWPexnImqIpjbwbWv63l3Y6Ky7YCxs2V49sCc3w7y3O8JpLiJLe5SJKyvdBuJwO21pRUu5PNyWE02IF3OyWVDnASuJZ3O8qHLrzbKal0Le92VKHbPsfuYhwU0u0gczwktNvJwH1vJ2V3shXFC3Oxv9spMnQ7xSnodjKA3U4RMCmLc3iCi56IyDGXWM4EVXEMMbD+Usu7HRWXUgHj5srxUmCOhy3P8ZpIipPc5iJJSkRot9MGtta41Z7JtkMOo8E7wLsd190BOAl2tLzbUT7cEd7tuNXG7SS5mcaNKHSRHLuL8U5Cuh1kju8stNtpg7uTLWXPZNslXph39Xc7uxi6nV1T0O20AXY7uwCTctccnuCiJyJyzH0tZ4KqOO7MwPp3s7zbUXHZTcC4uXJ8N2CO7255jtdEUpzkNhdJUvYQ2u20Bj40WLd3zxxGg/fMwevdy/IORY17r5yNDgbpZekqVEHZI8fuore3kK4CmZf7MBd6REz2YcjxVBbUVkwFdd8cRoP3ZSio+1leUNW490tRQXWS21w1MfbL4ZlwqHGncpK1RD7+XrNz/xxGg/dnWBH3B1b0AyyfsMqHBzBMggMsP0erJukBDO3P3sB4H2j56QKVOwcyFXtvQ8/tA4HxOcjyFr+mjsFJbnORHcPBlue4ivHBDEQOmYeKJOQGNp4y1ze03S2yeOZ5AGpnkPU6Rz3Nt4Xx/X4Uz0MIhxL6EwYQBhIGEQYTDiMMIQwlDCMcThhOOIIwgjCSMIpQRignVBCihEpCjDCaMIZwJOEowtGEsYRjCMf6r7H0i19P0WWHGGSHGmT9DbIBBtlAg2yQQTbYIDvMIBtikA01yIYZZIcbZMMNsiMMshEG2UiDbJRBVmaQlRtkFQZZ1CCrNMhiBtlog2yMQXakQXaUQXa0QTbWIDvGIDs2Z9Nrd13if/vG/zrJbdWKTrLFsh+g8HrXAQ8B6VJjPBSia4O/+ievKxj3lzsgWV1FVb53Byany9Hi6A5KRlewWk64g7dcl+PLL/ewLdRVEtskV90hW6YrbMh7d+iW6Aob55A7rO66SmuYj+7hddVVWuPcdofXTVcwQZ1wj6iLrtKENccdUXtdFZupX+7I2uoq3WwtdEfVTpdTi7rqltVGl1OrGu2Wb15XcS3rvVuxOV1FtV473GhCXUWxOqxDbmUiXaV1WtPcWM26wnVcH93RNeiKxOq81rpjzLqcLVi33SNNupwt4gDuUZvqcreQT7hH+3VFt5ibuGOr6wolwXPcYzRdwVhSnMk9VugZ7WNhXC9a7a7j43IYDT4uB33XcdQ9DhdA93iAUznPaCsfHg88o+358HjwJFA5VD+Q2kngJLVFU3b36AnxCXai/8zGCTmb3j16Yg7/3aO4SuK4JwAn0Ing4KKTT02aE4CT0Rv3CUJXpGNgeRSJ6vaOy2E0eBx8RYpExwFXpJMsX5GUD0+Cr0iR6ElCV6RjYHZHKgzmsqxIJ8cn2Cn+Felkw4p0SgpWpGOAK9LJwAl0ClNw0ReCkWM+FVjMAgH8anl8vAChLwQjW4HTgMXM5EMnuc1VMT6NgcmcJpTJjIXVn/KQbu/pOYwGnw5nMuWh04GT/wzLmYzy4RlwJlMeOoN58iMK6GmWF9AzwT70NvTCi8zxs4BzL5UMeCzM7vKgwVwWBjw+XpjP9jPg8QYGfHYKGDBuBXLc8cCkPJspuOiJiBzzOcwM2Eluc1VxPIuBvU2wnLWquEwQMG6uHJ8AzPFzLc/xmkgKgvygdJ0HXrBT1e0cDVtrwjHd3vNzGA0+H97thGPnAwN4geXdjvLhBfBuJxy7wPJuRxW683LsLsYXgouxt6HHjMzxiUK7naNhdocrDeaydDuT4oX5In+3M8nQ7VyUgm4HtwI57iRgUl7EFFz0RESO+WLLmaAqjhMZWP9ky7sdFZfJAsbNleOTgTk+xfIcr4mkOMltLpKkTBV6beco2FpT/XfHp+UwGjwN3u0EnWnASTDd8m5H+XA6vNsJOtMt73ZUoZuaY3cxniGk20Hm+CVCu52jYHan7nfHZ8YL8yx/tzPT0O3MSkG3g1uBHHcmMClnMQUXPRGRY55tORNUxfESBtY/x/JuR8VljoBxc+X4HGCOz7U8x2siKU5ym4skKfOEdjtHwtaaaLVuZ34Oo8Hz4d1O1JkPnAQLLO92lA8XwLudqLPA8m5HFbp5OXYX44VCuh1kji8S2u0cCbO7ImXdzqXxwnyZv9u51NDtXJaCbge3AjnupcCkvIwpuOiJiBzzYsuZoCqOixhY/xLLux0VlyUCxs2V40uAOX655TleE0lxkttcJEm5Qmi3Mwa21pRUeybGlTmMBl8J73ZK3CuBk+Aqy7sd5cOr4N1OSbVxO0lupnEjCt0VOXYX46uFdDvIHL9GaLczBmZ3ScqepXJtvDBf5+92rjV0O9eloNvBrUCOey0wKa9jCi56IiLHfL3lTFAVx2sYWP9Sy7sdFZelAsbNleNLgTl+g+U5XhNJcZLbXCRJuVFotzMad20nrNt7Uw6jwTfhr+2EbwJOgpst73aUD2/GX9sJ32x5t6MK3Y05dhfjW4R0O8gcv1VotzMaZne01GAuS7dzW7ww3+7vdm4zdDu3p6Dbwa1AjnsbMClvZwoueiIix3yH5UxQFcdbGVj/nZZ3OyoudwoYN1eO3wnM8bssz/GaSIqT3OYiScrdQrudGGytKYro9t6Tw2jwPfBupyhyD3AS3Gt5t6N8eC+82ymK3Gt5t6MK3d05dhfj+4R0O8gcv19otxOD2V0UNpjL0u08EC/MD/q7nQcM3c6DKeh2cCuQ4z4ATMoHmYKLnojIMT9kORNUxfF+Btb/sOXdjorLwwLGzZXjDwNz/BHLc7wmkuIkt7lIkvKo0G6nErbWlFe7k+2xHEaDH4N3O+XuY8BJ8Ljl3Y7y4ePwbqe82ridJDfTuBGF7tEcu4vxE0K6HWSOLxPa7VTC7C5P2Z1sT8YL81P+budJQ7fzVAq6HdwK5LhPApPyKabgoicicsxPW84EVXFcxsD6n7G821FxeUbAuLly/Blgjj9reY7XRFKc5DYXSVKeE9rtRHHdToVu7/M5jAY/j+92Kp4HToIXLO92lA9fwHc7FS9Y3u2oQvdcjt3F+EUh3Q4yx18S2u1EcYS43GAuS7fzcrwwv+Lvdl42dDuvpKDbwa1AjvsyMClfYQoueiIix/yq5UxQFceXGFj/csu7HRWX5QLGzZXjy4E5/prlOV4TSXGS21wkSXldaLdTgbuTrVy3940cRoPfwN/JVv4GcBKssLzbUT5cgb+TrXyF5d2OKnSv59hdjN8U0u0gc3yl0G6nAnezU5nBXJZuZ1W8MK/2dzurDN3O6hR0O7gVyHFXAZNyNVNw0RMROeY1ljNBVRxXMrD+tZZ3OyouawWMmyvH1wJz/C3Lc7wmkuIkt7lIkvK20G6nHLbWhKs9gfqdHEaD34F3O2HnHeAkeNfybkf58F14txN23rW821GF7u0cu4vxe0K6HWSOvy+02ymH2V2asidQfxAvzB/6u50PDN3OhynodnArkON+AEzKD5mCi56IyDF/ZDkTVMXxfQbWv87ybkfFZZ2AcXPl+Dpgjn9seY7XRFKc5DYXSVI+EdrtlDF1O5/mMBr8KUO38ylwEnxmebejfPgZQ7fzmeXdjip0n+TYXYw/F9LtIHP8C6HdTpnAbufLeGH+yt/tfGnodr5KQbeDW4Ec90tgUn4lpNtBjvlry5mgKo5fMLD+byzvdlRcvhEwbq4c/waY499anuM1kRQnuc1FkpTvhHY7o2BrTVm1Z7J9n8No8Pfwbqcs8j1wEvxgebejfPgDvNspi/xgebejCt13OXYX4x+FdDvIHP9JaLczCmZ3WdhgLku383O8MP/i73Z+NnQ7v6Sg28GtQI77MzApf2EKLnoiIsf8q+VMUBXHnxhY/2+WdzsqLr8JGDdXjv8GzPHfLc/xmkiKk9zmIknKH0K7nZG4bqdIt/fPHEaD/8R3O0V/AifBX5Z3O8qHf+G7naK/LO92VKH7I8fuYvy3kG4HmePrhXY7I3GEOGQwl6Xb+ccrzLmB6p3NP4ZuR72Iu9vBrUCO+w+y8ObyBBc9EZFjrpeLLT7oCaeK43oG1l8/l3fhcpLbXBUXZaPt4+bKcd3OZHU1sDzHayIpTnKbiyQpDYF5k8puZwRsrYlWu7bTKJfRYKUc2+1EI42Ak6AxcHJy+bBxLrrbiUYaMy8aiELXMNfuYtwEXIy9DT1mZI43BY45ld3OCFi3Ew0bzGXpdprFC3Nzf7fTLHfTbqd5CrqdEcBupxkwKZvn8gQXPRGRY25hORNUxbEpA+tvaXm3o+LSUsC4uXK8JTDHW1me4zWRFCe5zUWSlNZCu50jYGtNRaVub5tcRoPbwLudiso2wEmQYXm3o3yYAe92KiozLO92VKFrnWt3MW4rpNtB5ng7od3OEbBupyJqMJel22kfL8yZ/m6nvaHbyUxBt3MEsNtpD0zKzFye4KInInLMWZYzQVUc2zGw/g6WdzsqLh0EjJsrxzsAczzb8hyviaQ4yW0ukqTkCO12hsPWGrfatZ3cXEaDc+HdjhvJBU6CPMu7HeXDPHi340byLO92VKHLybW7GOcL6XaQOd5RaLczHNbtuCm7tlMQL8yd/N1OgaHb6ZSCbmc4sNspACZlp1ye4KInInLMnS1ngqo4dmRg/YWWdzsqLoUCxs2V44XAHO9ieY7XRFKc5DYXSVK6Cu12DoetNeXVup1uuYwGd4N3O+WRbsBJ0N3ybkf5sDu82ymPdLe821GFrmuu3cW4h5BuB5njWwntdg6HdTvlKet2esYLcy9/t9PT0O30SkG3cziw2+kJTMpeuTzBRU9E5Jh7W84EVXHcioH197G821Fx6SNg3Fw53geY41tbnuM1kRQnuc1FkpRthHY7w2BrTTis27ttLqPB28K7nXB4W+Ak2M7ybkf5cDt4txMOb2d5t6MK3Ta5dhfj7YV0O8gcd4R2O8Ng3U641GAuS7fjxgtz0N/tuIZuJ5iCbmcYsNtxgUkZzOUJLnoiIsccspwJquLoMLD+Isu7HRWXIgHj5srxImCOF1ue4zWRFCe5zUWSlBKh3c5Q2FpTVK3bKc1lNLgU3u2QHDgJwpZ3O8qHYXi3UxQOW97tqEJXkmt3MY4I6XaQOb6D0G5nKKzbKUpZt7NjvDDv5O92djR0OzuloNsZCux2dgQm5U65PMFFT0TkmHe2nAmq4rgDA+vfxfJuR8VlFwHj5srxXYA5vqvlOV4TSXGS21wkSekrtNsZAltrIq5u7265jAbvBu92Iu5uwEmwu+XdjvLh7vBuJ1Jt3E6Sm2nckEKXa3cx3kNIt4PM8T2FdjtDYN1OxDGYy9Lt7BUvzHv7u529DN3O3inodoYAu529gEm5dy5PcNETETnmfSxngqo47snA+ve1vNtRcdlXwLi5cnxfYI7vZ3mO10RSnOQ2F0lS9hfa7RwGW2tKHd3eA3IZDT4A3u2UOgcAJ8GBlnc7yocHwrudUudAy7sdVej2z7W7GB8kpNtB5vjBQrudw2DdTknMYC5Lt9MvXpgP8Xc7/QzdziEp6HYOA3Y7/YBJeUguT3DRExE55kMtZ4KqOB7MwPr7W97tqLj0FzBurhzvD8zxAZbneE0kxUluc5EkZaDQbmcw7ikF1Z5APSiX0eBB8G6nvHIQcBIMtrzbUT4cDO92yisHW97tqEI3MNfuYnyYkG4HmeNDhHY7g3FPKUjZE6iHxgvzMH+3M9TQ7QxLQbczGNjtDAUm5bBcnuCiJyJyzIdbzgRVcRzCwPqHW97tqLgMFzBurhwfDszxIyzP8ZpIipPc5iJJygih3c4g2FoTrHZtZ2Quo8Ej4d1O0BkJnASjLO92lA9HwbudoDPK8m5HFboRuXYX4zIh3Q4yx8uFdjuDcE+gTtm1nYp4YY76u50KQ7cTTUG3MwjY7VQAkzKayxNc9EREjrnSciaoimM5A+uPWd7tqLjEBIybK8djwBwfbXmO10RSnOQ2F0lSxgjtdgbi1poK3d4jcxkNPhLe7TgVRwInwVGWdzvKh0fBux2n4ijLux1V6Mbk2l2MjxbS7SBzfKzQbmcgrNtxyg3msnQ7x8QL87H+bucYQ7dzbAq6HeAK5B4DTMpjc3mCi56IyDEfZzkTVMVxLAPrP97ybkfF5XgB4+bK8eOBOX6C5TleE0lxkttcJEk5UWi3MwC21pRUu5NtXC6jwePg3U5J5TjgJDjJ8m5H+fAkeLdTUnmS5d2OKnQn5tpdjE8W0u0gc/wUod3OANz3dlJ2J9up8cJ8mr/bOdXQ7ZyWgm5nALDbORWYlKfl8gQXPRGRYz7dciaoiuMpDKz/DMu7HRWXMwSMmyvHzwDm+JmW53hNJMVJbnORJOUsod1Of9ha41Z7Jtv4XEaDx8O7HdcdD5wEZ1ve7Sgfng3vdtxq43aS3EzjRhS6s3LtLsbnCOl2kDk+QWi30x93J1vKnsl2brwwn+fvds41dDvnpaDb6Q/sds4FJuV5uTzBRU9E5JjPt5wJquI4gYH1X2B5t6PicoGAcXPl+AXAHL/Q8hyviaQ4yW0ukqRMFNrtHIq7GaPa93Ym5TIaPCkXr/ciyzsUNe6Lcjc6GKSXpatQBWVirt1F72IhXQUyLyczF3pETCYz5HgqC+ohTAV1Si6jwVMYCupUywuqGvfUFBVUJ7nNVRNjai7PhEONO5WTrF8Ozge6vdNyGQ2exrAiTgNW9OmWT1jlw+kMk2C65edo1SSdztD+XAyM9wzLTxeo3JnBVOy9DT23ZwDjc4nlLX5NHYOT3OYiO4aZlue4ivFMBiKHzENFEloGNm764jtLzU/1ggaB1LCIWcCA1tfsnB0vNHP8FxTUgQk+2Zy4TN/QFxRmASM4u/a6Kjajy50Dpp8KpqtcgTr6c3N2BxiTcjbQJ/okmutPxrm5m84yf+Ihk2UztrqbG8xcYBLPy4Ulg6P7dF4tJnOyts8B+gHp0/l18OnmPkv36XytaDbV/Kn71Eluc9cn1hesiLmh4srSYqekrKg4WhIKRoOlTrSoOOaSwcFIEbkmVlEUjoaDoViwNFixHmvfvznmFTZvIVkf2LiAqP0F9HchYVHuhkKYql58oRZ3NxwKBktDKj/CUcctitISEAxGy4ucCqesIlgZKXIjsaJgUagiWlFOuVTmxpxYWUUkFt6gS7f30lxGgy81cM1kjb8UyLEvs7wXVz68zMA1k/XhZWBG0DyQmvteFjJdNg5g/VuNESzWCQD6pAUwkK6+GuhG19Hmitok3+ItaEI35/TFwMm8BEwPPb8u0ZhLXXOBqJtb4ToxJxJ0ypzSipLS8kg0WB4ui4VixaFoaEv9urlkR/r1cia/Xh73ayr7WmQx0ovnFfEV+Uo1BzkKxmKGsxeLLT+7u6WTw6nDuJO18SrLz3ypxLyK4crA1UxF4eoExdZJbnOvZPLFNUy+uCaJhWdzNnPlxb2F/681ZbPn1bhy4L5Cu+vAwvi40bUUGG8X6cP/yjnPK5jOeV6bqMNxktvcq5gK4rUJOpzNqNnsOVRl87UMheH+Qp72t2EdY1YXIpPsmK/LtbPAIGOh5+V1hnPbdY3P5nyOjM/1+nnJUIjmRrTUjUVjoeLSSLDcLQmVlMSKYqUl4aJorLioLFpa6RaVhYKRylIn5oYr6WxvqKK0JBaJVpTE9KLtRkOhomikvMItDpaUlTvhaKjMiRWVhqj5jYZKo9FQuKSkLBSKloRj4Qg1rNQGh53i0tKIUxIMRYJc8ble6zRRi8LmzmzoOqUsCkslLgpLmReFpQyLwgOFdiwKNSZx6b/fkYshi84Nli4KyFjoeXkDYFHY3Gk+ZHxutHRR4IrPjf+h0483xU8/3mw6/egkt9V47h95HSRZXcBTmSw38Xk+RN/xwOXDZHXdYnk81IS5hWFhv5WJ5NzKeFr0ZiZf3Mbki9sYT4ty5cVDhXafFuXKgYeZx+0kt/27IN/CcFoUGG8X6cP/ymnRm5g64Ns5O+BbmAri7YwdsLL5dobC8EihjNOitwBJ0R25dhYYZCz0vLwjBadFkfG5E9gB60U72Q6YKz53GuKDvsELGZ+7mOrnXQA/bO5MDdIPdzP54e5anCa3eSE3mAvLY50k3CORJNzDTBLuYSAJjxamhiQkeXcstMjdC9SFJAnIWOh5eW8tSEKyd9ki43NfLm5hR5IErvjcl2v+jpH6f6/Axu/atG27YV+Pm5PkVpvv9txPfx8gPJhbPYfQdflBYF1W+Z0bqP59LS6777dkgU28BVkfaaqve4Xx/YfILw8THiE8SniM8DjhCcIywpOEpwhPE54hPEt4jvA84QXCi4SXCC8TXiG8SlhOeI3wOuENwgrCm4SVhFWE1YQ1hLW5gepfOFXGNPXJHjbIHjHIHjXIHjPIHjfInjDIlhlkTxpkTxlkTxtkzxhkzxpkzxlkzxtkLxhkLxpkLxlkLxtkrxhkrxpkyw2y1wyy1w2yNwyyFQbZmwbZSoNslUG22iBbY5Ctzd30Mb1d4n/7xv86yW3Vik7SJAagy3vk78MgXWqMj0B0bfDXo8nrCnqnXR9LVlfRxlO4jyeny9FPBz+RjK5g9VPLy7Zcl+M/Tf3kFuqiEz2bnPJ+ast0hU2nz5/eEl1h86n4Z+quq7Sm0/rP1lVXac2XCJ6rm65gossNz9dFV2niSxcv1F7XZi+tvVhbXaWbrYXuS7XT5dSirrov10aXU6sa7b6yeV3Ftaz37qub01VU67XDXZ5QV1GsDuuQ+1oiXaV1WtPc12vWFa7j+ui+UYOuSKzOa627wqzL2YJ1233TpMvZIg7grtxUl7uFfMJd5dcV3WJu4q6uriuUBM9x12i6grGkOJO7Ftj0Kd54Y2Bj47Q23sSsjjc1K+NNzop40/N6vAlaHm+KXok3SS/Fm6YX4k3Uc/Gm6pl4k/VUvOlaFm/CHo83ZY/GmzTF3RQXVFsqH+KxFsY/o9Ue4vFWLqPBSjnqfj3P+LdwSeW+DWwQuHyobESd0fZ8+DZwYqbyx2twBSWash+veSc+wd71n215Jx5YXfZuLv+P1+AqieO+A5xA74KDi04+NWneAU5Gb9zvgCdjqlakNbA8ikR1e9/LZTT4PfiKFIm+B1yR3rd8RVI+fB++IkWi7wtdkdbA7I5UGMxlWZE+iE+wD/0r0geGFenDFKxIa4Ar0gfACfQhU3BRBcizEznmj4DFLBDAr5ZvxwtQXe+M2pytyFZgHbCYmXzoJLe5KsbrGJjMOqFMZjWs/pSHdHs/zmU0+GM4kykPfQyc/J9YzmSUDz+BM5ny0CfMkx9RQNdZXkA/BfvQ29ALLzLHPwPOvVQy4NUwu8uDBnNZGPDn8cL8hZ8Bf25gwF+kgAHjViDH/RyYlF8wBRc9EZFj/pKZATvJba4qjp8xsLevLGetKi5fCRg3V45/Bczxry3P8ZpICoL8oHR9A16wU9XtrIKtNeGYbu+3uYwGfwvvdsKxb4EB/M7ybkf58Dt4txOOfWd5t6MK3Te5dhfj78HF2NvQY0bm+A9Cu51VMLvDlQZzWbqdH+OF+Sd/t/Ojodv5KQXdDm4FctwfgUn5E1Nw0RMROeafLWeCqjj+wMD6f7G821Fx+UXAuLly/Bdgjv9qeY7XRFKc5DYXSVJ+E3ptZyVsrQlW+/b977mMBv8O73aCzu/ASfCH5d2O8uEf8G4n6PxhebejCt1vuXYX4z+FdDvIHP9LaLezEma3GzOYy9Lt/B0vzOv93c7fhm5nfQq6HdwK5Lh/A5NyPVNw0RMROeZ/LGeCqjj+xcD6A3l2dzsqLspG28fNleO6ncnqqpdnd47XRFKc5DYXSVLqA/Mmld3Om7C1Jlqt22mQx2iwUo7tdqJOA+AkaAicnFw+bJiH7naiTkPmRQNR6Orn2V2MG4GLsbehx4zM8cbIuRdIXbfzJowcVqSs22kSL8xN8wLVO5smeZt2O+pF3N3Om8BupwkwKZvm8QQXPRGRY25mORNUxbExA+tvbnm3o+LSXMC4uXK8OTDHW1ie4zWRFCe5zUWSlJZCu50VsLWmpNozMVrlMRrcCt7tlLitgJOgteXdjvJha3i3U1Jt3E6Sm2nciELXMs/uYtxGSLeDzPEMod3OCli3U5KyZ6m0jRfmdv5up62h22mXgm5nBbDbaQtMynZ5PMFFT0TkmNtbzgRVccxgYP2Zlnc7Ki6ZAsbNleOZwBzPsjzHayIpTnKbiyQpHYR2O2/gru2EdXuz8xgNzsZf2wlnAydBjuXdjvJhDv7aTjjH8m5HFboOeXYX41wh3Q4yx/OEdjtvwLqdaKnBXJZuJz9emDv6u518Q7fTMQXdzhvAbicfmJQd83iCi56IyDEXWM4EVXHMY2D9nSzvdlRcOgkYN1eOdwLmeGfLc7wmkuIkt7lIklIotNt5HbbWFEV0e7vkMRrcBd7tFEW6ACdBV8u7HeXDrvBupyjS1fJuRxW6wjy7i3E3Id0OMse7C+12Xod1O0Vhg7ks3U6PeGHeyt/t9DB0O1uloNt5Hdjt9AAm5VZ5PMFFT0TkmHtazgRVcezOwPp7Wd7tqLj0EjBurhzvBczx3pbneE0kxUluc5EkpY/Qbuc13BOoq93JtnUeo8Fbw7udcndr4CTYxvJuR/lwG3i3U15t3E6Sm2nciELXJ8/uYrytkG4HmePbCe12XsM9pDhld7JtHy/Mjr/b2d7Q7Tgp6HZeA3Y72wOT0snjCS56IiLH7FrOBFVx3I6B9Qct73ZUXIICxs2V40Fgjocsz/GaSIqT3OYiSUqR0G5nOa7bqdDtLc5jNLgY3+1UFAMnQYnl3Y7yYQm+26kosbzbUYWuKM/uYlwqpNtB5nhYaLezHNftlBvMZel2IvHCvIO/24kYup0dUtDtLAd2OxFgUu6QxxNc9EREjnlHy5mgKo5hBta/k+XdjorLTgLGzZXjOwFzfGfLc7wmkuIkt7lIkrKL0G7nVdydbOW6vbvmMRq8K/5OtvJdgZOgr+Xdzr9Bx9/JVt7X8m5HFbpd8uwuxrsJ6XaQOb670G7nVdydbGUGc1m6nT3ihXlPf7ezh6Hb2TMF3c6rwG5nD2BS7pnHE1z0RESOeS/LmaAqjrszsP69Le92VFz2FjBurhzfG5jj+1ie4zWRFCe5zUWSlH2Fdjuv4H5dtNoTqPfLYzR4P3i3E3b2A06C/S3vdpQP94d3O2Fnf8u7HVXo9s2zuxgfIKTbQeb4gUK7nVdg3U5pyp5AfVC8MB/s73YOMnQ7B6eg23kF2O0cBEzKg/N4goueiMgx97OcCarieCAD6z/E8m5HxeUQAePmyvFDgDl+qOU5XhNJcZLbXCRJ6S+023mZqdsZkMdo8ACGbmcAcBIMtLzbUT4cyNDtDLS821GFrn+e3cV4kJBuB5njg4V2Oy8L7HYOixfmIf5u5zBDtzMkBd3Oy8Bu5zBgUg4R0u0gxzzUciaoiuNgBtY/zPJuR8VlmIBxc+X4MGCOH255jtdEUpzkNhdJUoYL7XZegq01ZdWeyXZEHqPBR8C7nbLIEcBJMMLybkf5cAS82ymLjLC821GFbnie3cV4pJBuB5njo4R2Oy/Bup2ylD2TrSxemMv93U6ZodspT0G38xKw2ykDJmV5Hk9w0RMROeYKy5mgKo6jGFh/1PJuR8UlKmDcXDkeBeZ4peU5XhNJcZLbXCRJiQntdl7EdTtFur2j8xgNHo3vdopGAyfBGMu7HeXDMfhup2iM5d2OKnSxPLuL8ZFCuh1kjh8ltNt5EdfthAzmsnQ7R8cL81h/t3O0odsZm4Ju50Vgt3M0MCnH5vEEFz0RkWM+xnImqIrjUQys/1jLux0Vl2MFjJsrx48F5vhxlud4TSTFSW5zkSTleKHdzgu4Xxetdm3nhDxGg0+AdzvRyAnASXCi5d2O8uGJ8G4nGjnR8m5HFbrj8+wuxuOEdDvIHD9JaLfzAu7XRVN2befkeGE+xd/tnGzodk5JQbfzArDbORmYlKfk8QQXPRGRYz7VciaoiuNJDKz/NMu7HRWX0wSMmyvHTwPm+OmW53hNJMVJbnORJOUMod3O87C1pqJSt/fMPEaDz4R3OxWVZwInwVmWdzvKh2fBu52KyrMs73ZUoTsjz+5iPF5It4PM8bOFdjvPw7qdiqjBXJZu55x4YZ7g73bOMXQ7E1LQ7TwP7HbOASblhDye4KInInLM51rOBFVxPJuB9Z9nebej4nKegHFz5fh5wBw/3/Icr4mkOMltLpKkXCC023kOtta41a7tXJjHaPCF8G7HjVwInAQTLe92lA8nwrsdNzLR8m5HFboL8uwuxpOEdDvIHL9IaLfzHKzbcVN2befieGGe7O92LjZ0O5NT0O08B+x2LgYm5eQ8nuCiJyJyzFMsZ4KqOF7EwPqnWt7tqLhMFTBurhyfCszxaZbneE0kxUluc5EkZbrQbudZ3K+LVut2ZuQxGjwD3u2UR2YAJ8Ellnc7yoeXwLud8sgllnc7qtBNz7O7GM8U0u0gc3yW0G7nWdyvi6as25kdL8xz/N3ObEO3MycF3c6zwG5nNjAp5+TxBBc9EZFjnms5E1TFcRYD659nebej4jJPwLi5cnweMMfnW57jNZEUJ7nNRZKUBUK7nWdwT6AO6/YuzGM0eCG82wmHFwInwSLLux3lw0XwbiccXmR5t6MK3YI8u4vxpUK6HWSOXya023kG1u2ESw3msnQ7i+OFeYm/21ls6HaWpKDbeQbY7SwGJuWSPJ7goicicsyXW84EVXG8jIH1X2F5t6PicoWAcXPl+BXAHL/S8hyviaQ4yW0ukqRcJbTbeRq21hRV63auzmM0+Gp4t1MUvho4Ca6xvNtRPrwG3u0Uha+xvNtRhe6qPLuL8bVCuh1kjl8ntNt5GtbtFKWs27k+XpiX+rud6w3dztIUdDtPA7ud64FJuTSPJ7joiYgc8w2WM0FVHK9jYP03Wt7tqLjcKGDcXDl+IzDHb7I8x2siKU5ym4skKTcL7Xaegq01EVe395Y8RoNvgXc7EfcW4CS41fJuR/nwVni3E6k2bifJzTRuRKG7Oc/uYnybkG4HmeO3C+12noJ1OxHHYC5Lt3NHvDDf6e927jB0O3emoNt5Ctjt3AFMyjvzeIKLnojIMd9lORNUxfF2BtZ/t+XdjorL3QLGzZXjdwNz/B7Lc7wmkuIkt7lIknKv0G7nSdhaU+ro9t6Xx2jwffBup9S5DzgJ7re821E+vB/e7ZQ691ve7ahCd2+e3cX4ASHdDjLHHxTa7TwJ63ZKYgZzWbqdh+KF+WF/t/OQodt5OAXdzpPAbuchYFI+nMcTXPRERI75EcuZoCqODzKw/kct73ZUXB4VMG6uHH8UmOOPWZ7jNZEUJ7nNRZKUx4V2O8twTymo9gTqJ/IYDX4C3u2UVz4BnATLLO92lA+Xwbud8spllnc7qtA9nmd3MX5SSLeDzPGnhHY7y3BPKUjZE6ifjhfmZ/zdztOGbueZFHQ7y4DdztPApHwmjye46ImIHPOzljNBVRyfYmD9z1ne7ai4PCdg3Fw5/hwwx5+3PMdrIilOcpuLJCkvCO12noCtNcFq13ZezGM0+EV4txN0XgROgpcs73aUD1+CdztB5yXLux1V6F7Is7sYvyyk20Hm+CtCu50ncE+gTtm1nVfjhXm5v9t51dDtLE9Bt/MEsNt5FZiUy/N4goueiMgxv2Y5E1TF8RUG1v+65d2OisvrAsbNleOvA3P8DctzvCaS4iS3uUiSskJot/M4bq2p0O19M4/R4Dfh3Y5T8SZwEqy0vNtRPlwJ73acipWWdzuq0K3Is7sYrxLS7SBzfLXQbudxWLfjlBvMZel21sQL81p/t7PG0O2sTUG3A1yB3DXApFybxxNc9EREjvkty5mgKo6rGVj/25Z3OyoubwsYN1eOvw3M8Xcsz/GaSIqT3OYiScq7Qrudx2BrTUm1O9ney2M0+D14t1NS+R5wErxvebejfPg+vNspqXzf8m5HFbp38+wuxh8I6XaQOf6h0G7nMdz3dlJ2J9tH8cK8zt/tfGTodtaloNt5DNjtfARMynV5PMFFT0TkmD+2nAmq4vghA+v/xPJuR8XlEwHj5srxT4A5/qnlOV4TSXGS21wkSflMaLfzKGytcas9k+3zPEaDP4d3O677OXASfGF5t6N8+AW823GrjdtJcjONG1HoPsuzuxh/KaTbQeb4V0K7nUdxd7Kl7JlsX8cL8zf+budrQ7fzTQq6nUeB3c7XwKT8Jo8nuOiJiBzzt5YzQVUcv2Jg/d9Z3u2ouHwnYNxcOf4dMMe/tzzHayIpTnKbiyQpPwjtdh7B3YxR7Xs7P+YxGvxjHl7vT5Z3KGrcP+VtdDBIL0tXoQrKD3l2F72fhXQVyLz8hbnQI2LyC0OOp7KgPsxUUH/NYzT4V4aC+pvlBVWN+7cUFVQnuc1VE+O3PJ4Jhxp3KifZQ7k4H+j2/p7HaPDvDCvi78CK/oflE1b58A+GSfCH5edo1ST9g6H9+RkY7z8tP12gcudPpmLvbei5/ScwPn9Z3uLX1DE4yW0usmP42/IcVzH+m4HIIfMwlSThAY0kuOFQMFgaUjaFo45bFK0IhoPBaHmRU+GUVQQrI0VuJFYULApVRCvKyf4yN+bEyioisfAGXbq96/MYDV5vmATJGr8eOPn/sZwkKB/+Y5gEyfrwHzBTbh5IzQW5B3J5FrsA1r/VWHggXysQaDYFDKSrXxjUja6jzRW1ST6lv66r4+acrnSi/FovH3vew/Or0jthC3OBLvS6Fa4TcyJBp8wprSgpLY9Eg+XhslgoVhyKhrbUr5tLdqRf6zP5tX7crw01mX+zuRjpxbNB/oa/DdUc5CgY+uRGOSOQj63MXOOuzzjuZG1sxOxDJ7nNVYnZKB8fm8ZMRaFxgmLrJLe5DZl80YTJF02SWHg2ZzNXXrxa+P9aUyo2Yx9bDiwvtLsOqIWvEUMtBcbbRfpQkQoFU4cTqKMPNpdTuk6O+o3yiU6wmibqcJzkNrcRU0FsmqDD2Ywad3Ofo2xuylAYXivkaX8b1jFmdSEyyY65Wb6dBQYZCz0vm2kL9ZbGZ3M+R8anuabLDYVobkRL3Vg0FioujQTL3ZJQSUmsKFZaEi6KxoqLyqKllW5RWSgYqSx1Ym64srK0OFRRWhKLRCtKYnrRdqOhUFE0Ul7hFgdLysqdcDRU5sSKSkPU/EZDpdFoKFxSUhYKRUvCsXCEGlZqg8NOcWlpxCkJhiJBrvg01zpN1KKw2TMb2iZlUWghcVFowbwotGBYFF4vtGNRqDGJS/+9eT+GLDotLV0UkLHQ87IlYFHY3Gk+ZHxaWboocMWn1X/o9GPr+OnHNqbTj05yW43n/pHXQZK+kAcsLhyB93zYQIgPk9WVYXk81ITJYFjY2zKRnLaMp0XbMPmiHZMv2jGeFuXKixWFdp8W5cqBN5nH7SS3/bsgZzCcFgXG20X68L9yWrQ1UwfcnrMDzmAqiO0ZO2Blc3uGwrCyUMZp0QwgKcrMt7PAIGOh52VmCk6LIuOTBeyA9aKdbAfMFZ8sQ3zQN3gh49OBqX52APhhc2dqkH7IZvJDdi1Ok9u8kBvMheWxThJyJJKEHGaSkMNAElYVpoYkJHl3LLTI5QJ1IUkCMhZ6XubWgiQke5ctMj55+biFHUkSuOKTx3i2ZW28+0Y/vmot7PFVYReZO/mw2h6uFiOlVz0STC3YNwY23UB+raqhcBLQwH4bO6KJSn2myYQasNLV8X9ochYAJyfzRHT/lydiAXIiSq2YXQQEqlM6UI47pLH9NnZOB8pxiwXMqMJ0oBx3ewGB6pIOlOMOF1D6uqYD5bgjBASqWzpQjjtKQKC6pwPluOUCAtUjHSjHjQoI1FbpQDluTECgeqYD5bhjBASqVzpQjnuUgED1TgfKcccKCFSfdKAc91gBgdo6HSjHHSfgFNI26UA57gkCZtS26UA57o0CZtR26UA57kkCZtT26UA57ikCAuWkA+W4pwkIlJsOlOOeISBQwXSgHPcsAYEKpQPluE8KYH1F6UA57jkCZlRxOlCOe66AQJWkA+W45wsIVGk6UI57oYBAhdOBctxJAgIVSQfKcS8WEKgd0oFy3CkCArVjOlCOO01AoHZCBkp9wbdNYON3y5SxXXxBqw8eANf3zpyktrCDHqeybQ3w12mVvk75dn89iMOHq8E+7Mzgw86W+3AV2IeFDD4stNyHK8E+7MLgwy6W+/BNsA+7Mviwq+U+XAH2YTcGH3az3IdvgH3YncGH3S334etgH/Zg8GEPy334GtiHWzH4cCvLfbgc7MOeDD7sabkPXwX7sBeDD3tZ7sNXwD7szeDD3pb78GWwD/sw+LCP5T58CezDrRl8uLXlPnwR7MNtGHy4jeU+fAHsw20ZfLit5T58HuzD7Rh8uJ3lPnwO7MPtGXy4veU+fBbsQ4fBh47lPnwG7EOXwYeu5T58GuzDIIMPg5b78CmwD0MMPgxZ7sMnwT4sYvBhkeU+XAb2YTGDD4st9+ETYB+WMPiwxHIfPg72YSmDD0st9+FjYB+GGXwYttyHj4J9GGHwYcRyHz4C9uEODD7cwXIfPgz24Y75dt+tyOHDh8A+3Cnf8hsJfRtGb6gkYNgwuoMun+6NOaVilhHf35n8vQthV+V3wm6E3Ql7EPYk7EXYm7APYV/CfoT9CQcQDszfoOOg/LhS7xcnlNJCn2wXg2xXg6yvQbabQba7QbaHQbanQXZQXKY29ERb4/uhBdQNlnX9abzEVm74QYhkbVQ3vIbjxQXlv05A3x0Mskv9kJOePwdr+RPgyCO3uu3J+qEfsKjqfujHOI9WM8wjdUMs+gdLgDfZuv2A4z2EKeaHpCD3DwH64VAmPxzKmPurGHK/kCH3gTdHu4cCx9ufKeb9uXOf/LCzpX5QOhqCx/om8kepqG6sBM2bDV/kcVzvhnjkPOyKnoc0buAN9tVuNE92vAOY5uGAFKxBA4B+GMjkh4GMa9AKhjWoG8MaBLyp3x0IHO8gppgPSkHuDwL6YTCTHwYz5v4bDLnfnSH3gV/GcAcDx3sYU8wPSwH/2sVSPygdaP71Gph/vc7Av3qA5+FWDPwL+IWeal9sSXa8Q5jm4ZAUrEFDgH4YyuSHoYxr0HKGNagnwxoE/BKROxQ43mFMMR+WgtwfBvTD4Ux+OJwx919lyP1eDLkP/PKXezhwvMOZYj48BfxrV0v9oHSg+dfLYP71CgP/6g2eh30Y+BfwC4TVvkiX7HiPYJqHR6RgDToC6IcRTH4YwbgGvcSwBm3NsAYBv7TojgCOdyRTzEemIPdHAv0wiskPoxhz/0WG3N+GIfeBXzZ1RwHHW8YU87IU8K++lvpB6UDzr+fB/OsFBv61LXgebsfAv4BfWK72xd1kx1vONA/LU7AGlQP9UMHkhwrGNeg5hjVoe4Y1CPglabcCON4oU8yjKcj9KNAPlUx+qGTM/WcZct9hyH3gl9vdSuB4Y0wxj6WAf+1mqR+UDjT/ehrMv55h4F8ueB4GGfgX8AEJ1R4UkOx4RzPNw9EpWINGA/0whskPYxjXoKcY1qAQwxoEfCiDOwY43iOZYn5kCnL/SKAfjmLyw1GMuf8kQ+4XMeQ+8GEa7lHA8R7NFPOjU8C/drfUD0oHmn89AeZfyxj4VzF4HpYw8C/gA1mqPZgk2fGOZZqHY1OwBo0F+uEYJj8cw7gGPc6wBpUyrEHAh8C4xwDHeyxTzI9NQe4fC/TDcUx+OI4x9x9jyP0wQ+4DH97jHgcc7/FMMT8+BfxrD0v9oHSg+dcjYP71KAP/ioDn4Q4M/Av4AKhqD0JKdrwnMM3DE1KwBp0A9MOJTH44kXENephhDdqRYQ0CPnTKPRE43nFMMR+XgtwfB/TDSUx+OIkx9x9iyP2dGHIf+LAw9yTgeE9mivnJKeBfe1rqB33M9cBj3gsw5vKyDbo47dxbiD/3EWLnvkLs3E+InfsLsfMAIXYeCLRT9a7qoY/6j2pnBKpvaPt3ZvAz2sZdBNi4qwAb+wqwcTcBNu4uwMY9BNi4J1ONR9gYKgmz6OWyN633v6UXpzsYZNTtejVB5yqn0Lw+lXAa4XTCGYQzCWcRxhPOJpxDmEA4l3Ae4XzCBYQL8wPVHwR9Sv6mD4c+1SA7zSA73SA7wyA70yA7yyAbb5BdYJBdGJcpQpcT2HgCQN/QxfTsfOuT0VX/6L6YmL/h7yR/0NUBP/NFn5k6G3QVRumaCDwjM0lI5yPFznOE2DlBiJ3nCrHzPCF2ni/ETkS9LI/8y6qrnYH1nx1Ptn4Cz2i4pzDFBj1m4BkS91QhYwaecXFPEzJm4Bkc93QhYwaeEXLPEDJm4Bkm90whYwaesXLPEjJm4Bkwd3yKxuxs2eZ6OxcAe6WLmK7i63rBfvA290Jg7C9C3VFYGYuo8bcPbPorYfqvg+m/Cqb/Gpj+K2D6r3/pv/ql/9rXunYb91s32PJ9/STMhdr+x5r+T7T9T7X9z7T9z7X9L7T9L7X9r+L7k+lzphCmEqYRphNmEC4hzMzfcPInN7DxvIW+obn5ZPtP/qitiE23u2H+er717gKeRX6ZTZhDmOs/yaQONvXJZhtkcwyyuXGZvjXCOqtaUJMtlLNQBSLmuLOBJ87mQHRt8Ndc8KX4VE3eKenJa5y888gv8wkLCAv9k3eeYVLON8gWGGQLUzB5pwAn7zzg5J0PnLwLgJN3odDJOzU9eY2TdxH55VLCZYTF/sm7yDApLzXILjPIFqdg8k4FTt5FwMl7KXDyXgacvIuFTt5p6clrnLxLyC+XE64gXOmfvEsMk/Jyg+wKg+zKFEzeacDJuwQ4eS8HTt4rgJP3SqGTd3p68hon71Xkl6sJ1xCu9U/eqwyT8mqD7BqD7NoUTN7pwMl7FXDyXg2cvNcAJ++1QifvjPTkNU7e68gv1xOWEm7wT97rDJPyeoNsqUF2Qwom7wzg5L0OOHmvB07epcDJe4PQyXtJevIaJ++N5JebCDcTbvFP3hsNk/Img+xmg+yWFEzeS4CT90bg5L0JOHlvBk7eW4RO3pnpyWucvLeSX24j3E64wz95bzVMytsMstsNsjtSMHlnAifvrcDJextw8t4OnLx3ACeBl0xXBMCJSlvTtL60vrS+tL60vrS+tL60vrQ+m/W5HvffOntjH9BH2++t7ffS9ntq+1tp+z20/e7afjdtv6u230XbL9T2O2v7nbT9Am2/o7afr+3nafu52n6Otp+t7XfQ9rO0/Uxtv722307bb6vtZ2j7bbT91tp+K22/pbb/Q7ON+99r+99p+99q+99o+19r+19p+19q+19o+59r+59p+59q+59o+x9r++u0/Y+0/Q+1/Q+0/fe1/fe0/Xe1/Xe0/be1/be0/bXa/hptf7W2v0rbX6ntv6ntr9D239D2i1ts3C/S9kPaflDbd7V9R9vfXtvfTtvfVtvfRtvfWtvvo+331vZ7afs9tf2ttP0e2n53bb+btt9V2++i7Rdq+521/U7afoG231Hbz9f287T9XG0/R9vP1vY7aPvH5mzcP0bbH6vtH63tH6XtH6ntj9H2R2v7MW2/UtuPavsV2n65tl+m7Y/S9kdq+yO0/SO0/eHa/uHa/jBtf6i2P0TbP0zbH6ztD9L2B2r7A7T9/tr+odr+Idp+P23/Wu08kH4pVb/Uql+KvUHb16/e6Fd39Ks/t2j7+glj/YSyfsL5Dm1fP0eln8PSz3HN1fb125/126P126cXavv6HZf6HZn6HZuLtX39Ji/9JjD9JrErtX39vhL9vhPvvpTbAxu2O+n/dxHuJtxDuJdwH+F+wgOEBwkPER4mPEJ4lPAY4XHCE4RlhCcJTxGeJjxDeJbwHOF5wguEFwkvEV4mvEJ4lbCc8BrhdcIbhBWENwkrCasIqwlrCGsJbxHeJrxDeJfwHuF9wgeEDwkfEdYRPiZ8QviU8Bnhc8IXhC8JXxG+JnxD+JbwHeF7wg+EHwk/EX4m/EL4lfAb4XfCH4Q/CX8R/iasJ/yjTnx2JH8S6hMaEBoSGhEaE5oQmhKaEZoTWhBaEloRWhPaEDIIbQntCO0JmYQsQgdCNiGHkEvII+QTOhIKCJ0InQmFhC6EroRuhO6EHoStCD0JvQi9CX0IWxO2IWxL2I6wPcEhuIQgIUQoIhQTSgilhDAhQtiBsCNhJ8LOhF0IuxL6EnYj7E7Yg7AnYS/C3oR9CPsS9iPsTziAcCDhIMLBhH6EQwiHEvoTBhAGEgYRBhMOIwwhDCUMIxxOGE44gjCCMJIwilDWcUNOq8373pHa+sb/OkluTaH6yp103fv/r3ve81LKKXcqCFFCJSFGGE0YQziScBThaMJYwjGEYwnHEY4nnNBxwwWRtlrO1dP+5sT3T6TXjSOcRDiZcArhVMJphNMJZxDOJJxFGE84m3AOYQLhXMJ5hPMJFxAuJEwkTCJcRLi4Y/zDqh4h3nHjYKseMW2QnWSQnWyQnWKQnWqQnWaQnW6QnWGQnWmQnWWQjTfIzjbIzjHIJhhk5xpk5xlk5xtkFxhkFxpkEw2ySQbZRQbZxXGZSrJ2AXOSdY7vT6bXTiFMJUwjTCfMIFxCmEmYRZhNmEOYS5hHmE9YQFhIWES4lHAZYTFhCeFywhWEKwlXEa4mXEO4lnAd4XrCUn8CTjYMZIpBNtUgm2aQTTfIZhhklxhkMw2yWQbZbINsjkE21yCbZ5DNN8gWGGQLDbJFBtmlBtllBtlig2yJQXa5QXaFQXalQXaVQXa1QXaNQXatQXadQXa9Qba0DpPhBnrtjYSbCDcTbiHcSriNcDvhDsKdhLsIdxPuIdxLuI9wP+EBwoOEhwgPEx4hPEp4jPA44QnCMsKThKcITxOeITzrnww3GAZyo0F2k0F2s0F2i0F2q0F2m0F2u0F2h0F2p0F2l0F2t0F2j0F2r0F2n0F2v0H2gEH2oEH2kEH2sEH2iEH2qEH2mEH2uEH2hEG2zCB70iB7yiB72iB7xiB7tg6T4Tl67fOEFwgvEl4ivEx4hfAqYTnhNcLrhDcIKwhvElYSVhFWE9YQ1hLeIrxNeIfwLuE9wvuEDwgfEj4irCN8TPjEPxmeMwzkeYPsBYPsRYPsJYPsZYPsFYPsVYNsuUH2mkH2ukH2hkG2wiB70yBbaZCtMshWG2RrDLK1BtlbBtnbBtk7Btm7Btl7Btn7BtkHBtmHBtlHBtk6g+xjg+yTOkyGT+m1nxE+J3xB+JLwFeFrwjeEbwnfEb4n/ED4kfAT4WfCL4RfCb8Rfif8QfiT8Bfhb8J6wj8q6QvoMwn1CQ0IDQmNCnxGf2oYyGcG2ecG2RcG2ZcG2VcG2dcG2TcG2bcG2XcG2fcG2Q8G2Y8G2U8G2c8G2S8G2a8G2W8G2e8G2R8G2Z8G2V8G2d8G2XqD7B+DTCWGX1bPIKtvkDUwyBoaZI0Kaj8ZGtNrm6jXE5oRmhNaEFoSWhFaE9oQMghtCe0I7QmZhCxCB0I2IYeQS8gj5BM6EgoInQidCYWELoSuhG6E7v7J0NgwkCYGWVODrJlB1twga2GQtTTIWhlkrQ2yNgZZhkHW1iBrZ5C1N8gyDbIsg6yDQZZtkOUYZLkGWZ5Blm+QdTTICgyyTgZZZ4Os0CDrYpB1Nci6GWTd6zAZetBrtyL0JPQi9Cb0IWxN2IawLWE7wvYEh+ASgoQQoYhQTCghlBLChAhhB8KOhJ0IOxN2IexK6EvYjbA7YQ//ZOhhGMhWBllPg6yXQdbbIOtjkG1tkG1jkG1rkG1nkG1vkDkGmWuQBQ2ykEFWZJAVG2QlBlmpQRY2yCIG2Q4G2Y4G2U4G2c4G2S4G2a4GWV+DbDeDbHeDbI86TIY96bV7EfYm7EPYl7AfYX/CAYQDCQcRDib0IxxCOJTQnzCAMJAwiDCYcBhhCGEoYRjhcMJwwhGEEYSRhFGEMkK5fzLsaRjIXgbZ3gbZPgbZvgbZfgbZ/gbZAQbZgQbZQQbZwQZZP4PsEIPsUIOsv0E2wCAbaJANMsgGG2SHGWRDDLKhBtkwg+xwg2y4QXaEQTbCIBtpkI0yyMoMsvI6TIYKem2UUEmIEUYTxhCOJBxFOJowlnAM4VjCcYTjCScQTiSMI5xEOJlwCuFUwmmE0wlnEM4knEUYTzibcA5hAuFc/2SoMAwkapBVGmQxg2y0QTbGIDvSIDvKIDvaIBtrkB1jkB1rkB1nkB1vkJ1gkJ1okI0zyE4yyE42yE4xyE41yE4zyE43yM4wyM40yM4yyMYbZGcbZOcYZBMMsnPrMBnOo9eeT7iAcCFhImES4SLCxYTJhCmEqYRphOmEGYRLCDMJswizCXMIcwnzCPMJCwgLCYsIlxIuIywmLCFcTrjCPxnOMwzkfIPsAoPsQoNsokE2ySC7yCC72CCbbJBNMcimGmTTDLLpBtkMg+wSg2ymQTbLIJttkM0xyOYaZPMMsvkG2QKDbKFBtsggu9Qgu8wgW2yQLTHILjfIrtAmg3qyp35Hgbd5E6Nv/K+T3OYCdbE+1b4X0M56mp1XFsQdnpl2eDU7kQ5ndej1WXQuv8OmepP9fuVOXXgc0BA7/lBGFvBRLAW4uJzbGacLGAtXr7hqvIWBQML8TNanVwN8GiqNRMroQ5Rt7bQcUv+/ujGdBvb2Czbuq83bdxps2Pfedw297lrCdYTrCzbIFbLivqlp64uJQVDZVJ/pMzxf1RRPJ7lNTAG/poCpgHtbfbDBevFJdtItLeApGEvjBUNNlg6BjROKM5D1Av/bCYe28yohdjYIpHgCJzvpkIPvzTR49JiBk9PtI2TM9YFj3lrImIGT0d0mRWN2ktvcbYH+y2ggo+huF5Bh5/ZC7HSE2OkCc13pQNefqxpR19YISJBJ132N8H4MguON7sbV2aIXOuBrZQho4+6F9vvwRQYfFgFt3FOAD19i8GEx0Ma9BfjwZQYflgBt3FeAD19h8GEp0Mb9BfjwVQYfhoE2HijAh8sZfBgB2nhoB/t9+BqDD3cA2thfgA9fZ/DhjkAbBwjw4RsMPtwJaONAAT5cweDDnYE2DhLgwzcZfLgL0MbBAny4ksGHuwJtPEyAD1cx+LAv0MYhAny4msGHuwFtHCrAh2sYfLg70MZhAny4lsGHewBtPFyAD99i8OGeQBuHC/Dh2ww+3Ato4xECfPgOgw/3Bto4QoAP32Xw4T5AG0cK8OF7DD7cF2jjKAE+fJ/Bh/sBbSwT4MMPGHy4P9DGcgE+/JDBhwcAbawQ4MOPGHx4INDGqAAfrmPw4UFAGysF+PBjBh8eDLQxJsCHnzD4sB/QxtECfPgpgw8PAdo4RoAPP2Pw4aFAG48U4MPPGXzYH2jjUWAfehv6PskBARl2DhRi5yAhdg4WYudhQuwcIsTOoULsHCbEzsOF2DlciJ1HCLFzhBA7Rwqxc5QQO8uE2FkuxM4KIXZGhdhZKcTOmBA7Rwuxc4wQO48UYudRQuw8WoidY4XYeYwQO48VYudxQuw8XoidJwix80Swnf5zvcmen32fziEf3QGn7yPSt18HvB/HCfDjWKAf1zH58SQBfjwG6MePmfx4sgA/Hgv04ydMfjxFgB+PA/rxUyY/nirAj8cD/fgZkx9PE+DHE4B+/JzJj6cL8OOJQD9+weTHMwT4cRzQj18y+fFMAX48CejHr5j8eJYAP54M9OPXTH4cL8CPpwD9+A2TH88W4MdTgX78lsmP5wjw42lAP37H5McJAvx4OtCP3zP58VwBfjwD6McfmPx4ngA/ngn0449MfjxfgB/PAvrxJyY/XiDAj+OBfvyZyY8XCvDj2UA//sLkx4kC/HgO0I+/MvlxkgA/TgD68TcmP14kwI/nAv34O5MfLxbgx/OAfvyDyY+TBfjxfKAf/2Ty4xQBfrwA6Me/mPw4VYAfLwT68W8mP04T4MeJQD+uZ/LjdAF+nAT04z9MfpwhwI8XAf2ofq2Ow4+XCPDjxUA/1mPy40wBfpwM9GN9Jj/OEuDHKUA/NmDy42wBfpwK9GNDJj/OEeDHaUA/NmLy41wBfpwO9GNjJj/OE+DHGUA/NmHy43wBfrwE6MemTH5cIMCPM4F+bMbkx4UC/DgL6MfmTH5cJMCPs4F+bMHkx0sF+HEO0I8tmfx4mQA/zgX6sRWTHxcL8OM8oB9bM/lxiQA/zgf6sQ2THy8X4McFQD9mMPnxCgF+XAj0Y1smP14pwI+LgH5sx+THqwT48VKgH9sz+fFqAX68DOjHTCY/XiPAj4uBfsxi8uO1Avy4BOjHDkx+vE6AHy8H+jGbyY/XC/DjFUA/5jD5cakAP14J9GMukx9vEODHq4B+zGPy440C/Hg10I/5TH68SYAfrwH6sSOTH28W4MdrgX4sYPLjLQL8eB3Qj52Y/HirAD9eD/RjZyY/3ibAj0uBfixk8uPtAvx4A9CPXZj8eIcAP94I9GNXJj/eKcCPNwH92I3Jj3cJ8OPNQD92Z/Lj3QL8eAvQjz2Y/HiPAD/eCvTjVkx+vFeAH28D+rEnkx/vE+DH24F+7MXkx/sF+PEOoB97M/nxAQF+vBPoxz5MfnxQgB/vAvpxayY/PiTAj3cD/bgNkx8fFuDHe4B+3JbJj48I8OO9QD9ux+THRwX48T6gH7dn8uNjAvx4P9CPDpMfHxfgxweAfnSZ/PiEAD8+CPRjkMmPy8B+9Lb6YDufBMamdwMZY34KOOalQsb8NHDMLzSSMeZngGP+rrHddfFvsq9xE5y+FqTrpKb4uvhsgCd3GoLtfA4Qm8rYhu3vxri4LOyE0zWn0O6czqC1PjMLp+960vU1w1r/fADrx3pgP6pxf0PjbgAe9wvAOZIBjPO5nXlqDDpvXgzIsPMlIXa+LMTOV4TY+aoQO5cLsfM1IXa+LsTON4TYuUKInW8KsXOlEDtXCbFztRA71wixc60QO98SYufbQux8R4id7wqx8z0hdr4vxM4PhNj5IZOd6PPLHwVw5yyuEXIdYR1wzDuAx4zOw+3Ivqsa4H34MdCHVwnJm0+AY/6qsYwxfwoc8+pGds+VV8m+LxrjffgZ0IdfCLiGF2uKvYZ3AsM1vM8DvLmIGPeJTfHXO74AxxqlS78m6CS5ccRDjXUcQx5+GbB7PqtrWk8C71VS1/G+YLh++VXA7vxR4/6S4frl1+BYo3Shr1+i46HG+hVDHn4DzkNvQ9v5rRA7vxNi5/dC7PxBiJ0/CrHzJyF2/izEzl+E2PmrEDt/E2Ln70Ls/EOInX8KsfMvIXb+LcTO9ULs/EeInUqhBDvrCbGzvhA7Gwixs6EQOxsJsbOxEDubCLGzqRA7mwmxs7kQO1sIsbOlEDtbCbGztRA72wixM0OInW2F2NlOiJ3thdiZKcTOLCF2dhBiZ7YQO3OE2JkrxM48IXbmC7GzoxA7C4TY2UmInZ2F2FkoxM4uQuzsKsTObkLs7C7Ezh5C7NxKiJ09hdjZS4idvYXY2UeInVsLsXMbIXZuK8TO7YTYub0QOx0hdrpC7AwKsTMkxM4iIXYWC7GzRIidpULsDAuxMyLEzh2Y7KzvszPZ77fUA455x//BMe8kZMwNgGPeOUVjdpLb3F3q4fx3TYGMMe8KHPNVBTJqbV8ha8JuQuzcXYidewixc08hdu4lxM69hdi5jxA79xVi535C7NxfiJ0HCLHzQCF2HiTEzoOF2NlPiJ2HCLHzUCF29hdi5wAhdg4UYucgIXYOFmLnYULsHCLEzqFC7BwmxM7Dhdg5XIidRwixc4QQO0cKsXOUEDvLhNhZLsTOCiF2RoXYWSnEzpgQO0cLsXOMEDuPFGLnUULsPFqInWOF2HmMEDuPFWLncULsPF6InScIsfNEIXaOE2LnSULsPFmInacIsfNUIXaeJsTO04XYeYYQO88UYudZQuwcL8TOs4XYeY4QOycIsfNcIXaeJ8TO84XYeYEQOy8UYudEIXZOEmLnRULsvFiInZOF2DlFiJ1Thdg5TYid04XYOUOInZcIsXOmEDtnCbFzthA75zDZWR9s51zNzmS/u9gwS8aY5wHHfFUrnjEXgsc8v3o+uk4S232t6ui/0hr952a1r3MsSmvS1aH9FsQ1bNaV3X6LciRs0pWzZboiJbFNdeW23+Lcdfy68tonMQ+C1XXlt09qTjm6ro7tk5yfRRt1FbRPeq4HPV2dktcVqtygzO0M0RVT2txCkC7S5nYB6PJqY1e/rugW63Kf3tQud0t1PWMao7Nlup41+8vZEl3P1eD7SKzuup6vOY7huup6IVFOlNZN14sJ86soVhddL20uV4tqr+vlzed9cW11vVKbOeTUTtertZuPTm10La/t3C7dvK7Xal8nKjan6/W61JzSxLreqFv9CibStaK6rlAStdANaFth/K+n20lucxfUw9nZDVizuwNrdg9gzd4KWLN7Amt2L2DN7g2s2X2ANXtrYM3eBliztwXW7O2ANXt7YM12gDXbBdbsILBmh+rKXxP0pkXA3rQY2JuWAHvTUmBvGgb2phFgb7oDsDfdMdn+SOtNd0q+16rqTXdOXldVb7oLsDfdFdib9gXo8nrT3drLOG+3EMjtdgdyuz2A3G5PILfbC8jt9gZyu32A3G5fILfbD8jt9gdyuwOA3O5AILc7CMjtDgZyu35AbncIkNsdCuR2/YHcbgCQ2w0EcrtBQG43GMjtDgNyuyFAbjcUyO2GAbnd4UBuNxzI7Y4AcrsRQG43EsjtRgnhdouA3K4MyO3KgdyuAsjtokBuVwnkdjEgtxsN5HZjgNzuSCC3OwrI7Y4GcruxQG53DJDbHQvkdscBud3xQG53ApDbnQjkduOA3O4kILc7GcjtTgFyu1OB3O40ILc7HcjtzgByuzOB3O4sILcbD+R2ZwO53TlCuN2lQG43AcjtzgVyu/OA3O58ILe7AMjtLgRyu4lAbjcJyO0uAnK7i4HcbjKQ200BcrupQG43DcjtpgO53Qwgt7sEyO1mArndLCC3mw3kdnOA3G4ukNvNA3K7+UButwDI7RYCud0iILe7FMjtLgNyu8VAbrdECLe7DMjtLgdyuyuA3O5KILe7CsjtrgZyu2uA3O5aILe7Dsjtrgdyu6VAbncDkNvdCOR2NwG53c1AbncLkNvdCuR2twG53e1AbncHkNvdCeR2dwG53d1AbncPkNvdC+R29wG53f1AbvcAkNs9COR2DwG53cNAbveIEG63GMjtHgVyu8eA3O5xILd7AsjtlgG53ZNAbvcUkNu9CeR2K4HcbhWQ260Gcrs1QG63Fsjt3gJyu7eB3O4dILd7F8jt3gNyu/eB3O4DILf7EMjtPgJyu3VAbvcxkNt9AuR2nwK53WdAbvc5kNt9AeR2XwK53VdCuN0SILf7GsjtvgFyu2+B3O47ILf7HsjtfgByux+B3O4nILf7GcjtfgFyu1+B3O43ILf7Hcjt/gByuz+B3O4vILf7G8jt1gO53T9AbhfIxHG7epk4bld/C3WZuF2DLde1CbdrmIwuH7drlJyuatyucbK6NG7XJBPBoTboapqJ4WNKV7NMHLdrDtDlcbsWmTK43eVAbtcyE8ftWmXiuF3rTBy3a5OJ43YZmThu1zYTx+3aZeK4XftMHLfLzMRxu6xMHLfrkInjdtmZOG6Xk4njdrmZOG6Xl4njdvmZOG7XMRPH7QoycdyuUyaO23UGcrtCILfrAuR2XYHcrhuQ23UHcrseQG63FZDb9QRyu15AbtcbyO36COF2VwC53dZAbrcNkNttC+R22wG53fZAbucAuZ0L5HZBILcLAbldEZDbFQO5XQmQ25UCuV0YyO0iQG63A5Db7QjkdjsBud3OQG63C5Db7Qrkdn2B3G43ILfbHcjt9gByuz2B3G4vILfbG8jt9gFyu32B3G4/IdzuSiC32x/I7Q4AcrsDgdzuICC3OxjI7foBud0hQG53KJDb9QdyuwFAbjcQyO0GAbndYCC3OwzI7YYAud1QILcbBuR2hwO53XAgtzsCyO1GALndSCC3GwXkdmVAblcO5HYVQG4XBXK7SiC3iwG53WggtxsjhNtdBeR2RwK53VFAbnc0kNuNBXK7Y4Dc7lggtzsOyO2OB3K7E4Dc7kQgtxsH5HYnAbndyUBudwqQ250K5HanAbnd6UBudwaQ250J5HZnAbndeCC3OxvI7c4BcrsJQG53LpDbnQfkducDud0FQG53IZDbTQRyu0lCuN3VQG53EZDbXQzkdpOB3G4KkNtNBXK7aUBuNx3I7WYAud0lQG43E8jtZgG53Wwgt5sD5HZzgdxuHpDbzQdyuwVAbrcQyO0WAbndpUBudxmQ2y0GcrslQG53OZDbXQHkdlcCud1VQG53NZDbXQPkdtcCud11QrjdNUBudz2Q2y0FcrsbgNzuRiC3uwnI7W4GcrtbgNzuViC3uw3I7W4Hcrs7gNzuTiC3uwvI7e4Gcrt7gNzuXiC3uw/I7e4HcrsHgNzuQSC3ewjI7R4GcrtHgNzuUSC3ewzI7R4HcrsngNxuGZDbPQnkdk8Bud3TQrjdtUBu9wyQ2z0L5HbPAbnd80Bu9wKQ270I5HYvAbndy0Bu9wqQ270K5HbLgdzuNSC3ex3I7d4AcrsVQG73JpDbrQRyu1VAbrcayO3WALndWiC3ewvI7d4Gcrt3gNzuXSC3ew/I7d4HcrsPgNzuQyC3+wjI7dYJ4XbXAbndx0Bu9wmQ230K5HafAbnd50Bu9wWQ230J5HZfAbnd10Bu9w2Q230L5HbfAbnd90Bu9wOQ2/0I5HY/Abndz0Bu9wuQ2/0K5Ha/Abnd70Bu9weQ2/0J5HZ/Abnd30Butx7I7f4BcrtAFo7b1cvCcbv6AF0et2uQxcPt6sX/gnS719dD+a8yZrIvWT9+3zgQ+JvQADzupbBxx2LKPtR4RzblyZuGYP/dgPNfJdJ/CzvhdJ3emScW9cGxuLEebsxXFsgY803AMS/IldGH31yvmi7XSWK7JRfHY+/Mx/HYu/K3IK418Ni787coR4w89p4t02Xksffmb3HubsJj78tPYh74eOz9+UnNqWo89oH8JOenxmMfzE96rlfx2IfyEevWBl0P52PWQKXrkXzUeuq4jwJ0ebXxsXzc+bryjrjzdRUdcefroh1x5+sqO+LO18U64s7Xje6IO183piPufN2RHXHn647quNm8r/X5uqM71mIO1fJ83diOtZqPtTpfd0ztdNXqfN2xtdVVi/N1x9Ve12bP1x1fF12bOV93QkfctYuAthXG/3q6neQ29xbgNZbHgTX7iXxczV6Wj6vZT+bjavZT+bia/XQ+rmY/k4+r2c/m42r2c/m4mv18Pq5mv5CPq9kv5uNq9kv5uJr9cj6uZr+Sj6vZr+bjavbyuvLXBL3pa8De9HVgb/oGsDddAexN3wT2piuBvekqYG+6GtibrgH2pmuBvelbwN70bWBv+g6wN303X8Z5u1uB3O49ILd7H8jtPgByuw+B3O4jILdbB+R2HwO53SdAbvcpkNt9BuR2nwO53RdAbvclkNt9BeR2XwO53TdAbvctkNt9B+R23wO53Q9AbvcjkNv9BOR2PwO53S9AbvcrkNv9BuR2vwO53R9AbvcnkNv9BeR2fwvhdrcBud16ILf7B8jtAsBrLfWA11rqA6+1NABea2kIvNbSCHitpTHwWksT4LWWpsBrLc2A11qaA6+1tABea2kJvNbSCnitpXXddCXkdm3qqisBt8uou64auV3bLdFVA7dr1xHH7dpvoS4Tt8vccl2bcLusZHT5uF2H5HRV43bZyerSuF1ORwSH2qArtyOGjyldeR1x3C4foMvjdh07yuB2twO5XUFHHLfrBLyPpjOQ2xUCuV0XILfrCuR23YDcrjuQ2/UAcrutgNyuJ5Db9QJyu95AbtcHyO22BnK7bYDcblsgt9sOyO22B3I7B8jtXCC3CwK5XQjI7YqA3K4YyO1KgNyuFMjtwkBuFwFyux2A3G5HIdzuDiC32wnI7XYGcrtdgNxuVyC36wvkdrsBud3uQG63B5Db7QnkdnsBud3eQG63D5Db7QvkdvsBud3+QG53AJDbHQjkdgcBud3BQG7XD8jtDgFyu0OB3K4/kNsNAHK7gUBuNwjI7QYDud1hQG43BMjthgK53TAh3O5OILc7HMjthgO53RFAbjcCyO1GArndKCC3KwNyuxOB3G4ckNudBOR2JwO53SlAbncqkNudBuR2pwO53RlAbncmkNudBeR244Hc7mwgtzsHyO0mALnduUBudx6Q250P5HYXALndhUBuNxHI7SYBud1FQG53sRBudxeQ200GcrspQG43FcjtpgG53XQgt5sB5HaXALndTCC3mwXkdrOB3G4OkNvNBXK7eUBuNx/I7RYAud1CILdbBOR2lwK53WVAbrcYyO2WALnd5UBudwWQ210J5HZXAbnd1UBudw2Q210L5HbXAbnd9UBut1QIt7sbyO1uAHK7G4Hc7iYgt7sZyO1uAXK7W4Hc7jYgt7sdyO3uAHK7O4Hc7i4gt7sbyO3uAXK7e4Hc7j4gt7sfyO0eAHK7B4Hc7iEgt3sYyO0eAXK7R4Hc7jEgt3scyO2eAHK7ZUBu9ySQ2z0F5HZPA7ndM0Bu96wQbncPkNs9B+R2zwO53QtAbvcikNu9BOR2LwO53StAbvcqkNstB3K714Dc7nUgt3sDyO1WALndm0ButxLI7VYBud1qILdbA+R2a4Hc7i0gt3sbyO3eAXK7d4Hc7j0gt3sfyO0+AHK7D4Hc7iMgt1sH5HYfA7ndJ0K43b1AbvcpkNt9BuR2nwO53RdAbvclkNt9BeR2XwO53TdAbvctkNt9B+R23wO53Q9AbvcjkNv9BOR2PwO53S9AbvcrkNv9BuR2vwO53R9AbvcnkNv9BeR2fwO53Xogt/sHyO0CBThuV68AwaE26KpfgOFjSleDAhy3awjQ5XG7RgUyuN19QG7XuADH7ZoU4Lhd0wIct2tWgON2zQtw3K5FAY7btSzAcbtWBThu17oAx+3aFOC4XUYBjtu1LcBxu3YFOG7XvgDH7TILcNwuqwDH7ToU4LhddgGO2+UU4LhdbgGO2+UV4LhdfgGO23UswHG7ggIct+tUgON2nYHcrhDI7boAuV1XILfrBuR23YVwu/uB3K4HkNttBeR2PYHcrheQ2/UGcrs+QG63NZDbbQPkdtsCud12QG63PZDbOUBu5wK5XRDI7UJAblcE5HbFQG5XAuR2pUBuFwZyuwiQ2+0A5HY7ArndTkButzOQ2+0C5Ha7ArldXyC32w3I7XYHcrs9hHC7B4Dcbk8gt9sLyO32BnK7fYDcbl8gt9sPyO32B3K7A4Dc7kAgtzsIyO0OBnK7fkBudwiQ2x0K5Hb9gdxuAJDbDQRyu0FAbjcYyO0OA3K7IUBuNxTI7YYBud3hQG43HMjtjgByuxFAbjcSyO1GAbldGZDblQvhdg8CuV0FkNtFgdyuEsjtYkBuNxrI7cYAud2RQG53FJDbHQ3kdmOB3O4YILc7FsjtjgNyu+OB3O4EILc7EcjtxgG53UlAbncykNudAuR2pwK53WlAbnc6kNudAeR2ZwK53VlAbjceyO3OBnK7c4DcbgKQ250rhNs9BOR25wG53flAbncBkNtdCOR2E4HcbhKQ210E5HYXA7ndZCC3mwLkdlOB3G4akNtNB3K7GUBudwmQ280EcrtZQG43G8jt5gC53Vwgt5sH5HbzgdxuAZDbLQRyu0VAbncpkNtdBuR2i4HcbgmQ210O5HZXMHG7evG/IN3uw/VQ/quMmexL1o+NsgKBDEID8LgfgY07FlP2ocb7cAeevGkI9t+jOP9VIv13bmecrp26yJjDj9WTYefjQux8Qoidy4TY+aQQO58SYufTQux8Roidzwqx8zkhdj4vxM4XhNj5ohA7XxJi58tC7HxFiJ2vCrFzuRA7XxNi5+tC7HxDiJ0rhNj5phA7Vwqxc5UQO1cLsXONEDvXCrHzLSF2vi3EzneE2PmuEDvfE2Ln+0Ls/ECInR8KsfMjIXauE2Lnx0Ls/ESInZ8KsfMzIXZ+LsTOL4TY+aUQO78SYufXQuz8Roid3wqx8zshdn4vxM4fhNj5oxA7fxJi589C7PxFiJ2/CrHzNyF2/i7Ezj+E2PmnEDv/EmLn30LsXC/Ezn+E2BmoL8POekLsrC/EzgZC7GwoxM5GQuxsLMTOJkLsbCrEzmZC7GwuxM4WQuxsKcTOVkLsbC3EzjZC7MwQYmdbIXa2E2JneyF2ZgqxM0uInR2E2JktxM4cIXbmCrEzT4id+ULs7CjEzgIhdnYSYmdnIXYWCrGzixA7uwqxs5sQO7sLsbOHEDu3EmJnTyF29hJiZ28hdvYRYufWQuzcRoid2wqxczshdm4vxE5HiJ2uEDuDQuwMCbGzSIidxULsLBFiZ6kQO8NC7IwIsXMHIXbuKMTOnYTYubMQO3cRYueuQuzsK8TO3YTYubsQO/cQYueeQuzcS4idewuxcx8hdu4rxM79hNi5vxA7DxBi54FC7DxIiJ0HC7GznxA7DxFi56FC7OwvxM4BQuwcKMTOQULsHCzEzsOE2DlEiJ1Dhdg5TIidhwuxc7gQO48QYucIIXaOFGLnKCF2lgmxs1yInRVC7IwKsbNSiJ0xIXaOFmLnGCF2HinEzqOE2Hm0EDvHCrHzGCF2HivEzuOE2Hm8EDtPEGLniULsHCfEzpOE2HmyEDtPEWLnqULsPE2InacLsfMMIXaeKcTOs4TYOV6InWcLsfMcIXZOEGLnuULsPE+InecLsfMCIXZeKMTOiULsnCTEzouE2HmxEDsnC7FzihA7pwqxc5oQO6cLsXNGfRl2XiLEzplC7JwlxM7ZQuycI8TOuULsnCfEzvlC7FwgxM6FQuxcJMTOS4XYeZkQOxcLsXOJEDsvF2LnFULsvFKInVcJsfNqIXZeI8TOa4XYeZ0QO68XYudSIXbeIMTOG4XYeZMQO28WYuctQuy8VYidtwmx83Yhdt4hxM47hdh5lxA77xZi5z1C7LxXiJ33CbHzfiF2PiDEzgeF2PmQEDsfFmLnI0LsfFSInY8JsfNxIXY+IcTOZULsfFKInU8JsfNpIXY+I8TOZ4XY+ZwQO58XYucLQux8UYidLwmx82Uhdr4ixM5Xhdi5XIidrwmx83Uhdr4hxM4VQux8U4idK4XYuUqInauF2LlGiJ1rhdj5lhA73xZi5ztC7HxXiJ3vCbHzfSF2fiDEzg+F2PmREDvXCbHzYyF2fiLEzk+Z7KzvszPklBQVVZYGK92QW+YEI+XhYqeouLwk7Ibd4nBxNBgOhSrDReHSSHmk1Im4RaFKN1YcCcXiunsCx/xZisbsJLe5n9fH+W9pgYw4NwT67wshud0IOOYvhYy5MXDMXwkZcxPgmL8WMuamwDF/I2TMzYBj/lbImJsDx/ydkDG3AI75eyFjbgkc8w9CxtwKOOYfhYy5NXDMPwkZcxvgmH8WMuYM4Jh/ETLmtsAx/ypkzO2AY/5NyJjbA8f8u5AxZwLH/IeQMWcBx/ynkDF3AI75LyFjzgaO+W8hY84Bjnm9kDHnAsf8j5Ax5wHHHGggY8z5wDHXEzLmjsAx1xcy5gLgmBsIGXMn4JgbChlzZ+CYGwkZcyFwzI2FjLkLcMxNhIy5K3DMTYWMuRtwzM2EjLk7cMzNhYy5B3DMLYSMeSvgmFsCx0yq/r3HZ118wL0JfQhbE7YhbEvYjrC9+iyCSwgqfxCKCMWEEkIpIUyIEHYg7EjYibAzYRfCrvHx70bYnbAHYU/CXoS9CfsQ9iXsR9ifcADhQMJBhIMJ/QiHEA4l9CcMIAwkDCIMJhxGGEIYShhGOJwwnHAEYQRhJGEUoYxQTqggRAmVhBhhNGEM4UjCUYSjCWMJxxCOJRxHOJ5wAuFEwjjCSYSTCacQTiWcRjidcAbhTMJZhPGEswnnECYQziWcRzifcAHhQsJEwiTCRYSLCZMJUwhTCdMI0wkzCJcQZhJmEWYT5hDmEuYR5hMWEBYSFhEuJVxGWExYQriccAXhSsJVhKsJ1xCuJVxHuJ6wlHAD4UbCTYSbCbcQbiXcRridcAfhTsJdhLsJ9xDuJdxHuJ/wAOFBwkOEhwmPEB4lPEZ4nPAEYRnhScJThKcJzxCeJTxHeJ7wAuFFwkuElwmvEF4lLCe8Rnid8AZhBeFNwkrCKsJqwhrCWsJbhLcJ7xDeJbxHeJ/wAeFDwkeEdYSPCZ8QPiV8Rvic8AXhS8JXhK8J3xC+JXxH+J7wA+FHwk+Enwm/EH4l/Eb4nfAH4U/CX4S/CesJ/xDURKtHqE9oQGhIaERoTGhCaEpoRmhOaEFoSWhFaE1oQ8ggtCW0I7QnZBKyCB0I2YQcQi4hj5BP6EgoIHQidCYUEroQuhK6EboTehC2IvQk9CL0JvQhbE3YhrAtYTvC9gSH4BKChBChiFBMKCGUEsKECGEHwo6EnQg7E3Yh7EroS9iNsDthD8KehL0IexP2IexL2I+wP+EAwoGEgwgHE/oRDiEcSuhPGEAYSBhEGEw4jDCEMJQwjHA4YTjhCMIIwkjCKEIZoZxQQYgSKgkxwmjCGMKRhKMIRxPGEo4hHEs4jnA84QTCiYRxhJMIJxNOIZxKOI1wOuEMwpmEswjjCWcTziFMIJxLOI9wPuECwoWEiYRJhIsIFxMmE6YQphKmEaYTZhAuIcwkzCLMJswhzCXMI8wnLCAsJCwiXEq4jLCYsIRwOeEKwpWEqwhXE64hXEu4jnA9YSnhBsKNhJsINxNuIdxKuI1wO+EOwp2Euwh3E+4h3Eu4j3A/4QHCg4SHCA8THiE8SniM8DjhCcIywpOEpwhPE54hPEt4jvA84QXCi4SXCC8TXiG8SlhOeI3wOuENwgrCm4SVhFWE1YQ1hLWEtwhvE94hvEt4j/A+4QPCh4SPCOsIHxM+IXxK+IzwOeELwpeErwhfE74hfEv4jvA94QfCj4SfCD8TfiH8SviN8DvhD8KfhL8IfxPWE/4hKFJRj1Cf0IDQkNCI0JjQhNCU0IzQnNCC0JLQitCa0IaQQWhLaEdoT8gkZBE6ELIJOYRcQh4hn9CRUEDoROhMKCR0IXQldCN0J/QgbEXoSehF6E3oQ9iasA1hW8J2hO0JDsElBAkhQhGhmFBCKCWECRHCDoQdCTsRdibsQthVnRcl7EbYnbAHYU/CXoS9CfsQ9iXsR9ifcADhQMJBhIMJ/QiHEA4l9CcMIAwkDCIMJhxGGEIYShhGOJwwnHAEYQRhJGEUoYxQTqggRAmVhBhhNGEM4UiC+q169Tvw6jfW1e+Xq98GV7+7rX7TWv1etPotZvU7x+o3hNXv86rfvlW/K6t+s1X9Hqr6rVH1O57qNzLV70+q33ZUv5s4gaB+70/9lp76nTr1G3Dq99XUb5ep3wVTv7mlfs9K/VaU+h0m9RtH6veD1G/zqN+9Ub8po36vRf0WivqdEfUbHur3MdRvT6jfdVC/maB+j0A96189R189o149/109W109t/wKgnretnqWtXpOtHoGs3q+sXp2sHour3rmrXqerHpWq3oOqnrGqHp+p3o2pnrupHqmo3peonoWoXrOn3qGnno+nXr2m3qumnpmmXoemHrWlnqOlXpGlHr+knq2kXpu0OME9bwb9SwZ9ZwW9QwU9XwR9ewO9VwM9cwJ9TwH9awE9RwC9R1/9f159d109b1v9Z1q9X1l9V1g9T1b9R1W9f1Q9d1L9b1G9Z1B9X089V039T0y9R0t9f0n9d0i9b2d9wnq+ybquxzqexKK86r7+9W98+q+dHWftroHWt3Hq+5rVfd5qvse1X2A6r44dZ+Yum9K3Uek7qtR95mo+y7UfQjqury6Tq2u26rrmOq6nrrOpa77qOsg6rqAOk+uzhur86jqvKI6z6bOO6nzMOq8hOrTVd+q+jjV1yieX38DbQio+5TV1juwcYuXFKX23+Pqvl51n6u671PdB6nuC1T3yan7xtR9VOq+InWfjbrvRN2Hoe5LUNfp1XVrdR1XXddU1/nUdS91HUhdF1HXCdR5c3UeWZ1XVecZ1Xm3QkIXQleC6ttVH6v6OtXnqHvnewU23RTX8LZ28b9Z63bLPeGF6/fSX5cd/7u43SkTeh6rorhxy4///Sjr0EvPbtFrvX5smwQ6D4r/vfyGTvfkr6s/TD92cIJjAxIcG5Tg2Jj439FnfNxy6NVPn6gfOz7+98qcsis+Wf9uC/3YKQnGcEaCY2fH/5p8dnnc72fuuXNo9uobz9GP3VCv5jHclODYXQmO3ZPg2P0Jjj2Y4NiyBMeeSnDs+QTHXkxw7NUEx15LcGxNgmNvJTj2boJj7yc49lmCY18kOPZtgmPfJzj2Z4Jjfyc41qh+zceaJDjWPMGxlgmOZSY41iHBsfwExwoSHOuS4Fi3BMe2TnBs2wTHnATHggmO7ZDg2E4Jju2W4NgeCY7tEz/24NNn/nnlmseP1o8dHD/2UPjp/Vdf36aDfuzw+LGX+1+6YnC7UzP0Y8MTHDsiwbGRCY6VJThWnuDYkfFjppp8dPzYHn+/vc/tsyZWWxJPSPC+mQmOzU6gc36C990aP2ZaH+6M/8+0pj6aQOfbCeL+ToJjHyY4ti7BsV/jx0xrquJSajOtqc3ix9Z+uKL/8ced0U8/1jx+rH4go/Wwp45+Wj/2aIOax74swbEXExx7OX7MFL8VCd73doJjH8aPmeL3XYL3tY+TSpOvsxIcK0hwrHOCY+H4MVP8+sWPmeI3MH7MFL/HGtY8vsJGNR/rnuDYwfFje0wbPHTGwPu76McObVnz+PonOHZYgmNDExwrS3CsIsGx0QmOHZng2AkJjo1LcOy0BMfOSHDs7ATHJiQ4dlGCY5MTHJua4Nj0BMdmJzg2N8Gxj9vUfOzTBMe+S3DshwTHfkpw7JcEx/5McOzvBMf+SXCsXkbNxxolONYkwbE2CY61TXCsQ4JjOQmOdYkfm9jth3a337Cgh37s87Y1v+/LBMe+TXDs+wTHfk9w7M8Ex7xm23SsfoJjjRMca5rgWEaCY+0SHMtMcKxDgmP5CY4VJDjWOX7MeL4gwbF+8WMvznn1maUXlUX1Y4cmeN+ABO8blOB9QxIcG5ZA5/AE7xuR4H2jEryvIsGxygQ6Ryd435EJ3nd0gvcdm+DY8Ql0npjgfScleN8pCd53eoJjZybQOT7B+85J8L5zE7zvggTHJibQeVGC901O8L6pCd43I8GxmQl0zk7wvrkJ3jc/wfsWJTh2WQKdSxK874oE77sqwfteSPC+vTJrft++8WOmPq5fgvcNSnBsaPyYqX8YneB9Y+PHTLz87ATvezR+zFSTH09w7LkEx15IcGxd/Jip7/gtfszUd/yTYHzHZNU8vu8SHPspwbFd4mdATH3HE7k1j29ZgmPPJjj2fIJjryU49kaCY6sSHFuT4NgHCY59lODYZwmOfZHg2DcJjn2X4NhvCY79keDYXwmOrU9wrEFezccaJTjWJH7MxFtfza/5fa8lOPZmgmOrEhx7L8GxDxIc+yTBsc8SHPsqwbFvEhz7JcGx3xIc+yPBsb8SHKvXseZjDRIcaxQ/ZqohoQTHiuPHTGtOaYL3RRK8b8cE79slwbG+CXTunuB9eyZ4394J3rdfgmMHJNB5UIL39UvwvkMTvG9ggmODE+gckuB9wxK8b3iC941McKwsgc6KBO+rTPC+0Qned1SCY2MT6Dw2wfuOT/C+ExO87+QEx05NoPP0BO87M8H7xid434QEx85LoPOCBO+bmOB9FyV43+0J3te1U83v61nDsfgyFfim+4a/zeL/94ituqSoTmH3jf/fSW5zm2l60frDTlmwWaD6BrY/1EzTyaA/6OlvyKP/32eSqe2KCdX1B3yf2yr+f+2Wkar3eMf05ufK+LGm8ePevnezQzOfPo646zah/dbeYH99bWxq22MCx2cHKzz9e8b1B6rpdkPhklAwXBIMRiudsmhJaSwSKnVC5cWhSEW564SKg+FoaVnIcSpDlRVFTrQkUhytLIsUh2LlZZEST/deRt2hynJSVVxWEi53Y2UlMae8qDQcKouVlkbLopGiytJiJ+pWlLgVQTcWDpcVF5dVFEdcN1YZKY6Fq3TvzeIXp2qu78Ojv6pW7cuiP1Ts6d+Px/4q/++v6Qc+b9Px9B/AYn+w3NN/II/9VfE9iEd/VX4eHNcfCOB930+zvR6Dbw7h0V/lm0N59Ic8/f0ncOTmRv0DWPS7VfEdyGN/kad/EI/+mKd/MI9/Sj39h/HYH/X0D+Gxv2p+DY3rD2i63XAoGCwNqe8xhqOOWxStCIZpdS8vciqcsopgZaTIjcSKgkWhimhFebgoXObGnFhZRSQW3qDd0z2MxfZQVe4cbrDdSWZzN9o+XLMdVxdCVWviEWjbHadqPR9Rs+4tDq2ne6RBd7AsVOFEYk5ZcbistDJcTFTPoZ3ycGWsJFhWTqQvGHVdt7KI/glWRosi5dESt7yksjRYXE4fV+XzURM48sWt4q9lYP0lZU6ksqSkqhaUg/WXl5eUlpE/Pf0VYP2hipLKWKi0ai2MgvWXFRfFYsWhMk9/JVh/setUFgdLq3IzBtYfKXeKS8LhqvwZDdZPPUsoGimr4plj0P4pr3Qqom7E64ePjOv3PkNt3mcfBf7s+Bap5/u8QKB6vx/wfX5zn63onqqe7/N0e3T/eL2157ujJ2xqa4bhmF5j/McaGGTe55h0lQN1VQB1RYG6KoG6YkBdo4G6vHnNO9eKqtbRo1n0h8Ke/rEs+p1KT/8xHPo1bnespj+As79K/3Ga/noM+o/n8X+V/hN4/FPVc5wY18+hexyP76t6jpN4fF/F8U7m0V/FUU/h8U9VbTiVx/4q/afx6I94+k/n0V/Fgc/g0V/FIc/k0V/Fgc9i0e9W2T9+Akd+Bqtq29ks9ger6s85LPaHquyfwKO/yv5zWfQXVek/j0d/VX0+n0d/VX2+gEd/1XmhC3n0V3GriSz6i6t68Eks+kuq8uciHv1V50Au5tFfdb5+Mo/+qvyfwqO/Kv+n8uivyv9pPPqr+M90Hv1V/GQGj/4qfnIJj/6q9Xcmj/4q/jCLR3/V9ZLZPPqr6uccHv1V9XMui/7SKv4wj0d/Vf2cz6O/qn4u4NFfVT8X8uivqp+LePRX1c9LefRX1bfLePRX1bfFPPqr6tsSHv1V9efyuP7AlusO+QXqSynqXrat4t8ZMt0DCORyjnd/XcONQ6l2vUDtN9LkwD4wWpvrBfrnN/fZynG9QP88zx6/f/TrBepYY4OtGYZj/hg2NnxOY8PnZBiO+blfMrrmAXVNBeqaA9SFHOMsoK4ZQF2zgbqmAXWNB+pC+h45h+ZbqmsSUBcyJ5C+R+bXZKAu5NxG5sTFQF3IGr0IqMvW9dHj1LzcyilpZfhsb/OONdE+W+dU/q2B7/+63YqrbtNuo17/67xNPTYn/viYQKzypIoxA8tGj66MHnjc6HGBBG9T254TzHLbXFjPd6xpLcYQCGzevX1r4V4/jddta+XTqb+3nkGX6ZYdf0rrPm9Ygw26Di9WfjrcN/5/J6nNDdVmHPrnp6qVMJUKUyvh+acJj3+C9Xz6dXuaGPzjz2F/7OoFNt7i0kjTpb++iTZG/fX6vvd+XfZu/G9GYNN55H29oZ7hWAODzPOvsn21b2x6bPx5yhOHIre2eep9fvMA57zZmKemvDAtac0Cm8YZeVtTbeJqqm3NDMc8Xd5thnqe6q9vqo1Rf72+771fl30V/5sR2DSn/XnazDAeXabn6Sfx/WY1jKdv/P9OUltpqWmd8s8D3U/I27RrOw+8z28e4My7jfPAFCdTPfF819xga4bhmP/UT3PD5zQ3fE6G4Zifjiajaw5Q18VAXVOAuuZbqmsGUNdsoK5pQF3jgbpmAnUh895GfyVaB+uqS23IXF0A1DUdqAuZq8gxTgLqsnVuLwbqOgeoy7uE6OeZnv5AYCNX8q/3feP/d5LaNvRu+ud549Bl+uc399mKtWcjVzL51cRpPf+04PFPlT0tDPa0MPjHi2VLwzFPl3euRe8Z9Ne30Maov17f996vy0riAcvw6VSbv2doaRiPLtN7Bqde9bHpsfHnKWcc9M/z7NZl+uc3D3DOGydhXpjmf7PApnEG+sepTVx1e71YtjIc83S1jv9fz1P99S21Meqv1/e99+uyPX15que0P09bGcajy/Q83cWXp3ps/HnKEgc3Vus89T6/eYBz3mzMU1NetDD4sVlg0zgD/ePUJq66vV4sWxuOebq8U/96nuqvb6WNUX+9vu+9X5f19+WpntP+r2a1NoxHl+l5emBcb7MaxtM3/n8nqa24yBRLnP5St5VhnP55pvsal9ehWs8z7/ObBzbNC4551sZnT0154Pkuw2BrhuGYP0cyDJ+TYficDMMxf1+TjK4pQF3jgbouBuqaCdQ1CahrBlDXLKAuZE5MBuqaCNQ1H6TLVJ+TsWseyC61LQDqQs7txUBdyFqInI+zgbqQcVwC1IXMCaTvUXM7AB4jMifmAHXZWieQdv0vcKb0mvb/53vkfJwK1IUc46WW2oXkE8gx+q8P6L1lvfjfZoFN5x6wz66s5/s8bxy6TP/85j5bsfZs7LNNfm1j8Kvnu7YGWzMMx/x9dlvD57Q1fE6G4Zh/zUhG1xSgrvFAXcgxzgDqmg3UtQCoC+n7xUBd6TjWTdcSoC5kTkwG6poD1IWsX/OBupC+R+Yq0ve21i9kriLzaxZQFzKOyPxCziFkfs0D6poE1IUco61cDjlGJJ+wNY62crlLgbps5TlIjpnmE/+NOYSsE0i7UPml9v3nVZOxayHILrUhfY/kAN5a67/fzdOvNt5zaMFa32PrP4fGcg/WZs6hme6taxbYNA+B/nFrE2fdXi+W7QzHPF3t4//X7wnTX99WG6P+en3fe78u2zvulAyfTrX57wlrZxiPLvP8q+4J61u/+tj02PjzlDMO+ud5dusy/fObBzjnjZMwL0zn0JsFNo0z0D9ObeKq2+vFsr3hmKcr/svw1fJUf307bYz66/V97/26bKAvT/Wc9udpe8N4dJmepwf78lSPjT9PeeJQ+3vBvc9vHuCcNxvz1JQXpnWqWWDTOAP949Qmrrq9XiwzDcc8XVnx/+t5qr++vTZG/fX6vvd+XVbuy1M9p/15mmkYjy7T83R4/D9tAjXPz7rWaRMf8/tQf59/PrDE2610ajsfvM9vHuCcnxvnQ/ta+tXzTyaLf6Kx2uSPbq8XyyzDMU9Xh/j/9fmgvz5TG6P+en3fe78uG+ebD/rc8c+HLMN4dJk+H47x1W09Nv48ZYmD48Rqm6fe5zcPcNbJjXlqygvT+tcssGmcgfZU1iauur1eLDsYjnm6suP/1/NUf32WNkb99fq+935ddq4vT/Wc9n+Hp4NhPLpMz9Mz4/9pVsN4+sb/7yS1VbqmWOL0lznNDL7G6Q9GmhnihdNfHvb05/DoL/H057LoD1fFN49Ff3GVf/J59Ec9/R158qfK/gIW/aGQp78Ti/7KKvs7s+gvqtJfyKK/vGr+dmHRH6nK/648/qmKbzcW/bFiT393Hv9U2d+Dx/6q+t9T0488F+Hp782i3wl5/ugV2Lg1MIzJ+3yPi2ylvb5eDX89Xf5j3mc19+ni4n2msen2+/u+Xpo9ug9q0tWrjrqaGY5xxLRngnHrn98qga3+cajN/2yMLfWJ2iYDdV0I1DUPpMvEbZOxawLQriyQXSb+m4yubKCuBiBdavP/VFgyduWA7FL7uZbqygPqygfq6gjUVQDU1QmoqzNIl9r8P+GSjF2FQLvmTsDZ1QVkl9rvCtSFWjvUfjegru5AXT1AutTmP3dqi65+cV2857uKIrznu0JlvOe7iqK857uKQ7znu4pKec93FVV4XN1bD73P0HNLX99wfUVRrb8j5n1+c5+tWHs29ncdffb4/ePNS893BQZbMwzH/HO0wPA5BYbPyTAc89/jl4yuRUBdk4C6ZgJ1zQDqmgzUNR6oaxZQ1xSgrvmW6kLm6jSgLpTvTeu2LbmKnI8LgLpsnY8LgbqQc8hW308H6kLWCeRai6zRSN8j/WVrfiG5CTKOSN//L9SJxSBdat/fwyZj1/lAu7JBdiF1qe3cCTi7coB2oXyvtolAXcic8J9LT0ZXA5AutaFyQm0XAnWdB9SFzC+kXahctbkWtgTahcxVZByRddVWfyFz1X9u1Za5jaxfS4C6kPxrKlAX8pwCkpMjewXkuUeP33vnsfO0Y/Xif3mvAThbfA0gj8eehNcA8gx+Nd0PC7QnWps46/Z6sexkOObp8q7l6/f2668v0Maov17f996vy2bFA5fh06k2/739nQzj0WWef9W9/VMbVB+bHht/nvLEofa/Del9fvMA67xxE+VFR4MfTXnhvTfDcMzP6WsbL1Ps/fe+JaNrDlDXxUBdU4C65luqawZQ12ygrmlAXeOBuuYCdSHnEDKOi4C6JgF1LQDqQs5tZH4h5xCyrv4v+H4WUBeyRnu10PQ9KiD/cEzfcwLqr/rOQecEvtA/338vjnfc9NfT5T/mfVZzny7w2NxEY0vUu+k83H9vr0lX5zrqMn03jiOmnRKMW/983u8CFgd5vwtYXML7XcCimJfzXTR/1vP5rhtLLMO1fpaK9/nNfbZyzaluPnv8/vH3Q90NtmYYjvnv3etu+Jzuhs/JMBzzr9vJ6FoE1DUJqGsmUNcMoK7JQF3jgbrmAnXNA+pC+t7WXF0A1DUFqAuZX8iaMweo63/B97OAupBjnG+pLuTcngbUhfK92vffl2tLrtrKAZC60ut2et2Wsnak1+30up1et/+bvrc1VxcCdSH9haw5SN9PB+pCziHkum1rjbaVTyDHiOS+yDgiff+/UCcWg3TVC2x6f04yujoBdaHOk6v9ziBdavPfe5yMXS2Bdp0PskttE4G6LgTpUvuFAZyu/7rv1b7/uxPJ6MoG6soB6VIb0l9dQXYhc1VtyDlka97bOsb/ei1E2qW29Nohf+1Q2wUgXWofec8Dyl9qPxdo13lAu1BrrdqQ6yPSXzauHWpbAtSF7PmmAnUhr+kgzwMgz08g78/xf7+tm3asXvyv6Xnx6nP6xv/vJLdF6/k+zxuHLtM/v7nPVrA9biK/djP41fS8e6A9FfV8+nV7ehj848Wyp+GYp8t7Tqb+/Tb99T20Meqv1/e99+uybxtu+Jvh06k2//fbTM9K12Wef9X32z5vWH1semz8ecoTh2Ctv9/mfX7zAOu8cRPlhWn+m/LCe68pXv51v7bxMumaAdQ1H6jrYqCuOUBdi4C6pgB1zbPUrslAXeOBuhYDdZ0D1LUEqAvpr9lAXcj5uACoC5n3yFqIjONUoC5kzUHmxCygLqTvJ1lq11ygLmROILkJct1GxtHW+oXML+R8tLVGI3Uh82saUJfne69f0fubevG/zL8BV1TP93neOHSZ/vnNfbZi7dnY65n82sPg17r8vphnq7evH9M/J9W/46W2OUBdFwN1TQHqmm+prhlAXbOBuqYBdY0H6kL9NpLaJgF1IefjAqAuZH4h/TUTqAuZX8g5hKyryJxA1lVb5zZyPiLn0CKgLuR8/F/Ir1lAXUgO4K21beLHdL6tP49EP6Z/TiLOr7/fe10rw/vqxf/y/oZvpNbP6/A+v7nBJxycv1ct/er5rrfB1gzDMf+9K70Nn9Pb8DkZhmP+tSkZXYuAuiYBdc0E6poB1DUZqGs8UNdcoK55QF1I39uaqwuAuqYAdSHzC1lz5gB1/S/4fhZQF3KM8y3VhZzb04C6UL5X+/7nddiSq7ZyAKQuW9dtpO+RHABZo5F8wtZcTa/b/39rWpqT101XmpP//+VXmhf+/+WXjbxQbUh/2ZqrC4G6kP5C1hyk76cDdSHnEHLtsLVG27qmIceI5L7IOCJ9/79QJxaDdNULbHqPUzJ2nQu0qxPILrXfEqgLeX0I6a9coF0TJ+B0XQjSpfYLAzhdqJxQ2/kTcLpQvkfObfR8RM0htd8ZpEttyPn4v5Bf/ucNJaMrG6grB6RLbUh/dQXZhayFakPWaFvz3tYx/tfXWqRdaktzE/lrh9ouAOlS+0hOjvKX2kdy8vOAdqHWWrUh10ekv2xcO9S2BKgLeU5hKlAX8roV8jwT8vwX8v5C//OGWmrH6sX/NgtsWuvU5/SN/99Jbqv1c1y8z28e2HStAtpTdZ9vZmBTv7Y0+NXzTxaPPeX1fPp1e7IM/vFi2cFwzNPl1WH9eUP667O0MfrrdrZmRyOf7MXGG/5m+HSqzf+8oQ6G8egyz79K5dONq49Nj40/T3ni4Nb6uVje5zcPsM4bN1FeZBr8aMoL770ZhmP+czi1jZcp9v57E5LRNQeo62KgrilAXfMt1TUDqGs2UNc0oK7xQF1zgbqQcwgZx0VAXZOAuhYAdSHnNjK/kHYh44i0C1knkDmBjOMsoC5kvffqqset/Jygb/z/TlJbcbHHTXQu43GqZgEzN8F8thuu5/u8QMDM67zPb+6zFWvPRl5nipvuHz+vyzbYmmE45o9htuFzsg2fk2E45p+byei6BKgLadcckC613ySA0YUe43igrllAXfOBuqYBdSH9tQCo6zKgrrlAXVOAupC+nwHUNRmoCznGxUBd5wB1eeej/dxCbX3jf2k5DIVLQsFwSTAYrXTKoiWlsUio1AmVF4ciFeWuEyoOhqOlZSHHqQxVVhQ50ZJIcbSyLFIcipWXRUp5uUNxpFnAvL5i9LtBT38Oj/6Qpz+XR3+Rp78Tj/5iT39nHv0lnv5CHv1hTz/PMzTcqvzszaO/zNPfh0d/1NO/NY/+Sk//Njz6Y57+bVn0Bx1P/3Y8+qvqz/Y8+qvqj8Ojv6r+uDz6q+pPkEd/Vf0J8eivWh+LePRX1bdiHv1V9a2ER39VfSvl0V9V38I8+qvqW4RHf1V924FFf6iqvu3Io9/19O/Eo7+qfu7Mo7+qfu7Co7+q/uzKo7+q/vTl0V9VH3bj0V9VH3bn0V/u6d+DR3+Fp39PHv1V9W0vHv1V9W1vHv1V9W0fFv1FVfVnXx79VfVnPx79VfVnfx79VfztAB79VfztQB79VfXzIB79VfXzYB79VfytH4/+qvp8CI/+qvp8KI/+qvrcn0d/VX0ewKO/qj4P5NFfVZ8H8eivqs+DWfQXV/HPw3j0V9X/ITz6q+r/UB79VfV/GI/+qvp/OI/+qvo/nEd/Vf0/gkd/Vf0fwaO/qv6PDGzcNuoOVZbTqfjispJwuRsrK4k55UWl4VBZrLQ0WhaNFFWWFjtRt6LErQi6sXC4rLi4rKI44rqxykhxLFxl+yij7mQ2t2pelXH4xY1V1YVyTX89mP3hKv0VLHHdqD/K4p9oVV2uNMQ2WBQtKS9zSmOlZWXhGC2iwSj9KaGsiRUHyyKhijLKomh5ZVl5qCISrIgGo6HKMNWaylCkpLKyKKpuBT4/fiHdew52TBtHI19MRsf/793rrLbjJ2x8TUw7rr/+geYb/qrPmxT/vFaarwLa56jNG3NDDp/Sufx6vs8LBMz3qXif39xnK9aejfepNPTZ4/eP/z6VRgZbM3zH1Oa/btnI8DmNDJ9j0rUEqGs8UNdcoK4pQF2zgbomA3XNAOpCjnEaUJet+TUJqGseUNcCoC5kfiH9NROoC5lfyDk0B6gLmRPIuurdz9YssOlaiFubSxxvrR0V2HTzjpUFqo9LP1auvX6vCRtf598a+P6vj6kp4ZB2G/X6X+e3R+dNZZr+mjiD2jw/NtaOIzmOp78Zj/6Q5/umgeo+9Y+pWQ2+8o6b/nq6/Me8z2oe2NTvHPzQNDbdfv98aarZo/ugJl1N66irmeEYR0wbJxi3/vmtEthqGoe/vzHVIxP/9l7fLIFd+uvbGD7be6/nw+baMaAPg4l8qM9F7/NbanZGK8tPHn3gcaMDvq2Bzw+e33J8r9tnwkY/+HOwaQ26Ar7/5/hkDTR9+sbbM/7/rgPemOq6Dui+LfMd29K6pzZ/bfD7XG0q1h/7zi00MIzJn0M1nVtooB3XX/9Fk42f93l8v4X2ma0SfGZrn93669W2z4Tqr2+jja2B4TWtfDZ6r/82bpeK36h4/Ey+8+xp5nv/fymXvTHVNZf1OPpt83Tq38HXY1tTXP7U4lLRbqPN/s9rHah5HN7/Rxo+z7O9re+1avNi3E6TA89x1fo337zPb+6zFbwOVXGYdj57/P7xaotah1rE98ceVxbdo+z4cSePrazvc2WGtq+rz/Cp816jv1bfMjSTAjW8zh92tQ2YsOn7/JvnykY+mzPia6AqJ43i+20Cm059/6OkdBsaGGT+8tzSYL/p9OuxE6of0+nQwb5jjRMca5rgWDPDuLxjzbX3He97XwuDTmXD4KYb9em+DQTM6eWVa5Ofa8qlmnTt7dOlv7+dT1f7zejq79Olv7+9T1fmZnQN9OnS3+9/fEnWZnSd5NOlv9//s0gdNqNrP58u/f3+x1Bmb0bXyT5d+vv9j8bK2YyuU3269Pf7H0OZuxldp/l06e/3PxorbzO6Tvfp0t+f59OVvxldZ/h06e/P9+nquBldZ/p06e/v6NNVsBldh/l06e/3/wxrp83oGuvTpb/fe28rgy7/kszzFZjaP57J+/zmPlu5luTOgU39qvvHf9mp0GBrhuGYv24VGj6n0PA5Jl2ZQF3+uuUdU1tddXUA6soG6soB6soF6soD6soH6uoI1OWvW5tbrwdN2PA30XrtvU/PXf11DbTXmNZoXUdNfKBBoPa8YIDPZtNnmjjmCROqH9NPwfm5qX66KMN3TD+V1s53TOeY/rqvn2Zr7zvWQjvmjUfnmI184xkal/O2646jc8GafOXvW0x/A4Hanc4xnZJr5ftcxOfo/vKvMRnAz/Hzev1z2gI/R9e114Tqn9Pe8DnMj4OM1WYc+uc3D5jrSl+MPa7/sXkmX/B8/buo1qdDsn2+4Pm6+0buZeon9FzxX3Iw9QymRxDpp09GV55EJ/F3P31g2egm2kv10uk3p7Xvdf6nRGbVYFZf3+uyff/3aInfDl2XvvntSHR6xvT5prLo7TcyyNVmarf8VNYUNl3mLw36+3MTfE6HJD+ng+FzvKmlUy+OK7sdefRXXQU0tbj6mLzPb2XwU11Ku/5ZzQObxoijDJjGlijOOvWtzamA/DrqamY4xhHTvATj1j+/VQJbTePQrybpde4v7ZTrxKbVdZtqBe/dJaGS2uaj9/mpuhO1tlfCTVTde2+G75jaLpiw8XX+Yw0MsvoJdM0B6loI1DUbqGsyUNd4oC7kGJFxRI7xYqAu5BhnAXXNBeqaCdQ1BahrAVDXDKAuZE4g5yNyDiFzAumvaUBd84G6kL6fCtSF9P08oC6kv5C1cBJQF9JfttZCpL+QNed/gTMhcwK5bqN8r/b9Twu2Je+Rvp8O1IXMe+QYkXUCyQGQ/loM1FWbb2ua+nrv9aY73E3npf5X7nAv9r1unwkb/eCvObW9w73YJ2sQMN/hrnR/7Pv2dL7vvWrjPR8bCtbzfZ5/jAHf5zf32QqOf9U5K9NtS6bznp7vCgy2ZhiOddX29WP65xQYPifDcMy/biejaxZQ11ygrplAXVOAuhYAdc0A6kLmxGygrvFAXcicQPprGlAX0l9TgbqQ/loI1IXM1clAXf8LcZwH1IX0F3IdmgTUhfSXresQ0l/Ieo/ML2TNQc5HZE4gORPK92rffw7GlrxH+n46UBcy75FjRNYJW/nXYqAu7xyM6Ssu/lvrTT1sxwSfo7+/Yy10mfph7/Wmr4EkOtejfy3Fey/vr7xsPNdjiof+tR3v87fkXI/nN9f3Ov+5Hr22dapBV8D3f9cnq+lcj/++pePiJ7J4f2XIfKu5/37FRF9NNH1lUpf581d/f7sadNX0RIDMgNlXJ8d9peIea1dd5+Zut/VibBqr/37C3Bo+X499I99rz9BsO7JdzZ/F4VfT57RM8nNaGj6nleF99Wr4632OX+b/HJPN3ufo9xB6+aHOlV7YbON7/PFqYHiv9xVJf8yu055eeVFcp+lrlDXlbz3t8/T7qPeeUP31Xm1uHNjoE/01/nz3Xj9Ny6lRvnzP9I1ZH6fJZk+n/lQK3WbvK+J+G2b56hPTvcDG+uR9lumrSM0CZn8EAuaY+POumcEPps/pluTndDN8TivD+5KdRyabE11L2NLP0XV5c5I3N+r+VBO/n8u1Y/77jiu0Y/4niOlP/tWvcfm3Br7/675Qc3dsLZ6GwnstLXU+zPMd033on+P6ZvKh54va+rBNYFMf+ud2O8M4TPPe/32Nus77Dgls0D+nje+Y/6uG+jF9fjb32dfAYF+DBPY1N3wO73cD6p6DHXzH9BzM9h3TczDHd0zPQX9eV2rH/F+9jGnHGvuOjdaO+Z9SN0Y71tx37EjtWF3ngxcX9XlX/F97bwImWVKdh96srKyupaurpnv2RV01PQzrQGZWVlaVlqfmTfcMw8AwzAwzbEJTS9bQQ9MNvcz0bJACzLAJxI5AgBACCbQAkrAkY8vWe/YnC56RZMlP8nuWZMvCyLKePtlYT16e5Te3+57KP//8b9x7KyOqsrsrvq++vHXj3HNOnDhx4kTEiQhPp4Whn7NCeaMCb9itjXNzefolpD9OvPrlp7MGrdq/OlVR3TRv305TXpze0u7AcV5ZvBty4PJ5U7PPW8Xf6RHXhzzi+rhHXD5v7/7IgPK1c3t3MVyf8ojLp7w+6BGXz/b4MY+4fOq9T1vosx7f4xGXz3r0ab98yuvDHnE96RGXT3n5bEM+/Qmf8nq/R1w7dnX77Kov2cfPvAY9KHrvU/bv9YjLp977LKNPO/HDHnENqr/a9ojL/FWe34qfcT3F5gDwKDqfa8Hbee4IlonPHUFZlVJ+DRfn8bkjV4Qpm/PcEZce4JwfHzHYz7kjhmurzh250lFupD/p4FWV41KPMslzO4WaWypat+qoWvs2cBvbiOe41CEnpN/P3p06wdna6lDUW3dXpuCK6P86vUuL51BnEuFa9YvGNc+4Vq2O/+XbEN4Ga9UvSZ7VusB01J2HumbH2IW93aX4PH+Z8lYgL+0sryjSc+RWpqK3EOD+LuQNcabdQjAC+Qj/6vEOL6/Zr3GWACfuc7N4FYO3tUmMIUAY5sHg7wceOIbAYIZTyjWagvMh0MXVcY0zEjhVucapXMzDGPFg8A9AuZYhwA1h7H+0ryfa3bxNCFpRyjvEjd9ynotu1rfxM95QwXmsKywv/D5NpqwrBv8Gh66MCB6wvFyvzAPDjKfwcErwgEcerh5/wyPJjRERJb74pkz/c1VyFYwIPGnJ8MffPDSu8dj/LvXDMJRRQWM0hUf8NhaPiW+tdbR1qpUioCFRAEVsKNJJXRFhtjTwjWG596byzW0jYfhx3tym9nCrY4rtW7Umz/FNeensjjpxdCdPHT+Rpgtc9/x/JYV+SXwf0bcl8S6Kuvc5K/+Ey1z0Fskxwb+iM94nnfGcdPb1SWdfTjqX90nnckGHcSl/NU4Ptjv5CP9BsONr+zXOoRScdmWKwasxhIptMXg1B3KpKKM62+CKKJs2ypL7vSsL8po1B8GxQ2osm5fXW7aY10pBXscFbez7n+rcjjzUOnHH8VMtNDHMRkTP3O/zSefcnY2msLqb4DgMmqeHKvT/ZfT/hOBPJeMDE/NSjrKTNVGT1WehiT6Q0kSjSDdRU3se/uK3avirwvRxajEtdDrN/NjNMBy2/EWH+VHbZ1wnc6stKWqrj7o15zrKQzlhWP1Z3O1enBtDNMjz6MasxvJ5cH+HD5ZPpZ1fFnFi2ambfXB7DR/1i1uPrqE8DJfjLVFZesX6imFv9i1uLbD6egPAcdf4Rvi/TPBI0+BPAB01JLJvKwT/a2JINC14Mn7G6Hu/OrMwZzI8GfUmyzsVdZcd804D/KF2B46Tmt6xMsWyOFhgegfrkXkznGhjsG7T6uXrUC98ySTSe2OUXg77vyzosSwtP05Wx6cJx8Hk/2pfaX65RPSiSA+3jP541CvbEMOt08QPy0e5DY5LJk/CM6J/BaEzGITF9ApgKUqBU9V+ufiOk4myQjx/C2bhfo9mhLHp8924yENZvOPRwbDgX9EZ6ZPOiKDDkdhx4sssHxBl5UjsOPHFk0cgjy+zfDDqLZflvc6B86gD5+sdecccecdFXszTvbs7PLI5Vk3DuhpVd2ntIA3XLYQLvz9NuB7KwMUXZOL3DxGuhzNw3UO48PuHCdeZDFynCBd+f4ZwPZKBiy/IxO8fIVyPZuDiCzLx+0cJ12MZuPiCTPz+McL1eAYuviATv3+ccD2RgesRwoXfP0G43pSBiy/IxO/fRLjenIGLL8jE799MuNoZuPiCTPy+Tbh+KAMXX5CJ3/8Q4XpLBi6+tA6/fwvhemsGrrsJF37/VsL1tgxcLydc+P3bCNffceCKn22oPiW+t28nBa5S8mvu19vhvT93p5Z7F4zRHyde/fLTcb/eHvXKFeXDs91PCl6nRR72RZiHdJ4UdBSukx5xnfaI6yGPuB72iOuMR1yPeMT1qEdcj3nE9bhHXE94xPUmj7je7BFX2yOuH/KI6y0ecb3VIy7uy1x+ffxs07kuv96+Q3vG00Nl+gbhEUfauKEMPJ/O4JmnTDc7foifv4twbXb8ED/vJ1z9jB/ubXfj2uz4IX6eIb42O36In59BuDY7foifn0m4+hk/PN7uxtXP+OF+wrXZ8UP8/KyoG9dmxw/x87MJ12bHD/HzcwjXZscP8fNNhAu/Z5ubNX54U7sbF35fZPwQPz+X+Nrs+CF+fh7hco0f3p6Bq0q48Pu3E64nM3DVCBd+/yThekcGrjrhwu/fQbjemYFrjnDh9+8kXO/KwNUgXPj9uwjXuzNwzRMu/P7dhOs9GbiahAu/fw/h+mEHrjjd3u7Ghd//MOF6bwaumwkXfv9ewvW+yF3GhagbF37/PsL1Ixm4FgkXfv8jhOv9GbiWCBd+/37C9YEMXN9NuPD7DxCuD2bg+h7Chd9/kHB9KAPX9xIu/P5DhOvDGbi+j3Dh9x8mXB9x4IrTK9vduPD7jxCuj2bgegHhwu8/Srg+FrnL+L9E3bjw+48Rrh/NwPX9hAu//1HC9XEHrji9rt2NC7//OOH6RAZfB4kv/P4ThOvHMnA9n3Dh9z9GuD6Zget/JVz4/ScJ16cycN1MuPD7TxGuT2fgOkS48PtPE64fz8B1mHDh9z9OuD6TgesWwoXff4Zw/YQDV5wsim5KfP8ThOuzGXzdSnzh958lXD+ZgesFhAu//0nC9bkMXLcRLvz+c4Tr8xm4Xki48PvPE66fysB1O+HC73+KcP10Bq4XES78/qcJ1xcycL2YcOH3XyBcX8zAdQfhwu+/SLh+JgPXSwgXfv8zhOtnM3DdSbjw+58lXD+XgeulhAu//znC9fMZuO4iXPj9zxOuL2Xguptw4fdfIlxfzsB1D+HC779MuL6SgetlhAu//wrh+oUMXPcSLvz+FwjXL2bguo9w4fe/SLh+KQPXywkXfv9LhOurGbheQbjw+68Srr+bgeuVhAu/t28nBa5S8mvrT78M7/2t9zRqJaJn5cB3SH+cePXLT2f96ZejXrmifHj96VcEr9Mij+ccf0XQ+RVBR+F6yCOuhz3iOuMR1yMecT3qEddjHnE97hHXEx5xvckjrjd7xNX2iOuHPOJ6i0dcb/WI620ecb3dI64nPeJ6h0dc7/SI610ecb3bI673eMT1wx5xvdcjrvd5xPUjHnG93yOuD3jE9UGPuD7kEdeHPeL6iEdcH/WI62Mecf2oR1wf94jrEx5x/ZhHXJ/0iOtTHnF92iOuH/eI6zMecf2ER1yf9YjrJz3i+pxHXJ/3iOunPOL6aY+4vuAR1xc94voZj7h+1iOun/OI6+c94vqSR1xf9ojrKx5x/YJHXL/oEdcvecTFc45ZcXKvSp5dcXL2Hc478RbDMn2D8IgjLQ6vDDxnxeO9mnjebDxe/PwDhKufeLzXEC78vmg83uWES8XjqX1wb2x35z0A3/EeBryRhPfW4Y0kJykP98HxvPTrIO805R2FvIco7/WQ9zDlHYO8M5R3HPJMRrgPzvZHmoxekbwfo7KZDh5M/q/2mdTNZSxHrLdSym8U9c6xx4ltAN5KUyI6Jz3SQVyH2ud+TUdRf/m4jFNEh98xHfz+VAqutJsiXwv5CN9K6l7dFKlik/GoyVvbUWpZ7VvTKbZrB5P/q/2lmuE/Ewb/nMv+Ypm4DaLsiugX0hqPItmvHPQkO1fZkH/WQ+wP8sSNP1wQ15jIC1GnDznKrWyu4lWVI61tIh3XqbVnHHwhvKt/NhliH+lRhnWXDFUfv5lTa01u1xCc2Z2hKEr1dRhXRP/zTY/lSJ9aq2zbWAqfRjfLjuP3Buc6wiKP3VB0FM9GB88XsH4i9hHeSnvlTe/wyA/81vaaVgj+0r0dnG9PcKp9N2ltpQT08GwCq3vmL+2oGO73DP7d0O/xCZ6vpTJjORXPhhPPf0Ce+cZYg/8R8rsC9ZHS7zJaU8Qv1w+XRdUJ690JIQeXbNFPQT8G4T9S0E9BHWU/BXmyb9VYj+Wg6Lj6yRM56Yz3SWdc0OnXD1F0FM88pooT2pPPkj0xvUN7gt/aPvgKwQ+BPfm8w55wfAr7Tmxj2Z4YvTR7wvpp8D/jsCfKN7+7nc6z4UR7gjyzPTH4L5M9CeQ/SXtitFR/ORFpeURRvv5yQsghdH85QXQe8kgHcVlbUb4c25+ivjV+z75sWnv9td2apmqv7B8g/Ncv6eD8dWqvqO8mc6U33Ec9JOhym4mi3vFZnFy27KEUXHn7KIP/TUcf5RprxMk1lnbNOSIcwrjm/8oOGqi3XfY36u07X0uwDxPsQw7YtHFj/Hx/8hx2bL+wZG0B5zAtWd6jgmfLwz2/r2h34DiV6X8sU6wrbThWkuGYH5TToyk4lb3gU/WtzEMC7xnCizaA5WXnbHH7//dJW4jb/x/t1vhYT+L0Awm+sOPXhWWuX0xcvywfTqp+je+4fr9UoH6xDh+jPLTZfLYb2nrDEcv+O+QTDFpb2kx7+VKf7UXJk9cIVN+J8qwQjssnOzB/TfpuMNxfxMnaj7VZk9+w+D5O7PsZ/H+Fvue/79f0Xe0tirRdQDnwmYyPRpoXVWaD3ZfIyfQR25g/fWzUrB4fJ56R9hOBaJeIXhTpeV6jPyn4Mb7HRd5wH7zO1xYW6s3G2vz6SnNxfr5VIvzGK7/jOUp1FsSUgDdZvzmIrOfW1JHQbwK5xmkY8p6gvArkGY9xG/rb/d38vykQ/3nkj/SnBfwt7Q5ckbqcFnR4zNEProc2iWtv1N0GVF+Ivg33hei/4DmgdegwlF102TqzbWz3sZxsB59Htg77P4861FD+KNu6xwPRzmvrjP5klF634yKvH1u3Nt+oNdaX5lfW1udaawvrpai3TyiLd2zrlN7uEfCBbUVV2Tq2Z8OQ9zjloa0zHpWtC9MvzlXzyB/pTwt4tnV563Ja0GFb1w+uhzaJy2wd+kHsp6KtYz/1jCgP2joel82TTQpz9L2eI2SbivzGCcfQZ0BOLF/Gg+/Qb8ZveM7G4L8P/PbvntT8WRnuEPypmCIs1/dPpsOdEXCxG29+1AOtU3e/dvlEa+3u1uqJ1qlypNnjInLxeTgVEVyc+Ea419P/PH3Da7fWBee9Ec5+EZeqOsTNXe/NichiEzY2c+55jPg1WgeT32qfSQ0duasNs4xXzz2sMPrjUa/KhQgfUVObKB/uHsMsS9Sr8YwzT33H6fXtXtkwH6Yv6jj8UsqvlZffcTeBush64zKBaSbrfjBZL53swLMNyBOylWcpHt8h/Arl4dJZyYGfp0Hug3a8TFM76OpYOcLe9FOvqZt+UJ/QjUrTf3V9g8G7QsniZEsNrtAipVuoS6Yjqp7tG7UcPkm8Fl36nxR0QrepSSoP6jG7eEWXHpX+Zi2hHU1pk2lLaDdBPsJ/DZbQjueoT9VmDC5wm6mrNoNyzdNmVD3kaTMow2kB/+p2dx7qDi8/qrzNtgX8Pq3NxelIe/N0+HuDC+uLLCyooYklNTThtoPLBHYMqlqSwWVXTmqZwMob6+PumQ5ehmNesd7Ztce2ZnwrW8OhTkVtjUv3TgEe1cfc0+6GV2E2SDstzOZ90BfzbYCqDSq9NHgVxqr6MrW8z2GsgcK7G8brI8Any5fpo44OAfwjDnj2eRn/oymyM/g4YR3zkj5u81ChIfYtT1F+HOr7frqZ7VFHeVSZeXrTFQ5coj9edorTQ+1e+mrZKP47mPxf7TNx/Q4DjceEPHh563PU99tUVlmUVcn1cUEXpx9NJhWC/xzU47tnunEabxOR7ju5Tng6m9vyyXZ3/kYIHIxLvpAy7REn9JW+Mqlpj0daD5nXM4JX7FueaHfnG/yXQF7vndG8Ij+KV9VG8ULmom30LuLV4L/qaKMuXVI2l8MpVBtlvtmG5dULg/8HoBdfI71Q454Y7hskaw4ZiZPLPrA9PZj8X+0zcV1iO1X2kuvyn1C5rP2WRVlVnT4m6OK0MtuHx4iusg9GA9vcKtBN0+OK4DlO3OYM/jcdbU71/UoP1HZT1V65TkZS4LksBv9bOeck0N+O0zDk+fNTanJOAm1qpd1d7rxzciwnhFfT59NRtk3mEP/4HfqqdkQ0h/h/G+zEv6TxrppDY3rIu2tcht/nmaMIvFSyVCJ6Vg58h/THhUxCzOuqa0ldOnRK8G9jUwWvdFTVWzwNwvMe04DL6I7Cu4fonQoH47rHvgz7or8kG6T0TW03YbmMRNr3T9ua+x9SbBDbW5OxGne/Nuoth5pDYhtf9EpaFbau6DzQJx21zGbtk7eOHUz+r/aVioc2PkB5atygwtNsHqQk6Ki5DtT798908DIc86rGna51rTz2KU68LRXrA9urshX8jutdtffQW0CmqTyukPqi2w/UVmLXVpPA8yC5+yD0FVkmIfogNYfkWltR/uHDDniX34Pw2AcZT6iTGO4dEe5RgGcbxnWvruGObfe+Pd18mwzQx8Jv7bpiXjt8H6wpXJ7gdM19Kxt+SaR5iaJ8Nhy/5yNWOKZB/Rodfudau7mEynPKUZ6itgm/3yrbdAnRSZtfeRrpzWa3X74B9OYZDr1x9f2urV4h5s5dx5Jslk7erWsXsk4tetKp14BOfQ/plBp7XqhyftgjHcTFW0vRd+B5EtXPnnHQcR19k6Y3L9yjaebVG4O/BfTmxTn0RtVB2vEtSHer4gm2ay0RcSmfx+DVup/LB1O6pMb1alxluh02ZL6WO5bO6I8Tr3756fi76hrZR4Tsdkedsd5y62StvniotXrikTec4sowhNNRt5AfJYQGH9H//F3M1DDBnBI04oRnHKAi8WCQHWrGn4enLNisfNUIH0kpZxTla4T4fVojTNtjznvrDL6VGLy8e8xReTj4z7XH/KEU3suiDOORNiS4QIN5WOZbHWU2+KOOMj+cUeZbqMxpZ0Xh/wxXFmUYjXp1AHEoGe+Nunkvqk/4/VY5K3uJTlrnfoY696xzI9YgH+HnoHN/jDp35XyHLn/aeTJYrjWASTvXYFjgjBMHtxv825KyB574kfs0XHsbcEH87XuyZeOqc4N/GtT5O3PUuav9qHOSXLbivHZkaq1qHh1H+ue9I/PHpW4h53Vk+DuXI8OwaY26X0dG8ZQGW9SRwRFA2gptFOVbMcXvOcI0zKpovcp1gtEq2JjSDmnDyDzXCI5XURk/dwC40UzJzjpFnnn9JDgxh2fPPau62pfCXxTlqyv8fqsi8PcRnRCzuHHiGY2tdtbTdPCm5DnLSfrZgh0mDhIQ/l9Md3B+iTrMPFHnKNc8O4GKzvC72lve9sMyGhY445R2uOY3yIEKs1I1X3XN4oV13uZzd/7s0Klov3GR19dBIwvrtWqzuTC3Xl9ebM03uY80XvldnhW9awR82Bmjhjxo5BGQa5yGIe8M5VUgD1cGefN9GMessZZH/kh/WsBzZEvRWWMfuGzDvBqsb5cty3vovsH/jmNCQx3+iv0WT+Kow095MMRlZJsYp4PJb5YmrWcko2f1s0vwwhHmBvsHIJcXzHaXRR0AYDaq7KARiXelKF12TEMdQNCKunl7OAdvauIJcZxI4TPGoQ4HZb0uejioa9IK6VzdJ52rBZ2QK19IM8sf+/OCK1L3tTv5CP+/gz/2/5A/hv4cRw2piVXXYed4EJ2aQGV7Y/D/CdpVnsPO7wOcaXqW97Bzg/+bAZjQ4jIPR51IerSPL2x3l8Hg/11yMkcs//+2pxjOF6XgfDrg/B8Fcb44BeeVgNNOE1H6eFnUTQ91Xek/tzn8HnfnIy+e63fjwpcHw+DfuBzkiJAFlsno9xs5ibS26sQOVTZXPePFV7wyrXAdKYhrTOSFqNPXOsqN9CcdvKpysF+h6FwmZGLwr3PwhfDWhlH37VuTIV4o5lGGdVd94wVnRn8zF76Y3K4gOOvjhqJe2T+Ygiui/6+gd+VIX/gS28zVpD9X8yaXpvBsPPA71n/8nvU/jM1caKrIYktqZwTyyKlM/yPfcX0/Z28HL8MhDtbjtMsTlc1Nw6HmcrPafZxwMcLKfvLU8ROtO08ceWj5VOvwQ61jp4T+jkbd5WO9ez39/yDB8skdlseLmUfo/2P0/3HBDyeWCaZJAZeWVPvA9vg0eN5M/4DfG5yic12fdK4TdFy4niZwGfxRAX+dgLdyKHtpNgAvdgxhv1Ubwj7D6G/GfpvcDhCcjbmGovT+K8t+H6B3afZb6coDKXwa3SxdUT4C48LxkwWdYFuuEPyLEr88rD+7NGf2HX0Mk1lYn2FprkT0TN74DulPCn6M73GR18/8dH1xrlZbfGoJvVVtVJfXqq62jO+47R8T8E8X8Cbr42FkLQ+HPQZyjdMw5B2lvArkYX/C89Nh7NNSLvkj/WkBz/MleetS4bplk7hsfhptvLXtrbJNYW1KcX+Sd0TmPRkK59I5KT/Uyhvr7e2zHbwMx7xiffBc6IOiHK6+FN+56srgrK5QX87HusK2x0nVlZW3aF1hfXBdvU6Uo0R5xg+/c9XV6xx0dvdJZ7eg4+qz8/Spio7iOWvX4fGpzjdo79J2HT7a7uQj/O/CfOQJx3wk8oi4S5FeC2Mbbd/j/LjLFzP4hxOe1Pz466jMWE7mEcs8LMoVJ54fN/jHyR8MNA6Q8+NGK6w/WNwWlSgP14MPtztwnJS9sTLFdXxnjjkKboPIm/JLXidw8Tj9BwU/Vs7jUTf/2DbixOu++P1xwpV1cgcHxeP3eXY4Ia67CJdr7T3rVJp7CJfaoGC4Hs7AdYpwuXbvn8nAdRvhcp3Q9EgGrtOEy3U63qMZuB4mXGmn8cV/j2XgOkO48Hs+be/xDFyPEC78/nHC9UQGrkcJl7ooQs3lY7+U53SfMJde1ApfBrVVp/soubuC298keJ0WeTzHqS6KepOgo3Ad8YjrtEdcRz3iOu4R1wmPuE55xPWQR1wPe8R1xiOuRzzietQjrsc84nrcI64HPOJ6PeFScQzKtu2OOmOhs+s9Ny+/4eTpo62IEvqTRgP/P5ZCf1p8Hzlw4TeusqCvyXNeeOKXWp/lixkN/p/CGMhOG1NrcMiPK/Yh8Jp+PW+/OqixFWo+w76dFnk8ziyyptmvjsfpcFvTL4nvowxc9j+uJRqcmmfFsvKY39oezkkgDo7ZM/jfB33nk86zxmK8BqDGW9ivGz9TUa+94H0Yakyp5vZx3TBOw5DnUa9X1cmjKJ9KO78s4sSyc92egnWvTh7htQC0c+xXZemV2VEeK+C3OCem6vJaoqnWhvAd92nXirIpOtf1Sec6QceF61qBy1V/rrVvFecc9maoztq3atdqXmAza98mt2sIjte+1VwL44ro/2voXdbaN9bpgyl8Gt0sXcHvXTr5QJ90HhB00mx8nNDv4Xldg9+T9C1h114X51z7HsPuP1vMvcaedsok8q1OdexnjX19sV5dnVtvVefnVlZWq2sum1H0BKJZAR82tnxRrrHjnoY4DUPeQ5SHfSVeaM9r7GHs4GI1j/yR/rSA5/FG0ZNPfeCyNXbsS6xtb5VtCmtTBneNHWNDiqzbYn3wuu1xUQ5Xn638SVVXxx10DvRJ54Cgo/zjUsqv0eF3TEfxnLVu+zQaU2WdFvtYu5OP8F+BfU3PcMREs6/NbQJ1ME7c7vHmwjz9u8HflPCk1m3V3szH2uk8G428+8wNvk4+RqATkeW6rWvfK88XFN33qs4KGLRb5XgPDs7BciwFzqlyvCHOkfL8DM95Yh6uGR2jPLX2YHlvhjw+o6MNeaijnJRtxsPJfrzAGre66YwP1kL5qtioG+AZ84xXfsf6ht8/mPId25HAe15qgdv0xr4ktecby8S++2bjgpDWOOHyLTtX2VzxULhOx+tsCtfpgrjGRF6IOj3qKLeyCYpXVQ4ez6t2doOQicE/5OAL4dUBbFs9X6Nk6Gu+xuT2bIIzv2Mo6tXB0ym4Ivr/2fQubb4ma3/6D05rnvOeF2TwHwM/bgWeeR8P4lqPuvPWIe9k8hx2jWehruZVWHYngTaPgU6J8uTtS61MsV4dLNCXot+EvCFOrL83Agzv3zf4N4Cf+5r9Gmcpcs9rsw7lPUPA4E85fG2DGU4p15EUnO8CXXw4RdcjgVOVi2M/mYcHiQeDfwzKZeueURTJfnYd/j/R7ubtqKAVpbzjvuBoSp6Lbta38fMb4Fn19ayvbyR4W1dPkynrisG/zaErKqbXtZ7NPDDM61J4eIfgIe4nJpL81eNveCRlKXQYntk8q6rkKnitwJOWTAxx8d41rfHY/y71U8vIUco7rgb7Fs/iXGsdbZ1KWyseImQPpBAbinTKE483aHEDoePxXOdNoCxVXDLHDai9R0XpbDZugHVhPYV+SXwf0bcl8S5OcWN5665zz2osynMfRceiqnEwrrQzgh5sd/IR/lNgjzje4EHgQ+G0GGuDV36x6yDjrPEl709T4xQXbZRlnjl9F69qrQd9fo6lQP4eLsjrLVvM64MFeU1rl9aHPWWkjzzUOnHH8VMtbCrMRkTPY/SOYXjbwutSWN1NcDztzUeqcb/JfdLrBX8qKdPAvJSj7MT3DPw8NNEHUppoFOkmyuEjaqufGtKpaVmX+64uW0IcHO5k8F91mJ+srRSs9mq7hOsCUHVZkNpKgcsoZ3G3O3kGFzjcaU2FO2F5K+1uWajtHq7jTNWWDnW89jTBoxzV0hBP26rpe7U0lLX15daU8lZSynu03clH+N9w6J+SiTqq2eDVVhZ1+braFvMY5eF3vJSP+mdwgfWvpfQPy8v6p7biIDzLTm37wCUODF1GeJSjOnLRaCr7hxe625GLanm7lPJrvPI7V2jBHe1uOqEuWbNlQW5PypWLn2+KuuEfB7rcnhS8yRmnWlT9VQj+X0P7e/fMuWeeeo4TTj/+ybSmjW3/tOCVaf8tTPN8i6YclfvGR3n/GfB+32z697wciv0OH4WedmQryh/LiXXONs7g/xL4fGXCp7IlOI0ep2HI82hL1ov2Zcquuvoyl+1BmU1HvXqadq8O4kKZp/lBI5H2QfBofYT/r2K6Tw37zhDvJwryntc3PA3l+Fk6OhZlyduLVF0pu6+uN3gsB64zjvI+DjwreLQTCF9J7vlB2TPOSqR16dEUnKOAk4/SzsK5loJzAnCyr6L6T3WvjcGrbU3Yp7I/gm3kTZSHvHO/+QTQ5zp9VbubvtqOGwm6kYNfFY7v4pdtu+VdjxdSJ89jhM+zXZxz1eWNojx56/K0o/yMy74bjnr1VbWhJ4S8rrtE46wUxDkD+m79q/J13tju0L6eaCsbgnaRbeBpwRf6HK4jz9k/eIZor9s2hqy1qqrfRVlwv6vGYK57zFxjTuxfpgX88XZ3Xp677pDOZvq1t6fcDZiG9+XtbniXPxY/L0M+wi847LiSoUvmWeN2DmnF+niU8pROD5q+onxYX12yiFPR8TrrK9pN9sNcVz5l6ZVLX/Fo/TPkh6lQajW3wFO6WTrDoc5oBxU8+0AG/6IcfhXy4NpqkXd+QPVxT0SaNrZblAlf8G3wd+W051YvYcdRtZpqHyhXbh8uGcapqI9oMnNt71ft43HKQ/3ktpN3HjBrfocvec868ofHdereWPQxlyEf4Vcctt53/8rzDEquLtsxaLo8KLae5wuUrVf6h3MBizl8jdc6+M9a22D7l3dt4wTwfxZ3O+op93bU/VaubXDdu9Y2VEh6XptyN5Ujy6bwvKXBtwvaFJde+bQp6m727ZtnHGy9ctmUonrl6gPRBj2N/MeHBK8uPXL5Z1l65JrnfiSFDsLFSW2jjdPB5LfaZ3KtyYS9BrE6XyJ6Jg98h/THhRxDhH+pelXXqoW95rLaiE2eWk97fbtXNsxHWnuytbA43QN4eOuTuuo3bk+fprkmNR+A3xoNng/4HMyd/QThzBuHkbW+vi/lSjnEm3aVIcp2JAUey47wX3CMAZX9VLpl8Fk+HMd35F1fP5VCR8USqH7Z4L+cc3y4NWv29dp2r9nzHIlrzR7rgNeBlK5iu+A2oHw01V59h9WxD+66ylKtAW+fr1SvK13B8rKuuMYjcfI1N4xyVOuhaVdXIp28vpJ9G+vK0aQylC1Js41IU41F1RgC45awPL/lWD9U4wY1zmCc/7zgvLOrLeT1fZW/96jjO+XvIa2DyW/2hb/5rgM2W7MrSvch2M7/XyBHuw5Y+T/d/PaX1JxIieSEdtOjbch9nbvRHxeyDOGbKn9AtTuTz+NB+Kmto2+K+ou+adpR06YvanyKvuafUt+lbADa0+dAPsL/Ofia307BGUX9rVP82u5uvL7n6lzzWXn8PFfcAvtCaTEay5CP8P8JbIMr1mpLfMDa+ravEfA6gOvIZKV/qAs8J28yHInccV4Vgv8fYkySZ53ioYK8nxG8czvntvOnOXzUza5TxMnWsNkujCQ+Rt45RZdvEGqdAo8mOIu73cnbWafonVPEuIm86xSfJdutYi3U2Iv1NS0W9wrIR/grHfrnex8Ix0PlXSvZ9piIaq2+3XPaVvd51krUnLYao2NMzlsT/Qspx4XF6oZPa3WIx3FhGoZ8hH92oq/jUA777etoyoXl2vrc8vry/PLaWmN1mY/XipPVWbzdLtaHG/d2ZGZy8i2zOBn+Shj8G/GPuD+9LMpk9E2XeNu3+o0iPWYxWuOEy3PZaq6yIf88VzBM/NhzGq7hgrjGUvIO+in3Rp2WHeVm+mnwqg3Y+xEHfoQ3u446PEKy2BVGFnVXvY0ATaO/meOD7P9rCY6Pe0Z5V1JwRfT/tfSuHOnjg9guTUa95bZvAtuU3McqGP3xKGh72LADFeInre3ituqjx5fXktMO2ORx1aE4ER0Xm6tuo1ukd6wOfIKGuYGqC2U+SwKHEoHhnIq6ecBvlSkpp9CNoo66svnIwmXPZQcvaThKhGPSgWOn6ew0HZF2mk6+puPbG68vLjaX6ivVxsLa6vpaYy7LG/dNf3WludJoraw2a43mXKO6ttX0WyuNpYWVpdX56lp1qba05eVfWF58ivpSY7nRrK5WF5pFRkOm++hZcVtXXuOIwD0tvjc4RYd1eJeDDpvMUtTx+kYit4dYIfjTMIvC0RYj8I2VAw+e3pXCw7Aoc5z44GmDfwR4+IHZc8/WbtF04+rGY3vdvLJdHo66aRv8W/Z2cL6J9EB5t9ORtjOYh3VpMpqI8tW7ySSKdD1WCN5mPdLqfZTKbfBPinqfIhglgzHBH75z6f9YCi5VZ3HiS7gN/ocdM3/jgr+y4M/gJwQ82iTjR8lmgvLGCbeig2XFuuaD6w3+Q6KsajbRaG/HqTIow0q7u9x4mlFZwHN9TAp4vFjeZDZN8Fg3qo1OUB7SHSEelI1HveSVGTUzgDZKuecoA+NzTJTXX92t5r7A1+iPE6+edalWVEdMPpNh5FN16eCkkI/xsycIP9WNy5imBW3jNVn867IrCD8JMkR4fLbv8d1XSV+n4DvDP015cbLTakoiryzeDW0TrmmBC+VmdRq34y+SLPiENvVrePkd84j1aTrvshGbpYO4zI9S7Sn+O5j8X+0rzW0cer1HlMNoo175azvzC3ltndEfj4K25ZpLh1E+Vm+q7du301GvDv9QuwOXpd9IR+H62IDierdHXB/wiOvDHnH5lNf7POL6oEdcP+wR1xMecfks44c84vLJ1zs94vLZHn3W47s84vLZhj7qEZfPevSpqx/3iMunfn3EI64f84jLp94Pqs3xWcZPesT1Zo+4PuURl095+fRNfOrXoPqFPvV+UH25Jz3ier9HXBeDLzeoeu/TN9np04rhGlRfblBtoU9fzqct9FmPPuU1qP5X2yOuQfW/3uMRl8+27bMN+ZSXz37IZxsaVNn7tF8+5+UGdW7Ip3759H196teF3nfEz7xm5aPvmErBjc+utWFFpyR4VmvKQ4BjLOotr891ZcO/NxB+K/clQlZYJqPPa8yWr34NF+cZrXHC5blsNVfZXGvRuO6OMkjDdUlBXGMiL0SdTjvKjfQnHbyqckx6lEnFIy6ODVLtX63fGvxeAa/0ZErQtm+tbvdBnse6rbvqFm2E0d/MLiOT270EZxdCDkW9beOSFFwR/X8vvSsDPkxbZd/5f4utwZhevtVp62MkmnMlomdljqhcF0qMxFvbHbh+fYZPeMTlc47ep989qPMZPsvoc614UNdtBnWO60c84roYdGJnTWP7ZO9TXj7nBH2W0ed8xqCuyfqc4/Kp9+/1iGtQ5/t96sSO/3Vh2Giffe3bPeK6GGzhoK6ZvcMjrh/1iGtQ59V99mk+/ZyLYQ37Yogf8NmGfMrLp43e6TsujL5jJ95i+3RiUPuOQZ1T8FlGn3sSBnU85FP2PuOpB3W+0Kefs2Mnts+f2LET2yf7QbUT5n+5YmcCxxHlPu7P6G9VbI6Sq4q5KBqj4jq/C8uEeciD65ywKUFnTHx3MPIiqzqXl2MUFB+XeOdjbt7qAONkWH9Dxr0gvSjS+mv0x4nXUPq7j/hh+bD+Xip4nRZ5abFZlh8Fl/ncymZlHiiuzSlzFSNWROZxelu7A8d5ZfFuyIHrSY+43ucR1/s94nq3R1zv8ojrCY+4PuYR14c84vJZxnd6xOWzjB/wiOvDHnH9qEdcPvXLZ3v0qV8+baFPvj7oEZdPvb8YdOK9HnH51K+PesTls4w+Zf8ej7h86v1HPOLasRMXhp3wWcYf84jLpz8xqLL/pEdcO22oGK63e8S104a2T/Y+x+4+x8i8jxbnkHh+VM237HPQwe8RDv9X+6xOtLt5uhS+20s8FS07fm9wis5Un3SmctIJUZ4x8d3B5LfaX9rYh3xZ/7jn+YXhvtw/3w2bA8S7Bt7QPvcbz5n/9aXd9YB3T5Tp2xLUQ4XgX3VZB+d/SXDyfTYRPI8RvlLkc640/63uRn+cePXLT2fudoj4Yfnw3G1Z8DpNeXF6S7sDx3ll8c6F630ecX3UI653esT1IY+4Pu4R17s94vrIgPL1Lo+4nvCI68kB5etjHnH51HuffPmU/fs94vJZjz5l/x6PuHyW8ZMecb3ZI65PecTlU14f9IhrUNu2z77D/AkbU6D/aPeTqDvR+P4rvPcNcWAe8ue6eRq/H075jsvB8TKWfzD5v9pfqhn+0TD4N87Yybr7z+irO/JKKb+Gi/OM1jjh8i07V9mQf9YDFY/kwrWrIK7AN3hv1KnrTjGkP+ngVZWD74FU7awkZGLvRx18IfyUoG3fmgz53sCDyf/V/lLdJUNsi0Z/M+cTmdz2E9yt7Y4cWAd3peCK6P/99K4M+DBNEQ5lR7k9p9XvdMr3cXLdiTspvrPy4R2WV0D+KNG4QvB4hYNH/N7gFJ1Sn3RKgg7jUnM0cXqw3clH+LVkjkbdRXml4M/VFq8S8FcCjPGjZHNVju/iNCloGU/Wjq+G975tIdIzfvEd0h8nXkP1SVcTPywfbhvXCF6nRR7bhWsEnWsEHYXrSuIBdWuL6q++2fq7Mgw/zvq7Usi1aP2xj3BNkHLUVo2va6PeZHnXAW3Whe+CPGwrnMr0P5Yptl/3z3bwMhzzgzpmvI0JXj3KqcXljQRf2Nd+ut3Lf+SQxXUgi1MFZIH6vZ/ysD5mKA/1aZbyroW86ynvOsFPnrYZJ7YxLr260iMdlNFVROcqj3RQ3tcQnWs80sG6s7qainrrDtsJt/GyeMd0rhZ0rDzo6+P60ycu0zTRt8Fv7QzOCsHfvr+D81MJTmvj+4Evf228XrWyzUS9yfJmgfZ1lHc95LE+H4A81sEbIA/rlpOyGyaL2G58oIDdQLvN7d/Vvwfyh3L370Z/q/p3l18cJ1f/bt+qdmtrw1NCrlimNB6Uj7hZexfWx8hft0Z/q3zva3LKVflB15DMMY/jJJQv7eLB5ZdfKXhQdK7qk85VOemcz+WxPsfs5ceTjLjP+Y3LumGmE5hfvLID85sEY7FAvwWxE99InlXfcqzdnTcLeXxG8/UiL8a/O+HHZIZ9Cc+N3AA4yuKda27khhRcw4BrDHBxv27wf0F9+dMAr7823lwwud0IPLG9e3og2nntndGfFPwY3+Mib7gPXtdXF6tz1WZzrdVsrMw31kuE33jldzxf9AwBr87JNlk/Mwoi6/rGvRbtDv5ngFzjNAx5T6e8CuQZj7He/+3+bv6fEYj/PPJH+tMC/i4oQ5G6DIkL7YEPXLs2iWtv1N2e0OaEtUH1prJBllSb57U1bGM2xioJXGpcYGWKcf7MbAcvwzE/aOeRNy6H6j9svWIq6pXrjYTr6Rm4biFcNwq+JgUutvFh2m1+n9boKzsewqdVdlm1C5PdMwWv0yLvxi2Ra32J+cJkec8C2ihPTqpdGN9xu/jjAu0C9Q/pp8kcddls6lSUbtf5O25vefyZQLre2Kyu3xiGH6euo3w2q+tot1gXy+LdkAPXDR5xmd4oX5/j/Iv6+lOC57B+cn1R9XOWVJ3dSHnPSik/J2UHrEyxHfj2bAcvwzE/KPNnUt429EPNi6kfipPtqem3PV1suFRbK6X8Gh1+x3RQp9knOwDf4frA3OWdb/A7XB/Ab+9pd/IR/jMwD9NMcCq7aDxaO3w25Hm0ZRvrqM+JepPl3QS0L4NnTspeGd9F1wexnd9EeVh/z6U8bI/Pozy0u1XKe7bgZ7P6hXWVx+ffLB3lj4VuL9x3PNMjHaw7q6upqLfu2Dd5FtHhd0znBkEnq/3fdbmmmdb+T7U7+Qj/fmj/L0twjokybmcbfzblPRfyWJ+fB3msg1XIw7rlpOyGyaLo+iDWrZUp7FxefZntSyT4QvvC8+fPAb5wfZOTkhPO/f3PTdpXrm9s78bbVNQrQ54bKdrf3yjKoehM9UlnStAJ3OZWVL1bUvXOY4SbUsrPKavtFBkjoMyfQ3mu8XsYGeYfIxj9rRq/q/7GNX5/tuCVfYU4sf/8bEHn2YLOxY5L2d9Syq/R4XdMB3Wa22aaj/Au8hHsu7xjBIN/M/gIP0xjBDWfZ+0QbYZHW9ZiPwCT8gOKjhGM76JjhH59/fi5Rnlok+uUd5PgZ7P6hXW11T516PbC/kSosRX7Jqo/LVGe0eF3Lt+E+8K09v+FyzXNvGMEgz8O7f9naYyAZdzONs5jcuXrW14N8lgH65CHdctJ2Q2TRdExAtYtlgl5H4Z3OGZ/afvcb4Xgv5bUU1xnv3p5N70DQMNon51TuqIbTrXHsPM/+feXGP3xqLe9h/CxlF+gxvTKbtu30yIP9w9uxi4oGzNoc3Qcw4vjd6w3Tlnzd0X2OmAb43E48uNRTutspyLBVxXeFd3r8FyQRRE/JaQvEj/PUd5zBT952nmcWN+V7lxo/oNqX/3SwbqzupqKeuuO/ZSbiA6/c/kp3CejH4l+yrcv1zTRT8FvOSbS4F8Nfsqfk58SaCxSqI2j/m7WF7G8OcjDuuWUNb4p4qeg745lQt7z+ikG/1+ongL5FdW9VC4l0x1/J7y/g3O5bOOK+js8dzoo/g7vFdkOfwfb6o6/08nb8Xc0nYvV38F2gnlGJ8vfUe1MrVGgv3PDFZom+jv4bZq/cxv4O09PcAZeWzwv/R1ck9zsvAzbjaw5lBLRTvOL7myf++X5m8UrOjibV6TzdQBof3ln/obTeTV/Y3W5M3/Tyw+2tx1/ppO3489oOherP4PtBPOMTpY/o9pZ1vzNWg5/Js/8TRP8mQfIn9mZv+nAbMf8DfspBn+a6mk7529c+wYC+Re5/R2OCQq9b0DFBLn2DeSJCYqfef5ms/EyqI+DFA8ZP/P8DbbPovvkcOxRxN9BORtvgdfc19gXiARf6AsU9XdwfXyzsfe+4+vRhofut7cq9v5Cjd+ZivzbI9XOeMwRJ/R3PnOFppkWV8P+jsEfAH/nJ6kfDbQvuFAbR/1lP0npc9GYm7x2A/caF/F30Jdlu5E1h2L1gH6av3qY27h/qBH1JsubB9q4l5aTkpnxHcvs69d38DIc00Q7Mk95qJNNykO7sEB5WN+LlIdteYny0HZ+N+XheOB7KA/193spD/X3+ygP9fd/oTzU3++nPPTzDybPg6Y/3FabkMf7ZBYgr+g+GdS7q27o4GU45hX12/jeHXXOR36gder21iP3Lh89srZ86sjxY3e13ni6dfLUMKHlLpW3nT0zhV3EEznYjdMQ5T2N8u1YqaFIp0nxndEwtWnA++0Yrhj98ai3ekIMVxrED8uHhyvzgtdpkcfhLPOCzrygo3CZrqjQd762Tx3xcqODzl7B86CZkL2Uhyakn+5ps2F8xtuY4MejnBbYLEaCr0V4V3RY1ARZFBkWocy5W0Wd4W4VbQt3q1jf3K02BT957EmcWN+V7rjs4mbpoIx4WnvOIx2Ud4PoNDzSwbqzupqK/Ns91c6yhkX/nYZFWUcS8LDI4KdhWPS35I6H2UpXrI2j/lreEuSxPn835LEOfg/kYd1yUnbDZNHPsIjtxgzAv7HdnTcL391A310PeTicsmM1DQ6PIp0hHHj06yzl4VHV1wP+7yRna7MO7QUdmrmy8238l/e4I4NX23ufIcqrjqXiKc4ww/rB0l/L+17I6+d4sdUcwwhVz+poPLQ/t7a7+T0g+EW7xtM3TwMdmyPaNwnaqHesY88V8GpZT02B2beDtu2Sp45weM3DURxe89QRDq95yhH73aLbtXAZLa+OcT2r6ca8OvZswPsZ0jHjbRF07Bai/bwM2qxjVQGP9cVHHqAe2bdj4juPdqw6KXi1pHSFp/WK6oryiVlv0a9CmXBSOmZyKqJjt+SwJdgnsY6pkERcpmcdux107BU5dEwdbZFXx6yf3dGx7ryt1rFX5NAx9IlYx9Q2HwxtZR17DejY0Rw65vLHduxYJ2+QdexoIDvG28WU7+TSH6VvuGTAvhYuQ9i3gxR6iPIJ4U+5dCuv/mCoYx79KREdw4v1EyeXf2XfqqMQbsyJ18WHqx9Uuq5CfZU/fxPl4XfPSqGTtnWAj3Qw+CeTtolXXlp94BUARnss+R2GPI/rAM2YjweBD5Zhpd1dbtd4KU5F27zJbDrq7Rc4/BvrgNvdAYFTHcWj9OkGB/9F9UnxOEjhQ8q+5A0t4OXKorYur83CcKUiNkuF3uW1WfatOuIx73yGiw+Xjrm2SCgdw/6ZQ3Twu7QQHbRZWDa2WQb/hZw2C4+hitMw5IW2WShDtlmqzavQpLxtfmO+nOCxboqEOSFOPGLY6nQW4EaJ19mol9dZUTZ1JdJsCq68VyIZ/G8n+mF2Duek/dV750okbHtmB4z2DYFol4ieyRvfIf1JwY/xPS7yQlyJlPcIfYN/moB3XYkUZk1IX4mEc+NxGoa8GygP2z+u1fCVSIGu7qrnkT/SnxbwfI1R0esQQuBCe+AD165N4rIrkdB+ms3ZKpsZ1tbV55Sts6RsC1+9hG256NVLVqaiVy+hzPlo7gNEk2VuPtRU1CvXA4TrhgxctxCuA4KvSYGL+5JAsVe5r14y+qq/8MhPzWX/VftTc5Fsy1SYb1i5Fr+uDOXJSbULvJKsyNVLys9zyRx1ma9eUv0Hf8ftLY/fFEjXc1+9xLp+IAw/Tl1Xa3hFdR3tFuuia45U4Zr1iMv0RvWPfKz6rKDj6h+nBM9h/fH6vOrnLKk6O0B5T08pPydlB6xMRY9VR5nzUdLb0A/lPlb9QuiH4sRHjm+2PV1suFRbK6X8Gh1+54oPZZ9sBr7DOMerr+p8g9/hfBZ+y8eqG/w74Jrs6xKcyi7yNauDcmVk0WPVMaarSJyz63ocrD+e13IdmZ3nOifkZ7P6hXWVx+ffLB3lj4VuL9x33OiRDtYdX9eIdTcLz5hndPgd05kVdLLa/9JVmmZa++f5bIM/A+3/exOcY1FvGbezjfNaC65Tsj7j3DTrIM5NY91yUnYDr5gsEueMdctXU4SZM6wvsH2JBF9oX/jqJVxTKXr1Es4xFrl6SV3zp+wrx9Uov3az/b1aN1V0pvqkMyXoBG5zha9n5THCdlzPijLnNVXX+D3QsSa5xwhGf6vG71lrsjxGUFd9sq8QJ/af1Z4FFU9+seNS9reU8mt0+J3raA1umzPwHfoIbyQfwb7LO0Yw+HXwEU7RGEHN5w3aNXJFxwh4VVyRMUK/vn78vJmjZZCfzeqX62qv0D516Pay1dfAqtgU9k2KXtd4QNDJav8/cpWmmXeMYPD3Qvv/II0RAh2XVbiN85hc+foq/ivP1a157cZmj/jFusUyIe/D8A7H7HylgcH/RFJPcZ39+FXd9GaAhtE+O6d0dTec6yi7MPM/+c+GMPpbdZSd8gtcR9k9U/Cqjq+qwPNm7IKyMYM2R8dH96qrwPO2MZy/2+zRvTwOH4QjjuNU9MyGnWvkdbl80LlYr5FnP6XoNfKqnSk/Ev2Ub16laea9isDgbwY/5XfIT9m5Rr4Ds9lr5NV+uxLxntdPMfg/pnoK5FfIo3tZpjv+Tnh/B+dy2cYV9Xd47nRQ/B0+unc7/B1sqzv+Tidvx9/RdC5WfwfbCeYZnSx/R7UztUaB/s7E1Zpm3jOqDL4K/s6eBGfgtcXz0t/xcUYV240ZyFNzKCWineYX8ZUGBr//6g7O665O52sGaH90Z/6G03k1fzOTPO/M3/TyMwN5O/5MJ2/Hn9F0LlZ/ZgaeMc/oZPkzM4JO1vzN7Tn8mTzzN9eBP3MH+TM78zcdmO2Yv2E/xeBfTfW0nfM3rn0DgfyL3P4OxwSF3jegYoJc+wbyxATFzzx/s9l4GdTHQYqHjJ95/gbbZ9F9cjj2KOLvoJyNt8Br7oWuqIpTUX8H18c3G3vvO74ebXjofnurYu8v1Pidqci/PVLtjMcccUJ/5x1Xa5ppcTXs72yMfcHfeTf1o4H2BRe+ho59WoxPYX1GnyJPzE1eu4F7jYv4OzOQ5zpvxuBwDsXqAf00f/UwVzM+alFvsjw8N+p6eOakZGZ8xzIrcvUS2hG+ntd1jwHaBT6D+2K8zmnQ9IfbKp6xyPtk8IzFovtkUO+KXL2E+m18b+LqJe5SedvZjSns9nP10vWUn/fqpesFDVMbPE5uO4YrRn886q2eEMOVGvHD8uHhSl3wOi3yOJylLujUBR2Fy3RFhb7z1UsHBJ0DDjp7Bc+DZkL46iU0If10T5sN4zPeBumKqjgVHRbhNVRFhkUoc+5WUWe4W0Xbwt0q1nfadU7ITx57EifWd6U7Lru4WTooI57Wrnqkg/Lmm3xrHulg3VldTUX+7Z5qZ1nDoj+hYVHWkQQ8LDL4v4Glz2+RO458bVcbR/21PLxKjPUZb7JkHcTrcLBuOSm7YbLoZ1jEduMagOerl/JejTSTPMf19x1akh4GuGsIx9WQdx3lXQt5+wH/NxJA1qH/Cjq065rOt/Ff3uOODF5t732aKK86loqnOMMM6wdLfy0Pr3Pq53ixvEf9cz2ro/Fm4N2t7W5+ZwS/aNd4+mY3TN9cTbTVspu6StTgs449nkme1RSYfTto2y556ugmyOPhqDoGXQ2v8xzJnVfHcBktr45xPavpxhl459KxZwDed5COGW/7QcduItrPyaDNOnaTgMf64iMPdo5v7/Z/WCaclI4VPb5d1bOyJdgnsY6pkERcpmcdq4OOHcyhY+poi7w6Zv3sjo515221jh3MoWPoE7GOqW0+GNrKOnYYdOzuHDrm8sd27Fgnb5B17O5Adoy3i2Vdf8j647oCQflauAyBV9Hwd9sZlsShWj79KZdu5dUfDHUsco2JCqedgXcu/8q+VUchHMiJ18WHqx9Uuq5CfZU/z+F9+N3TU+ikbR3gIx0M/ljSNuP6cF1jYrTHkt9hyPO4DiCvMUEZVtrd5XaNl+JUtM2bzKaj3n6Bw7+xDrjdzQic6igepU+zDv6L6pPicZDCh5R9yRtawMuVRW1dXpuF4UpFbJYKvZuBdy6bhVffLKUc8ZqF18WHS8dcWySUjmH/zCE6+F1aiA7aLCwb2yyD/5GcNguPoYrTMOSFtlkoQ7ZZqs2r0KS8bd5k5jrCqUiYE+LEI4atTnH+d5R4vS7q5fU6UTZ1jch1KbjyXr1k8L+c6IfZOZyT9lfvnauXZoAnswNGezYQ7RLRM3njO6Q/KfiZSZ7HRV6Iq5dmidcsO3S9gHddvRRmTUhfvYRz43EahrxZysP2j2s1fPVSmNiKztVLLvkj/WkBz9cl5a3LkLjQHvjAtWuTuOzqpRn43mzOVtnMsLauXlW2zpKyLaOUh2256NVLVqYYZ5Grl9Q6ZUmUQ8ncfKipqFeuM4RrNgPXLYRrxsHX9Rm4+Oob1X4nxXfcLwWK48p9tY3RH4966ypEXFmWXDmu7IDgVcVEoF5gHtJxxXshrhmPuEwvlP7ysdX7BZ39Djr4vcGF9XfqdWVHLKk647iBG1LKz0nZHytTbH+KHFuNMj9AebPi28BtM/ex1dw2w9Spu22qfrZI24wTH+m82fZ0seEKHX9ndatijTCO7D/RuoF9h/MF+C0fW23wS/s7OP86+UDZReMx8NabwlfyFT22GmNmisSRYjvn9QCsP543wPbIa015rstBfjarX1hXsynl8kEHZbRV8arcdxzwSAfrjq/Dw7pjP6foFbf7BZ2s9n/JtZpmWvvn+UKDfya0/0sTnGOijNvZxnkuG9eBWJ9x7o91MO0IT07KbuAVfkXiSLFu+ej/MHMy9Qbbl0jwhfaFr7bBOeuiV9vgHE6Rq23QdnB9Y3vnuAXl1262v79OlEPRmeqTzpSgE7jNFb7+kscI23H9Jcqc16xc4/dAx0bkHiMY/a0av6v+xjV+V1cpsq8QJ/afVUy4ite92HEp+1tK+TU6/I7poE5z20zzEW4jH8G+yztGMPgrwEd4UYJTzd0aj2GPkyl+TVfRMQJexVVkjNCvrx8/b+boDuRns/rlujoptE8dur1s9TWbau2ffZOi1+FdJ+hktf/XXqtp5h0jGPwuaP+vozFCoOOICrdxHpMrX1/F1+S5GjOv3djsEapYt1gm5B2PHJsFHHxkvME/mtRTXGdnru2mdw3QMNpn55QIbhuuGM+99/5CuGI8fq7A82bsgrIxgzZHx0ej4vi9nz1v92+yjfE4fBCOkI1T0T3xeEzszjXdO9d0u+ioI8lUHCL7KUWv6VbtTPmR6Kd8/lpNM+9R7wb/n7+rg/ML5KfsXNPdgdnsNd3ou2OZkPe8forB/zLVUyC/Qh6NyjLd8XfC+zs4l8s2rqi/w3Ong+Lv8NGo2+HvYFvd8Xc6eTv+jqZzsfo72E4wz+hk+Tuqnak1CvR3/m0Of0fFNbK/82/A3/l31I8GWls8L/0dXJPc7LwM242sOZQS0U7zi/jIeIP/G5i/+etr0/m6Bmgfv64bbsefOb/mb6wud+ZvevnB9rbjz3TydvwZTedi9WewnWCe0cnyZ1Q7y5q/OXCdpll0/uab4M/cmODcmb/pTiiLrZy/YT/F4BtUT9s5fzMryh84Jii3v8MxQbNh+HHGBKF8NhMTFD/z/M1m42VQHwcpHjJ+5vkbbJ9Yb5yyxh5F/B2Us/E2SFcAxamov4Pr45uNvfcdX482PHS/PZtSLh90UEYXavzOVOTfHql2xmOOOKG/c/91mmZaXA37Owb/NfB3VqkfDbPPrfg1X+zTYnwK63PRmJu8dsNkUdTfQV+W7UbWHIrVA/ppHuuhZXw8N+pNlofn8szAMyclM+O76NU2aEf4+lPUySrloV3gM44vxutyBk1/uK3iGXa8TwbPsMN65ZSld0WutpmBPON7E1fbzNL/19P/B1LY7edqmxnKz3u1zYygYWqDx3Vtx3DF6I9HvdUTYrjyXOKH5cPDlecJXqdFHoezPE/QeZ6go3CZrqjQd77apuixJXsFz4NmQvhqGzQhM/DMKctMbDaMz3gbpCuA4lR0WITX/BQZFs1AHnerqDPcraJt4W4V6zvtuhzkJ489iRPru9Idl13cLJ0ZgOFp7Zs80kF5802pz/VIB+vO6moq8m/3VDvLGhb9PRoWzSYweYdFBv/TMCz6B+SOh9lKV/yaL3Z/8aqmGcrDmwJZB/G6EaxbTspumCz6GRax3UA/iK+2watn9tN3ePUMDqf46hnD/6+3pl43jhjfL2RitGcC0c7Txl32D/lWflg/xxDWWyurzeXl9bnV9erq8nqrFPXaXpcfxm0c4S8R8GGnNeaWTe/xGMJZkGuchiFvhvIqkIfTDXwM4Wwg/vPIH+lPC/hb2x24InWp+spd0eZw2XF/eOwBb1flMVucwtqB/OMeoz9OvHrmZ2Pco8YJw0Kukw65qmNEOCyl6DFmiMvsvhr3XEl0io57rhTlGbTjGjn8BW0Y6gcn1WfjcY2bHfcYb4N0rFycio57ZkEWRcY9KHOeZkZ94uUJ1Cee6p+BPJ7ynhX85LEncXIt0wynlMsHHZQR6++VHumgvNkn3O+RjjpiVB0ZyuOeGaKT1QdeJ+hkjXumvkvTzDvuMfgPw7hnb/Ic1kctfnTkLOXh1D7rM07tsw7i1D7WLSdlN2aS537CedluuHwS1PHt8EmM/lb5JFcSPywfl09i36p2i0dJsX0o6pNYXU5FvXV0FdFR5bnSQecqUZ6w/mltXdlMS6qP4hCVWcgr6pPgPEIRnwRlPpM8B7ZXNdUnM19oy4r6JDNRRxab9Ul4OQ31ie2OOj6niL+C/OSxJ3Fyjfu2yidh/b3KIx2UN489r/NIB+uOj7RXNnGzds/lY6X5JLd/l6aZ1ycx+LeAT3IH+SQ4j7hdbRz1V/krrM/or7AOor+CdctJ2Q2TRVGfBOuW16qN94qAvYLyDPZVUF9vTp6not72tzvqzrsC8ibgGemi7lwRddKDbc3n/Qn9WCavnNU4h1Jwmj6qeT0rR9iri1Zr6uoitFOVdneZsD2VBTzPnaq5EmxT7EuhTrIvNSxwoY9jc4NKnsbjdsgTecwjT+W35ZWnyUjJ82rCdZXAhTJ2yRN9xjgNQ15oeSKPLM+rM8rE8lTyRzmZjNTWkWsJl/LBsb3z3LXhHhHwbJMQ/nGwOcv7u/nbDd+zLkwI3GhDXe1sXJRjkvLw27NbOi/t5t/627eB/f4A0Z4VtF3t4XoBPwswVl95jnvH77Zz/mGG8vLOP7hC+l1H3RadmzA5FbkC+AMpvprR4LbIOnaN4Bd9QJ5n+ijo2OeIttIZNX9v8AcEPPpmrGMzkGffBg55nlNz1ZaUHs1SHuoR6xjqEc9xKT2yPAxRnYFnTlnh0Hl17HMpc5RGo4iOzQDeKdIxk90XQcd+ZYt1DG3V1ujYYMWPWF4T8lAmnHzp2K/k6K/y6tgs4P17FENi7fEfgI59g2irba+od6xjWde6so6hTbBvB+3YY17HwvB2tnHqmmfLK3rlcF4dw22seXWM61lt98mrY08DvPeTjhlvvw069kdE+5kZtFnHsq6qNbnvXE/dnbeV11Orela2BPsk1rEDgl/cJs869m9Bx/5jDh1D2kV1jNdNdnRse3TsP+bQMXXlplo3QB2zo6VYx/5f0LHh/d20n5lBe8eOdeedLzrG9ezLjvFxrcp3cumP64p35WvhGMu+HaSjf1A+Ifwpl27l1R88aiiP/pSIjuHF+omTy7+yb9VVBNflxOviw9UPKl1XR20pf56P18Hvbkihk3Z0H1+pYPD7k7YZ18cazOGe5bfdoWG0w84lV5tqLhllWGl3l9s1XopT0TbPsazYL/Dxa1gH3O7SjuW7LeUqDORnv4P/ovqkeByk4zuUfcm7tZ/jG4raurw2C48LKWKz1NE3eW2WfRvrDF+xOJsTr4sPl465jihUOob9Mx+Rgd9dn0IHbRaWjW2WwT8/p83Ca6DiNAx5oW0WypBtlmrz6miQvG3eZOa6QqnIMSOI8+xRokmG1YOtqb0YruN5Ffl4ti6MPF/tKKNaa8C1ZZvvniIe8Nsx8d12xsbxes4s5Lli+XmNCNvXNZSH7QtlwknZNZNTEV+e6/laooF1FSe2ccOC3xjvJ5K70caJrn1zMPm/WjDV19ZatUZtYWmx1WisLc3z8W1xMl2cCEC/Mb+8sLq8UKstNWqtRm3L6a/ON1dWn2Ki2qqdFcdW059fW1msLtSXl9ZWm2tz86tZ9O1Kz5F2Jx9tepx2Jf/HfJUFvOGrEPwxsFdvoH6jIuidXXd3wJVSfs/iEO+G293vxtq98OV2L7zRHm/38mh5E5CH/U2cdif/o7wQl/FRIfjHk7JbnYzCN/b9tKA/SvS7+BbvsC9gXGXxzuDj+jmd8Gh6i2X32MfXjLcRwo/vmDfTnVivYxt7Y6L8KkamqC6lxbTGya7/tP5wJAoik7rh30X8ecK/sZZZiXrlZLRHg5RtfT1PPSD9ceI1hP4hPeOH5cP7nMfCyKcV76023cP2OyJkw3zsIh7HA/GoxgTGk+UNQ57xEcN88oZuHocC8Ri2ja5vnDuA/h/GZ3+Y/DmrGxyTod5j34rwH4e+9WPQbxhe+97s1ATk7xL59r/V15CA5b3hu0iGSq4Ibzo5klLWESqrwf84jD/v36txovyQr6EUnJ8VY1rDiXF9rjZv8BMCHtuY8TMV9bbNCfoOeR+LuhO+U/VTIlj2LfHK610EuyuFDstD8TAq8Ki9H2PEK9JkfYgTj2XKgg62KezzxwR9j/3DvOorLVneCJUX87Dsr2l34DipcaSVKS5vm/xlhGN+VFvz6RvZ+wq8Z7plgh0hWD6/AHmseOBxWtAZIby7HPyXCM+w+G4y0u1R/ebltyT4VX1Nv3QQ1w+2u+lgPWOf9ptkP9GOl8W3j7c7+Qj/TejT/o+cfRrbEizD/e3OO7bZ7Mdym+Q5Xe67GAb7cYT/XdF3sX1AXPG7f5HDR1B+H/sIfw3y/AOSp/IBpqJe2bAOjxEt9I+tf2EZ/Gvg4w/3p9MyuU46yhi/+5P9Gg55QDjGofpOw6HatX03Jfjitse2Y8RBQ/VnikaF8vqtH9Vvo6+hfBiVj/050uF3QwI+y/8YT8Gt8I4IPMrOj1JeSeSxDcPyog1j30SNydA2qnaXVncu31vxnsevGnHwruSHdsj3HGV1sVqrri7Mr6/X1prLK42sOUp7b/OKVq6zv/CuAuWKE86f8fwdzgUOt7vp21wZzt8hLuOjQvCjM+d+1ZyqfT8t6OMcF9NS9Hn+Ts1rjgn4uE5LM+eeQ8w91+eXFpeXVqq1+nq9PrfYzKpXNUfnmnsKM2av1UqCTzX3ZPS3au5J2SDX3NOuMPKpuuyK6kOtLkdFHvtT6NOocaTqO7AvYl/jmplzv9NRb99hPmtJ5JXFO2w3l810l43HDOrX8PI79rlVX1+i/5UvXQL8FYKvz3R4n53pxpk17rZ93SyntHkb9n0N/mkz535xTybjTCtXGs5nzXR4eUbyrGyHlSGGq87o8pcit0zzln8ohdfnzkQb5b8/xc5xn1ulMqEfWgG4RgpcnHBsZnAl4rUc6fXje9qaT8Ohfg0fv3ONudl2hVlXqDbY3qhyM/34bxzK4PJ3XTqF+McJ3r4fjvT40+qQderwzLnfuG6/f0bzEEVun9Wl13na4M0z537VXus0vTa+lR9s32TNM7xgppv/LNvI/Bv8HTMdnLcTX6q/Vz4+zkFwfxdF/bcVV7+F4wRVz/cQPM4xsy4reNNV1E3cJ8/2zuDvnTn3G/P+7uRZ2RGs05fPaNpYpxXBK9N+3UwH56uS56moVyd5LF/UR0E5393u5sXg758595sVL2e0w8bL1eR5EV0+VLu73Gr9A+GLrn+wbqMuVSgP64DHtRVBJ++YHPtOtiMTjvKy/sR/uwGXgjd8FYI/PnPuV/lDu+Eb1eaGU3CemunwcmKmu/xYj8fbHbj2jKaN5S+L8hj8pCg/wu8mXg3+zEyUWv4JUX7k603tbpwG/xjg5HW8SVEuZXPt/R4BPynKNRX1ysW+ZdkjHMpe4WCfwuiNR706EaeH2t28Ii5e43e17d2CV1dd7xZ0uK6fnDn3q3yE0RQ+0/jDds9tvCJwYb/ie46j2WjWFheXF1ebq+tLjdWVLY8vXGquL83NrdTmltZaS7VNzbGEOtvP4LZ67BBm3qMzdhgFPl1+JvsN6J+NOuB5Xovxp83von+G8xE8djD435o59xvDfnqmG6erjHFiH5HjnBiGfSlsm4rnNL/uJ2fO/arYD7XOiH4z+2cG/1OAM0/sh6vPyPJ9XGtHHPuBtpfrXOFG+HKU3Q+URDltfi1O1p8gDmtjk4TnYPJ/tc/EfR1eQz4pysr+z1dnuvmaIpm6ZIb99rDAgTKpELzRxbEOl2Ui6tV1VScc98R6dbLdnW/wX5s59xv//6vJs4ovwfHWr89o2uhj7HbwOiF4xTbzRLs73+D/4cy531he703hFflBXtXYyXR2O8ZOaLcqxJOyHwi/Wfuhxk6uWCu2vyVBx9XHYD0oeMPHOvnPZs79Zs0NlQC/9UtTgk7afHhWP8UxOPhtTPN3Z7rx4pyGsvtH293lNfjmbAfn/5mC0/yAOD3c7sBsrNVFvXXm0Y+psuyU34D88HzZH810lyvLH+L5c+WvYD9tMmF/xeiijXXNv0cgS9SbOB1Mfqt9JjVHWSLagepxqUT0TB74jm26qpuDfvhxrlOifLbIX1/EGHlcz3p9u1c2zAfPQaOMsf/89zOdb7jNKLtxS7uTj/B/OdPB+RfJc95YN8MxlEKTfXWeN4vTUYLBZ+VXozy5vRr8d2bO/Sq/OmttIi0+D+FVjJ/yq9PWZqKU8uRZF8mz3vnfZqKN8udZ70S+WKYG/z8AJ8tUxWS5ZOqa10V+1Nw4+4FZMjW9Z17zynTDr5uNNsq/nFL+vDI1+F2AM8/4zyVTH7H/eWVqZ6Mzr3llavB7HDJV9swlU4O/ZBtlquaqlc1Q8yzcX6oy8zwr4hxNwansV1rfk1aXrhhfg7/GUZeqXKM5yzXmqVxjBctl8LOBylVOKVe5YLlGM8rFvrTBP12US/VhPK+qYsCxX+e5LoN/tmiXajxttLdjPI1trdLuLrfLD4gT2w7VJ2Ib5fVGNY/p2tvh0pcSvON1ipKgg/6kGvuyDqh4B6TJOmDw351TB9BPj9Nwu5vng8n7al9J6wDqMutA3jhIbisIz/MhcZoW8ObrKx3guYghQSevDmBsoc1F+F4rajXmVtZr60sLK3Pr1bnF2pafRbFcrbcatZWV+VpreWlpvchaVSnqlr8ai6AcKwT/EtD5dcI55MAZp/va3TgN/i7RjpjPKMq3bqBiGXivYpxcc2IuvQpRn61arbbebKwsNlfr1fW11S0/22V9Ybm5vlCdr681WvW15a2mv7LWXK0uzdXWlpcXqgvNxX70OU4um6F8W+4PFK4hB66SA1dWbM0thEvZxTxzY4Fi5hslomfliKjcG3s2ot52FWJuLEuuQyQ7FQuuYqN4jlX1kWrdQeEqecTF92Sk2SYVl+DSG/bbDyb/V/tLufXG3m2V3ij/0qU3qu9QZ9Xc0e7ApdkQdTfUVuFy7WkOvac/ry4Y/fEoqG7WXHItC7mqmCi+7wrtEdefslXKzz5fcKH9cdkjFS9apjyUt40RVDzVsSSPbZyKReY+2Oyo6lsRN8+7f2z23G/g9ZUq+ztIK3D/3lRr75ZUHAHXO84BcL2rOQAVx4n1wqlM/6MsYtpfvqGDl+EsKR0pUd6IKIfaU8F9gPKBXOdJufaoK/v9xnY3z2psrPYgK990Mz400uN5clz3Z3jEx/MmX54996vmIHkuJk6PtXtxMs9527bB/RLw8GegQywH7iMHzc8O1Gc7/WzlexTxs+PEfdFmfeNQuELH2rI/r/rBmK9/PNv5htuUay2L9f03Zzs4fyN5VjbCeJyI3HZBzRWx/NPWz9gubMQ4OeyCWjtHvh5ra5y/DTjzrJ2r+rP3WWvnfN6LWo/JGuefxd3uxRn47O/Gdq8fcL+KvgP3ndiO2DfJ8ul57ljpJbY71U/mXaNQc4zlFN4UHONOo82yRtgi8wUuGbrK55pLq2TgyjP/5bLriOsuwoXfj+TAlXeOL23/ahT1+guBYtZyj6kHNWbNFaM8LfJ4Xs51ZgbSUbiGPeKqeMRl9VakzTIfvLYSJ/NpKoT3H15/7vdsP319N8zGGAtgKtdr/uL00nZ3nhpPxe/+foJDnUcb/x1M/q/2lRaWlb/uD399TfWR3PbDnL3QWM3b9o3+eKTb00Ev/LjPdFa6r+YHOB4f/YW/0+7AcV5ZvBty4PqQR1wf84jr3R5xPeER13s94nrSI66PesTlU14+y+iLL2VnB0VXP+IRl8+27VMnPugR14792rFfIcvoU/bv9IjLp97/qEdcPtv2oLZHnzZ6UPtan/X4Lo+4LoZ+6GIoo0++fNrVQey342cetw+KfvmU1yc84nqfR1w+fZNB7dN22uP2lXFQ++2LYZzmUyfe4RHXoOr9hz3iGtS5jo97xBXSRhusiguMk8VK8RrIr15/7ncs6vUtPM7Lr7nOqx2Len0cn7RLRC+K9JqA0XfNwY+LvL72d9TW51rVlZVGfWVtvtlsFtUNg1f7ndX6gsl6IoysV1ScxjjINU7DkDdGeRXIMx5j2f/t/m7+w9wn2VjJI3+kr9pm2tnJClecrG72Rt26hu1RrSva+aoqTtXWNXFdUcV1lAi/Os/pbFzU9R1e8TvkEcunYt1KQF+9x+cSvUe6SO/Odvd3HJPGvHB5y4JPJYshIQvXPtus87vVXpQy8R6nMcGLx/XJVl7bOKj7D+Jz4+yO+wdap+48vXL0yOrtrUdOPv/Y2p3LJ04dWT76/LW1E62TJ1nDMMqQS4vSUDAMx/BKG1UpOJKmaIQP4uJoIVeET95TP1S03i76Lu00c4RRp1dgftqpB8jzWAbP9xDPyNcY4RrPwHWKcCnLb7gmMnDdRrjUyZD2XdopiAiDPbc6RTvt5EnkeTKD59Ptbp6RLz6Vc08GrocJF36/h3BNZeA6Q7jwez6FczqFDsJMwftpQVvhZ1leksHzI+1unpGvSwjX3gxcjxIu/H4v4dqXgesxwoXf76PvLk2hgzD74P2lgrbCz7K8LIPn+4hn5Mu+zdObXgbvPfZeuUcaRn+retMsuXL00eWC12mRx9GClws6lws6ClfFIy6OHOwH16hHXGMecU14xLXbI65Jj7imPOKa9ojrEo+4zBaabULf7GDyW+0rzTWsXaOvwjYRZb0dIwyjPx716ncIm6h8DZQPz5jsC8PPmqu/3ifkY3V5mchjfcQdQQi/D8rI+oh6W6F3Bw6c+50WONnmqj4H3+GI+roD3WVTkcN59Ajxqihyq9+sW7+ecaC7LOqmGPyWd1gZ/K4bOjifneBUO0N4R7MHG7DGLww31rU/Pa4tmEyviHqT5V0pylwS8GX6H/mO++NTsx28DMc00Y5cSXnYbq6iPGx7V1Me6v01lLdVujvhkQ7KiO3MlEc6KO99RGefRzpYd1ZXU1Fv3fFMaF6bpXaq8/gjzba84ICmmWZb+GQwg/+bAx2ctyfPYcc3tSaPDzBx+0f9Ve2f9fkqyGMdvBryeOyISdkNk0VsNz4w28HLcFwOrNsrKM+1syWQ3zKXpy0g/a3a2aLmv1w7W6YEr8o+cNtU/tqUoKNw2TzBGOGO/MljfRt97Hpe3RhUH1v1ufatsunlLZFrbU71TRHxjHNQbNPS/GNOym5Zmc7eQjXbwctwzA/WO+s98upRTvNc3kjwhX3Gp9u9/EcOWVwKsiji+6HML6c81H2276hP7DOiHrLPeKngJ0/bjBPbL6yrXSnl8kHnYvAxp6J0G1KKett4Wbxz+X7sy6b5fu88oGmm+X58YonB/yn4fu8h3y/MPEWxNo76G8IvzGs3TBb9+H6XA37VZ9qzur2A21AkcDAengtQvkptbq721BB/oba+tj43v7BUX6k155rN9cb6QnOxsbY+31heW2jVGstz9aXWQnW9tthqLczPrS4015fWVpvrRsvkOeQoWwGfqb66Xpubf4pStbncmF9rztXX6gvVtcb8eq22WKsvNRbn5tZXG4tri/W59fpCfTWPzxRo3i33qVJGf6t8JmWHXD7TpYJX7kPidKLdgeO8snjn6o/Ydm4WV5wsSjHPul0gXZjbrC6EXrfLWsPdjC6wfepXF7gvd42NA41/crdlHv+EHhsPyBrDnKueyw5+Aq2T140ftW6m5g7i9baRKN2/Y51EvrH/tndcD4r2re1zv64bf1z1jLg4Nkv5wq42j7g4NkvJo0J5/xz8xf/tQDeMxQt9E2D+Ma3HqLnZsGPK/G3a6I9HQdtQzdWG1Dgh1tldkVt3sO7S4tXGRVnz6DLylEeX1ZjZ4GKd+O0Dm4PDCNhdAPd7DrhRAce0+MQmxME3hf1+giPG+x/oRFOUBZ9epm5QVqf0TlMe8sSnWQ6LcvLuiFLUGaco+XCkMsbOuHYx7KE81MVLKA/rdzflYbyIxXVNRL3j1H8HNuU/p6x7xMnVF7n6CrTzBq/G+vbtoK2P8BhZrY+qcTC3WVwfYX/sGsjrZ+1kNcdp0qqeVX+Gcxxmm5Se7wO8PHei9MGlP1cIeJyvYP1BHbFvB3UNPYSOWN61kIcy4ZS1Zp9Hf1y2Ia/O2LdqrXUiJ16X7rp0TPGNbY51bErwrexXWmwNzjlh2dLWjKeSOsi6lQ1j0uI0DHkefaqWOlkXZVhpd5fb1QfEqWib5/VHtM28/oR1kLbWjzgxjgh3+xgfvNMyIpyueZBAJ6fm9rn55NTQ8yBZe194HiTvyakleu7nhNIhj7hMN8ZEnkf5LrLfiYn9xzgVXbczvouu22G9sD+LcmafHNsU93/YZtifDbWeVkoplw86+B3r/5BHOnnGHT7oqP1qav8Zj32L3mjgGu/hrkNct3v+DZpm2on7vG5n8HdCPOih5DnwDs9CbRz1V41zWZ9x/Mg6iGNErFtOym6YLPpZt2O7gXppcDhmtTq6C+rofqp3tXfR5Q+qPYujopxKz+3bMfGdR/1YUnY+Itmpm9CVDrB+oA6wfuA+EbYruO+O95RiUrpjcioyZr0/pX0bDW7fPP5I2zX/fPC3+VauPDdvK7xx4pt7DP4I2ZRAOiNv5eJbPFw2G8unbPZdKeV7G7TN19+QTU/dUlWiPHVLl9r3y3VkbaKSswwGfyrnGAzjAOI03O4u38HkfbW/JG83wf3RlXZ3udUYGuHZBqo9ymgz2D9P6zfwf8SlbvhiPRsR8IiP9ezNUEd2247yu/gUEDWHrfwOvv0JdWsMeP4xas+Bxn0Lyg+2pOam2c5jO2E7zye1YB7qQdGb7kwWRW+6U6eBKDvBtkD126rdGv7taLfYh3O7VWceuE4UymrnfGs91iXrN7aZMcpT60PcZuJ0K9FT6yjYZiaA1ki7A+t7HTtOJusy8Dzc7vBu9E1fRiHP4Db8vTC8Vo3X8QQ/3iI4BvxYWYYInp8r9O5L4ENhGbEesdxY73GagDyDL8M749Hm5UYgb6JdDNco4drVBy7ja1rA79okXwrXCOEaE7jwHe6v/Ay0CXXyEParOO79xRzjXvw2bdz7dfDb/i75bdjHs811nSJVdNyv5hcmxXcb8o16+wSP7TH3LVVGfzwK6gPU2GdCuaqbjwOPMRrGjxpDq3qO16/3RL11puIqcCzH5wa5bsJVMQ8u/0D1f75vwkXaE1Gx8Zdqx9zOEf6b0I6/5Rh/sS/hOvMpiorPmxivql7GKE/5rS6faNTBl8snUnyhX8wxzuP0v6sMLr1TY9Rt9EvnlV+KZWe/1DU+jBPXwaSAV2PGaYJHmat2yeM1taZXtF3iWO5bOeaY0M7yHJNqn9hH83lhxsvB5P9qwbS80FpqNOfqq3PrS8uL1UWe84lARhMB6C/UV+eX5+aXqqut+YXl5kIW/T9L/hmjPN/95Jgopy/8i9X5dZ6H9cz/nPXbIeXDbcTnOMba28vbHfxcljipNTf7Jm7rpk/x8zPgmzi9AnCXKO+Vgq7lvaqt+YjTqyGP7fQPQB7fePwayEMbrvqFg8n/1T7SUzq4FNi3a+6L0v000/+b20Fo1w3/oTD4N+zD4TD4m4bfYsojf7irhpvnUX3L5gVh8G/U7W1h8M8Z/heGqdsN/LeHwd8w/C8C/CH058Vh5L+B/44w8tnA/5Iw8tnQ/zuDyKe+wf9Lg+BvbvB/Vxj8G/p5dxj884b/njD4lwz/y8Lgbxn+e8Pg3/A97wuCf6Fh84+fSRqWK9aRf6Ood34sThvz1FFQv7PwyeTqTG+eh1G4hgUuNe5M21di+eo3ivLJMFAs0oYMKznLrebkWIYKl5qvdK3DunC54ntGCsLvKgiv5s2GHfBjBfGPF4SfKAi/uyD8ZE54jhMyHHEa1LOW9oThp+Y6Q8VkMR2G9kJeWUyTLALVTS1weTfslzrzfY8o7zTBc9kRVuGKk+l83JbMHjzQOnXH8VOtk0MpuLA+kCbD87OlkRQ8ZeJXfcu+f4Xyle3E97tS3o+mvB9LeT+e8n4i5f3ulPccU2LpULv7/zvo/1vbbvjDyf/TUW8q0R+/D/V/tIW0fPBqOqmeSw4YVzx+4PnL3DbT3o2nlOegH342bFqZ+GH5cN+r/FpeA4mTzVOVRF4enxfz7vCIyydfPnG9OABfPsdZyo82uJD7XOJk9R94z8S82keDN6o9EHWXHeNIy/Rt/DwF+QjfLHVwPpi8c+2tCRwHupjXNvH+vzC3Rrr3/6kxXpH9f3HCeVDOK4t3Qw5ct3jEdceA8uUT14sD8OWK59qs/VExaK55iaJ7DngOQo35Rx384fd8nkia/XqSaGbZL4wXQvg/jTo430VlVPYir69xqN2NS63vMu9puG4mXK75n5EMXC8kXEXv2ENctxOutDvw0nQC5cv7yNLi37JwxelwuxuXijMLvD68YDyNZ5Sb9xypc5PGxHclb7w2mkoW/vA3V9WNtx7xL6gYLfY3dgep51ruGFijv1VncOaNSVN7Ge1bFX/GOqjmOycFnWmRx2t8/eC6xxMu1Q764etuT3zF6S6PuO70iOs+j7ju9YjLVxmV7RoUnfApe5864bNt++TrZR5x+dRVn/Vo+mW+rsH+YfKr/AmPfWKT91tGUW9/PB6IdonomfwiKq/rLETje1zk9RMPvLTUas3X15dr1fm55lyr4fIRN7sfGeFN1pNhZN1QMfp4Lk2chiFvnPIqkLexr/Cpv58qdfMfyHfLJX/lDyE8z3Pkrcu9kfY1TD7YbuNn13mZrvM5+awLbvOYh+3EdY6ojVFwr45rHkGVUY13eCyrYgHUfl81j8D31GbND4xCPsL/RfIbl98OWS9a5hDzI4xrWJQrTqafFYL/TvIb//8LpW6cSu44R3GoHaWWNc899YiL5zbSzg1mG6dw8dxG2j3yaTYUcfHchrqz3tVXq/Y5Jb7nsdWeDL4Ot7tx4fd7iE7aftGzuNudPDyrLU7DkOdzbj7Wk6+WOnxwebE/KEX6THIVV2DwKg4BcVhbmBbwFi+r5LNnG+VTKSgftaaQVz6H2pGUD7bxQdOfUYd8VFty7Y3M0rebST4YB4NndbF8RrdRPi79ybLzLB8lT8TxQpIPxhONO+QzqPrj2sOr5JN1PsntJB/VP13I+uOSD/aTSj67HfK5WPTH+n4lH5OLWvPDs2XmyNdTa0/oPx5qR13lVWMSXI9j/9kW5GMevpFCO6/vavDfAzjZd1XrX3tEeVw+0lad3WG4ss6rYJ6LrrO5/G3XOltW+2Z/W40D1Hga4RBG+f6YnzbOiKLg80pV03/0oSxZHsbI8nh9b9Qrt5LAVab/sUxx+b8J9ofhmB+UEfKWx9Ycap/7Ve0kz7gMcbHOpfV7jIvrNsw8UP54+AtlDW98S+RavM2gPDmpdmF8x+1iaKiDl+GYJuoftwslc+XjuuYFAs+7FpYrx9TgORRF73TGedrxAjJXtsjy1F08Rc8rKtHzxvxzpH0v9i0M/iT4Fn9M5duGs00Xivqcai7K5XOqOYFJISc1J8DnPGzDmGWh6Jgl79lgLnkijkPtqEs+ys5u45hFymeXQz6jGeXNM2ZBHDxnknfMu53tq1JQPkXHvIjjhQ75DMCcrZTPiEM+qn25zknL0jeeM1FjACWfLTorLLj9ccknfuY5E5QP+4AqblTtUTjU7i6Pmg/APQQhZbyw2Dn31eoXz33FNAz5CP/5BIHv873WF5Zr63PL68vzy2trjdXlrPO97P2udie/TLye5T953vC1EJ7yxtq95Tc6dq6t+UCMy/jgc3C/kiBQ59Ty+a5If4Tod/Et3qGuM66yeGfwse59MfkoxLltq/PNldXG/HK1VYv/rWfVq5IT2qI4mayxLkZE2SoE/6ulTpm/BnbmLKygF8N93QFXSvk9i0O8G253v1N1hLpr8EZ7XPBoeXg2MNrJOO1O/kd5IS7jo0Lwv0G6i/pm36uzifGsZ6al6LPuqnORJwR8XD//iOwRlt33PMJZmoQf3zFvXw/YrlorjaWFlaXV+epadam2NJfVrvCclVLU3d9FkZ4zxrk17OdGIh33Yfh4jvl3E7oxD38ypHFiP3S43YuTecb32OfbHq4Kwf8+8PAtGIuyHDbaJuH2rE+579bb6E+EPELMk+U9i0XFMrEfhL7qLe0OHOflmfMPjUv5m0Xtu2udguPK0OfCvVjfTmmjGGuF31obZX3/C+jr/hzsuOGNiMeJyG0XsLzsV+P5swqe7YLB/5XDLmTdqXa4rXF+B3DyelbWHqzNjhfUWhLvRVL2So21DG4r7gsJOZeRdWa36cc0waMcVTviNbqs87cOtaOuMiq9xHan+smyoFESNFz7E7PaUVngTqPNskZYFZua5gdYPvbBCB8ns48Vwvt7CVAsuz1D3TCGbx/ATFOfi/K7rd2dp86Oj9/9TvKPOrM4/juY/F/tKzVaqu/3h7+5qM7r9Yd/YS7sHsSFZcM/FgZ/PfAexw35TIThf16tBfrDX19Ta2Ie+d/Qzz1h5F9XZ7J55L+qzv3yiL/J64JGI05GG8dj/vrtxmqJ6EWRHjcY/XHi1bMfsTFu2Ev8sHx43LBP8Dot8tjG7xN09gk60yKP95j1g+s+j7ju9ojrTk+4VP/XD18v9cjXLo98+ZKXzzL65Ev5AYOgq8p/GJS27VMnXuYR14792rFfIcvoU/bjHvnypffx84RHvny27UFsj75t9KD2tT7r8S6PuC6GfuhiKKMvvnzb1UHtt3neZFD0y6dd5bmbfvi6xyNfPsdWg+pj7rTH7SvjoPbbF8M4zadO8Nzwhaj3PD89KH60z/HQtEe+Qtpog8X1Xov1iZOdOcFrmN+kNcMw8TyNNbWGXoq6aY8Gol0ielGk1wR47xLyw/fK8/3lBzfJ60ptfa5VXVlp1FfW5pvNZonwG6/8Lk88gVpfCLt3tbGiYjY4dn4Y8visjwrk4V5UPqdrLBD/eeSP9KcFPJ/Tlbcu7Zwu9DF5by/qsJ0JrvZKWFwCxgWoGI8S4cc4HIxb+ldDHV7xO+QRy+faz15OeY/PJXqPdJEe343K8WnMC5e3LPhUshgSsshzzhm2U8MXIt61sb6w3FxfqM7X1xqt+tryVt8/3phfXlhdXqjVlhq1VqM2v9X0i96/vp48n+f3ny+g3Q/A/wVz/7nFUKmyxMkVdxXb6quizvMMfBMnjgPHvNsFXct7UVvzESe874HvP8f+hWMl8S5e3tOHvv8uysNxJ/fJOGfLfTn6tLwHFeddeP8l+q983g767xt7j5L/Q9wLuFhtLKuYG496uLZP8D8FZYvTze0gtC+4O9xD2Lg43RoGf0Pd4+5Ttyxu9f4En9pLaXYpsL1tlYheFOmxlr0bj8L2LyWiZ/ywfOw5tkXflTw/0Dp15+mVo0dWb289cvL5x9buXD5x6sjy0eevrZ1onTzJHitbcM7HxDAMx/B5S3Gofe5X7WRgrz9rd5PrJhjedZR1stcthEtF+6uRA8IhjDrhCvMVfq6PkQyebyWeFc3AN4zNG6+jDl6R/mZvtMFyH6Zyq10b9p3alcB1pUbNmD+SwmsUbe/NOUOCrzw35wTiddF4nSjIqzoFIzCvS8br7oK8qhOOyvQ/wyGMOpEA8ycE7S3StWWTyWRBmagTnAPzujELtqcgr+qE6MC8rhqvUwV5VZ54mf5nOIQZFd9j/h5Bm/sgF89xMo9xykFTzTTxqFb13WqWy3XyP5/uj33MGOWhfUw7dQ/1RZ0q55qNd92osZvysP1YnUxEg3+SSCv5f7tPEjFv+PyeKWvszJRlJGvPh9od/HlnyuybuI1aG4uf0UbF6TDgLlHeLYJuyDI/pRPzgW9Gru+L0u2vjdqvTP4vC1hsC7jTW9VLJN6VBB6WLdbjweS3NjdXe2piYaG2vrY+N7+wVF+pNeeazfWnVhmai4219fnG8tpCq9ZYnqsvtRaq67XFVmthfm51obm+tLbaXOeyDjnK5tqRm7WKMug2/Lrk/+224bPJ844Nd6a5wDa2HtjeSBvu8v2UDVezh2a3s+w72nDDHbJfXIQbZQPVWW1flG5zzYZfE3USyplPBUA8fCLJ5clvPB+yLwXfSJRtK8sp39kK1pjAEXmUlyvKAPlwrZ6fD7Z9Jvl/u237/uT5PLftyzu23Z22wrZbxFj8vBfwxUnZdsvDlTNe5eZVL8zDVXk82cf8XfzuYPJ/tY+E/UWgOfvGPsG/0bL+wmxgPDdxRfL81GrTU+tM9y4fPbK2fOrI8WN3td54unXyFB++Vqb/OZ8DoIw0wnEq0f+8cFii/4cEHKY8gVGuwCvl7rsC1M6H7sKmUba7u0A3APN2hgJdaS6wOZ8LaebipLqLtGXXOJl5x2fjabNdijrMz3Dj8CF+3jjkN9K242DUv1xMb0INR+K0L0p30c38m3u/G56PHT91ZP2RO04fPXpk/Uhr7Y7jp1oRJTb9aWYZi8XfcTK488GE2kzZdpvQevJ8npvQla0yoYE8rQV1TlxoE6ruQzMdtjhQfO7XhAaeAW8GluGc2ptgMgi8Mpz7DGGjPx4F1deNWDQVgaPO41V7aXgENdzuLYfaS2P1G8NcC3CsW3wXOw4b+BxKdT9fjP/pQOsZyXPgbn1lO7t1e7er3ZHHRt8L7yogv7PyQXjKC3HXwo3J/4N814LNZk1EHXfpOYCP2wqvmiG+2L2yGY1z7tXNJ1rLp7RzpTYO4f9DKUzkHY8j/shBi3Ei3PniqNWS/7fbUfup5Pk83+RT2xnrupN1bjhudY11bUoSn12OmuFVjtqtlIftxHDHRsym+XC5SE2DligPHUl2DG4n3jEPNxfxBiLcXMQbiHBzEW8gws1FvIEINxfhhXylKMxm3ac6/aWwm5mri/sE/xjuG6edTTsyzVnn/XCCzzpqtjER6Qq+88WLclh5EBJqOaBE9KJID0KM/ngU1FbWXE6UuhwudqIsZPPkqeMnlh9o3dVa7jpTQblDnB8RuTixq5Tmctn/aUshrqUNTK77PUpRLw9l8c54mk75Pk6BxyJNNaa2pKJzeXkFx5+H2h04TiqyzMoU43gC8DIc84MyN97UfRAszyHih9+56oMj3QKt/HqtD+xOOLki/YrWB8oc7z8N6AYWlpMynS5ZDIMsPgJ4GY5pls8DWQwJ/kPIQrXTUtRrf1WXcah97le16+GU75SdVK5CxUFb1ZM989kfiie213E6mPzW1+Zb1aXFlcX6yvLcwkpjbmVpabk2V2vWaovra/XqWqO+Pl9rNleXWkvrtbn1lfnWcnN+eam5VmtVl5trTGtI8DVE5drlKFdZfK/ubdqVIgOUDe8MVEvrafyPOvgfTeE/SuE/66wd3lloz2M5+Od2HKeDye9cdW6utVxvNFvz1WZrcWmxtbSwPr9QXV1eX19bqDZWV+KDmZrVubheF+rVlfpSqza31JpfPXtXZ81ojZNsxkT5rVy4+4WHLWXxvdrtN5EiA6xbPiN0XHzD/w+Jb7lux1NoI8yQKGMaDmXXFP9j4ps8/LP8d6fwn2Z31C5CVb8uHGzf2BYNpXw3RnSVfjPOkQycvBtL7eBVO7VKlIc4eTdWiXjDPFfYj+oTlL/CZVC2hH0rtImuHWznw/Tq48n/2z29isP7UtRdv1Gk/fVD7W54jFBW9sPwcbT0W5LfmIdPRRpn2p2pG2sQUa9Oxulg8lvtMxk/Vn/YZoYdZTT4J6GMn6EylqmMLGcrr/JjPZaxViF+3g08/yTxrPxHpVssN4RXdlWdUOE6N8+eA4/T6yWiF0V6fsToj0fafh70w0+N+x2Uq6oHZet5vK30uIhtQLqH2ud+z4d7Ii+08/PWG/VWa36xsbLy1FNtrbbV9FfnmyurTwmh2jrrW9ez6H938nx+L+0tzO3senCnvLseygSnvulnZ8TVUeeZl+9w2bFEebdCHi/fFd0ZoZYEeb5UzQWo2KKQsVcYjxNi6e8ptVtUsVG8JDkMea7YKOMxhnkmySdEXBzG3YWJfatvnDeoToKy/rkBMsF8g0c5BKrHpbw+ktEfDyq3jo+kTqpSZzbH8wOXJs8b58UdWj61fN+RU8daJ0/yPFqZ/s+7fcf+5zlZ49Pi7NR8cloyftgmIj6eaynR/0MpcFhOn/MCPIZX87murUKuOYMJ4HFXO9pIG74nvDP7sV2xfHPJ/4Mcy2dxe+fDnMpS8v/O9qz+8e+c1JCddk5q8K/TeU5q4JMVLD/PyQqlFLw7+6by2bY/S/45z8Nx13dOEnMns20vb3fwqzapbJt9gycQ4D4Ss1+vANw85n6loGt5r2prPuL0asjjMfcPQB6HzL4G8njdOcz4cX4p8N6ppmv8uBP66kw959VH/nBXDTfOK5UCyOYFYfBv1O1tYfBvzKe+MEzdbuC/PQz+jbsCMHw/hP68OIz8N/DfEUY+G/hfEkY+G/p/ZxD51Df4f2kQ/M0N/u8Kg39DP+8Og3/e8N8TBv+S4X9ZGPwtw39vGPwbvud9QfAvNGyc9JmkYaltTaWU3yjqnbuNE69vhxr/mSxUnEFZ8KNuo0De0nANC1zTUfYYnud61W8U5ZNhoHmJDRm6Yi+QH3U7BsvQFbuLuJQMKzlwqbo1+JGC8LsKwqvY1WEH/FhB/OMF4ScKwu8uCD+ZE950Hm8QMH22sUugu7Zyx90Y/XHi1XebmiR6ShbTYWgv5JXFNMkiUN3UApd3w35dQuXl+jX60wTPZUdYhStOuBZo9uCptcD4lIGTQym4sD6QJsPzs6W0mPgy8au+Zd+fjyZQthPf70p5P5ryfizl/XjK+4mU97tT3k9GOh1qd/9/B/1/a9sNfzj5fzrqTSX64/eh/o+2kJYPXk0n1XPJAZMnbjOQH5nbZtq7rYrbLBM/LB/ue5Vfy3GbceK1oKI+L+bd4RGXT7584npxAL58jrOUH21wrna1WTqYZ/UfeP10Xq19Gu2433og6i47HsNTpm/j5ynIR/hmqYPzweTdNh4nsJjXNg3qcQJq7419O015ccJ5UM4ri3dDDly3eMR1x4Dy5RPXiwPw5ToPcLP2B9ua6ZxrXkLdklmivFGBs0R5xh+/Y/7we96flma/niSaWfZrF+Qj/J9GHZzvojIqe5HX1zjU7sal1neZ9zRcrptmWfYjGbheSLjUKewufUZctxMutefapRMoX+sHN3tDK/J1uN2Na1jgCrw+7Lw5tST4yXNzaonkcNALrzrW2h/+5qo6hsoj/gXejxtFvf7G7iD1XJsvET2r54jqy+iPE6+e9W7D33Dd7hon9jcmBa/TIo91UM13Tgo60yKP1/j6wXWPJ1yqHfTD192e+IrTXR5x3ekR130ecd3rEZevMirbNSg64VP2PnXCZ9v2ydfLPOLyqas+69H0y3xdg/3D5Ff5Ex77xGae/VLjgWiXiJ7JL6Lyum5I5vPOMa+feOClpVZrvr6+XKvOzzXnWg2Xj4jveM0jb99usp4MI+uG2mOIt0vHaRjyximvAnkb+4Se+vupUjf/gXy3XPJX/hDC8zxH3rrcG2lfw+SD7TZ+du35cu3r4v1g3OYxD9uJaz8YngWTZx5BlVGNd3gsq2IB8J1rHoHPvsqaHxiFfIT/i+Q3Lv9cqZv3vGUOMT/CuIZFueJk+lkh+O8kv/H/v1Dqxqnk7jrHDnliuY9n4OK5DTX+NVwTGbh4bgO/57Oadmfg4rkN/J7P3pp04ML2OCW+57HVngy+Dre7ceH3e4iOmttRNtvgQu7TeSotxnry1VKHDy4v9gelqDsexBVXYPAqDgFxWFuYFvAWL6vks2cb5VMpKB+1ppBXPofakZQPtvFB059Rh3xUW1J2Nq++3UzywTiYMYd8RrdRPi79ybLzLB8lT8TxQpIPxhONO+QzqPqT94wDV1+HOG4n+aj+6ULWH5d8sJ9U8tntkM/Foj/W9yv5mFzUmp/RRB/WaKq1J/QfD7WjrvKqMQmux7H/bAvyMQ/fSKGd13c1+O8BnOy7qvWvPaI8Lh9JrWflWWdT5whNO+gYLrXO5vK3i66zufxt1zpbVvtmf1uNA9R4GuEQRvn+mJ82zoii4PNKVdN/9KEsWR7GyPJ4fW/UK7eSwFWm/7FMcfm/CfaH4ZgflBHylsfWHGqf+1XtJM+4DHGxzqX1e4yL6zbMPFD+ePgLZQ1vfEvkWrzNoDw5qXZhfMftYmiog5fhmCbqH7cL13nWcWKbp+YFAs+7FpYrx9TgORRo/zkpmeM87XgBmStbZHmof8ab6p/yzCuWiE/0LbBvZN/C4E+Cb/HHVD51ll5gn3OhqM+p5qJcPqeaE5gUclJzAnzOwzaMWRaKjlmyfC2Wj5In4jjUjrrko+zsNo5ZpHx2OeQzmlHePGMWdV9P0THvdravSkH5FB3zIo4XOuQzAHO2Uj4jDvnkPV81r77xnIkaAyj54DkzWy0fn/bHJZ/4medMUD7sA6q4UbVH4VC7uzxqPgD3EAz6+V6fTxBs9/le9n5Xu5NfJl7P8p88b/haCE95Y+3e8hudzZ6d+ZUEwSCfnfnF5KNBOGtdyQltUZxM1lgXI6JsFYL/1VKnzF8DO3MWVtCL4b7ugCul/J7FId4Nt7vfqTpC3TV4oz3e7uXR8iYgD+1knHYn/6O8EJfxUSH43yDdRX2z76cF/VGi38W3eMe6OyHgJwR8XD//iOwRlt33PMJZmoQf3zFvXw/YrlorjaWFlaXV+epadam2NJfn/hw7Z6UUdfd3UaTnjHFuDfu5tPtz8C4chP/dhG7Mw58MaZxp9+dg/A3+n3Zfn+3h4jt8fh94+BaMRVkOG22TcHvWp9xX9W70J0IeIebJ8p7FomKZ2A9CX/WWdgeO8/LM+YfGpfzNovbdtU7BcWXoc+FerG+ntFGMtcJvrY2yvv8F9HV/Dnbc8EbE40TktgtYXvarTZ4jKfBsFwz+rxx2YUSUG/k63NY4vwM4eT0raw/WZscLai2J9yIpe6XGWnhPaJyGIc+n/Qk9l+Far0X9mCZ4lKNqR3nuicX2cagddZVR6SW2O9VPlgWNkqBxPtwlheWzfOyDET5OZh8rhPf3EqBYdnuGumEM3z6AmaY+F+V3W7s7T91XG7/7neQfdWZx/Hcw+b/aV2q0VN/vD39zUZ3X6w//wlzYPYgLy+qeFo/464H3OG7IZyIM//NqLdAf/vqaWhPzyP+Gfu4JI/+6OpPNI/9Vde6XR/xNXhc0GnEy2jge89dvN1ZLRC+K9LjB6I8Tr579iI1xw17ih+XD44Z9gtdpkcc2fp+gs0/QmRZ5vMesH1z3ecR1t0dcd3rCpfq/fvh6qUe+dnnky5e8fJbRJ1/KDxgEXVX+w6C0bZ868TKPuHbs1479CllGn7If98iXL72Pnyc88uWzbQ9ie/Rtowe1r/VZj3d5xHUx9EMXQxl98eXbrg5qv83zJoOiXz7tKs/d9MPXPR758jm2GlQfc6c9bl8ZB7XfvhjGaT51gueGL0S95/npQfGjfY6Hpj3yFdJGGyyu91qsT5zszAlew/wmrRmGiedprKk19FLUTXs0EO0S0YsivSbAe5eQH+N7XOT1E6e2Ulufa1VXVhr1lbX5ZrNZIvzGK7/LE0+g1hfC7l1trKiYDY6dH4Y8PuujAnm4F5XP6RoLxH8e+SP9aQHP53TlrUs7pwt9TN7bizpsZ4KrvRIWl4BxASrGo0T4MQ4H45b+1VCHV/wOecTyufazl1Pe43OJ3iNdpMd3o3J8GvPC5S0LPpUshoQs8pxzhu3U8IWId22sLyw31xeq8/W1Rqu+lrk/wDv9+eWF1eWFWm2pUWs1avNbTX95obXUaM7VV+fWl5YXq4tZ9C9Pns/v+88b82j3A/A/F/b8zmpVxSr5xG+29FC7gx/LYnRje4x7vK0/mnR8H5L3p+q2Efhupdq+FP7jZLFw5v/GsrExzQOtU3ctH1s7/vpbjrSOrmELY+m60kQ0+Lu5Lkv+3+7dXFcmz+e5tWpulbUKKZ+ALVJaK9U6lTdo36D1ip/3wDdxOgy4t8iSzQ+CJbM2FluyS5Pn1de2Vl93x+mjR4+sH2mdOHzmyMlTJ9meIc6InvPavqyo40G3g1ck/2+3Hdzx2nKlHTsYpXt0IT1atHWhPNp9kduWsNdmbebY8VNH1h+5+URr+VRrbcPmRZTyWrQd7y2/1bKM89tqLaxsldUKs4ezPhd4z+qG1bq13cGv9rWVCY6/QQv3AoB5QQrMbQBzWwrMCwHmhSkwtwPM7SkwuKbwohSYFwPMi1Ng8P7nO1JgXgIwL0mBuRNg7kyBeSnAvDQF5i6AuSsF5m6AuTsF5h6AuScF5mUA87IUmHsB5t4UmPsA5r4UmJcDzMtTYF4BMK9IgXklwLwyBeZVAPOqFJhXA8yrU2B+AGB+IAXmNQDzmhSYHwSYH0yBuR9g7k+BWQaY5RSYFYBZSYFZBZjVFJg1gFlLgWkBTCsFZh1g1lNgHgCYB1JgXgswrwWYMsAcAZgjBBPY21oIa9PrtTxnIIS5X7ie+6xQvl849BkI6jyBtDMQzsK0O/yUKG+43VsOtRZo9Rt7t4cAjnWLzxEwXuJk+qvOGDC9jfG/BGjdE3Xzjt+UiX4U9a6zhqiLxWpzOazenzv382wZ2934TX5xGoa8YcrLU3dxehTgWHYhRpcouzDtpLYxG4X8I6047WpHG6lMskb5bde5XHck/w/yuVy3Js84Fr0Z6IcYWx0Kgr9WNfyHw/DfMPy3BMHfqNrMwx9YnUUh7VO1qmIeuF/eFYR2rZa3X+aYoTB+QqdfznseZth4q1q1RPiRHxVTpc5t5jjrjfPLABfCj0IZER6f7Xt8t5b8qnNWNntHXCzz11DZVNxbHj1CvNNRr2w4tkWdC6RmTvlcoMeA9wcJp6pH9IPQpqBM0s474vvvDP5Y8hvn/1Gkcea9U8/gTwIvb0yes+KlHol0+UuRW6Z5yz+UwuvDUaf8/yaFV+QHec2K33rCAVcRcCXitRxpX9/6K5c93qyeq3Nuwsb/VXvu6VTlZvrx3wSUoRz12iCGVzqF+Hkf5sZce6RtKZ9RZPDvTX5jWb4jhYco6tXrOKEvlabXedrge5JfbNdZdwcZ3+r8fTxvmXHE6WDyW+0v1cLqWr0W9hyfTmxVmHN8qosqxhFtyYeJrq3G5bXhBv8JwPmx5Fmd1cf+RFrsJd9hEkX92yrcr8Z+wx74RrUzs6EGPw10y4RDwdsYDW0D7lvg/sbgP5v8xnL/0+RZ3ZOBdfq5SNPGOt0teGXavwI4fzp5dt1Zqu4gZR9xj+AF5Xyo3c2Lwf9c8hvL4dvJs5r/wBXkOA1Dns/xRczHnwMfXP+Vdne5fd5dijJT93DwOe9YB7znSd1vo/oX1V7tW2VHph3lZf2J/y4BXAre8FUI/u8nv8ofvQS+UW1uOAXnrwMv/zDqLj/WwTjA/bMU2lj+siiPwe8V5Uf4S4hXg/8nUXr5p0X58QytMcJp8P8UcH47hU8sl7K59l7tn9oryjUV9crFvlWyNziUvcLBe5SN3nikdWKCeMU8pI9lV237EsGrq64vEXS4rn8v+VU+2mQKn2n8YbvnNr5b4MJ+ZdBjSv4w+X+7Y0outP0b9cXF5lJ95akVvbXV9bXG3FbTbzaatcXF5cXV5ur6UmN1ZavpD9I9EH9psE/9/VXynHUPxP90wJVSfs/iEO+G293vBv0eiP8v+X+Q74H4a8OX/GLZfc9Fn6VJ+PEd82a6E+v1sxIE53esXHP1/I6Vq9W3KlYOY9FcsXJp8WtlgEmLX0OYtPg1hEmLX0OYtPg1hEmLX0OYtPg1hEmLX0OYtPg1hEmLX0OYtPg1hEmLX0OYtPg1hEmLX0OYtPg1hEmLX0OYtPg1hEmLX4vzA8cxbUk8B7axCMoSNo4p/3rpxRbHVAc41i1XHJPpr4pjMr2N8X8f0DocdfOO+Fxj7bCxOPOrgfsxGcfE9Trc7qaNeVh3wyDPOsknhJ+C8gkh/1g+rp1zPI6IIu1/m4y2K1bpe5P/BzlWaT553oJYpXrYWKWO73w4DP65sLFKnVirW8PwvxFr9YIw+FuG/7YQ+J+afrBYLhzTp/kOefr2OPGaAt9bh3RC3THGfVqY+LBODMEo8KnWO3n9Cse8ao2f4dlfY/xjW1PenngvXIccEfyrdfUo8mufYpyB1tUXK1Rei6uIy3ov0cQ5f66jOKENiv92Ux0xDMd7TQJtljl+WyH4VyW/cRkqpW6cKoZsAnDeQjgN/jWAc7Sk+Ywit79p7/cIeFyHMH7U3XJ76DvX2qDCjfDlFDy89sPlHIJ34wJ32Dt4Om0SYwNKgiaumSP8UeJrL8nUJbP47xJBF+e0x4nuJUQ31qEJ0iHjbSLS9oV3eI+EkW2D5Yh3v6EcRijf4F0xicrex3CPUllwrKzW8FkWYe6qqvfoGcpC6Qfr2Znk9+xJJaV0WYwIWbjG5VsRo3EJ8Yt2t0I8KfunYrOL2r/pqLd+RylPxYSizWI6Kg6D9S4tBtDwcd/w9uQ35u3ppW7+1DmAGK+o7o3kb3C+2NXPqrkWjG96D+HFNTLVb5mPz+eq/hXgfF/yHHKu4Km0yLJQ8WZGE/kJsw+g0weZDqTFrpajbhka/Mei7rowXcQ6rgg8Bj8h6KI+c1zcBNHFPqgsaOA4JXAsatU1Ngpcj0slomfywHdIfzzSdXPQDz8b87cqfhnlw+O9iTD8LMa+y3TUrR9xwvE51g3ygXPFbJew//8svOc2o+ySzS1VCP6nAefnk2cVS4vxskxzKIUmj2V4fj1OfIYFPu8SZUI94/Zq8D+X/KpxR14dYZuB8MpWTREPXK9ptFE/DrU17bz7Zgz+l5Jf7FsZZyWlPGk28JcBJ8tUxXW6ZKp8n92iXFNRrxx5nJUlU96zgHGkeWRq8L8Wdcr/9JTy55Wpwf864MwzPnbJNMs/ZJmivHkskCXTw23Na16ZGvw/jTrlZ5kqe+aSqcF/A3ButUyxzDznkDZvh3YT94eq78YdOCdScCr7tUuUwVWXyqZxXf6L5FfVpSrXRM5y7fZUrt0Fy2Xw/3egcpVTylUuWK6JjHKxL23w/0aUS/VhPC+PbVmNW3ku0OC/BfSsXarxOs4Jx2m43V2Wg8n7al9Jj9fR7lXa3eV2+QFxYtuh+kTl501HWs8xD+uA61/pSwneHWpHXWUsCTroT6qxNesA7i1UNFkHDP4/J79ZOoB+epyG2908H0zeV/tKWgewP2AdUPEhrv5D9aM83xInvjMC24HSAZ7ryIrdONSOusqIOoBr0jbXMegx98MJggst5n67Y96LxpxfcDH3S831pbm5ldrc0lprqdbczpj7yxIEcbu8gmxlRdCL4W50wJVSfs/iEO+G293vBj3m/gD4MHEaxJj7a8luYdl9z4edpUn48R3zZrozCHuJPp48n98x//NrO3exuJP5OIfbHfzKN8HT+uPny6Ju+Cz/h+d9y0Hqu3PSd6DY1cVQsatvIPmEiV0NfetDbdEVu3penwcHMXiPOeqq5K88VRVLXiLagfQ89/qS0R+PQupVZ31pmPhh+bCdCbR3o2ddF/mpCPlwPALXHY431bwO4h0ieHy27/Hd05Jf1xlOJcqLIj23hP7KfipbqFjUMtEpe6DD+hGng8lvta9Ur/K6I9JRcSncpsPEhNZ3zkh0y+e8OiPxu5NfdUYit+kiZyQ2qGzo1/XbppEv13lhIfznQOeOLrJORpFff4br1qe+q5hsn/yruU6MVTsE7zFPzWlz/4jwtwHOW5PnrPgJFaPM/cpECj2057ym82Lg5RXJc/57GjlSKS1Zze0m+IPJb7XPNEmlQhpGG1dht6OX2pjlIl5D9VJq5Rrlw73UnjDyqWJkE/aSh9q9smE++KQwtMgcvaqiB1CrVQsaojyuE5TdbkG7FHW3/I1Rc8p3fKKVwf9g8hvz/UMAj/JAXlxRv66T3JAfdRreFOUp71/NKGDvGKdhyPM5yovl8zbgA8sTp0q7WxZKdghfVHbWnqcJHuWoRgRIk+uP9Ykjr8viu5LAo2ax+OSsPD1bnGxFwfCe/YV3FcAbp63erWvR+4O8W9d2aJwPt9wlPxfc6uggnYj1DoN96u9dyXPW6tyPOuBKKb9ncYh3w+3ud4O+OveR5P9BXp2zXRmDuDpnunPhrI41GzurY+60szpWJNXWd1bH3PLZWR27EFbH6tU8PgLSv8hWx9ZLhB/52VkdK+5r7qyO7ayOGT9pOrezOrazOlY0BV4dW99ZHUvnf2d17FzaWR3Ln3ZWxzLks7M6BrA7q2P96dLO6lg3LzurY+fSzupYwlOCf2d17FzaWR3rpOF297ud1bFz6WJYHbspQXB+r441tmzvWKBZ4XrYWXB9XwyWhWd30T7YN2omxe6JOXv+ZNR5vhzwxQnviuHxV6AVosBn/1drg7RCFPnDXT2/z6fvnB9/K+APIZ9A59NX1fn0Hvmv2erfSoIvHoPYCshTszq3HVtrnWmt3bP8wANHjj1wd2v1ROvU80/e3Xrq9QmeROWFElzY4WRiYhwl+n/IgSOK9IQaLn7kOeox0CRtI4/LhfS36qjHvEexmOx2CV7VlcVpC39IZ5ego3ANecTF9Y31cTD5rRZLc/wi9LGhvCiDyfLGRZlLAp6HfMh3/PtawMtwTBPraZzyUB8mKA/b3G7Kw7qbpDy2D+o3ivIt3OB3Qynl8kEHZcSuVajFZT4KdcQjHaw7qyt1/BkftVS0DVcEHbVYbl1vzNfBFJrqGNQ4mVvDwQUviTo4b06ewwZfVBdY/zHxMWuov2rBlvUZbQProDpaLa/dwCvY3g54GY7Loabh1fTjxtA66q2jlya/Mc8/CN8gTuMbeY1TnsXkvEfV8tUwg9YHqHpm/cDlB9YPnPpnu4LT3igTTll9zqcBL8NZUvWsbArS4qntsuAX7cagT8E+kPy/3VOwOGRw9ZmBh925feyNKb2ot08O4WOXiR+WD7c/FRjG/XqcDrU7cJxXFu+GthjX9gV3Vufz6sKgBnfyWBW/ZZ8oTofaHTjOc/V55wsu+z5OruM31VjEFVxp/qLywW2aiG3cVJReN8YXXs0RRb3lNNwceINHh3I/6nMqiW060grs2zbVOMSSGvdxvavjy5Xfy/Wu/N6S4CHLt/2XgJfhLCkdKVGeK6yE6z1OaqxaoTwVgKjCAtKOxY0TTi8izijS4STmV6mAtDQ/wRUuwv6cGsvGiduQwX8u+Q3sg8s2NOooX9lRPiXXw21dvn+U/MawX8hBT+kU66JqU5aHbYrrSAX/uspg8F9Ofvno6Dht/THm1UbMx6XAB/J6lv92d7nVMeYIz2PKfo4xZxui+lDVHlnPRgQ84mM9+1ryG8vmWaVu/lDnx4l3LLsrNIltF+rWGPD8B8lz4Dn6LZtz4X4J9aBov2SyKNovcVgY5qm5d2Untj+8T7dbnBPhdotttCzgud1mtXPzH6ej3rpk/cY2M0Z5SJf7ZjWH4brSANtM2vi8IsoQf/evAB/WI9p3/Jbtu8F/B3j54+RZ+USsX8ouMS9RpO2ea+yQZw48sM+de0w6CJuT1JgssD+1cf2rmn9V9RyHie+JeusM+duwP/C9hRfk8dGVH+6yhVvhoyPtrI0eXMeqHXM7R/i/SX7jfLtG1jV+KRF/UeSuQ1edo3yNV9ecu6qXEj2PO+govlz2X/GFPgBvLRmn/11lcOmd8se3sQ+eV30wlp37YJcvHCeuA7UtRfnH0wSPMlftkn1TpOvaKuJql+i3Wntx9V9oZ3l9QrVP7KMv5NDnK0ud8l4NunUWVtCL4Z7pgCul/J7FId4Nt7vfDXro841gm+M0iKHP+5OPBjH02XRnEK7tuCJ5Ps9Dr5s7odfuZP3IoXY3/ijq7dux78Jv1Hrr4SRvNILtVlFnfZ5j30LUO/enPuW2T/DP88yXJP/HfsKNyfORY6snWq9vHTv1/De8oSuI9Wxgq0WyRpR4JbtE/2dFpZ4Pm7ksKH+7IwmWkufz3PItbpXlC2SZGoFXAKXlUyulZYLjb+J8l3XcqqPGAsmpHnhGai7PyATp9xupirTGo6A67Ixwd0Wy+JyBVLi2s05R1linZ2HanbwhyhuGvBHKQy8eV8lnAI7bIHs22FfZqm6M49mA7znJc2DvZXE7vRceNUeRHm2azLdrM/2zkv8HeTP9geR5Iup4hXOAL62NoB/HqxNqRiZwe64brypyTEXfxx6vHV168tTxE63bjh0+01o9ferI8WM3L6++thVRwsaHijkUpXfMWFCFowzfq3Q+OMWLyf/b7RRfkzzvOMXONBfYGWuEPsdNOcXK4JgO2zIWPhtPBnMrwNwKMHHa7LSC6rRvoTwVRonDcjxr+ULu0K3jMYMcG+eZ5PnY8VNH1h85fOyNp1unW2t3nl45emT1ltPHVs8Z6qNHI0rsdJfof56oYJs8LPBwwu9KUIZBt9VXJ/9vt63G7T9xwjPEQ9jqS8Pgr6oQqMvg+VIqJ+reQU88GD7Tg0rUm3j5aMOJJP5K/vmrRZTUMpKlfcnvpfDushReOVTsoB9+64Y/0CmCUmdwyXuC8qzulD0qpfyvJlvTYEsOvJMiz3BaXSG/Vg7rv/BUPsPrU5a4jBwA/4b9CDUJoXSBz++OIt1m2A9gm+qZ1+WNQTfwUCaazCPCKP3lxYBhel/OAav0F8OMmD/+jkNq+B1P5EQCfmOgnvxWUnBheBHCc/h2qDrcJ3gy3v9/nuoJ/kOIJgA=",
      "debug_symbols": "7L3Bki29bp35LnesQYIkQMCv0gOHui07FKGQHLbcE4XfvTORBBar6haLtXceR3TEP9H5/qtz1srMTSCTJEj+x9/+yz/93//rv/3nf/7X//pv//Nv/+n/+o+//d//45//5V/++b/953/5t//nH//9n//tX8//9T/+dlz/h4r+7T/RP5x/2v1nPcafNP4s4886/mzjTx5/yvizjz+HXh16bei1odeGXht6bei1odeGXht6bei1ocdDj4ceDz0eejz0eOjx0OOhx0OPh54MPRl6MvRk6MnQk6EnQ0+Gngw9GXp96PWh14deH3p96PWh14deH3p96PWhp0NPh54OPR16OvR06OnQ06GnQ0+Hnp165fqTxp9l/FnHn238yePPU4+vP0+9fv2p40/zP8txjD9p/FnGn3X82cafPP6U8Wcff17XVy6wAXQEUEAJqAEtgAMkoAeEMoVyCeUSyiWUSyiXUC6hXEK5hHIJ5RLKNZRrKNdQrqFcQ7mGsscOX9ADNMAGePw4UEAJqAEtgANCuYVyC+UWyhzKHMocyhzKHMocyhzKHMocyhzKEsoSyhLKEsoSyhLKEsoSyhLKEso9lHso91DuodxDuYdyD+Ueyj2UeyhrKGsoayhrKGsoayhrKGsoayhrKFsoWyhbKFsoWyhbKF9xR3pBD9AAu6FesXcDBZSAGtACOEACeoAGhPIVg6VcQAEloAa0AA6QgB6gATaghHIJ5RLKJZSvGCx8AQdIQA/QABtwxeANFFACakAo11CuoVxD+YrBYhfYgCsGb6CAElADWgAHSEAPCOUWyhzKHMocyhzKHMocyhzKHMocyhzKEsoSyhLKEsoSyhLKEsoSyhLKEso9lHso91DuodxDuYdyD+Ueyj2UeyhrKGsoayhrKGsoayhrKGsoayhrKFsoWyhbKFsoWyhbKFsoWyhbKNtQbscRQAEloAa0AA6QgB6gAaFMoUyhTKFMoUyhTKFMoUyhTKFMoVxCuYRyCeUSyiWUSyiXUC6hXEK5hHIN5RrKNZRrKNdQrqFcQ7mGcsRgixhsEYPtisFKF5SAGtACOEACeoAG2IArBm8IZQ5lDmUOZQ5lDmUOZQ5lDmUJZQllCWUJZQllCWUJZQllCWUJ5R7KPZR7KPdQ7qHcQ7mHcg/lHso9lDWUNZQ1lDWUNZQ1lDWUNZQ1lDWULZQtlC2ULZQtlC2ULZQtlC2UbSjzcQRQQAmoAS2AAySgB2hAKFMoUyhTKFMoUyhTKFMoUyhTKFMol1AuoVxCuYRyCeUSyiWUSyiXUC6hXEO5hnIN5RrKNZRrKNdQrqFcQ7mGcgvliEGOGOSIQY4Y5IhBjhjkiEGOGOSIQY4Y5IhBjhjkiEGOGOSIQY4Y5IhBjhjkiEGOGOSIQY4Y5IhBjhjkiEGOGOSIQfYY5AtsgMegAwWUgBrQAjhAAnpAKPdQ1lDWUL5isB0X1IAWwAES0AM0wAZcMXgDBYSyhbKFsoXyFYPteghXDN6gAXaDXDF4AwWUgBrQAjhAAnqABoTyFYOtXUABJeBSlgtaAAdIQA/QABtwxeANFFACQrmEcgnlEspXDDa7QANswBWDN1BACagBLYADJCCUayjXUG6hfMUgHxeUgBrQAjhAAnqABtiAKwZvCGUOZQ5lDmUOZQ5lDmUOZQ5lCWUJZQllCWUJZQllCWUJZQllCeUeyj2Ueyj3UO6h3EO5h3IP5R7KPZQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lC2ULZQtlC2ULZQtlC2ULZQtlG0o9+MIoIASUANaAAdIQA/QgFCmUKZQplCmUKZQplCmUKZQplCmUC6hXEK5hHIJ5RLKJZRLKJdQLqFcQrmGcg3lGso1lGsoXzHI5QIJ6AEaYAOuGLyBAkpADWgBodxCuYVyC+UWyhzKHMocyhzKHMocyhzKHMocyhzKEsoSyhLKEsoSyhLKEsoSyhLKEso9lHso91DuodxDuYdyD+Ueyj2UeyhrKGsoayhrKGsoayhrKGsoayhrKFsoWyhbKFsoWyhbKFsoWyhbKNtQ1uMIoIASUANaAAdIQA/QgFCmUKZQplCmUKZQplCmUKZQplCmUC6hXEK5hHIJ5RLKJZRLKJdQLqFcQrmGcg3lGso1lGsoRwxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMmscgX0ABJaAGtAAOkIAeoAE2gEKZQplCmULZY1Au4AAJ6AEaYAM8Bh0ooATUgFAuoVxCuYRyCeUSyjWUayjXUK6hXEO5hnIN5RrKNZRrKLdQbqHcQrmFcgvlFsotlFsot1BuocyhzKHMocyhzKHMocyhzKHMocyhLKEsoSyhLKEsoSyhLKEsoSyhLKHcQ7mHcg/lKwbluKAFcIAE9AANsAFXDN5AASUglDWUrxiUeoEE9AANsAFXDN5AASWgBrSAULZQtlC2ULahTMdxJFFSSapJLYmTJKknaVJ6UHpQelB6UHpQelB6UHpQelB6UHqU9CjpUdKjpEdJj5IeJT1KepT0KOlR06OmR02Pmh41PWp61PSo6VHTo6ZHS4+WHi09Wnq09Gjp0dKjpUdLj5YenB6cHpwenB6cHpwenB6cHpwenB6SHpIekh6SHpIekh6SHpIekh6SHj09enr09Ojp0dOjp0dPj54ePT16emh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh6ZJxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4zzknFeMs5LxnnJOC8Z5yXjvGScl4xzrxASucjj/CZKKkk1qSVxkiT1JE1KD0kPSQ9JD49zdWpJnCRJPUmTLMjj/CZKKknp0dOjp0dPj54ePT16emh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh6WHh4UdEgSipJNaklcZIk9SRNSg9KD0oPSg9KD0oPSg9KD0oPSg9Kj5IeJT1KepT0KOlR0qOkR0mPkh4lPWp61PSo6VHTo6ZHTY+aHjU9anrU9Gjp0dKjpUdLj5YeLT1aerT0aOnR0oPTg9OD04PTw+PcnDhJknqSJlmQx/lNlFSSalJ6SHpIekh6SHpIevT06OnR06OnR0+Pnh49PXp69PTo6aHpoemh6aHpoemh6aHpoemh6aHpYelh6WHpYelh6WHpYelh6WHpYeHhhUuDKKkk1aSWxEmS1JM0KT0oPSg9KD0oPSg9KD0oPSg9KD0oPUp6lPQo6VHSo6RHSY+SHiU9Snpccd6vN6KXNQ2ipKvQWZxqUkviJEnqSZpkQVecD6Kk9Gjp0dKjpUdLj5YeLT1aenB6cHpwenB6cHpwenB6cHpwenB6SHpIekh6SHpIekh6SHpIekh6SHr09Ojp0dOjp0dPj54ePT16evT06Omh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh6WHh4cVRgyipJNWklsRJktSTNCk9KD0oPSg9KD0oPSg9KD0oPSg9KD1KepT0KOlR0qOkR0mPkh4lPUp6lPSo6VHTI+OcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84545wzzjnjnDPOOeOcM84l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOJeNcMs4l41wyziXjXDLOe8Z5zzjvGec947xnnPeM855x3jPOe8Z5zzjvGec947xnnPeM855x3jPOe8Z5zzjvGec947xnnPeM855x3jPOe8a5V391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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AK1Zzn3eUvwvjnbWA\noOdByolxjeAouLZFn9usFFEKcQcvYaP4dwI17/ggN3U9p0f+TVMT8QopBPvm1zkaPd5aXhYo06aU\nm0n2f9HwZmLAEzOgphraCCke5ZOP6fv87GeFCaRdrnJ3raDtxswsLqbqFrx5DsONdAkZO092Fh9k\nm64eMkEaBlFUOzFz6AlR3JsrriSMgWt1l1QA2m3Txy9hXAtNd5cZOEtsN79AQvnbImrGib1NLxGm\n/E+Ga2zORDqAE2z4EQ49Y+bjHlbxuZOE2nCbqkCG7bxEH0ZctywqM2wMaD1i8j3HKYmcsJbqmfUz\nt8PsjE2THdAKYxJ23AiQWQ4uqH9oln37eGtnSo9yhNX/SdN3ENOb14u6FcltzZ67BXWP2F2us3N3\nj7I1bX/w7jWT4fqH4JY4JuH36e3swaMNIP55cVS3G9XzWb/udRPCumXu9CPC7cxXIEBgTdA/fRby\nW6dsbE8fhTiCjUghDDaR184AC9KGUrMUoChsPMHVJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7\nBxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTBvXnQilB4yRxfjcQTfMdGyI0Wrk\nk5klY8dKjIvMEJ/oANpXi7JrrFbFgEcrQSXytuKWUjBDi+6i4Khm6U90/PAbrrvsfUCkkXccWLvv\neUzO64SZa8Pw4c/abQGw38QQVxa2QqKe8O2WtFcX3+qKvpP40sU/OOIPS98mV3fu7e78LpTxoQlR\nPNbPRZs5oxvutL3SXwcpkld3uxn5ru4n6icmemygQ10riY+ULk2rHsX0MdVV8wMaaFz+MuOIYQe2\nPy+AUB9U/bTINowvfiiv7qVku3sUlO3UcT2UKDTTWP7oBfEKM1zSufGhlZyAqS0rovTge6o04pN1\n9rB997uQn2Ikdx8KVfC2p0qR+NqAkjyTVbVR/dQhgk2OuYF7rg+zUQ7wHtbiniO50k8ib7h1OP4a\ng1Obu0HOMarZLCWvC+5YFpo643S10TVsrhs3/lllLhWQGMGMROjC/TFH8JoLYtApQEYEi3rr4uxY\nCnnMP+nM60vw01JDHWLQQbr7ra5h5h5gPDx5sh87DHpKFewINmdBJiTR38hO85MguGXBXmsjAbKp\n0xSUu5XDelbW0Mi3VkNTxXhf/21T+wdP2e8SoB8hWvdvFc6v5ZO1kUJdAzFE/reFbFdLXAdLIMvo\nG/uoVA4SpCK+lNeEx8tuYkdvUVCaiHnd1FiwM+GBJ3D5/x+iB+iF7gd5ydxnoYqH1eNxNHSBteJy\ntawju1xUJUGK87YsDK7Ic73GFuXpq6OhrNcoWck6qiW2YWK52u4d+YasZAyhGUz0YgvE9YopRuTM\nr2fEGPc/UH5wZT46HKpt4pMZHcMPxc6TvsmhNoYYy60eWvPd1EgB7PwCRVkkHgjUH74WnI1lp22Q\nzA6h6lqxnm/QoOQDz5cMBeaeL8dadiquECtZwieOzDow2MrFJ9BbJ28aMqH47pcSdnUJq9wLmMVH\nAqqsSRpHrx7zV1A/FH5d6QE6A1Wdehu8x7+ewRauwRMGxUFCzNpV0BsR2IHpL4JlXecjtUap9Nq9\nM2m5FdnOzwuaTeecKN9RI4WGOtXraiLm3CMjW0qhNmrEvlcu0morCOB8kVLP+ugyC1vdCqdHRE8B\n+x91x6CI40Ns4xZ9quMjLVDNwHJf7FMU6hUk898l9vhSt/9d6wu+VPhuanmrfigdNNrM1rB2Il/+\nHmnfA4VlAC29lw5AwRVk5xoIoMEVB2Rb5wgRC2ZQzOq6BA1B3umKnuB45D7RkFLexQZBkLYhU/97\nioBAYk0IQqs3WDAbMLI5iWdu02VDINYJZ3ETeAtaDT7C5fKzBDrVkn917iJOe4uwdsAdnRXmldtJ\nYoR5L0k+SqJepx+Q/5V+KqqeomSYTxXLfqssT2ml2Ailb00MDfwyFqfkTkJc7/GGGfQrfw/rg2SO\nEbH+DYvGtgxvIQt+Bww1reRIgasMq+ppQb4/zeTE4IFhvnl5SCKu+7P2F0xNqsxv6+gtiDGpBETv\nEX32GkvxinRGtU2OzdDlJyENPQ9wXJw7Qm4veGR5CujPFMTyBusHozGX/1z2u6wLrwcDm+cLVXtv\nDU1Z+xKAoZlYPQqQ5tVT5L1kSbWO9QehChGFSw0wrqddreiukl/tbL8F77PitlsEvecaM00v6zMA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACMFiRYqEcw0aq7EfWmfz45212mv+2xUC3KplIDSsMilUi+eCGedPrvKviojeNDFHDXDfh\n9HMc3m5NRFY2qRlnwQDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0T/DBF7F3IrJuupLmeobqEaLN+EOCE3rvz8G891XJ5kBMevpRD\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACDScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHABAnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjYtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI2LQIAAC0LBgELIgABgEQAByQCAAcAAAGeJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2QtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB7yUAAAR3LwoAAwABHgIAAgEKKgECAyQCAAMAAAIMJQAABIkmKACABAR4AA0AAACABIADJACAAwAAAjUqAQABBfeh86+lrdTKPAQCASYlAAACDS0LBAYLIgAGgEQAByQCAAcAAAJYJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAvAjAAACcS0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAApslAAAEmy4CAAeAAygAgAQEAAQlAAAErS4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAALbJQAABTstDgoBLQ4IAi0OBQMtDgkEIwAAA2MnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADZC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABK0uCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAANjJiUAAAINLgiARQAFIwAAA3QNIgAFgEMABiQCAAYAAAPkIwAAA4ktCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAAA/ojAAAEZi0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABK0uCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEZgEiAAWARgAGLQoGBSMAAAN0KgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVeEKDJz12ECzwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAEyCMAAATTLgCAA4AFIwAABTouAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFJi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAE9SgBgAUEAAEDAIAGAAKABiMAAAU6JioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "tZjRais5DIbfJde9sGRLts6rHEpJ2/QQCGnJaReW0ndfyZacZmEGzix70/+zx/5HtjWaaT53z4fHj18Px/PL6+/dj5+fu8fL8XQ6/no4vT7t34+vZ+393CX7AynvftQ71TYU0LUORW+jt7O3Mw8tyZVcZSgVV/VtqlWGtuzq/eJtGW1M2bUOBXDloZhcyXX4Yi6u6sOqBV3rUAJXGsrJtbj6vJpdZWjzdvProuPFVLrmVFzbUNu/rjzU4u3q49DH5ezq7eLzLF5Ti7crufr92Oexj6s+rvr9mrebzgMw0ImAClIHlEQOkAI0OMgG4oA5oDpkCKCAGFxieokeiulk04sCU4CN0cwotTg0dJAUoINRA6OkN0Uy0OWh7j9ZPgwQB9sBrAY2S3OA7Mw6CATwAE4pQO+OulFsiZSTgTjY0QyoDgUCYoyldwfGABusG86WQR1aCiAHi2cAD6gJAmyMLrlCDmgOyA52BANisB1BhxKzyOLJBtWBIYACxKGH2iEGt5jeokdiusR08enNntVcDMTBsr4DQkB1sMLRwSrGAN/DVpoDYUD0NBujCSB9f9hAHPpGdWgOVqssE8Ru2iFDADuU6CnRQ9FD0cPRw+ETOSY9xzqIQ0+2DjFYYnA/ZbLiammXe5ntwXayaC1spRqUZ58FPKjvV+tEQTT7eiJKJwmyGuE0nWsO6mk5iIL6IQ+K+0KCSTRJgmL3ob8pBvVE5a+vu128aB7eL4eDvWe+vXn0ffS2vxzO77sf54/T6W731/700Qf9ftufu77vL3pVz/9wflZVw5fj6WD0dXednZanNraq0Wc3LjwN6NYBlh30BVfcAbQ+TgcgurHAFQtid8CE0yBDuzHIywa1FnGHWuW6Cmy3yyjLFpnQHQp8M0i3BrRsgCAQq8Akixa8bEEYq6CcNhlIdQMG2rQIbBEC5m9n8ScWFeZp1pVlQPp/PYA5ngvg2rZ5aOEPjyq4zUMLcXho4V32WLEo81T0c5EXHzFYORbWN2g8Ish5esjtQwYr2aUvyPmQXfcTuGwqNpwWi01b2Qr9fo6tgJoWowBZWUfLkRm1EUwPvg0D09pWzEe1MrdFC1hdiczkAkJeMlnb0EotNrTWxeqNK6WT9DUXRSe15ZWslE7dw3ms3wvXn6yjlOs62tI61p6yhFG/9WW+XPvWLGCmhZ5N22bBMwpo26LIs4YrbouCMF3LRd1mwdeK02TbQq51T/+Z22Yx0wIybVpILXEgtfAWA5n1RmjTIiTFeQpui2DmlH5U/8cl/NvgXpv7p+Pl5gePL7O6HPePp4M3Xz7OT9+uvv/9FlfiB5O3y+vT4fnjcjCn668m+ucn6pc9Et/bR7M29ev8Tj+PrQl2lapelfsvC+Yf",
      "brillig_names": [
        "slash"
      ]
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ul+BNVBaASKFQCIHaCzAIoLqIo5VKrFxmWBMnWQslaKMmyZFVVZkIUKS4ACJKiCPxCAYS4g5RIyS1bdnuX97W9yJLttk9Pn1m6j3vaHs/4dI/taXu6e7rHM6e7Z46nt8En/su8efP9+P9nvqhKEhXnAPXzR8R9L168ePFi+RGFoBMK8d/RYIAgIPfcdPXvePx7E8SPXPl3LP5dGSxUx4muJf58ZWF+XCmfIf/18Riz4Ae/Ivie5F/ZEuN8OezgY1mE7tYr/7bB80NBRz98lV/qz2f5dzvKLLrz1jBohw7dan1+tl6bn63VGs3KYmN2rrVQn6vUl2bqC8tL1Up9pjbfmFusVyrNenN5utKYXZhpNBcXZuqtpcWFWcF+m4pdby5dgZpZnJ1fqrYWZ1uVpem5+fpia26usdhYmG7OzVQa1eXZ6nKt2pqfX5yZWVyeWahWW82FmdZ8G/t46EVmNcF/ux/8tk14hxf8+ozgfxfgjwa2bTYK3+0Hvy2fd/rBb9fvu2L8wINs3h36qNtqG/89XvAr04J/px/8uuC/F/ALHnTnfX7w2/x/jx/8tm6+34/8W4L/gRg/AOzqfL1Wm6svzF3plxqV6nRjuTZ/xfovTVeWK4vLtebCdHWhNV2bri83lpfmp+cXq61Ka3F5oTV/FVywP+iF93pbNz/kRfb1dr9ylyKbymChbZM/nIzdt/gF+yMKdm2xvlxZaFUWZ+YX55rzM1e668qVh6X5Zmu2trh0peOuNarVanP6yn+1ZmN6YakxW12abc7VZpaukGvX6UdDH3VaXRb87zXGn12sLDRnZ+cE/2PG+EtLs3OLV+Qp+N9njF9fnm226nNte/BxY/zFmelWa6a+KPifMMafqVaaM7W5tm5+vzH+wlJlZnZ+vq0/nzTGv+J31hsLi0uCv2gtn6VmZblRXZiIcZZifKERBaG9bEw7DgsFohfE+PxO6BeJV2u/uED0kB+Uj4xfRHaNsJfXkhKHNobjRpR3QkfD+pgh1vcZYn3cEOsThljfb4j1SUMsadd+29p0ux9teMGvt+eBml7wK03Bb/nAr3Z8xxOAH9jx38b/FOAXPODf7Uf+bfxP+5FPe9x0T4zvA/teP7Jp+2Cf8YPfHhfc5we/7aPe7we/bRse8IO/IPgP+sFv+6gn/eC3fbxTfvDbPuppP/gNwX/IC361LZ8zgG9nO2tt2/awF/x6G/8RP/ht+/aoF/zpNv5n/eC351Ue84Pfts+f84Pfts+P+8Fv+z5nveDPtMfI57zgz7b1J/SD356jWPGD355zPe8Hv63/q37w2/p/wQ9+W/8v+sFv+ydP+MFv+yeX/OC3/ZPP+8Fv949P+sFv+w9P+cFv+w9P+8Fv289n/OC37eezXvDn2v7Dc37w2/bzeT/4bft52Q9+236+4Ae/bT9f9IPftp9f8IPftm9f9IPftm8v+cFv27eX/eC37c+XYvygf+w6v4j29ET7ef5m11W87Vf+7YixTzRPv+Xe+5fvufOhzyw1T+KMt5QwgL/yPBL0hgh1Vwf1rfffd/rk4vLp72w0TjZPnWKETQpykIBaBNRPLd5933c3kvjJiXZX8+Spu++/j9FGM6LJvqUxSG/oE1cmYrzNxB/S3kJSsKFdbWg1z1JG+kXi1Xh8Xy0QPeGH5YPrIlHcVoXXkhLHdbhVobNVoVNS4tiHHgTrOUOsC4ZYzxhiWZbxKUOsS4ZYTxtiXTTEOmOIZSl7yzb0/JBinTPEstQJS9lb6td5QyzLtm2pEyuGWJY2+kVDrGHtH2Vs4te3qsxPKLQlSBx+M4E+FQf2xJHvCP8/7OrgcjoJkVc8GT+3mqeXP/XBxRMnmo1333/iVODIFgXZNs/vh02E7BYWM5QhCNLFO767g8vpmB+sxnGK26LkLShY2kCHVRplvjmBB8SQukJ32HAoUc9SDqS/VkMJzVRoQwmRz7gf+dQKhI/8jCvyYR3muov+yWc8Y4CF6fGTL0yPz5If3/1p/LcU9LYj+ZSgoMSNKO9EvpHM/wmVDeuG9dRPPUxXs+qp0C8GPttNR081vdC6tPGgt54tt29lqVfNtm1T4gRre/wb9RTTF6GMmB6fJT++++v4byno1WnW021KefAd6umfx8/jCeU5Fv+uDBTm5rR+itsByslyO3rWdiD0i4FPveu0A62eNHsistuu8FpS4njqZ7tCZ7tCp6TEsTs6CNYzhlgrhlirhljPDynWJUOspw2xLhpinTHEetIQy1Lvh1Fern4wL1YULHX1siHWE4ZYlrpqWcZzhljD2rZfMsR62BBLlmLZzxT8KIwHvW3PeuyG9KQc+A7pF4lXW346vpImV82nFflM+JFPm58JhZ8JRT5SlzuUOMGSqSocM2D6CSgjpsdnyY/vKnGFlQgzCjxm2KGUB9/hmOH1he6yYd2wnvqsB6QnfOM7pF8MfLabilMvtPY/HvTWs6F8KlnqFfmVupxU4gRLPrVCPcX0O6CMmB6fJT++ezPpKeo06+mkUh58h3o6T3qKdcN66qUeqq3Meir0i4HPdtPRU00vJhQ5jge99Wwon0qWekV+pS5LSpxg7Yx/o55i+kkoI6bHZ8mP795Neoo6zZ+glZTy4DvU07fHuOMJ5TkW/64MFGamtbq0w5+rTijl5HaGsrbT63rmdib0i0GvXvhoZzuJnyQ9ENntUngtKXGsI7sUOrsUOiUljsc1g2CtGmKdMcRaMcR60hDrnCHWJUOspwyxLHXivCHWWUOs542wNPs8CF/PGfEVhcuGWJZt+yVDLEtbaNkenzbEsqzHlw2xLHXCUvZWbTswLqOlTjxjiDWsdsKSr2vBZ9ro09ZP9pbt8YIhlmUZvzCkfFn6E5ZllL5Wxoo4tizEf8eD3rZnOM5uFoielAPfIf0i8WrLT2ecrcl1pyJXkd1uhdeSEsfj7N0Knd0KnZISx33GIFirhlhnDLEsy3jJEOtpQ6zLhliWsn/JEGujHvNhvWyIZakT5w2xnjHEsrRfzxtiWcreUlctZT+s9stSVy316ylDLMt6tNQvyzZkqV/PGWKdM8SyLOOw+nKWZbT0J4a1HofVl/uCIdaw+jmWPuaGP/HaaEOWdsKSLyv9ip55XnUQvl4w4isKlrK39AGkr+X9boIfBb9zaLXMe2x5Ds3LHqyUOTRtb9140KuHhvKpZqln5Ffq8jolTrD2xL9xTxim3w1lxPT4LPnx3bFYKCXCjALvCbtOKQ++E/lGe8K+Jf4xnlCeY/HvymBhnudDhQbSRjkZ6l2mqyqQfjHwqXeddqDVk2ZfRHZ7FF5LQa/usD7sUejsUehsYA0X1nuNsFw2TOKjMK7ks7a3SE/Kge+QfjHwaheqLrlq9lLks9ePfNp7lPcq/OxV5CN1uU+JE6z98W/sjzD9XigjpsdnyY/vGtQf7YO03Ab2KeXBd9gffWJTd9mwblhP/dRD9m8+hH4x8NluOnqq6YXW/seD3no2lE8lS70iv1KX+5U4wToQ/0Y9xfT7oIyYHp8lP747SXqKOs16ul8pD75DPb03/jEZJLfPLO0ZcTW7zTLEfNwevNR3tVnJ2h6EfjHw2T477WFfRrmKfPZ7kU+jlUV/kF+pywNKnGAdjH9je8D0+6GMmB6fJT++W6X2gG2H28MBpTz4DtvD42S3sW5YT73UQ6XSyqqnQr8Y+LSTHT3V9ELr/8aD3no25KeZpV6RX6nLg0qcYB2Kf6OeYvoDUEZMj8+SH9+9QHqKOs3f6h1UyoPvUE+fpvEul+dY/LsyUGhWtbq0w19sX31/0At+bWFcqS87/KX21fXX+8GfFfzDXvDn2/V7gxf8mbZ8bvSD3xD8sh/9afM/5QW/Xhf8I17wm23+j3rBn27j3+QFf6ndfl/nBX+hrf83+5FPu35v8YLfmhH8W/3Ip83/bX74b9v/2wHfci5C8O/wgl+pizzeEHTCiFImoS++yOshfSHhr2BxnNAqEpYvv08rG/LP4743AD8ogySsN+TEGlfifNTp7Y5yI/0JB69cjig8HNrIJArnDbEeN8R6zghL820H4esRQ74OGPGl+b+DYB0yxBozwooCX604CF/XG/EVPR8eUqwbDLFuNMQqG2JNGWIdMcQ6aoQVhS+GdnzdZMjXs4Z8vc6Ir+j5ZkMsq74jer7FEOtWQ6zbjLCiwHOnw4Ila8h+57umF/zOd9UX/c53TTf8znfN1P3Od03P+Z3vml4WX136Q6GBulWG93bjiunM34IK/SLxastPZ3xXJn5YPrx/Z0rhtaTEcRudUuhMKXRKShzv5R0E60VDrHOGWE8aYl0yxDpviHXGEOspQ6xVQ6znhxTLUlcvGmJZyT565n57WHTVsj1eNsQa1vb4giGWZRsaVtk/YYhlaScs+1pLG20pe0t5Dat+WfomlvVoKftrwU68ZIQVPfMYdhC+HjPk65ARX5ZYUXg0tOPrekO+rGQfhbOGWJY6wXPpg2CNGWFFwUonovC4IdZnDbEs9cuSLytdHWZbuMOQL0tdtaxHS7s6rPKy1FWeWx0GXY2Cpf162RDL0v+6YIhlOadg6ZNbjhUs5x7Fv5d57BsgrhD/9bsGUOl7DeAGP/w41wBuUOSq7Yc15KeRpZ6RX6nLI0qcYB2Nf+Pefkw/BWXE9Pgs+fHdj8YVVyLMKPDe/iNKefCdyDfa2/+DI91lK0M61lM/9ZD9DlihXwy8tpuqSy/Kihw1vZC8JSWOffqs9aXVPe99GwTrGUOsFUOsVUOs54cU65Ih1tOGWBcNsc4YYj1riGXZhizr8UVDrHOGWJcNsSzbtqV+WbYhS7t6Lcj+KUMsSxsttlD7jsrQ/6ho3zkZ4re/OTjqkAXS5704Eq/9FSyOE1pFwjIuW9VVNuSf6xn9cJRBEtbRnFjat3E+6vSIo9xI3++3gDM1v98Czsz6/RZwuiU6/zqQZ4Fkd4uXupzPfJaK0C8Sr77a1C3ED8uHx0O3KryWlDjeu3erQudWhU5JieN+exCsFw2xzhliPWmIdckQ67wh1hlDrGcNsZ4zxLKU/bDq6mVDrFVDLEv9srQ5zxhiXQuyf8oQy7KMzw8plmXbvmiIZSX76Jn35Q6Lrg6rD2CJtdFvb/Tbr5a+Y6Pf3ui3N/rt16bsh1VXXzDEspSXpc2xlP0ThliWbciy3x5WGz2s/oRlGS19X8t6tJT9tWAnXjLCip55f84gWEcMsazmyaPno0ZYUeC9x4PwtcOQr8eM+IrCWUOsx42womde/9qQvbuM/O3EIFiHDLGuN8KKgqW8bjbiy1JXo2DZhoZV74e1jK91W2jJVxQ2+o5Xf98Rhc8ZYUXPlnserOQVPR825OuzhnxZ9bVRsOwfLeU1jH1HFF42xLIc810wxLJc07GcB7Ccn7Dcn8Pft+HesEL8VzsvPqJzLP5dGSw0CkRPyoHvkH6ReDXmp+qS6y2KXLXz7g35WS4QPvJzmyIfqcvblTjBknMy8fs2TH8blBHT47Pkx3f/dfTq3xJhRoG/b9POSsd3It/o+7a/He0uG9YN66mfeqhl/r5N6BcDr+2m6tILrf1reiF5tfrifj9rfWlYlwyxnjfEWjHEesYQ60VDrFVDrOeGlK/zhlhnDLFeMsR62BDrZUMsS3k9bYhl2R4vG2JZ6r2lLbSsxwuGWJY2x1InnjLEspT9uSHl61lDLEudsPRNLPtty3ocVvtlqV+W7XFYbbQllqV+XTTEEtnLeAXHN4X4r+c74KYLRE/Kge+QfpF4teWnM9bT5HqbItc894tFz5Z3Nlnd4xWFZwyxVgyxVg2xnh9SrEuGWE8bYl00xDpjiGV1N1IUzhliWbbHy4ZYlvplKa8nDbEs9cuyDVnaVUudsLSrw9q2LdujZRt60RDLsj1eC/r1lCGWpQ8gfe1kHIf+9hQ8YxzScfn8mF/STSj5CvFfv3f4LmQ+r0PoFxWZ+PD535BRriK7OxReS0oc7125Q6Fzh0KnpMRx3zQI1ouGWOcMsZ40xLpkiHXeEOuMIdazhljPGWJZyn5YdfWyIdaqIZalflnanGcMsa4F2T9liGVZxueHFMuybV80xLKSffTM53UMi64Oqw9giTWs/bal7C19AEsbbelPDKuubvTb69enbfjk+bA2fPL1068Nv3D99OuiIdawyn5YdfUFQyxLeVnaHEvZP2GIZdmGLPuOYbXRw9qnWZbR0ve1rEdL2V8LduIlI6zomfc4DcLXo4Z8HTHiK3reYYhluT5kKa/DhnydNeIrCo8bYUXP/E3/MOhEFPjb5mGQvWXbtm6PVm0oej5qhBUFy/Z4LegXnzc0CNYhQ6zrjbCiYCmvm434srSFUbC00cOq98Naxtd6X2vJVxQ2fJNXf98Rhc8ZYVn6E1Gwklf0bOmTf9aQL6u+NgqW/aOlvIax74jCy4ZYlnMKFwyxLNetLOeZnjTEstxfKHNWE0G3/Rf8KMg+X7R1EZ1j8e/KYCHzOS5Cvxj09lWG/LT3+e4PeuW6Q5GryOeAH36WCoSP/BxQ5CN1eVCJEyyxw3jeEKY/AGVku30I+Bijd3+2+erfEmFGgc8bOqiUB9+JfCPIP97cXTasG9ZTP/VQzXwultAvBl7bTdWlF/sVOWp6IXlLShzP4WStL63ueW/CIFjPGGKtGGKtGmI9P6RYlwyxnjbEumiIdcYQ61lDLMs2ZFmPLxpinTPEumyIZdm2LfXLki/LerTky9JOWOqEZT0+ZYhlae/FropvxT7Bsfh3ZaAwMyO+CfoyhaCbNvomhn7dfIHoiZzwHdIvEq+2/HT8Oq3eUD7s1x1SeC0pcVyHhxQ6hxQ6JSWO2+YgWJ83xLLk6xkjrOh5PLDBsi7jGUOspwyxnjfEumiIZSmvy4ZYXzTEetYQa9UQy1L2lwyxzhtiWZbxJUOshw2xZD6afYsoHIv/XukO6/Oz9dr8bK3WaFYWG7NzrYX6XKW+NFNfWF6qVuoztfnG3GK9UmnWm8vTlcbswkyjubgwU28tLS7M+fUdZhbGg14bb+ibVAX/ej/4NcE/7Ae/LvhH/OBPC/5RP/gzgn+TH/xZv2doVNv6f4cf/HnBf6Mf/Hb7epMf/EXBr/jBbwh+1Q9+U/BrfvBbgl/3gl+rCP60H/y2/Zzxg9+2n7N+8Nv2c84Pftt+zvvBb9vPBT/4bfv5LX7w2/bzW/3gt+3nt/nBb9vPb/eD37afb/aDvyT43+EHf1nwj/nBb9v/7/SD37b/b/GD37b/b/WCX2/b/7f5wW/b/+N+8Nv2/+1+8Nv2/x1+8Nv287v84Lft53f7wW/bt3f6wW/bt3f5wW/bt3f7wW/bt/f4wW/btzv94Lft23v94Lft2/u84E+37c/3+MFv25/3+8Fv258P+MFv+58f9IPf9j8/5Ae/bT/v8oPftp8f9oPf9j8/4ge/bZ8/6ge/bZ+/1w9+2z5/zA9+2z5/nx/8tn3+uB/8tn3+hB/8tn3+fi/4M23/85N+8Nv2f9EPftv+L/nBb9v/ZT/4bfvf8IPftv9NP/ht+9/yg9+2/yf84Lft/6eCTuhg15tLV5ZaZhZn55eqrcXZVmVpem6+vtiam2ssNhamm3MzlUZ1eba6XKu25ucXZ2YWl2cWqtVWc2GmNd/m/W4Ve5DQWRf5tA+5VFttu3AP4BfM+J9v49/rBb/Sblef8SKfRtsu36fUbW26Mbu0WJlrzS0uzreudKK1xpU/s1e0pjVTW1yoLy9e0aLGUnNxqb68UFtu1Br15vwVW9OsL8w2m50+635rvalW2nJ/wIvcO+shD5rLff6V/6Nt8F/ZchVrEvgXWluoXLKPaQye7w6700g8pv+j4tW/Eb0fjkEnKE8Az+OU39ZOVRcKRC8gWgHRLyqy8bFHa4T4YfnwHq1RhdcSxUWB1+xHFTqjCh0N62VDrDOGWM8aYq0aYj1tiHXeEOuSIZZlGS8aYg2rfp0zxHrOEOuyIZalflnK60lDLEv9smxDzxhiWeqEpV2VvZzjgd4XHot/VwYKswvS1+K4Q4LE4biB++h7IP3bwk46DiP0G8u09cq/A7s7uJyO+UFf5tOAr8lJgrYn39LHEfwtfvDrolObg26Zcpm2JMhK4rW/QaD7h0KrGPTK3Yd/qJUN+ef2shn44X36GtbmnFjjSpyPOh1zlBvpTzh41coxSjLR7FFBkYm83+LgC9NPKrQlr8hwK8QZyrDmkiG2RaG/HZ4bzaWHTrz7/hMBhRGSg8htP6V7e9iRA+vg5gSsgH7zt9kjgIfB75hxffsBeZe3H0Bb9WmK69fuRYFtg1aHUf3+Z8fcQpIOZZ1bkPSbtnboFeLnbUBzm4PmdorD9FF4O9GfgLKNKGm2EY+SfkvMV/Tntrj+NNkJP+OU/7Wky1KmvLqM9Yi8ISaeP4F1m1Qvu6Fe3rC7wzPT2x4kl0N+f0qhJ7yXKG0UpI53wnvDOa7M9x0K/SLxatwPtX2YncQPy0d0bTvI8d77FxtvXXzg1EP3NjeRKCfhGeFLBCdpMC2GErCE6Tk/q+q7w958HESUY8TzrWC6DsfPk0Fv0+dj1JCHEeUdm+cdCv/a9OuJsDsO3aF3UdyYI26zI26LUi6J2wr57qZ8RQUzonPf1g4eyjYKmnqJudbknKRLSVjHCQvz7ySsXSlYdxIW5t9FWLtTsN5DWJh/N2Fdl4J1L2Fh/usIa08K1mcIC/PvIay9KVj3ERbm30tY+1Kw7icszL+PsPanYD1AWJifj006kIL1IGFhfr6O7WAK1knCwvx8/O2hFKxThIX5+Ui+61OwThMW5ufjbw+nYDUJC/NL3gkFi7vkG+C9YReY+WgyoV8kXn11yTcEvXJF+bD7d6PCa0mJY7t1o0LnRoWOhrXbEOs6Q6w9hlh7DbH2GWLtN8Q6YIh10BDrkCEW2620/vr94dW/rv5a8qHuYroRSKP10YiR5A/glFeaX/Bu4lmjqfmYnw6743AKjn1TnC6apDicSttJcehjst3HabZdFFeEOCkP+phjVJ4H4/d+h+uVCtZXkqxQxoWEv0GQbToH87HtnzCkg1h3hd10Jg3poF/O5SkZ0kGst4XddHYpdERvuA0ei39XBgutLOVA+sVAtyvHbPipiiz2OGSx1wvt6czTIXtJFns8yULamTaeQF3hJQdtzLBHSY/TJyeap69M4r/l0Q8unsAVCzSdzA6f3Lubfl+XwNYxSreXfotbwnwgFgbmg6dnOP2xlPT4PKq8j4I23GJXVqs27ZTUkpJ/v4POngHp7FHoeD5RuOr31JLOKqDrBDOk7zrVN6sZ4NPZfJ+6q5XNVc/aqbsurCwn9CGW35NuOnXqOm0Y6ec9bRhXk9DOXRcfmRa5dV/d2o3N9gHl4Gd3SX02qz4K/bXaiZp1JVxz1SVvieKiwLdlaKvSYwodDesZQ6wXDLGeNsQ6b4h1xhDLsoyW9WhZxhVDLMsyPmWI9awh1pOGWKuGWJcNsS4ZYlnqhGV7tGxDljphKa+LhljPG2JZyv6CIZal7J8zxLKUl6UtPGeIZSmvYbWFlvKytDnXgs9kqROW/baV7KPn8cAGKwqWem8p+ycMsSz13rKMlnbC0gewlNdLhlhZvtYsKFjyXtvhrs1LXSs73GconcUO9xl6NxLoO9xxRzXPhwWQ3u98bL1WIHpcxoDoF4lX4/pvz1lp25a0eU+R3fUKryUljm+71rY0Xa/QKSlx3G8PgvWUIdazhlhPGmKtGmJdNsS6ZIhlqRNPG2KdMcSy1AlLeV00xLKU1wVDLEt5vWCIZamr5w2xroV6fM4Qy1Jelv3QOUMsS3kNaz9kKS9Le2+pX5Y2x7I9WuqEpc9kJfvomedghkXvLWX/hCGWpd5bltHSTlw0xLKU10uGWDIHo33iknSTOtJx3YCF+Q9lwNLGw5Je+wzENdeDn6VIXpl7wO3wPuZ6tPrAz3aEfj9zPSK3KqXjuR60bYcTsAL6XaV3SXM9Y/E72bd0KTaeIl9P+9HUrea8X9H1aaL2ySS+Y/3F/DsTsMaCjlzxRIDdgS6rZ2NZRfX+pt3dmGnbbaWOtbLyfsL9CfQLUM4xSvsi8FbbnUzLh1w1OjsGpLNDoTOh5Csk/BU6/I7paDxrt/yKfkRzpT803snD9TWi5JVPJLnOvgmnV/5IjKl9RpmkvwWgh/uoj4fd6cU24+kSmIb1XdL/BOjUbaTvu6nMWE6NZ8HE/Y7I84lQ5+FnyD552gus2iehpX2KxCeYap9i4TvWuy2KHDQ6twxI5xaFzoSSb9B2pPHsWkvolw5iSZv0qxv5TzVhOePpzLzvGE9W5hPEPgNxuMbFYYR+oyyifDMZTkPxu5a2djI8QHEoQ7RJHDQZiiyyynAy6JUht+2dSjm0ds/fa+Rt93scPCCdCYqbILoYh212K6UrKPy52vFWhY7fbwPy6+AeikMd3EtxqIP7KA51kPX6PojjTy/vh7gxinsA4viUOjzVeyvFnYS4vO1B6iXCvNvotDD0c+6huM0Krt9PG+v1LP0S0i8Sr7b8dNagtfavnaoostur8FqiuCh8Nuyk47gR5d0mB9YlQ6znDbFWDLGeMcR60RBr1RDruSHl67wh1hlDrJcMsR42xHrZEMtSXk8bYlm2x8uGWJZ6b2kLLevxgiGWZT1a2i9LeT1riHXOEMtSXpZtyNKfsJTXk4ZYG3Z1/eyqleyjZ16DHha9t5T9E4ZYlnpvWUZLO3HREGtY/dVHDLHEX+X5regZ11NkDgCPorNcC17Pc0ewTHzuCMqqkPBXsDiOzx3Z66dsznNHXHqAc358xOAg544I1lqdO7LPUW6kP+HgVSvHbkOZZLmdQptbylu32lG1ktdzG2vv59jtkBPSH+TbnRqlOx525MB1ty8BK6DfNXqXtJ9DO5MI16obRZ1nXKvWjv8do/Q/CGvVJ+JnbV1AjsSbDHp1rRQ/+73dJf88f4HicJ4/6SyvINDnyKVMeW8hwO+7mDfBxDrDWwjGIB7Tny52eLmprGMWABO/c5P9KpJe1iaTbqhgHiT9I8AD7yGQNKMJ5dqcgPkc6OJjRR0zUDC1cm2lcjEPW4gHSX8OynVLuYOPaeQ32td7wm7eigqtIOEdYmNejnPRTcsbPeMNFRzHusLywvxJMmVdkfSfd+jKmMIDlpfrlXngNFsTeHhG4QGPPFy+/4FH4xsjAgoobmEDf3NVchWMKThJQcQQFe+5oo4jv13qh9tQNis0NifwiHkj8YiJazTvbZ5uJghoE4EVEohtCvTAtjIADM83hmX+NpVvbhvzw4/z5jbtG27tmGLJq63J8/6mrHS2B522fur0/SeTdAH7Tk0XRhPoF5T8gQML82g3RyEdLnPeWyS3KPxrdLYOSGdrRjq7BqSzKyOdPQPS2aPQYSzNX43CctiJx/Q/C3b89WUdc1MCplyZIum1MURBKY+81+ZAditl1M422Buk00ZZcr+3LyevaXMQvHdIG8tm5fV4uLa8jubkdatCG/v+K53b3WeaJ++8/3STzRWyEdDzOL3jk865O9ucwOp2SsfboHl6iP2R6+h3UeFPC1wtGi8jQXqQJiqy+jo00TvK3bQ0E4JNVNSeh7+YVxv+atv0cWqRVfQg8K7x0Qy7yybp/77D/Gifz7hO5tY+SdE+9dFuzbme4lBOuK3+FeywF1N0YxTiDN2Y5Ug+lXKHD5bPWJhdFlFg2Wk3++DnNXzUL356dJDicLscfxKVplesr7jtTfLipwVSX49COnZPPgu/Ryg90pT0jwEdbUgkecco/Z8oQyLN5RF+xim/rc7MLYsMPxf0Bol7HGizC3wW0r817KTjoE3vSJkiWYznmN7BekTeEBNtDNZtUr38JdQLXzKJ9D4bJJdDfo8p9FiWEh8FqeOz8N6ujmcWC0RPyobvkH4x6JWtj+HWWeKH5aO5DY5LJj8Hzwj/UYKTNJgWw0eBJUzP+bnaDyr5OIgox4jn/wyzcP+GZoSx6bM7gzyMKO94dLBZ4V+js3VAOlsVOtoJ7ifC7rgRpazaRZd88eRJiOPLLE8FveWSuNMOzIccmGcccQ874h5R4l65vGh7h0c2x1rT4C8gse6S2kES1nHCwvxnCetcChZfkIn5zxFWmILFF2Ri/pCwVlKw+IJMzL9CWOdTsPiCTMx/nrBWU7D4gkzMv0pYF1Kw+IJMzH+BsC6mYPEFmZj/ImE9kYLFF2Ri/icI61IK1knCwvyXCOvzKVh8QSbm/zxhPZmCdZqwMP+ThPVUClaTsDD/U4T1dArW+wkL8z9NWM+kYPFlcpj/GcJ61oEVPfPXoJj/WcJ6LgWLh2WYX/JOKFjSD4n79Ty8t3N3qpm/ghH6ReLVlp+O+/V80CtXlA+7+pcVXktKHPZFGId0Lit0NKzPGWKdNcQ6Z4gVGmKtGGKdN8RaNcS6YIh10RDrCUOsS4ZYnzfEetIQ6ylDrKcNsZ4xxOK+zOXXR88yZeby6yUf2jOeHhqhPJgeMZLGDbiCcDaF5yPEc7/jh+j5KGH1O36Inm8irH7HD9HzGwgL87PNPZ+CdQdhYf4844fo+Y2E1e/4IXp+E2ENMn54KOzGGmT88FHC6nf8ED1Xgm6sfscP0XOVsPodP0TPNcLqd/wQPdcJq9/xQ/Q8TVj9jh+i5xnCGmT8MEtYrvHD8ylYc4SF+Z8nrMspWPOEhfkvE9YLKVgLhIX5XyCsF1OwvoWwMP+LhPWFFKxvJSzM/wXC+mIK1rcRFub/ImG9lIL17YSF+V8irJdTsN5MWJj/ZcL6UgrWdxAW5v8SYX05BesYYWH+LxPWD6RgfSdhYf4fIKy/k4L1FsLC/H+HsL6SgvVWwsL8XyGsH0zBehthYf4fJKwfSsE6TliY/4cI66spWG8nLMz/VcL6YQdWFD4YdmNh/h8mrB9JwXoHYWH+HyGsvxu4y/iOoBsL8/9dwvrRFKzvIizM/6OE9WMOrCg0wm4szP9jhPXjKXx9N/GF+X+csH4iBeudhPXjEPcThPWTKVjvIizM/5OE9VMpWO8mLMz/U4T10ylY7yEszP/ThPW1FKw7CQvzf42wfiYF672Ehfl/hrB+1oEVBdlFN6nk/1nC+rkUvt5HfGH+nyOsn0/B+h7Cwvw/T1i/kIL1fsLC/L9AWL+YgvUBwsL8v0hYv5SC9UHCwvy/RFi/nIL1IcLC/L9MWL+SgnUXYWH+XyGsX03B+jBhYf5fJaxfS8H6CGFh/l8jrF9PwfooYWH+Xyesv5eC9b2Ehfn/HmH9RgrWxwgL8/8GYf1mCtb3ERbm/03C+q0UrI8TFub/LcL67RSsTxAW5v9twvp6Ctb3Exbm/zph/U4K1icJC/P/DmF9IwVrkbAw/zcI65spWEuEhfm/SVi/m4K1TFiYX/JOKFiF+K+sP/0evLdb75muFoielAPfIf0i8WrLT2f96feCXrmifHj96fcVXktKHM85/r5C5/cVOhrWOUOs0BBrxRDrvCHWqiHWBUOsi4ZYTxhiXTLE+rwh1pOGWE8ZYj1tiPWMIdazhljPG2JdNsR6wRDrRUOsLxhifdEQ6yVDrJcNsb5kiPVlQ6wfMMT6O4ZYXzHE+kFDrB8yxPqqIdYPG2L9iCHW3zXE+lFDrB8zxPpxQ6yfMMT6SUOsnzLE+mlDrK8ZYv2MIdbPGmL9nCHWzxti/YIh1i8aYv2SIdYvG2L9iiHWrxpi/Zoh1q8bYv09Q6zfMMT6TUOs3zLE+m1DrK8bYv2OIdY3DLF4zjFtn1wjfnbtk5N8IcTxJ4YjlAfTI0bSPrwR4DlM4blJPA+yH69FWJh/hbDOp2CdICzMn3c/Ht9Co+3H076D+3TYHYfzs/wNwyjE8bd1eCPJ5ygOv4PjeenTEHeW4h6CuHMUdwbiQop7GOJWKO4RiBMZ4Xdw8n2kyOjB+P04lU1kdSz+XRkwaDeXsRyx3goJf4Oguw4lsA3AfDzf/TlDOogln2mLjqL+4glqGCd0+B3TwfyPJ2Al3RQ5CvGY/vG47rWbIrW9ySPw7u2Oskpe0Sm2a8fi35XBQlXwV/zg1132F8vEbRBll0e/kFaRsKxl5yob8s96GAI/WfaNhzmxxpU4H3V6zlFuzeZqvGrlSGqbSKeoyMTVP2v14eqfRYbYRxrKsOaSIbZFod/PqbUit0OUTuzOpiBI9HUYK6Dfh+jdSKCfWqvZtm0JfArdNDuO+SWd6wiLLHZDo6PxLHTwfAE8hfcr9K286B0e+YHftRyCeEz/z3Z1ML8aY2rf3SS1lQLQk74rClL3zF/SUTGjCfz9GPR7fILnqFLmQw6eBRN9R+T5RKjz8NPkd3nqI1W/S2hpJ5DxN6ZYFq1OWO8eU+SQJNsooJ+Cfgym/4WcfgrqN/spyJPk1cZ6LAeNjquffCwjne0D0tmu0BnUD9HoaDzzmCoKaE++TvZE9A7bFuaV7+DHKP1/B/bkmw57wvtT2HdiG8v2ROgl2RPWT0n/Bw57ovnm7w6TeRZM1FPkme2JpP+HZE/CoLvsx+LflQGDZk+EltZf8k2tefvLCUUOvvtLvuH0nCEdxJK2ovlybH9CosPvXPYnpPIktdc/2a7T1Nor6u4Ypf8CtNf/mdor6rvIXNMb7qPOKXS5zQRB7/gsCi5bdi4BK2sfJen/wtFHucYaUXCNpV1zjpgO07jm/0YcNFBv8b34xkk+DtLR/PLRBNyCwqPchuB3bD9fk7aAc5gSJG5V4VniLkD6D4SddBxG6DeWKdKVt5c7uJyO+QkhbjUBU7MX94TdaaXMmxTcFcKVuLGgV15yzha3/0JcmKj9/z/bdTzWkyjcFUf6Hb/O17l+MXD9snw4aPUrfEf1+1C5g8vpmCbW4QWKQzriA/B4DjEi2W+LiQ5rW+qnveSRZwhxvEaAdHiNQOs7UZ5jhPFG0PeJiW6eJA33F1GQ9iNtVuQ3quSPAvt+kn5nTDOSz++Xdfqu9hYEul1AOfCZjKuBzotWZkl7O+njBcpzLP5dGShMV6UeLxLPSPsJT7QLRC8I9HleoT+h8CN8F5W40QF4nanOzdVmpxszraXZ+ZmZZoHwhVd+x3OU2lkQO5X0IuvPe5F1vaEdCX0J5BqFUYh7guLGIE54jNrQH5a7+b/kif8s8kf6JSX98bCTLk9dlhQ6POYYBOtcn1i7gu42oPWFIeTjvnAF4vAc0Hcm2OUstk5sG9t9LCfbwXeQrVsl2sfi35WBQn1a80fZ1l30RDurrRP6E0Fy3RaVuEFsXWNmujrdWphZarTqzcZcqxD09gkjyju2dZrelpT0nm1FRbN1bM9GIe4ixaGtEx41W+enX6xXssgf6ZeU9GzrstZlSaHDtm4QrHN9YomtQz+I/dQQ8rGfuqKUB20dj8veQzbJz9H3+hwh21TkNwo4hl4BObF8GQffod+MeXjORtJ/CPz290/o/EkZ3qXwp+0pwnJ9eCI53YqSLhoqT8bvTzRPf+BTiyebjQ80l082T48EOntcRC4+D6cCShcFnp45Q785njGlCx4N0gOqBGJpVYfY3PV+DIY8/7h89Xmc+BVax+K/lQGDNnTkrtbPMl4t87BC6BeDXpXzsX1Em9pE+XD3GPqRTyUafvDUdxRaYa9smA/RF94GKPHaXykvv+NuImkon2YCk0zWI2Cy7p7opGcboNUFTzNnWYrHd5j+HorDpbOCA5+nQe6HdiwXlGqujpTD700/tap20w/qE7pRSfqvXd8g6UMlvbYk5NpapOkW6pLoiFbPkkdbDp8kXvMu/U8qdHy3qUkqD+oxu3h5lx41/U1bQruQ0CaTltDqEI/pL8AS2iWqT8yPcn6lXGEnbo3aTC1vm9HqwdVm0rbsiwy1JdYPhd1xWpvR5Mq6M6LwoPVzmu6MJNCJwlLYPx3OL+my+CncLx2Lf1cGCtXMforQXys/ZTSjXEU+j/uRTyWLLdLsp7acyn0K2hht+KMt94XABw8Xfzw2Kq6tC642qi3Bv7IlkIZFvv0tV3volw5iyfUwY/FvGbP8AvhqPzeRnF+uhNkMebRtD1we1CHsg36Z+iBcjnEt//MY613QB/1anz6Fz+2Eaf0IX7WjbalirG0KX9HzA/Gz1LFMxfwu1PE3Eob7UcD6+ftUP2gLtfoR2to0guRFXObxHwCPf+hoe8jjP0xIFz0/GPSmY1sUBLq/w3W4AlhaesEbo/T/fcZxg+iDXx+oqo4bsP7ZB8raH7GcMD1iiA0qUXqWYRREL/430Is/pvat2dF+23CSv5pk+z1PTy5k9VGEfjHw6TN1fBTtKkCXToQK/0thcvo0HZL00VwK2/kSYIXxM15FuELvuI9y+TRRQNvz1xM6BpZP84vkGHzEyGL78+qzVqZhaDdZ9Fqj4/KZHjOkg+2ZP/daIR6Oxb8rg4Vpkf154FPzkZF+9G8VyjBCGFr6kPhn/FVKL/lHIb1gREHaA/d7t+24+jfS8b+lvtdVxijItY8FhacRJU1IPF8IOrQ1nt9DPEv6/wJ9NW+Pl/zom+I2Mv4koM3Tjg4m31x+AfJnsaPach0uyQk/2jbti5QPlwW5zjVsXprXcC4QDpdzE7zbpWBrS9PRv2Px78qAQfBk6XYUaFxS+Bmj9JM7uvl6kmTqkln07/MKXTxmcRfR/TzRjXTon5S7MYU3HA+EgMl1EhIN5vNeipf0e6A9746fta0s2D8e2qHTxvHDEw5eLyq8Yps5E3bHS/oDIK8/Luu8Ij/I6/rNT+q+ufD4SjnDbvlo9gPT92s/tK0DKxSHfXFIdLS5QVcfI/k3J6THeQFMfwvUs4ytXPOaEb70S9q8Bc8BPAZlcPVTacvrd+zQcZM+L2uG3eWV9N8G8xyVHTrtKGAbrOWkfTyB9r/f2cGcIRlqcx+W/p9WV9cF3eXK+2kN5udPJnx8RoU0tf6Zff0w6C1P6KCD+UMqD+YTXj37s5nHrkK/qMjEx9h1JeiVq2tN57yS/nFH+lUlfaikx7Er2taA6OLYdZXeuWxxml14d067gHPHmP4fgl14L9kFba+MZjP2BDovQeCuo5KSn49D8jUu3EPledxRnrzruZh/rT4l3UN0kvTmE6Q3/X4q/TXQm0WH3vDap7bWrdVBljl4Vx2MZqRzdkA6WT8zfS3r1INGOvUl0KnTDj/vtS7n0JBOCHFSZ9xvsXwxTujwO5eftELlSdKb1R06zax6I+nPgd48kUFvtDpIOmoJ6a7V3p+1socuLM33lvShkt7lg2m6pM1Ha593im77/bwl+34SoV8kXm356fi72hzBeUV224PO3Mdi81S1Nv+25vLJRx84zZUhgCUS8ioBSvqAfnO+iKkk5cS0UcDzSFCRSpR/hd4zfhae0tKmxWuN8HxCOYMgWyPE/HnPVlyFeEz/VZhEyXIeBCoPb9R1nQdxLoH3EaUMxYR8OGmMcVhm4Ukrs6T/CUeZ4+yJZT4edpc56Vw3/M3pRpQybA16dQAxNBnvDbp5z6tPmH+tnJW9RCepc//lhMnjpA2qn4F4TH8vdO6/Rp275nz7Ln/S2U9Yrs9AmqQzSEYVzCicCDt4mP4bcdk9T/yo31QJLW2iFDfk/+6OdNm46lzSfwLq/O9nqHNX+9HONHPZile1I1NtVrLoONJ/1Tsy/2uhW8hZHRnO53JkOG1Sox7UkdF4Skqb15FB2uzI5N0xgvklnd/dVLWeHc24qoONKelARdxh4RrB8S4VxucOAD8K1WTHOywk/Z+AE/On5avPWl3tS+AvCLLVFeZfq909+4iOj1ncKPCMxlo760k6KF+KpDlJf5Wzw+Sv2yT9Dugw/yV1mFl3kWWZqWWdD4JsM/yu9pa1/bCMNN6jwA5UO338CZffL2hnKuu3ajeTufMX+q5dFUUlbnQAXmfmWtXK7OxcvVVbnG/OzHIfKbzyuywrejcq6f3OGE2rhwKdB7lGYRTiVihuDOJwZZAPyvDjmE03ssgf6ZeU9DhYz1OXllhyuEUIPLtWK9fClmW9IKO98zu2TVkPntYOF3YdVMyDIS4j28QoHIv/pmlSKyUIvTDG26Lwwl8GSdqdIJc/K3eXJWnnz2hCebFsgYKRJDumsUnJe1/QzVuYgTdt4gkxHkvgM8JYqx0oGp0bBqRzg0LH58oX0kzzx45OdvKgvUlakTodduIx/X8qdTBvjjG1r3/DoJueNrGKvhDbSMm/OdAnUNneSPrboV2lXUyA5XTpGfpjyHPShFaF/LEVyL9WE1pc5tGgs7sX7eN3hd1lkPQ3Qj3XJ/NhfncC5icnO5izOTHfmYD5PYC54NDHA0E3PdR1Tf+5zWF+Sef3S/DO5Uyn/OC3L/I5qcgCyyT0NRuTx5YhrbX6al0rm6ue8ZI6ntPSsE7mxBpX4nzU6aij3Eh/wsGrVg72KzQ6BxSZSPrTDr4wvbRh1H3JKzLEy/8MZVhz1TdeRij0+7mcSeS2j9JJH7cp6JX9qQSsgH7vo3cjgX45U2QzfzC289q8yf4EnoUHfsf6j/lZ//3YzLmWtlNaAvtizCOHEfqNfEf1/R92dXA5HWKwHidddKrZ3CQMbS43rd1HARcjZNf3qdP3n2y+7+TdZxZPN4+fad53WtHfrUF3+TbRbz7xDnlFviYoHS9mnqTfD9PvRxR+OLBMMEwo6ZKC1j6wPd4Gz/30D5hf0ml0pgakM6XQcWHdpmBJ+oeU9FNKeimHZi/FBuAlrD7st9aGsM8Q+v3Yb5HbUUonY65NQXL/lWa/j9K7JPut6UoSn0I3TVc0H4GxcPx0POyk4Tl8SX+RxkN+/NmF9qUU6GOIzPz6DAv1AtETeeM7pD+h8CN8F5W4Qeana/P1anX+yhJ6szJdWWxUXG0Z33Hbf1hJf7uSXmT9iB9Zqwc5PwxyjcIoxD1EcWMQh/0Jz0/7sU8LmeSP9EtKep4vyVqXGtbxPrFkfhptvLTttbJNfm1Kfn9yhOJWII43cuF6D86lc9D8UClvpLf/vNzB5XTMK9ZHGD9rYy2uK5c/GgVXXUk6qavTROdY/LsyUFi7usK2x0GrKylv3rrC+gjjZ82v4rrSxtj4zlVXpx10dgxIZ4dCx9VnZ+lTNToaz2mndf00zUeKvcP5ccx7MuzEY/rtMG/6s475SOQRsQuBvhbGNlry4/y4yxeT9L/kmB8/TWXGcjKPWOZRpVxR4PlxSf/r5A96Ggeo8+NCy68/mN8W8QbLFUj/trCTjoNmb6RMUR0f2N3B5XTMD+pkCPgsp9MKFo/TP6XwI3rzSNDNP7aNKPC6L+Z/hLDSTvw6TliYP8sXToh1J2G51t7TTnV/D2FpHygIVpiCdS9hJZ3SznqlYX2GsDD/CmGdT8G6j7AwP+9hW03Bup+wMP8qYV1IweJTLTH/BcK6mIL1IGFhfj5l54kUrJOEpV3qos3lY7+U5VRAPxfUVHNf3LZWpwJqcndtbr+k8FpS4niOU7vU7ZJCR8M6aYh11hDrIUOsRwyxHjPEetwQ65whVmiItWKIdd4Qa9UQ64Ih1kVDrBFDrDOENaJgabZte/wvCq+s97x18YFTD93bDCggXiHoXed5OIF+SckfUN4CvSslYAlO9A59TZ7zknJuVtIjHu8ZKcSE8XQulh3z49r74HlNv5a1Xx3WvRXafIbkLSlxPM7Ms6Y5qI5H4W2hTr+g5A8Iq6C8iwKuJUo6bZ4Vy3o87E4vbQ/nJBCD9+y1549B3/mkz7SxGK8BaOMt7NeFn8mg117wdxjamFKb28d1wyiMQpyhXi9rpxyifMbC7LKIAsvOddMR1r128givBaCdY78qTa/EjvJYAfPinJhWl2Wiqa0N4Tvu08pK2TQ6UwPSmVLouLDKCpar/qaU9Nr8AJ/WHEKcdV+R1K61eYF+1r5FbocoHa99a3MtjBXQ70P0biRwr31jnZ5K4FPopukK5nfp5MiAdEYUOkk2Pgro9/C8rqR/R2zj/a69ztdd3z36/f5sPvMae9Kpmch3UYkbZI29NV+rLNdbzcpMfWlpudJw2Yy8JxC9Tknvd2/5vLrGHoJcozAKcecoDvtK4VFbYw898Z9F/ki/pKTn8Ubek1wtsGSNHfsSadtrZZv82pThXWPHvSF51m2xPsL4WVt/4LrS+mzNn9Tq6hEHnVsGpHOLQkfzjwsJf4UOv2M6Gs9p67afoDGVdlos5j0VduIx/b+GddtFx55o9rW5PlEHo8DtHk/fztK/S/oWjOF43Vb7NvNUmMyz0Mj6nbmkv4d8DD/9vL5u6/rulecL8n73qsnBsy+jfksvQbNr/A0OzsHyXopViOP9hrg2dlfYHYdznjx3g2tGD1OctvYgcZ+HuFGKwxsmUEc5aLYZDye7O8caN+rNCsVpZ2xoe6NuhWeME175Hesb5j+VkI/tiOdvXqqe23T7uyTtm28sE/vu/e4LQlpFwrKWnatsrv1QuE7H62wa1tmcWONKnI86fchRbs0maLxq5eDxvNbOblVkIunPOfjC9NoBbGs9X6PJ0Gq+RuR2O6Xjb81QB88mYAX0+3Z6lzRfk/Z9+pdLOs9ZzwuS9H8EftxX4Jm/49HKNUm/o7+fi5/9rvHMLWnzKiy7zxFtjOM17CAIMvelUqZIr8Zz9KXoN32O6PO3ItG7z0Ia/n5f0n8N/NybyjpmIXDPa7MOZT1DQNL/vMPXljSjCeU6mYD5B6CLv5Sg64GCqZWL934yD6eIB0n/a8q6ZxD02kVu6/eE3bw9pNAKEt5xX/BQQpyLblre6PlRwuC+nvX1s5Re1tWTZMq6Ium/4dAVbU+vaz2beeA0pxN4+H2Fh6if2BbHL9//wKMJS6G8TYyXRrkquQpGFZykIPhR8f6gpOPIb5f6acvIQcI7rgbJi2dxNpr3Nk8nrRVvUgqgEeM1ZAlZ9uMN274B3/vxXOdNoCy1fcm8b0D79igvnX73DfDvQgL9gpI/SMgbUJ5X/JgtV5+1sSjPfeQdi2qNg7GSzghaDjvxmP5/cuw3OAV8aJiyx1rSa36x6yDjtPElf5+mjVNctFGWWeb0XbyGSnr0+XkvBfIX5uT1eLi2vJ7KyWtSu5Q+7IqRvvtM8+Sd959uYlNhNgJ6Hqd3SdvZ5PfpBFa3Uzqe9uYj1bjf5D7pjMKfFoQPDMzLSJAe+J6B/x2a6B3lblqaCUEavH0EuxR0ub+cMDWPuC73XbtsCTF4u5Ok/z8d5icM3GVjtV9R0oeQhrc0aZcFaZ9S4DLKK9hhJ07Sed7u1NC2O2F5x8JuWZxXZIHpWXarSnqctubtTjhtzZcW4fSw0NSGobi8wktDWl1qes3lHUsobzPsxHfJJz6yWNM/TSbaUc2SXvuUBeXEOobyvUBxmC+MnzX9k3Se9a+p6R+Wl/VP+xQH07PstM8++LLwKJQoPcpRO3JRaGr2T+oDj1zUlrcLCX+DoNdFx7JpWwveFXbTCQ3phBAny4LcnjRXLnquB93p8aJ3bk9aepEzTrVo9TdG6Q9A+5NLyXnqOQo4/Xhop04b2/5ZhVemPQfHld8QP7vcNz7Kewp4/9fl5Py8HMrbmDAuhDj+bGZFKaekjwLbOEl/C/D5b8tXnzVbgtPoURiFOENb0srbl2l21dWXpV1QHsbPpaBXT5Pu1UGsEN4l+UGbA90HwaP1MX0N6ogvIcc+c4V4fywn71l9w7NQjr+io/xRlueJplZXmt3Xrje4kAFrxVHei8Czlh7tBKZ/syJ7xhwLdF1aTcD8TsDko7TTMD+TgPk2h6+i9Z/oA3Ib0T5rwj6V/RFsI5coDnnnfvMJoM9p7yf62ue4gUI3cPCrbcd38RvGz9w3fAwvpI6fxwnP2C7WXXX5eqU8WevyrKP8jCX5RoNefdXa0BOKvO7aqWOO5cT8qNK/ar7Op8MO7Y8l+AZRYN8gCmwDzyp8oc/hOvKc/YNFpb2u2xiy2qxo/S7KgvvdFYjTZMc2xTXmlLJEoaSk/1TYHZflrjuk00+/9rsJdwNquNHzIeJDyqb5Y9HzpyEe0z/gsOOaDF0yTxu3h/GzdqzDKsWFEIdbc1/BDnsx10NfUT6sry5ZRCHveJ31Fe3mCsW5rnwKFTpZ9VXy4l2WWl3ypc2aDmTVmRFKj3ZQS88+kKS/mMGvQh5cn1pknR/Q+rgnAp02tluUCV/wLemfzmjPpV78jqOqVa19oFy5fbhkGIW8PqLIzPV5v9Y+LlJcCHHcdlYUHrK2HcmrXfKeduQPj+vin106gz4m23pJ/xWHrdfKNkj/yvMMIcTxFlnNdgybLg+LrQ8pTrP1mv7hXMCDGXyNUQf/mq6ECv951zYeA/5fwQ6DnnKvR91jebnurdc2uO5daxvalvSsNiXp3vkkm8LzlpL+t3LaFJdeWdoU7W729ZtnHG69CikObUpevXL1gWiDPpHhSk6XHrnWvrKO/Vx6NKLwFQKu9hltFI7FfysDBteajN9rECszBaIn8sB3SL8Y6H3AMRt+qq56DeHdJpLPqh9+piOTx20lCq2wVzbMB7enx4F3kfF7wm6+o6Bt88Z1qD+luSahk7QHQmjwfMA/h7mzPyPMtCMzXW0f19ffvUPnFXFdV0qeBywtPZYd0/+lYwyo2c8Q3uX14Xh/R9b19XMJdLS9BFq/LOn/VcbxodD22//Vquu9Zi8yy7Jmj3XA60CarmK74Dag+Whae8WrNLW2hTYBeQwgXRPS8LxJHJVoD+SYVPbv/janf7cb3uXtl7nNhBCXZSyu1YPLZmh107MnJ/6mWLMZaft8WKZt3wIws+zzccnUYp9PVpkeD3Ves8pU0hcdMsX5uywylfQTDplqMnLJNG3NnmWK8ubjH9NkytuWtflNl0wl/XUOmWpHG7hkKun3raNMscwXKR/ajBCeR4Jee1dMyLfLgXk+AdPlfzJGUl2GCh2uyylHXYZKuc5nLNeqUblWc5ZL0t/iqVyPJZTrsZzlOp9SrseoXJL+DqVcWh+WNK7V5lyiwHP/kr6qtMtrec6M58U0P9y1f8mlL/2Mb2o0t+E6ckTbq67N0/EerWMZdQCPJYnCKMT51gHUZdaBEOI03e93zrmkpJdxsqYDSdfdI51+dOCOHd3pQsAoJPwNCE+Ca28tHk2F5cZxBM5R8DhiFehqbZHTS7vDvbXY3nj/iaT/AOgr760dUcoTyfBDu3TaSW2F5zQk/ad2dTA/Ej+7rp7v13ajnJNs98c3bHeX7RaZabab27TLdo8odLTjtLRjDyTvK/saJtL5X1HySnrN58P0OL7B9Pc6fCNtDgjlNJ2A+SDo/f27usuv7XeK0j26y4b2acfYQRsLuD4hTJvbEX5c+y243FxXj5JdwDKGxI/kQ18V07OvinF5xhba3l6W4eaE9OyDS/pQ0bMsex80/rL2i+hXs023/pxU6GrrSiHFad8+rN8aYa2m2eKY1CuBbfFK0CsLTN/vupi2H57tNNrikOikXYfl0hXJG+nKhbgytLmrpDUBpKntwdDWzrmthPHvL0Nb4X3zIeTJ4rdL+q847KJWBldbSOtbuS2EELfqyBcC7rhC61j8t1JpDRSEntitLQovSf3lj4Ec/6ys81ro4XewoPWdBZIT2mBD21ApEL0g6B0rcN+k6cMxE346a7LaPKDW7kQ+F73wU23hmmwI9HFNFutG8x80/xfHIz9PfZfQSVqbq0E8pv9V8Mt+KQEzCPLbTskb4f7J9m5cl62IwqDrCiHEudY3eW8w1gmPxdO+TeJ9jpL+62AbXN8YCl9+94631n1vLO9/dV0VFipYqAu8rqbNBWv7FXku+B84/FDX/txzOXlfUXjnds5t5+cz+Kham3TZBeT7EMRj+n/s8A1WFB5cvoHlXjrMh0dyvoIdduIk3cb+XP1YUqGZtjfu62S7tW+MXGvd2pwy8nE9xGP6v3DoX6jwgG0g73wtfweYdY/wun8LVKnW1nvOjNc0UDd5LUTbF6XtTcFv0b4S659POc7NV9o+rdSh6CuHUYjH9P8+1tcilEP+jg7AZ2tusdqqL7YWZxYbjenlRT5WPgpSZ9ExU5E+/M2ujsy4bRv63RXBH/OD3/7udxTKOqKUSeiLLm2C9IWEv0Ggj1mEVpGwjMtWdZUN+ee5glHiR56TsEZzYo0nxB2zKXe7Tkcc5Wb6Sem1NiDvNzvwMb3YddThzSSLLX5kUXPV22agKfT7OTZbfl9P6fiaM5T3WAJWQL+vp3cjgX5sNtulLMeJerIpmY8TFfprdZzoGPGT1HbxOMF7719sxKd8ssnjqkNxIhwXm6uu3S3SO1aHTZRP3ECtC2U+CwqGJgLB1E4430T52GxrdIOgo65sPtKw5HnEwUsSRoEwJhwYG01no+koYaPpZGs61t54bX5+dqG2VJmeayy3GtP1NG/cmv7y0uzSdHNpebY6PVufrjTWmn5zaXphbmlheabSqCxUF9a8/HOL81eoL0wvTs9Wlitzs3lGQ6L76FlxW9e8xs0KtnZ5naTT6LAOb3HQYZNZCDpe3+bA7SGOUfo3xyuF2k6OzZBHyoEXrm1J4GFUKXMUToQ6D28BHv6v8tVnabdounF142273byyXR4NumlL+nft7mC+I352XZ5SCnQ7g3FYlyKjbUG2eheZBIFej2OUXmY9kup9K5Vb0r9PqfdJSqPJYFzhD9+59H88AUursyicDHXe7wLeeeavqPDnmvnbpqRHmyT8aLLZRnFFwtboYFmxrvnCRkn/caWs2myi0F6P05RRhmNhd7nxFO8RJT3Xx4SSfjukEZmVKD3WjdZGt1Ec0t1MPGg2HvWSV2a0mQG0UZp7jjIQPseV8trV3XK1QPSkfPgO6ReJV2NdqubVEZHPhB/5VFw6OKHIR/jZ4YWfSvsS8pJCW3iNP3jssiuYfgJkiOnxWfLju7NwQVb0fhLyCX6J4qIgpzQXlLgR5d2mdcIqKVgoN6nTqB2fIlnwzQTaX8Hld8wj1qfovMtG9EsHscSP0tpT9O9Y/LsyUKjXpBw7lHIIbdQru7YzM5fV1gn9YuC1LVddOozykXrT2r7kLQW9Ovxo2EmXpt9IR8O6PKRYq4ZYTxliPWuIZSmvS4ZYTxtiXTTEOmOIZVnGZwyxLPlaMcSybI+W9XjeEMuyDT1viGVZj5a6+qIhlqV+PWeI9UVDLEu9H1abY1nGlwyxHjbEetkQy1Jelr6JpX4Nq19oqffD6sudM8R60hDrWvDlhlXvLX2TjT4tH9aw+nLDagstfTlLW2hZj5byGlb/6xFDrGH1vy4YYlm2bcs2ZCkvy37Isg0Nq+wt7ddFQ6xhnRuy1C9L33dYfcxh7DuiZ16zsug7JhOw8dm1NqzRKSg8a2vKmwBjPOgtr+W6suDv8oQv5d6pyArLJPR5jVnitb+CxXFCq0hYxmWrusrmWovGdXeUQRLWzpxY40qcjzotOcqN9CccvGrlmDCUyZghFu8N0tq/tn4r6Xcp6TU9mVRoS16p290QZ1i3NVfdoo0Q+v18ZSRyu4vSyYnCm4LetrEzASug33fRuxHAw7BW9p1/y94a3NPLt5mv/R6J2XqB6EmZAyrXa2WPxGNhJ92gPsMXDLEs5+gt/e5hnc+wLKPlWvGwrtsM6xzX5w2xrgWd2FjTWD/ZW8rrgiGWZRkt5zOGdU32oiGWpd4/YYg1rPP9ljqx4X+9Nmy0ZV971hDrWrCFw7pmFhpivWCINazz6pZ92sY6RD6sa2H/gGUbGta9Zxt9x2uj77hgiHUt7LfYmFNYP9lblvGLhljDOh6ylP0lQ6xhnS+09HM27MT6+RMbdmL9ZD+sdkL8L9feGc/7iDIf9yf012pvjiZXbc9F3j0qrvO7sEwYhzy4zgmbVOiMK/mOBSayqnF5eY+CxsdOcz7qM1IHuE+G9dfnvhekFwS6/gr9IvHqS393Ez8sH9bf6xReS0pc0t4siQ+8y7y+1K/MPe1rc8pc2yOWR+ZR+FzYScdxI8q7TQ6sc4ZYlwyxnjTEWjXEOm+IdcYQ67Ih1jOGWJZlXDHEsizjU4ZYzxpivWCIZalflu3RUr8sbaElX08bYlnq/bWgE08YYlnq1/OGWJZltJT9BUMsS71/zhBrw068NuyEZRm/aIhl6U8Mq+xfMsTaaEP5sM4aYm20ofWTveXY3XKMzN/R4hwSz49q8y27HXQwP6bD39p3VveE3TxdB/l2EU95y475JZ1GZ3JAOpMZ6fgoz7iS71j8tzJYaH+HvGdw7Bl+Idh77fmeljlAvGsA76b45p7uesC7J0YobwHqYYzS37S3g/n7MSbfZxPA8zjhFQLLudLst7oL/SLxastPZ+52E/HD8uG52xGF1xLFReGzYScdx40o71xYlwyxnjfEWjHEesYQ60VDrFVDrOeGlK/zhlhnDLHODSlflw2xLPXeki9L2T9piGVZj5ayv2CIZVnGlwyxHjbEetkQy1JeTxtiDWvbtuw7xJ+QMQX6j3I/iXYnGt9/hfe+IQbGIX+um6cx/2hCPi4H75eR+GPx78pgoSr4W/3gt8/YSbv7T+hrd+QVEv4KFscJrSJhWcvOVTbkn/VA24/kwtqSE8vzDd7tOnXdKYb0Jxy8auXgeyC1dlZQZCLvtzr4wvSTCm3JKzLkewOPxb8rg4WaS4bYFoV+P+cTidxupHRvDztyYB3ckoAV0O8b6d0I4GGYJAzNjnJ7TqrfUkL+KLjuxJ1Q8kn58A7LfRC/lWjsU3jc5+AR80s6jU5hQDoFhQ5jaXM0UVgOO/GY/o54jka7i3K/wp+rLR5Q0u+HNMKPJpsDGfJFYUKhJTxJOz4I761tIdITfvEd0i8Sr776pIPED8uH28YhhdeSEsd24ZBC55BCR8PaTzygbq1R/dX6rb/9fvhx1t9+Ra556499hENeylFdFr6uD3qDxB0G2qwLN0ActhUOI/QbyxTZr39X7uByOuYHdUx4G1d4NZRTk8sbKHxhX/ulsJf/wCGLwyCLLVMdXE7HNFG/b6Q4rI8yxaE+TVHc9RB3hOIOK/xkaZtRYBvj0qv9hnRQRgeIzgFDOijvQ0TnkCEdrDupq8mgt+6wnXAbH1HeMZ2DCh0pD/r6uP7U2KvTRN8G88oZnGOUfme5g3kixpQ2fiPwZdfGaxUpWznoDRI3BbQPU9wRiGN9PgpxrIM3QRzWLQfNbogsIrvxuhx2A+02t39X/+7JH8rcvwv9terfXX5xFFz9u+TV2q2sDU8qcsUyJfGg+Yj92ju/Pkb2uhX6a+V7H8ooV80POkQyxzjeJ6H50i4eXH75foUHjc6BAekcyEjn1Vwe6XPEXi7GnU/U51ze251GvlV87EAnzYuURvYCfRn2Tnwxftb6lhNhd9wUxPEZzUeUuAj/n8YCFJlhX8JzIzcBxojyzjU3clMC1ihgjQMW9+uS/tepL38d4Nq18dk5kdvNwBPbu1s80c5q74T+hMKP8F1U4kYH4LW1PF+pV2ZnG83Z6aWZ6VaB8IVXfsfzRbcq6bVzskXWtwVeZF1r32sRdvBvBblGYRTibqG4MYgTHiO9/8NyN/+3euI/i/yRfklJfyeUIU9d+sRCe2CBtaVPrF1Bd3tCm+PXBtVmNRskQWvzvLaGbUzGWAUFSxsXSJkizDdPdXA5HfODdh5543Jo/YesV0wGvXK9mbBuScE6Tlg3K3xNKFhs4/202+w+rdDX7LgPn1azy1q7ENndpvBaUuJuXhO51haYLwwS93qgjfLkoLUL4TtqFydztAvUP6SfJHPUZbGpk0GyXed83N6y+DOedH26X12/2Q8/Tl1H+fSr62i3WBdHlHebHFg3GWKJ3mi+Pu/zz+vrTyo8+/WTa/NaPydBq7ObKe71CeXnoNkBKVNkBz471cHldMwPyvw2iluHfmj2WuqHoiDf1Azanq41LK2tFRL+Ch1+x3RQp9knOwr5cH3gP9H6gOTD9QHM+56wE4/p74Z5mP8aY2p2UXiUdng7xBnasvY66huC3iBxdwDtPfDMQbNXwnfe9UFs53dQHNbfGykO2+ObKA7tboXiblf46Ve/sK6y+Pz90tH8Md/thfuO2wzpYN1JXU0GvXXHvsnriQ6/Yzo3KXTS2v+hfTrNpPZ/b9iJx/QfhfZ/Q4w5rpRxPdv47RT3RohjfX4TxLEOViAO65aDZjdEFnnXB7FupUx+5/Jqi2xfAoUvtAk3KPy7ZIHzey/2aUO5TrFNi15MBr1y4vmPvH36zUo5NDqTA9KZVOh4bldLWt8hgdscykJrc3nHAdg+8owDUOZvoDjXGN2PDLOPA4T+Wo3RtT7FNUa/XeGV/YEosI98u0LndoXOtY6l2dhCwl+hw++YDuo0t80kP+D95AdIvqzjAEn/DvADPhRjanPGwqO0Q7QZhrasyX09Bq2vzzsOEL7zjgMG9eej5yrFoU2uUdwdCj/96hfW1Vr7zb7bC/sTvsZP7Jto/WmB4oQOv3P5JtwXJrX/B/fpNLOOAyT9HLT/0zQOwDKuZxvncbfmz0tcFeJYB2sQh3XLQbMbIou84wCsWywT8j4K73Bc/r7w6t8xSr8a11NUZyv7uukdBRpCO0r3Hymd1h79zvFk/4ZE6BeD3vbuw8fS/AJt3K7ZbclbUuLwG8F+7IJmY4ZtHo736eIYHeuNQ9ocXZ7vGbCN8Vgb+TGUU4vtVKDwVYF3eb9neCPIIo+f4tMXiZ7rFPdGhZ8s7TwKrO+a7rzW/AetfQ1KB+tO6moy6K079lPuIDr8zuWncJ+MfiT6Kb+4T6eJfgrm5X2Pkv4m8FN+hfwUT2ORXG0c9bdfX0Ti6hCHdcshbXyTx09B3x3LhLxn9VMk/e9RPXnyKyq7qFyaTDf8Hf/+Ds7lso3L6+/w3Omw+Dv8Pch6+DvYVjf8nU7chr+j07lW/R1sJxgndNL8Ha2d8ZgjCujv/JsM/g7mTfJ3doK/8zfUj3paP3xV+ju4JtnvvAzbjbQ5lALRTvKLvie8+pfnb2TQHGH+l33JfB0F2o/s70634c+8uuZvpC435m96+cH2tuHPdOI2/BmdzrXqz2A7wTihk+bPaO0sbf7mDft1mnnnb/4L9Hlvip835m+6A8piLedv2E+R9N9O9bSe8zeubwM8+ReZ/R3eE+T72wBtT5Dr24Ase4KiZ56/6Xe/DOrjsO155PkbbJ95v4XDsUcefwflLLx5XnNvsC8QKHyhL5DX38H18X7311vvoUcb7rvfXqv99a/V/TuTgb090toZjzmigP7O3ft1mkn7atjfkfT/B/g791I/6unb31xtHPWX/SRNn/PuuclqN/B74jz+DvqybDfS5lCkHtBPs6uHevuOoemgN0jcDNDG72U5aDITviOZve9IB5fTMU20IzMUhzo5S3FoF+YoDut7nuKwLS9QHNrOb6E4HA98K8Wh/n4bxaH+fjvFof6+meJQf7+D4tDPPxY/D5v+cFudhTj+FmYO4vJ+C4N698NHO7icjnlF/Ra+twedM5BPNE+/q/noXYv33t1YPH33/fe9v/ngQ81Tp0cJlrtU/rTstgR2ESdwsBuFTRT3OoqXo6M2BXqYUPIJDVGbaXi/HsMVoV8MeqvHx3Blmvhh+fBwZUbhtaTE8XaWGYXOjEJHwxJd0ba+89V82jEuNzvo7FJ4HjYTsovi0IQM0j31u41PeBtX+DGU0xybxUDhax7e5R0WzYIs8gyLUObcraLOcLeKtoW7Vaxv7lZnFX6y2JMosL5ruuOyi/3SQRnxtHYd8g1KB+U9TXSmDelg3UldTQb2dk9rZ2nDoj+gYVHasQM8LJL0fwrDon9A7rifT+nytXHUX4lbgDjW52+BONbBb4U4rFsOmt0QWQwyLGK7UYb0nw6746Yg302U7wjE4XDqn9KSNB43WiYMPN51iuLwOOojgP/bMSDr0P8COvQvSS+zHmkk6bXPe29VyqsdPcVTnH6G9cOlvxL3bRA3yBFif55hGKHVs3b8HdofOUpPaxe3AK7YNZ6++begY/8xYQkMaaPesY69UUmvLetpU2CSd9g+u+SpIxxe83AUh9c8dYTDa55yxH437+dauIyWVcf+Y8LUn9DIo2O3A+7dpGNt/YEtXjsOdNN+Uwpt1rGKkh7ri488QD2SvONKPkM7VplQeJWg6QpP6+XVFc0nZr1FvwplwkHTMZFTHh3jetZsCfZJrGPalkRcpmcd2w06NpVBx7SjLbLqmPSzGzrWHbfWOjaVQcfQJ2Id0z7zwa2trGM3g45NZ9Axlz+2Ycc6ccOsY9Oe7Bh/Lqb5Ti790fQNlwzY18JlCMk7TFsPUT4+/CmXbmXVH9zqmEV/CkRHcLF+ouDyrySvdhTCzRlxXXy4+kFN17Wtvpo/fwfFYb7XJ9BJ+nSAj3SQ9O+N2yZeayn1gcf8C+3x+O8oxBmuA8xGfFSAD5bhWNhdbtd4KQp527zIrBT09gu8/RvrgNvdUQVTO4pH06ebHPzn1SeNx2HaPqTZl6xbC3i5Mq+ty2qzcLtSHpulbb3LarMkr3aMY9b5DBcfLh1zfSKh6Rj2z7xFB/MlbdFBm4VlY5sl6R/MaLPwGKoojEKcb5uFMmSbpbV5bWtS1jYvMnMd4ZRnmxNi4jHCUqdTkG4r8ToV9PI6pZRNu/ZoKgEr67VHkv7LsX6IncM5abt671x7hG1P7IDQvskT7QLRE3njO6Q/ofAjfBeVOB/XHmU9Jl/Sv05J77r2yM+akH7tEc6NR2EU4m6iOGz/uFbD1x55up6rlkX+SL+kpL8TypCnLn1ioT2wwNrSJ5Zce4T2U2zOWtlMv7auVtdsnQTNtvD1StiWZa24oGBp/peUKe/1SihzPn77KNFkmYsPNRn0yvUoYd2UgnWcsI4qfE0oWNyXeNp7lfl6JaGv9Rc+9oJp9l9rf9pcJNsybZuvX7nmv5IM5clBaxd47Vie65U0P88lc9Rlvl5J6z84H7e3LH6TJ13PfL0S6/pRP/w4dV1bw8ur62i3WBddc6Qa1pQhluiN1j9OEp0phY6rf5xUePbrj9dmtH5OglZnRynuloTyc9DsgJQp77HqKHM+Snod+qHMx6q/FvqhKPCR4/22p2sNS2trhYS/QoffufaHsk9Whnziu0bzIn9J61qSD+ezMC8fqy7p3wtXYf9VjKnZRb5KdViuhcx7rDru6cqzz9l1BQ7WH89ruY7MznJlE/LTr35hXWXx+fulo/ljvtsL9x03G9LBuuMrGbHupuAZ44QOv2M6UwqdtPZfOKjTTGr/PJ8t6b8D2v9ojDke9JZxPds4r7XgOiXrM85Nsw7i3DTWLQfNbuA1knn2OWPd4poA82Ao3zm2L4HCF9qEvNcr4TxinuuVtOv6NBvKe2c037XfPl1bG9XoTA5IZ1Kh47ld5b5mlccB63HNKsqc101dY3RPR5dkHgcI/bUao6etu/I4QLuyk/2BKLCPrH2XoO0Zv9axNBtbSPgrdPid6/gMbptlyId+wDz5AZIv6zhA0t8BfsC3xpjanLHwOGxXxeUdB+B1cHnGAYP689FzP8fHID/96pfr+i7ffrPv9rLW17lq+0/YN8l7JeNRhU5a+//wQZ1m1nGApD8M7f97aRzg6Uis3G2cx92aP6/t8cpyBWtWu9HvMb5Yt1gm5H0U3uG4nK8tkPR3x/UU1dmJg930ykBDaEfp/oLSrcNV9pnPf3gtXGUfPY/Bcz92QbMxwzYPx8fzald6Z21jOEfX7/G8PNYehmOMo5D3XIaN6+D1clnQuVavg2c/Je918Fo70/xI9FNeOqjTzHrdQPvoUvBTvkx+ysZ18J00/V4Hr31TVyDes/opkv4nqZ48+RXq8bws0w1/x7+/g3O5bOPy+js8dzos/g4fz7se/g621Q1/pxO34e/odK5VfwfbCcYJnTR/R2tn2hoF+jv/JIO/g3mT/J3/91AH84+pH/W0fviq9HcszqFiu1GGOG0OpUC0k/wivrZA0v81zN/8i4PJfJWB9icOdafb8GdeXfM35fh5Y/6ml58yxG34M524DX9Gp3Ot+jNleMY4oZPmz5QVOmnzN7sO6TTzzt/8C/Bn9sTPG/M33QFlsZbzN+ynSPqjVE/rOX/j+jbAk3+R2d/hPUG+vw3Q9gS5vg3Isicoeub5m373y6A+DtueR56/wfaZ91s4HHvk8XdQzsKb5zX3XNdQRSGvv4Pr4/3ur7feQ4823He/vVb761+r+3cmA3t7pLUzHnNEAf2d9x7SaSbtq2F/R9L/Efg776d+1NO3v7mvmmOfFvensD6jT5Flz01Wu4HfE+fxd8oQ5zpTRtLhHIrUA/ppdvVQrwof1aA3SByeDXUEnjloMhO+I5nluV4J7Qhfweu6qwDtAp+zfS1e2TRs+sNtFc9R5G9h8BzFvN/CoN7luV4J9Vv47uN6Je5S+dOymxPYHeR6pSMUn/V6pSMKDVEbPDJuPYYrQr8Y9FaPj+FKlfhh+fBwpabwWlLieDtLTaFTU+hoWKIr2tZ3vl7pqELnqIPOLoXnYTMhfL0SmpBBuqd+t/EJb8N0DVUU8g6L8KqpPMMilDl3q6gz3K2ibeFuFes76com5CeLPYkC67umOy672C8dlBFPa1cM6aC8+bbeqiEdrDupq8nA3u5p7SxtWPQ1GhalHTvAwyJJ/00YFv0cuePI13q1cdRficPrwlif8bZK1kG88gbrloNmN0QWgwyL2G4cgvR8vVLW64/K8XNUf79NS9KjkO4QYRyEuMMUdz3E3Qj4L8TfJ7MO/R7o0D8ivcx6pJGk1z7vfZ1SXu3oKZ7i9DOsHy79lTi8smmQI8T+PMMwQqtn7fi7Mrx7e9jNb1nhF+0aT9/8j6Bjf5GwBIa0tetCJX3a0cbl+FmbApO8w/bZJU8d3QFxPBzVjjrXhtdZjt3OqmO4jJZVx/4iYepPaOTRsVsB972kY8LbX4OO/Xui/YYU2qxjdyjpsb74yIONI9q7/R+WCQdNx/Ie0a7Vs2ZLsE9iHdO2JOIyPevY34KObbm+m/YbUmjn1THpZzd0rDturXWM69nqSgDZ2so6th0+zTmYQcdc/tiGHevEDbOOHcygY/3YMf5cLO2KQ9Yf1zUHmq+FyxB43QznW89tSbxVy9KfculWVv3BrY55rirRttOW4Z3Lv5K82lEIRzPiuvhw9YOarmtbfTV/nrf3Yb5bEugkfTrARzpI+pm4bUb14bqqRGiPx39HIc5wHUC9qgRlOBZ2l9s1XopC3jYvMisFvf0Cb//GOuB2V1YwtaN4NH2acvCfV580Hodp+5BmX7JuLeDlyry2LqvNwu1KeWyWtvWuDO9cNguvt+FjHLPOZ7j4cOmY6xMJTcewf+YtOpgvaYsO2iwsG9ssSf/hjDYLj6GKwijE+bZZKEO2WVqb17YmZW3zIjPXEU55tjkhJh4jLHWK879bidfDQS+vh5WyaVeFHE7Aynq9kqQ/G+uH2Dmck7ar9871SmXgSeyA0J7yRLtA9ETe+A7pTyj8lOPnohLn43qlKeI1zQ4dUdK7rlfysyakX6+Ec+NRGIW4KYrD9o9rNXy9kp+9FZ3rlVzyR/olJT1fiZS1Ln1ioT2wwNrSJ5Zcr1SG/GJz1spm+rV1tYpm6yRotmUrxWFblrXigoKl+V9Spggzz/VK2jplQSmHJnPxoSaDXrmWCWsqBes4YZUdfB1JweLrbbT2O6Hk437J0z6uzNfXCP1i0FtXPvaVpcmV95UdVXjV9kSgXmAc0nHt90KssiGW6IWmv3xs9Y0KnRsddDC/pPPr79Rqmh2RoNUZ7xu4KaH8HDT7I2WK7E+eY6tR5kcpbkrJ67ltZj62mtumnzp1t02UTz9tMwp8pHO/7elaw/K9/07qVttrhPvIfovWDSQfzhdgXj62WtL/1xs7mL8TY2p2UXj0/OlN7mv38h5bjXtm8uwjxXbO6wFYfzxvgO2R15qyXImD/PSrX1hXUwnlsqCDMlqr/arcdxw1pIN1x1feYd2xn5P3GtsbFTpp7f9Pr9dpJrV/ni+U9H8D7f/PaG7I03V7uds4z2XjOhDrM879sQ4mHeHJQbMbeE1fnn2kWLd89L+fOZnaNNuXQOELbULe62twnibP9TVoH7hOsU3z3gTNd+23Tz+slEOjMzkgnUmFjud2lfsaSx4HrMc1lihzXpdyjdE9HQ2ReRwg9NdqjK71Ka4xunYlIvsDUWAfWdv3re3JvdaxNBtbSPgrdPgd00Gd5raZ5AdMHu7kwXxZxwGS/p+BH7ArfqnNzwqPfo+MyX8VV95xAF63lWccMKg/Hz33czwH8tOvfrmuR/LtN/tuL2t9Xaa2vs++Sd4r7w4rdNLa/xsP6zSzjgMk/f8A7b8aY3o+cih3G+dxt+bPa3toslxxmdVu9HtMKtYtlgl5x2PFpgCDj4WX9Mdi0KjO3ny4m94hoCG0o3S/SenW4arwzN/XvxauCo+ex+C5H7ug2Zhhm4fj409xjD7Id215vnvHNsZj7WE4JjYKeb97x6NgN67b3rhu20VHO3ZM22vIfkre67a1dqb5kein3HtYp5n1OHdJ/9vgp9xPfsrGddudNP1et42+O5YJec/qp0j6x6mePPkV6vGnLNMNf8e/v4NzuWzj8vo7PHc6LP4OH3+6Hv4OttUNf6cTt+Hv6HSuVX8H2wnGCZ00f0drZ9oaBfo7X8vg72h7F9nf+Snwd36O+lFP64evSn8H1yT7nZdhu5E2h1Ig2kl+ER8LL+m/AfM3Xz+czNchoD1zQ3e6DX/m1TV/I3W5MX/Tyw+2tw1/phO34c/odK5VfwbbCcYJnTR/RmtnafM3/8po/uaL4M/8m435m1fCsMzfsJ8i6f+/IZq/mVLK73lPUGZ/h/cETfnhx7knCOXTz56g6Jnnb/rdL4P6OGx7Hnn+Btsn1huHtLFHHn8H5Sy8DdM1P1HI6+/g+ni/++ut99CjDffdb08llMuCDsrotbp/ZzKwt0daO+MxRxTQ37n5Bp1m0r4a9nck/Qr4O7fFmH6/Zct/lRf7tLg/hfU5756brHZDZJHX30Fflu1G2hyK1AP6aYb10BQ+3hj0BonDs3fK8MxBk5nwnff6GrQjfMUp6mSF4tAu8DnG1+KVOMOmP9xW8Zw6/hYGz6nDeuWQpnd5rq8pQ5zw3cf1NVP0+wj9PprA7iDX15QpPuv1NWWFhqgNHsm1HsMVoV8MeqvHx3DljcQPy4eHK29SeC0pcbyd5U0KnTcpdDQs0RVt6ztfX5P3aJJdCs/DZkL4+ho0IWV45pBmJvrdxie8DdM1P1HIOyzCq3zyDIvKEMfdKuoMd6toW7hbxfpOuhIH+cliT6LA+q7pjssu9kunDGl4WvsOQzoob74N9Y2GdLDupK4mA3u7p7WztGFRSMOiqThN1mGRpL8PhkWr5I77+ZQu/1Ve7P7idUxlisPbAFkH8UoRrFsOmt0QWQwyLGK7gX4QX1+D18vcSPnwehkcTvH1MoL/k2tTr+1jxG9UZCK0y55oZ2njLvuHfGt+2CBHDdaaS8uzi4ut+nKrsrzYahaCXtvr8sO4jWP6nUp6v9Ma9UXRezxqcArkGoVRiCtT3BjE4XQDHzU45Yn/LPJH+iUl/dvDTro8dan1lVuC/rDkSD882oA/V+UxWxT82oHs4x6hXyRejflpj3u0ccKoItcJh1y1o0J4W0reo8oQS+y+Nu7ZT3Tyjnv2K+UZtiMZefsL2jDUDw5an41HMvY77hHehunouCjkHfdMgSzyjHtQ5jzNjPrEyxOoTzzVX4Y4nvKeUvjJYk+i4FqmGU0olwUdlBHr735DOihv9glvNKSjHSOqHQvK454y0UnrAw8rdNLGPX98g04z67hH0n8Mxj1/Sv5xGfharzaO+qtN7bM+49Q+6yBO7WPdctDsRjl+HmQ7L9sNl0+COr4ePonQXyufZD/xw/Jx+SSSV2u3eJQU24e8PonU5WTQW0cHiI5Wnv0OOgeU8vj1T6stzWZK0Poo3qIyBXF5fRKcR8jjk6DM42y+7VVV65OZL7RleX2Scvw8iE/Cy2moT2x3tONz8vgryE8WexIF17hvrXwS1t8DhnRQ3jz2PGxIB+uOj63XbGK/ds/lYyX5JDtv1Glm9Ukk/XeBT3Jd/DxO+dezjaP+av4K6zP6K6yD6K9g3XLQ7IbIIq9PgnXLa9XC+5iSdh/FSdopqK/j8fNk0Nv+tgfdcfsgbhs8I13UnX1BJyyHOp83x/Qjmfzbso65KQFT9FGb15Ny+L2eaLmqXU+Edmos7C4TtqcRJT3PnWpzJdim2JdCnWRfalTBQh9H5gY1eQqP6yFP5DGLPDW/Las8RUaaPA8S1gEFC2Xskif6jFEYhTjf8kQeWZ4HU8rE8tTkj3ISGWmfjlxPWJoPju2d564Fe7OSnm0Spn8L2Jxbyt38bYf8rAvbFGy0oa52VlTKMUFxmDfC/eaebv6lv30n2O+PEO0phbarPRxR0k9BGqmvLEe6Y771nH8oU1zW+QfXln7XUbd55yZETnmu+f1Igq8mNLgtso4dUvhFH5DnmT4OOnYP0dZ0Rpu/l/RHlfTom7GOlSGOP//wtOW5rs1VS9D0aIriUI9Yx1CPeI5L0yOJwy2qZXjmkLYdOquOcT2XiUYeHSsD7h/T+r7I7gHQsbNrrGNoq9ZGx4Zr/4jEzUIcyoSDlY6dzdBfZdWxKcANScekPa6Cjr1AtLXPXlHvWMduVdJrn9Vqn6BI3mE79pjXsXB7O9s47Spnict7rXBWHcPPWLPqGNez9rlPVh17HeDeTDomvL0MOvbjRPu2FNqsY2nX0YrcN66g7o5byyuotXrWbAn2SaxjRxV+8TN51rGvgY79RgYdQ9p5dYzXTTZ0bH107Dcy6Jh2raa2boA69rUEHfsd0LH/NoOOufyxDTvWiRtmHftvPdkxPq5V851c+uO6xl3ztXCMJXmH6egflI8Pf8qlW1n1B48ayqI/BaIjuFg/UXD5V5JXu4rgcEZcFx+uflDTde2oLc2f5+N1MN9NCXSSju7jKxUk/V/BPOXry1eftblkoe13Lrkyq80lowzHwu5yu8ZLUcjb5nkvK/YLfPwa1gG3u6Rj+SYTrsJAfm508J9XnzQeh+n4Ds2+ZP20n/c35LV1WW0WHheSx2ZpR99ktVmS95U9eAnXqKbhuvhw6ZjriEJNx7B/5iMyMN+RBDpos7BsbLMk/Zby1b9pNguvgYrCKMT5tlkoQ7ZZWpvXjgbJ2uZFZq4rlPIcM4KYkf7JNb5SD7KmtrvcSTNV7uZZ1oWR54OOMmprDbi2LPPdk8QD5h1X8q3n3jhez5mCONdefl4jwvZ1iOKwfaFMOGh2TeSUx5efKnfeI02hgXUVBbZxowq/EW5j79XnItGVPMfi35WcodZoNKvT1bmF+eb0dGNhho9vi4Lo4jYP9KdnFueWF+eq1YXpanO6uub0l2dml5avMFFpVl8Rx1rTn2kszVfmaosLjeXZRn1mOY2+XOm5OezEo02Pwpb4d8TXiJJe8MYo/XQ5Tnvl32z8LPo+ptB7Zd3dka6Q8PcVDOXdaNj9bjzsTT8S9qYX2sWwl0eJ2wZx2N9EYXv8G+WFWMLHGKV/S/nqX6mTrZBH8pcU+luJfhffyjvsCxhrRHkn6aP6+dZyjBe/w7Ib9vFV4W0z4eM75k10J9LryMb+Taz82h6ZvLqUtKc1CnL9p/SHmwMvMqkJ/hbizwi/vZY5FvTKSWhv9VK2VitLPSD9IvHqQ/+QnvDD8uHvnMf9yKcZfVstuoftd7MiG+ZjC/FY9MSjNiYQniRuFOKEjyjNwZu6edzkiUe/bbTVPncA/T/cn/2xcocu1g2OyVDvsW/F9J8sdzA/ET9PAq7kFzu1DeK3KPHyW+prk5KWvw3fQjLU5IrpRSc3J5R1M5VV0rfKV/9GvN22W8dE+SFfmxIw7wZMGdMKJu7rc7V5Sb9NSY9tTPiZDHrb5jbKh7yPB90B32n1U6C07FvilddbKO2WBDosD42HrQqO9u3HOPGKNFkfosBjmRGFDrYp7PPHFfqG/cOM1ldKkLjNVF6Mw7J/OOyk46CNI6VMUXnfXu7gcjrmR2trlr6RvB+D90x3hNJuprR8fgHyOGbAY0mhs5lwtzj4LxDOqJJvItDbo/Y3K78FhV+trxmUDmJ9JOymg/WMfdrz5Q4u2/ERJe9DYSce03+x3MF8MX5O69PYlmAZPhp23rHNZj+W2yTP6XLfxWmwH8f0P1C++hf7LrYPiBW9+0q5m7bmI2h+H/sIXy93ML8aP7t8gMmgVzasw+NEC/1j6V9YBj9Z7vDxY+VkWiLXCUcZo3c/XdbTIQ+YjjG0vlMwtHYt+SYVvrjtse3Y7KCh9WcajTGKG7R+tH4bfQ3Nh9HisT9HOvxuk5I+zf8oJmBruJsVHM3Ob6W4ghLHNgzLizaMfRNtTIa2UWt3SXXn8r013rP4VZsdvGvyQztkPUdZma9UK8tzM61WtTG7uDSdNkcp72VeUcr1yl94NwbligLOn/H8Hc4Fjobd9GWuDOfvEEv4GKP0/6h89a82pyr5Swp9nONiWhp9nr/T5jXHlfRRnf435avPPuaeazML84sLS5VqrVWr1edn13rue3Z6tjo/vzi/PLvcWpheXlrzuf+F2dZCvb5UrS80mgvVNS9/c7q+1Kq2FuaW6q1Kfb665msPi5XalTWXpaWZanNxYaGVRh/HawWgH4Ws8yGS/i/LV/9GmG+iOYJNDswonA67MSX9XwEmzxFo3wNq5ZT3Y0p6HptGYTLo7U8kL48rMJ0XfapWq63Z6aX52eXalamt5TVfy2vNLc625ioztcZ0s9ZYXGv6S43Z5cpCvdpYXJyrzM3OD6LPUdD0RPpiqfcR4j0Na5MDq+DAGkvBOk5YmJ/1kcf/URgPev0vw/mX6QLRk3IEVO52Hx30tisf6wVpct1EstP8/JISx3MQmn+6WaGjYRUMsfi7yCTbpK3HufSG54yOxb8rg4XMetNeNw3WRm9GiJ80vdH6Dm1tUu6kcNkQ7SyAtcJyzWH5nsPNqgtCvxh41c2qS64jilx5XhTz8vg3Clx/mq3S1jleLVhof7R57RNhd5xmq7TxPM9LaWt7bOMmg+S6Ybur9a3IL8+T3j519a+2H8BQH9WrN3kt2VP/PqvN7UmYUMrN9Y7zOVy3vEaPcdq5HQWFhxH6jbKIaN9xUweX00nQdKRAcZuVcmhzSdwHaD6Qa/+Aa05Ss99yR0CBMIPAPeek+ab9+NBI707iRcq7WUmPeGOU/q1TV//iGTKMKWPIKJwKezGZ56xtW9K9A3hogg6xHLiPHDY/2/dZpa7xdBT68bOjwH1Rv76xLyzfa6HszyftY/nwVCcPtynNZ+FzBiX99011ML83ftZshPC4LXDbBW2uiOWftP+E7YKk/6TDLmhrncjXqVDHXAZMnlvS5u+1+pP32h411/qetq6WNs5/BTvsxfT8rce09q0HymcszC6LKLDstHUtbU2yROm1vhPbEfsmaT69a68Lnh/2YdAb7ie1MWRBoaHNMY4k8KalY+wk2ixrTJtnvsAlQ1f5XHNpYylYxwlLaxcuu45YdxKWtvfEhZV1jo/3hbjmVzztUc48phb6azW/kiZX9hdcewM0v9tluzX7o2GNGmKNGWJJveVps1ymsaC3XYhPwz7BD0xd/RvJ/eWpbtpYZ+8Lu+O4LgTjPUeuPo8r/Ef/jsW/KwOFuUVtvsoOv9bIsj/fT7ueXu63Xfven6+1a22uKE+7jsLjYSfdIO0nCs8YYl02xFo1xDpjiPWEIdY5Q6znDbEs5WVZRiu+JL8VX5a6+pwhlmXbttSJpw2xNuzXhv3yWUZL2a8YYlnq/QuGWJZte1jbo6WNHta+1rIezxtiXQv90LVQRku+LO3qMPbb0bPV/IslX1GwlNcXDLEuGWJZ+ibD2qdttMf1K+Ow9tvXwjjNUidCQ6xh1ftnDbGGda7jRUMsnza6EL/X9hFGQfZB8frGO49c/et3D+t0Q9snJzz43R843SgQvSDQ1wSEvmsOvhjo/tixPnldqrbqzcrS0nRtqTEzOzubVzck/XCc/zO9lPdsnS0UNwZxwmOU/w/L3fz7Od9peimL/JG+1jbvhjLkqctdQbeuYXvU1hU/FXbH4d4GWbPEdcV+9xMnfReB9Lgte9pX18zalod1L3x0x5+cr3miefp9Dy3de/fyu5qPnvrO+xrvWzx5+u7Fe7+z0TjZPHUKS8OawKVFaWhpOB2nl7ixlFLwro68u00Q6zhhuXabbEnB4p0r2pfikm9rAh1Mo7V0jNfwuT7GU3h+T9jNc9KpaNG/YgrWvYSlnYokWNtSsD5DWJifT4HankAH0+DNldsV2ho+y3Iihef7wm6eka8JwtqRgnU/YWH+HYQ1mYL1AGFh/knKV0qgg2km4X1Joa3hsyx3pvD8YNjNM/K1k7B2pWCdJCzMv4uwdqdgnSIszL+b8l2XQAfT7Ib31ym0NXyW5Z4Unk8Tz8iX5M3Sm+6B94a9V2bPWOivVW+aJlf2WvYqvJaUOJ453avQ2avQ0bDGDLG2GGJtNcQaN8TaZoi13RBrwhBr0hCrZIi10xBLbCGP2qNwLP5bGSjUp6Vdo6/CNhFlvR4jDKFfDHr124dN1HwNlA+P8Hf74afh6q93K/KRutyjxLE+4tcpmH43lJH1EfV2jN59LR75lhRMtrlan4PvRL6vnA5HI2psA4WEv4LL71wrfVK/aScb/sKR7rJIvqSTDflrH0n/7NEO5i/HmNpXCsKjoQ1o8AvBxrq20+Nq+zaifUFvkLj9SpkLSvoR+o18R/3xlqkOLqdjmmhH+DYQbDd8Gwi2vYMUh3rPN4Wsle5uM6SDMmI7M2lIB+W9m+jsNqSDdSd1NRn01h1i5bFZ2lfTPP5Isi3/6IhOM8m2yJhnjNI/Drblj2jVwc/4pjrL4wMM3P5Rf7X2z/p8AOJYBw9CHI8dMWh2Q2QR2Y3XTXVwOR2XA+t2H8VpbXw8CHz6LfUsbQHpaysrPvwobf5Lm43XbK7k1ewDt03NX5tU6GhYMk/ApwwFdvJoraOPXcuqG8PqY2t9ruTVbPrImsi1Wtf6poB4xjkotmlJ/jEHzW61bwO68u/flTu4nI75wXpnvUdeDeU0w+UNFL6wz/hS2Mu/BE0W14Es8vh+KPO9FIe6z/Yd9Yl9RtRD9hmvU/jJ0jajwPYL6yppJd2CzrXgY04GyTakEPS28RHlncv3Y182yfebPKrTTPL9+PQMSf9p8P12xc9+5ynytXHUXx9+YVa7IbIYxPfbC/hanynPSTfRbFPo8dytay5A81Wq9Xr1yhB/rtpqtOozcwu1pepsfXa2Nd2am52fbrRmphcbc83q9GK9ttCcq7Sq883m3Ex9eW62FV0Q2BJaIs9NjrLl8Jlqy61qfeYKpcrs4vRMY7Zea9TmKo3pmVa1Ol+tLUzP1+ut5en5xnyt3qrN1Zaz+Eye5t0yn3Ak9NfKZ9LskMtnuk7hlfuQKMgtAAUlbkR55+qP2Hb2ixWFE2F3eVzrdp50od6vLvhet0tbw+1HF9g+DaoL3Je7xsaexj+Z2zKPf3yPjYdkjaHuqucRBz+e1slrwo+2bqbNHUTrbZuDZP+OdRL5xv5b3nE9aLR5bxbm5/57MgXrOGFpvrCrzSMW783S5DFGcR8Bf/G7jnankf1CH4Q074yfXXOzfseU2du00C8GXttQ1dWGtHFCpLNbArfuYN0l7VcrKmXNosvIUxZd1sbMki7SibuO9pcOd8BugXTf60i3VUnHtHjnPWKMUdqPxxgR7qfodE2UBZ+khfsSixSH9VKiOOSJdxxrN0xpp9dOUBzKh0/ix70z4xSHurSD4lAXd1Ic1u92isP9IrKva1vQO069F2zKZ2nsm3VPkquvQDsv6bWxvuQdtvURHiNr66PaOJjbLK6PsD92COIGWTv5c2ivnE6CVs9af4ZzHGKbND3fDbg8d6Lpg0t/9inpcb6C9Qd1RPIO6xq6Dx2RuOshDmXCIW3NPov+uGxDVp2RvNpa67aMuC7ddemYxje2OdaxSYVvzX4l7a3BOScsW9Ka8UvQD8rps9oXRrgnLQqjEGfoUzW1U15RhmNhd7ldfUAU8rZ5Xn9E28zrT1gHSWv9iIn7iPBrH+FDu8kjCn6/yKossF+AgX2bKORdqxG+867VoB/Gvhb6N2zX0EdjPwXrjP0pvl1S+xsEvWOOKPB8iOs20xFDOjzfjHR835LM8rago3334/l2i1z6j3Wr+cxc1+gXc/3gvmiWKX8HEwTZ25vIKWsfq52Gei3JF201B02+km5Dvp04l3zz3p7Sr3z5y9pj8e/KYGGo5JtVhiKLvOucqKNSpqQbjbSvqAVDbNCoUoYoyBoP31T+17R27cnnUW80ynK7t1a+EaV8dyaUrxDPNUVp//XRdHqu26K171p5PIFzPVxHUr/abfJaGST9/51xzID9dxRGw+7yHYvfVwYL6s0Q6K+Ohd3l1sZ8mJ7HDNo3tdim+fRorU0X6DdiabcjsZ5tVtIjHuvZf4I6kptKSkFyG5c4bc7V5WtKHOrWOPB8INZ3z7cNzGlrjRK0udQCxWE74TXUIvGMcagHefs5kUXeW8L4232M26KUQ7MTfNYBtlvBX492i30st1vtG31Mz+02rZ3LPixtPxrrN7aZcYrT1jO4zUTh7URPm/fHNrMNaG0OO2mt112jILIeAZ5Hww7vQl/0BW+hl3TC67gfXivCazHGxxvYxoEfKcsmSs/PY/TuDTd1+MYyYj1iuXncsA3iJP0IvBMeZR5pM8RtC/NhbSWsLQNgCV8lJf2WPvnSsDYT1riChe/we8AboE1oJ+Vgv4r7KytQp2jb0OfBvOzzSPp3gN9Wj5+1c1XY5mp9NfMSBLovMOgcjOd5k8w3/Aj9YuDVB6iyz4RydZ3U5WmMMS38aOfUaPUcrbfuCHrrTNsHgKch8Tk3rGcYp63Ru/wDrf+zvkUUaW8L8o2/tHbM7RzTvwva8RK1Y+2G1QLxFwTuOnTVOcpXeNXqZZziNL/V5RNtdfDl8ok0vtAv5j25RfrtKoNL77Qx6jr6pTOaX4plZ7/UNT6MAtfBhJJeGzOWKD3KXGuXPF7T1qDytkscyy0l9KVYDrSzvCartU/so/l8K+HlWPy7kjMszjUXpmfrteV6a2FxvjLPcz4ByGibB/pzteWZxfrMQmW5OTO3ODuXRv//B8aWIILprAUA",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "view",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3449819541828076517": {
            "error_kind": "string",
            "string": "Function tally can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vf3RjuU8cmALv0tf+0JBMhjkvMpgYPR4+gwaaLQHPfYBfhh+938rxIi1M8vJUu7c37lxrf5cFUvSVoQkMkT9x5/+11/+57//73/+69//n3/9v3/6b//9P/70P//x17/97a//+5//9q//8ud/++u//v3xX//jT8f5f6TIn/6b/NPjz7L+rOvPtv7U9Wdff9r6c6w/5/VnPdafK15d8eqKV1e8uuLVFa+ueHXFqyteW/HaitdWvLbitRWvrXhtxWsrXlvx2oqnK56ueLri6YqnK56ueLri6YqnK56ueH3F6yteX/H6itdXvL7i9RWvr3h9xesrnq14tuLZimcrnq14tuLZimcrnq14tuKNFW+seGPFG4945fyzrT91/dnXn7b+HOvPRzx9/Dkf8ez8U9afZf1Z159t/anrz77+tPXnWH9O/7Mcx/rz3L5yQgmoAS1AA3qABYyAuUCOgIgsEVkiskRkicgSkSUiS0SWiFwiconIJSKXiFwiconIJSKXiFwisufO4+AWTx4HCSgBNaAFaEAPsIAREJFbRG4RuUXkFpFbRG4RuUXkFpFbRG4RWSOyRmSNyBqRNSJrRNaIrBFZI7JG5B6Re0TuEblH5B6Re0TuEblH5B6Re0S2iGwR2SKyRWSLyBaRLSJbRLaIbBF5ROQRkUdEHhF5ROQRkUdEHhF5ROQz72Q84Ey8CySgBNSAFqABPcACRsCKXI8jQAJKwFklygktQAN6gAWMgLngzMELJKAERGSJyBKRJSKfOVj0hBEwF5w5eIEElIAa0AI0oAdE5BKRS0SuEfnMwTJPKAE1oAVoQA+wgBEwF5w5eEFEbhG5ReQWkVtEbhG5ReQWkVtE1oisEVkjskZkjcgakTUia0TWiKwRuUfkHpF7RO4RuUfkHpF7RO4RuUfkHpEtIltEtohsEdkiskVki8gWkS0iW0QeEXlE5BGRR0QeEXlE5BGRR0QeEXlE5BmRZ0SeEXlG5BmRZ0SeEXlG5BmR54rcjiNAAkpADWgBGtADLGAERGSJyBKRJSJLRJaILBFZIrJEZInIEpFLRC4RuUTkEpFLRC4RuUTkEpFLRC4RuUbkyMEWOdgiB9uZg1VO0IAeYAEjYC44c/ACCSgBNSAit4jcInKLyC0it4isEVkjskZkjcgakTUia0TWiKwRWSNyj8g9IveI3CNyj8g9IveI3CNyj8g9IltEtohsEdkiskVki8gWkS0iW0S2iDwi8ojIIyKPiDwi8ojIIyKPiDwi8ojIMyLPiDwj8ozIMyLPiDwj8ozIMyLPFVmPI0ACSkANaAEa0AMsYAREZInIEpElIktElogsEVkiskRkicgSkUtELhG5ROQSkUtELhG5ROQSkUtELhG5RuQakWtErhE5clAjBzVyUCMHNXJQIwc1clAjBzVyUCMHNXJQIwc1clAjBzVyUCMHNXJQIwc1clAjBzVyUCMHNXJQIwc1clAjBzVyUD0H9YQSUANagAb0AAsYAXOB56BDRLaIbBHZIvKZg62c0AMsYATMBWcOXiABJaAGtICIPCLyiMgjIo+IPCPyjMgzIs+IPCPyjMgzIp852NoJI2Be0M8cvEACSkANaAEa0AMsYAREZInIZw42PaEE1IAWoAE9wAJGwFxw5uAFEblE5BKRS0Q+c7CNE3qABTwi63HCXHDm4AUSUAJqQAvQgB5gARG5RuQWkVtEPnNQ6wk1oAVoQA+wgBEwF5w5eIEERGSNyBqRNSKfOajnr3Pm4AUjYC44c/ACCSgBNaAFaEBE7hG5R+QekS0iW0S2iGwR2SKyRWSLyBaRLSJbRB4ReUTkEZFHRB4ReUTkEZFHRB4ReUTkGZFnRJ4ReUbkGZFnRJ4ReUbkGZHnimzHESABJaAGtAAN6AEWMAIiskRkicgSkSUiS0SWiCwRWSKyRGSJyCUil4hcInKJyCUil4hcInKJyCUil4hcI3KNyDUi14hcI3KNyDUi14hcI3KNyC0it4jcInKLyC0it4jcInKLyC0it4jsOdhPkIASUANagAb0AAsYAXNBj8g9IveI3CNyj8g9IveI3CNyj8g9IltEtohsEdkiskVki8gWkS0iW0S2iDwi8ojIIyKPiDwi8ojIIyKPiDwi8ojIMyLPiDwj8ozIMyLPiDwj8ozIMyLPFXkcR4AElIAa0AI0oAdYwAiIyBKRJSJLRJaILBFZIrJEZInIEpElIpeIXCJyicglIpeIXCJyicglIpeIXCJyjcg1IteIXCNyjcg1IteIXCNyjcg1IreI3CJyi8gtIreI3CJyi8gtIreI3CJy5OCIHByRgyNycEQOjsjBETk4IgdH5OCIHByRgyNycEQOjsjBETk4IgdH5OCIHByRgyNycEQOjsjBETk4IgdH5OCIHByRgyNycEQOjsjBETk4IgdH5OCIHByRgyNycEQOjsjBETk4IgdH5OCIHByRgyNycEQOjsjBETk4IgdH5OCIHJyRgzNycEYOzsjBGTk4Iwdn5OCMHJyRgzNycEYOzsjBGTk4Iwdn5OD0HJwn9AALGAFzgeeggwSUgBrQAiJyicglIpeIfOZgf9wfzjMHL5CAElADWoAG9AALGAERuUXkFpFbRG4RuUXkFpFbRG4RuUXkFpE1ImtE1oisEVkjskZkjcgakTUia0TuEblH5B6Re0TuEblH5B6Re0TuEblHZIvIFpEtIltEtohsEdkiskVki8gWkUdEHhF5ROQRkUdEHhF5ROQRkc8c7O2EueDMwQskoATUgBagAT3AAiLyXJHlOJOwm5MklaSa1JI0qSdZ0kiaQZIOSYekQ9Ih6ZB0SDokHZIOSUdJR0lHSUdJR0lHSUdJR0lHSUdJR01HTUdNR01HTUdNR01HTUdNR01HS0dLR0tHS0dLR0tHS0dLR0tHS4emQ9Oh6dB0aDo0HZoOTYemQ9PR09HT0dPR09HT0dPR09HT0dPR02HpsHRYOiwdlg5Lh6XD0mHpsHSMdIx0jHSMdIx0jHSMdIx0jHSMdMx0zHTMdMx0zHTMdMx0zHTMdMxwSOa5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknkvmuWSeS+a5ZJ5L5rlknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknnvDkB1OmtSTLGkkzaAzzxdJUkmqSemwdFg6LB1nnltxmkFnni+SpJJUk1qSJvUkS0rHSMdMx0zHTMdMx0zHTMdMx0zHTMcMhzcVLZKkklSTWpIm9SRLGknpkHRIOiQdkg5Jh6RD0iHpkHRIOko6SjpKOko6SjpKOko6SjpKOko6ajpqOmo6ajpqOmo6ajpqOmo6ajpaOlo6WjpaOlo6WjpaOlo6WjpaOjQdmg5Nh6ZD06Hp0HRoOjQdmo6ejp6Ono6ejp6Ono6ejp6Ong7P83qS5/lFklSSalJL0qSeZEkjKR0jHSMdIx0jHSMdIx0jHSMdIx0jHTMdMx0zHTMdMx0zHTMdMx0zHTMc3ri0SJJKUk1qSZrUkyxpJKVD0iHpkHRIOiQdkg5Jh6RD0iHpKOko6SjpKOko6SjpKOko6SjpKOmo6ajpqOmo6ajpqOmo6ajpqOmo6WjpaOlo6Wjp8Dw3J03qSQ/HOJxG0gw683yRJJWkmtSSNKknpUPToeno6ejp6Ono6ejp6Ono6ejp6Ono6bB0WDosHZYOS4elw9Jh6bB0WDpGOkY6RjpGOkY6RjpGOkY6RjpGOmY6ZjpmOmY6ZjpmOmY6ZjpmOmY4vDlqkSSVpJrUkjSpJ1nSSEqHpEPSIemQdEg6JB2SDkmHpEPSUdJR0lHSUdJR0lHSUdJR0lHSUdJR01HTUdNR01HTUdNR01HTUdNR09HS0dLR0tHS0dLR0tHSkXmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p53jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmec987xnnvfM85553jPPe+Z5zzzvmeeWeW6Z55Z5bpnnlnlumeeWeW6Z55Z5bpnnlnlumeeWeW6Z55Z5bpnnlnlumeeWeW6Z55Z5bpnnlnlumeeWeW6Z55Z5bpnnlnlumeeWeW6Z55Z5bpnnlnlumeeWeW6Z55Z5bpnn3gw2qpMklaSa1JI0qSdZ0kiaQZoOTYemQ9Phed6cNKknWdJImkGe5xdJUkmqSeno6ejp6Ono6ejpsHRYOiwdlg5Lh6XD0mHpsHRYOkY6RjpGOkY6RjpGOkY6RjpGOkY6ZjpmOmY6ZjpmOmY6ZjpmOmY6Zji8kWyRJJWkmtSSNKknWdJISoekQ9Ih6ZB0SDo8z9WpJ1nSSJpBnucXSVJJqkktKR0lHSUdJR0lHTUdNR01HTUdNR01HTUdNR01HTUdLR0tHS0dLR0tHS0dLR0tHS0dLR2aDk2HpkPToenQdGg6NB2aDk1HT0dPR09HT0dPR09HD4d385jD+Z+606kYJ/luXCRJJakmtSRN6kmWNJLS0dPR09HT0dPR09HT0dPR09HT0dNh6bB0WDosHZYOS4elw9Jh6bB0jHSMdIx0jHSMdIx0jHSMdIx0jHTMdMx0zHTMdMx0zHTMdMx0zHTM5Sje7rNIkk7HdKpJLUmTepIljaQZdJareTg9HLM6laSa1JI0qSdZ0kiaQWe5WpSOko6SjpKOs1zN5tSTLGkkzaCzXC06Hd2pJNWklqRJPcmSRtIMOsvVonS0jHwWqWlOI+n8t/67nfm7SJJKUk16RJHDfxBfH2BhBw0c4Ez0lQIWClhOFMcKNtBtfvR91YDDD6avG3D4/vnKAQtnoq8esFDAAnpcP9d8zYCFlujv+691Kwwc4Ez09/4XCljACjZQQWwT28Q20+ZtOIECFrCCDVSwgwYOEJtgE2yCTbAJNsEm2ASbYBNsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxVWwNW8PWsDVsDVvD1rA1bJ6F0hwNHKBvw3naX0vhLBSwgBVsoIIdNHCA2AybZ6GvaXEtl7Owgg1UsIMGDnAm+roeC7H52h5ijhVsoIIdNPC0FXGciZ7zCwUsYAUbqGAHDcQ20+YtOYECetziqGAHDRzgTLxW4LlQwAJWEJtgE2yCTbAJtoKtYCvYCraCrWAr2Aq2gq1gq9gqtoqtYqvYKraKrWKr2Cq2hq1ha9gatoatYWvYGraGrWFTbIpNsSk2xabYFJtiU2yKrWPr2Dq2jq1j69g6to6tY+vYDJthM2yGzbAZNsNm2AybYRvYBraBbWAb2Aa2gW1gG9gGtoltYpvYJraJbWKb2Ca2iW2m7Vo1aKGABaxgAxXsoIEDxEYtqdSSSi2p1JJKLalXLamOHTRwgDPxqiUXeomfjhVsoIIdNHCAM/G6PbhQQGwVW8VWsVVsFVvFVrE1bA1bw9awNWwNW8PWsDVsDZtiU2yKTbEpNsWm2BSbYlNsHVvH1rF1bB1bx9axdWwdW8dm2AybYTNshs2wGTbDZtgM28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1sE9vENrFNbDNt7ThAAQtYwQYq2EEDB4hNsAk2wSbYBJtgE2yCTbAJtoKtYKOWNGpJo5a062akO3bQQC9X5jgTr5uRCwUsYAW9OLrtuhm5sINuG44DnIleS861UIq3GAUW8LTV6tjA01abYwcNPG3Vd9NryYVeSxa6zbfBa8nCCjZQwQ56XN9Nrw/tcDwjNN90rw8LFezgub3Nd8jrw8KZ6PVhoYC+vepYwQa6zXfT68NCA912/d2Z6PVhoYAFrKDvm58EXh8WdtDAAc5Erw8LBSyg2/xQe31YqGAHDRzgDPSOo0ABC1hBtzVHBTto4ABnoteHhQK6bTpWsIEKdtDAAc5Erw8LBcRWsBVsBVvBVrAVbAVbxVaxVWwVW8VWsVVsFVvFVrE1bA1bw9awNWwNW8PWsDVsDZtiU2yKTbEpNsWm2BSbYlNsHVvH1rF1bB1bx9axdWwdW8dm2AybYTNshs2wGTbDZtgM28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1sE9vENrFNbDNt/ThAAQtYwQYq2EEDB4hNsAk2akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSb8WKj4cT9u5vFPp12LFF3bQwAHOxGvZ4gsFLGAFsTVsDVvD1rA1bNdSxs1RwAJWsIEKetzzgt2vRYuvFYkL6BGGYwMV7KCBA5yJ1zLGF7rNf4BrKeMLK3jauv8sXh8WdtDA09bP+x1vcnoM4ToWsIIN9Lh+HLwS9GvxZY/rh8QrQfft9UrQfcu8EpiLvRIsLGAFT5v5lnklWNhBA0/b2exevNnpMfLr6Iru6ApzdMV0PBWjOCrYQQMHOBM9/ReetuHb4Om/sMVZ4g1PgR00cIAz0XN+oYAFrCC2gs1zflxLXxs4QN8h/7ue8wsFLGAFG6hgBw0cILaGzXPeJ229FyrQbcOxgW7zX9Oz22d4vflpoWf3QgHPuFMcK9hABb1OXv/MwAHOxOtO4UIBC1jBBtrVB1G88ekx5O84Ez3lFwpYQN8JP8085Rcq2EEDBzgT/ZZgoduaYwEr6DbfdC8EPhvsrVDi07zeCxU4wJnohWChgP7A6qRJPcmSRtJc5O1Ixed6vR8psIINVLCDBg5wJvoiyAuxFWwFW8FWsBVsBVvBVrBVbBVbxVaxVWwVW8VWsVVsFVvD1rA1bA1bw9awNWwNW8PWsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWyGzbAZNsNm2AybYTNshs2wDWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vENtPmi3IFCljACjZQwQ4aOEBsgo1aMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSUza0k9spbUI2tJPbKW1CNrST2yltQja0k9spbUI2tJPbKW1OPAJtgEm2ATbIJNsAk2wSbYBFvBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbBVbxVaxVWwVW8PWsDVsDVvD1rA1bA1bw9awKTbFptgUm2JTbIpNsSk2xdaxdWwdW8fWsXVsHVvH1rF1bIbNsBk2w2bYDJthM2yGzbANbAPbwDawDWwD28A2sA1sA9vENrFNbBPbxDaxTWwT28RGLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWyJXS1VHAArqiOTZQwQ4aOEAf9jrJBwgukiRXdccKNtBVw7GDp0p8FzyfF85Ab4oMFLCAFWyggh00cIDYBJvn8zl8Ub1VMrCCDVSwgz7C5jSSZpAPHV4kSSXJI1ZH39Lm6Ft6fVztAAUsoG+pOTZQwQ4a6DbfBs/OCz07F562cjgWsIKnzb8b542Pgaet+A55di4c4Gnzv+rJeZEklaSa1JI8oh8iz7X1kTn/192xgBVsoG+p76Dn2kIDBzgT/bp9fchOkkrSqfKt8mv2RZrUkyxpJLlknui5vVDABp7/vvrB93xdeEbwQ+tX4Isk6dzK6kfP83VhA88Nrb4tnq8LXXV9qG+AM9DbEcvZJ1K9HfFxajm6bTj6QRHHBirYQQMHOBM9XxeetvOzNvX6uOHZ8FGvzxuePQT1+pxhu74o6HF9I/1Ku3Am+pV2oYAFrKAH8930VF04Ez1VFwpYwAr6P/MD5Tm3UMAC+j+bjueRPCf7ao0PNdUaX2qqNT7VVGt8q6nW+FhTrfG1plrjc021xveaao0PNtUaX2yqVdOh6dB0aDo0HT0dPR09HT0dPR09HT0dPR09HVe6XXgeED8e+cFCvljIJwv5ZiEfLeSrhXy2kO8W8uFCvlzIpwv5diEfL+TrhXy+kO8X8gFDvmDIJwz5hiEfMeQrhnzG8PpY4TllWq/PFS4s4BnonJis10cLz8nRen22UK8I57adk431+gjhOYFYr88Qdv+7fmVb2MFz5851HOv1OcKFM9HzZ6GABaxgA92mjh008LSZ75unkvnmeCotPOOa/12/6i1UsIPGPxvgTPQMXIitYfMMXNjADtr1wbB6fajwohnkiXeRJJUkD94dG6jgSPRLnfkx9Eud+W/ul7qFDVSwgwYOcCb6pc78rPFr3cICnrbh55Kn30IFT9vwM8wzcOEAZ6In4UIBC1jBBiqIbWAb2Aa2iW1im9g8I4efd56SCxX0uOdv7v1y5Zy7rd4ZF+ib0x19c8xxgDPRr2rnbGr1HrhArw/F0YuL267PeLri+pDnhQOcidfnPH0brg96XljACjZQwQ56XN/e64O6FwrocX3Tr8/qXthABTto4ABn4vW53Olo4ABn4vXZ3AsFPHPsfDe1Xh8NXNhABTto4JnN/uR1fUDwQv+E4EIB3ea/m3+605/HvCOs+oOVd4QFDnAm+kc8FwpYQN8L/439Y54LFXSb/27+Sc+FA3SbHx3/sOdCAQtYwQYq2EG/Yvsxuz70eR6Hfn3Gszo2UMEO+j3EuZv9+nznhQIWsIINVLCDvmXqOMCZeH3S80IBXdEdG+jBztO+X1/nHI4uno6n2J+PvNkqcFzfQqzea3XRmUyLJKkk1aSWpEk9ySXiOMCZ6NeehQIWsIINVNDj+u/p93T+XOE9Vn6T7S1Wi1qSJvUkS/KIvv2eVRd6Vi0UsIAV9MPswTx//OHO14oK9AhOJakmtSRN6kl+TP2X9cxZOBM9cxYKWECP6ieEZ4M/qPliUH5H7/1RiyTpPKDmVJNakib1JEtySXGciZ5GCyt47uf5ikD1tqfAAZ6beR5E73paJEklqSa1pHPH/QnSG54CDRzgTPRv3y4UsIAVbCC2is3zzp9MveEpcCb693D9IdUbngLdNh1P29kfVL3hqfrTpjc8BXbwtHkuehtU4Gnzk93boOp1dPzLZB7WP012UU1qSZrUkzyi/9p+WbtOmutbuP4Xrq/hXqjguaX+1GTXN3EvHOBMvL6Me6HH9R30VPPHDO9fqv5s4f1LgTPRE3ChgAWsYAMVdJsfOE/DhQN0mx9OT8OFAhbQbX7M/AK2UMHz8Pqu+WfJLhpJD5Ufg+vrgBdJUkmqSS3JJcOxgwaORL/GLfTNnI4KnhH86c37owIHOK9vl9X8JmDNjwLW/Cpgzc8C1vwuYM0PA9b8MmDNTwPW/DZgzY8D1vw6YM3PA9b8PmDNDwTW/EJgzU8E1vxGYM2PBNb8SmDNzwTW/E5gzQ8FVm+EqmebbPVGqMAGnoesV8cOGuiHTB1nomdo9+Pvl8iFBaxgA93mP5CPjiw8bea/il84zbfMs9f8zPARkoUCnjZ/4PVGqMAG6vWBuHp9WPAiSxpJM8g/LniRR2yO55b6Y7G3NVV/rPS2psCZ6Nm80LfUd9uzeWEFG6jgw3adobFIeh2x4Fr1jiR/aPKGpEWWdG7T8KPnX4x39HakQAELWMEGKthBAweITbAJNr8R9edFb0cKbKCCHTRwrmPgLUiLJMnjV8cKNlDBDhroe6OOM9Gvsgt9b7pjAdv6kWasg15nrINeveXIhx6842jRDPKL6rhQwAJWsIEK+q4MRwMHeB6182yasYBqnbGAap2xgGqdsYBqnbGAap2xgGqdsYBqnbGAap2xgGqdmo6ejp6Ono6ejp6Ono6ejp6Ono6eDkuH3/Ge7dbVO4sCK3ges3n9XQU7aOAAZ6Kn80IBC1hBbAObX5yn54BfnBcOcCb6xXmhgAWsYAPd5kniT5cLDTwPo5+PvojZg9q1iNlFklSSapJHvNC3tJ3oSX4OnDTvEwosYAV9S81RwQ4aOEC3zRP9aXOhgAWsYAMV7OD5BHCOPjTvE2rn6EPzPqF2+PaeKR8oYAEr2EAFO2jgALE1bA1bw9awNWwNW8PWsDVsDZtiU2yKTbEpNsWm2BSbYlNsHVvH1rF1bB1bx9axdWwdW8dm2AybYTNshs2wGTbDZtgM28A2sA1sA9vANrANbAPbwDbc1k+cB+g2T5FZwAo28LSdI0zN+4QCDRzgDPQ+oUABC3jazlaA5n1Cga4ojgYOcCaKK6qjgAWsYIu6I1cBubCDBg4wy5VcBeRCAQuo101Xu75veJElPYL26+/NIP/u2UW+/RcWsIINVLCDp8kPoX/97KIZ5BXiHGBr3v0TWMB6fTis5YcOW37osOWHDlt+6LDlhw6bxAfQWn7osOWHDlt+6LDlhw5bfuiw5YcOW37osOWHDlt+6LDlhw5bfuiw5YcOW37osOWHDlt+6LB5n087xxGb9/kEGuin1/V3Z6LXgoUCFrCCDVSwg24bjgOcif6dJD9T/DtJF5WkmtSSNMkjnlcmbxhqxf+rZ3bxn98ze2EDFTy3tHimeGYvHOAM9I6hQLc1xwJWsF1fnWolvnrWSnz1rJX46lkr8dWzVuKrZ63EV89aia+etRJfPWslvnrWiqRD0iHpkHRIOiQdJR0lHSUdPtJ2jnY2X0mtnYOMzVuHAjto4ABnot8SLBSwgBXEVrFVbBWb3xKcY57NG4oWesIvFLCAFTzjnpP97VoSzX+5a5EBp/MfVf+9/cq+sIEKdtDAAc5Ev7JXV/iVfWEB3eaH36/sCxXsoNvObPaeoXa2xTRvGgosYAU9rh8Fz9tz8LF551BrfkA8b5tvr+dt8y3zvG0u9mv4QgEL6DMKvmV+DV+oYAfd5j+rX7jVN8cv3Oqb4+mtfnJ6eqtvjqe3+g55ei9UsIMGDnAGeoNRO0fFmjcYBdY4R7yrKFDBU+GXOu8qChygD2/73/UL90IBC1jBBirYQQMHiK1gu4bTm2MB3VYdG+i24uhx1XEmekIvFNDjdscKNlDBHsW6Xgl94QBn4pXQFwpYwAr60fFf0+/mFw5wJvrdfPff2O/mFxawgm0NYrWrQ2lhBw0c4Ey8BuEuFNCPznRUsIMGDnAmes77xdBXKwssYAUb6DM5fmp4HnvZ97akZn4SeB4vrKBH8HPH83ihTxD5DnkeLxzgub3mv7yn9EIBC1jBBiroNv8JPaUXDnAGeh9ToIA+YD8dNY5Du6a5LjTQ4w7Hmeh5vFDAcy/O0ZXmPU+BDTxt54Bc856nQANPmw8deM/TQs/jhW7zTfc8Psfvmvc8tXOcrXnPUzsH15r3PAV20OP6cfA8XihgAT2u75tnrJ8l3t0UOMCZ6Gm60KcXLlSwgz5B4ft2NTJdOBOvVqYLBSxgBRuooB9UP2Z+Eb7QL8ILBTx3fvqP5RfhhQ1U0Ofk/Oj4TNfCAc5En+laKGABK9hAn1n0A2UDPPdi+unpybtQwAL6Xvg/8+RdqGAHDRygz2P6kfQhtoUCFrCCDVSwgwbGXHDzhcDavLCAFWyg70Vz7KCBA/S9OH83vWapLxSwgBVsoIId9N/iTD1f8itQwAL6XnTHBirYQQMHOBM9eRe6zRwLWMEGum04dtDAAUajQ/NGrEABC1jBBirYQUu8mkWKo+/FdCxgBX262o/6NV/tJ8E1YX2hgQOciWfOBwpYQJ8b9xPGJ718KOlqxPLnPm+5Uh9K8qW5AhuooEfwo24GDnAmjgMUsIA1t+HqJblQwQ4aOED24monuVBA3wv/5afvhR91n7FeaOAAz73wkS1fhCtQwHMvfJDL27MCG6hgBw0coNvOE8abtgIFdFt1rGADFeyggQN023k+eNNWoIBuU8cKNlDBDho4QLed544vwhUooNuGo7cA+PH1WW8fzfC+MPV08r6wQAMH6M0Gvhc+9+2P+94app6b3hsWWMEGus03p7ltOnpjg29ZG+BMPHM+0PfNHAtYwQZGz1vr17sBFxo4wJl4vR9woYAFrKB3Z/iR9JnuhQOciT7Z7ddjbx4LLGAFG6hgBw0ciV4J/LLoPWWBFfS4/hMOBTto4EicHtd/bs95Hz3wFrLADho4wLl6jptdTckXCljACjZQwQ5aome3j1X4GluBBayg78Vw9F/o/DW9mSxQwDOCj3Z4P1lgA8899jEQ7x1THwPx3jH1MRDvHbuOg/eOBRawgg1U0OOq40z0LFwoYFkN+M2ulwIubKCCHTRwgDPR34VbeMb15DVtoILn+dCuv2ug78X1F2aiX2MXnnvhIzneQRZYwfPo+HOAd5AFdtDAAZ429aPjWbhQwAJWsIEKdtDj+i/k7wN4jfJeMfURIu8VCzTQt8zPvjETp2+ZHwfPt4UF9LYlV3gWLlSwgwYOcAZe/WI+1HM1jC0sYAUbqGCPPfbv/qkPAPmH/wIFLKDHrY4NVLCD5znpl5lrqa2FM9Ff7lkoYAEr2EA/Os1xgDPx6h+70PfC/9nVQXZhBRt4ZoBc/6yDBg5wJl6vtF4oYEk8L3XmxcYbvQIbqGAHDRzgTDxTL1BAbB1bd5v/8l3BDho4wJloHtd/WKtgAxXsoIEe1xxnos8HLRTQbcOxgg0cGddbvy6cByggmz7Z9NnSNhXsoIEjxXMGeq/YQv+MnI9textW4ADniWcwb8ma1z/zb8ktLGAF24nTUcEOWqJ/Ps4rra/0NH0k3XuuAhU0/u65kV5pvdtqoX8nbqGABaxgA13RHDtooNvUcSb6l+UWuq06FrCCDWSHtIMGDnAm9gMUsIAcvs7h87y4jpnnxYXnJSlQwAJWsIEKdtBAbIZtYBvYBraBbWAb2Aa2ge1KJz+NrnRyvNLpQgELWMEGKthBA7HNsOlxHKCABaxgAxXsoIEDxCbYBJtgE2yCTbAJNsEm2ARbwVawFWwFW8FWsBVsBVvBVrBVbBVbxVaxVWwVW8VWsVVsFVvD1rA1bA1bw9awNWwNW8PWsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWyGzbAZNsNm2AybYTNshs2wDWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vERi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItd9iTj6nUJzNHCAM/G6L7lQwAJWsIEKYhvYBraBbWKb2Ca2ic1ryXlrqd4HFthBAwc4A70PzM5nf/U+sMACnrbzwVyvPrDzCVuvRrCFHTRwgDPRa8lCAQtYQWyCTbAJNsEm2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYGraGrWFr2Bq2hq1ha9gatoZNsSk2xabYFJtiU2yKTbEpto6tY+vYOraOrWPr2Dq2jq1jM2yGzbAZNsNm2AybYTNshm1gG9gGtoFtYBvYBraBbWAb2Ca2iW1im9gmtoltYpvYJraZNm86CxSwgBVsoIIdNHCA2KgllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVa0qgljVrSqCWNWtKoJe2qJdWxgwYOcCZeteRCAd1mjhVsoNsOxw6eNrtwgDPRa8lCAQtYwQb6Hd507KCBA5yJXksWCljACjYQW8VWsVVsFVvD1rA1bA1bw9awNWwNW8PWsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWyGzbAZNsNm2AybYTNshs2wDWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vENtOmxwEKWMAKNlDBDho4QGyCTbAJNsEm2ASbYBNsgk2wFWwFW8FWsBVs1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLdHrvsQcDRygXwPO8urte1el9fa9wALmNUC1gQp2/q6BeQ3Qqyj4373SvzsOcCZe6X+hgAWsYAMV7CA2w2bYBraBbWAb2Aa2gW1gG9gGtoFtYpvYJraJbWKb2Ca2iW1im2nrxwEKWMAKNlDBDho4QGyCTbAJNsEm2ASbYBNsgk2wFWwFW8FWsBVsBVvBVrAVbAVbxVaxVWwVW8VWsVVsFVvFdq2Jcd7LeSefnW9lqHfyBRawgg1UsIMGDnAmKjbFptgUm6f/+TqIeidfYAcNHOBM9FuJ87UC9U6+wAL2KBX9KhUXDnAm2gEK6MEurGADfdOHYwcNPG3n2x7q68Qt9FKxUMACVrCBCnbQQLf5znupuNBLxUIBC1jBBrqtOnbQwAHOQG8ADBSwgG4zxwYq2EEDBzgTvVQsFLCA2ASbYBNsgk2wCbaCrWAr2Aq2gs1LxfnejPqidIGW6EVhoUeYjg1UsIMGDnAmevovFLCAp+18r0O9hTBQwQ4aOMCZ6Om/UMACuk0dG6hgBw0c4Ez09J++F57+CwuIrWPr2Lw+rL9r4ADnuTqOb/q1UM6Fknhm7Dj8rD4zNrCB+eRujBMY4wTGOIExTmCMExjjBMY4gTFOYIwTGOMExjiBMU5gjBMY4wSDcYLBOMFgnGAwTjAYJxiMOQ7GHAdjjoMxx8GY42DM0VsIx/l6hXoLYWAFG6hgBw0coP9u57XQWwgDBSxgBRuoYAcNHCC26jZzFLCAFWyggh3EVrFVt52npzcWjvOdCvXGwsACVrCBCnbQwAHORMWmOb5z9S4urKDb/Df2da8WdtDAAc5EX/xqoYC+b/4b+/pXCxuoYAcNHOBM9OxeKCA2w2bYDJthM2yGzbB51Thf8VBfqm6I/7BnfRjFj+9ZHwIHOBPP+hAoYAEr2EAFsU1sE9tMm7cxBgpYwAo2UMEOGug2cZyJcoAV9AjF0cABzkTP+YUCFrCCDVTQbepo4ABnouf8QgELWMEGuq07dtDAfMK+Frm78JpnuNBtFxawgg1UsIMGDvDct+q/kOf8QgELWMEGKthBAweIrWPr2Dq2jq1j69g6Ns/u6ueO53H1H9bzuPrx9TxeqGAHDRzgTBwHKGABsQ1sA9vANrANbAPbxDaxTWwT28TmOV/9h/WcX2gL+1q77kKPMBwbqGAHDRzgTPQ8XihgAU/b2X3evSdynG3k/bhWpnS8lqa8UMACVrCBCnbw3N5zxeTuPZGBM9HzeKGABaxgA93WHTto4ABnol+7FwpYwAo2EFvD1rA1bA2bYlNsik2xKTbFptg8j5ufMJ7HC2eiZ+xCj+A/t+fmQgMHOBP9erxQwAJWsIGnTf2M8jxeaOAAT5v6qeF5vFDAAlawgQp20EC3+VnieXyh5/FCAQtYwQYq6Db/La7Vai8c4Az0PsdAAQtYwQYq2EEDB4hNsAk2wSbYBJtgE2yCzevDOSTTvc9xodeHhRX0CMPRwAHORM/5hQIWsIINVPCMew5+d+88HOeDTffOw0AFO2jgAGeiZ+xCAc8tO1+06t55GNhABTto4ABnol95ux9qv/IuLGAFG6hgBw0c4Ew0bIbNsBk2w2bYDJthM2yGbWAb2Dy7u58wnt0LG2iJnrHdf27P2IUFrGADFeyggQOcgd5NOM65ju7dhIEFrOBpO0d6u3cTBnbQwAHORM/YhQIW0G3FsYEKdtDAAc5Ez9iFbuuOBaxgAxXsoIEDnIme3QuxVWwVW8VWsVVsFVvFVrE1bA1bw+b14Rw27t5NGKjgSPScNz8fPOcXVrCBCnbQwAHORM/5hR53OjZQwQ4aOMCZ6Nm9UMACYjNshs2wGTbDZtgGNs/u4SetZ/fCCjZQwQ4aOMCZ6JXgXGOpey/gGH4qeyVYWMEGKthBAwc4A69eQE/0qxdwYQHdpo4NVLCDBg5wJnolWOj7Nh0LWMEGKthBAwc4E70SLMRWsBVsBVvBVrAVbAVbwVaxVWwVm1eC6QfVK8FCBUeiZ/e5mlL3/r7ACjZQwQ4aOMCZ6Ff/C/16PP188Ovxwgq6rToq2EEDBzgTPWMXCljACqLw1DtXU+reOhdYQP9nfkZ56i1UsIMGDnAmeuotFLCAKDyHzrWQuvfABQro/8wcK9hABTto4ABnoufQQgFReDKcqyl1b2Zb6Mmw0P/ZdCxgBRuoYAcNHOBM9GRYiMJf+D1XU+relRY4E/2F33Op9+5daYEFrGADFeyggQOciYrC3+c951u6N50FdtCDVccBzkR/n3ehgAWsYAMV7CA287jN0eOqYwEr2EAFO2igD6j4vl3DTY7XcNOFAhawgg1U0I+OZ8CYifMAfS/8TJ0FrGADFeyggQOcgd5IFiigxx2OHnc6dtDAAc5EOUABfai9O1awgQp20MABzsQSE39dSwUbGJNjXbNpvWs2rXfNpvWu2bTeNZvWu2bTetdsWu+aTetds2m9a8VWsVVsFVvF1rA1bA1bw9awNWwNW8PWsDVsik2xKTbFpjHx11UV7KCBA5yJ19dTLhQwJv669go2UMEOGjjAmWgHKCA2i4m/7p1mgQp20MABzsSBbWC7JqP9tB8x8de90yxQwQ4aOMCZOA9QwAJiuyajPQOmgh2Mib/unWaBMfHXvdMsUMACVrCBMRXXvdMs0MABzkQ5QAELWMEGYhNsgk2wCbaCrWAr2PyKfs4Mdu8eu4pNLzEV13s9QAELWMEGKthBAweIrWFr2Bq2hq1ha9gatoatYWvYFJs//hb/Yf3xd2EFOxgTf907wgIFLGAFG6hgBw0cYEz8dW8ZCxSwgBVsoIIdNNBt/st7zl/oOb9Q1hxgv1rGFlYwJv66t4wFdtDAAc7Ea4L5QgFjKq73WcEGKthBAwcYE3/djgMUsIAVbKCCHTRwgNiuKShxzHsjbwPzKbPubWCBA5yJ5QAFLGAFG6ggtoKtYCvYKraKrWKr2Cq2iq1iq9g8533iz1vGFrYDrGBO/HkbWOAAc+LP9AAFLGAFG6igTxX5j9Vz4s96ASvYQAU7aOAAc5rxau3yybyrtWthASvYQAU7aGBOxflKcgvHAQpYwAo2UMEOGohtYJvYJraJbWKb2Ca2iW1im9hm2ryR7Jr480aywAIqmBN/3hy2UA5QwAJWsIEKdtDAnPi7msMuvCaQLhQwJ/6u5rCFDVSwgwYOMKcZr+awhTnxdzWHLaxgAxXsoIEDzKm4qzlsoYAFrGADFeyggQPEptgUm2JTbIpNsSk2xabYFFvH5vXBJ/6u5rCFFexgTvxdDV8LBSxgBRuoYAcNzGnGcU02+Rk1cuLvau1aOMCc+LtauxYKWMAKNjAn/q7Wrn6hgQPMib+rtWuhgAXMqbirtWuhgh00cIA5FXe1di0UsIDYBJtgE2yCTbAJtoKtYCvYCraCzbPb76OuNrCFOR14NXwtzIm/q7VroYIdNHCAOfHnrV2BAhYwJ/6u1q6FCnYwJ/6u1q6FOfF3tXYtFLCAFWyggjnxd7V2LRxgTvxdrV0LBSxgBXMq7mrtWthBAweYU3HXV00XCljACmIzbIbNsBk2wzawDWwD28A2sA1sXh984u9qA1uY04FXw9fCnPi7WrsWdtDAAcbEn10NXwsFLGAFYyrOroavhQOciXKAAhawgg1UEJtgE2yCrWAr2Aq2gq3ExJ9dzWELO2jgAGfiNYF0oYAF9Omq5hgTf3Y1hy3soIEDnIleCRYKWMC65gDtWjBvoYIx8WdXc9jCAc5EPUABC1jBmIqzqzlsYQcNHOBM7AcoYAEriK1j69g6to6tYzNshs2wGTbDZti8Ekw/qF4JFo7Ea+7rwpj4s6s5bGEHDRzgTJwHKGABY5rRrnatcw7QrnathR2MiT+72rUWzkQ5QAELWMEGKthBFNd0VXNsoIIx8WdXj9bCAc7EeoACFrCCDVQQxTVh2x0r2MCY+LOrXWuhgQOciXqAAhawgg1Ecc3zDscCVjAm/uzqu1rYQQMHOBPtAAUsYAVRjGPNAZo3UAUWMCb+zBuoAhXsoIEDnInzAAUsIIprssnP9Wuy6cIZWI6Y+LNyCFjACjZQwQ4aOMCZKNikrplB864pn9cz75oK7KCBA5yJvh70wpj4s6tramEFG6hgBw0ciVXWHKB5f1RgBWPiz7w/KrCDBg5wJrYDFLCAFcR2zRQPx5j4s9Jmoh6ggAWsYANj4s+urqmFBg5wJl7vJV0oYAF9SsdPgmsC6UIDY3LMWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNWEHNrq6pK7PmAGPiz7xrKlDAAlawgTHxZ1fX1EIDBzgT5QBjcsyurqmFFWyggh00cIAzsRwgtmsFtepYwQa6TRw7aOAAZ2I9QAELGJNjdnVNLVSwgwYOcCa2AxSwgNgatoatYWvYGraGTbH5pfmcdLNKJfBV0Xw2ynxVtMCZ2A9QwAJWsIEKdhBbx9axGTbDZtgMm2EzbIbNsBm2a7LJf9hrsulCARsYk2N2tWstnInzAAUsYAUbqGAHY3LM6vWG4oUxFWdXl9dCAQtYwQYq6LbuaOAA55pes7XS2YUCuu3CCjZQwQ4aOMCZWGJyzK7msIUFrGADFeyggQOciRVbxVaxVWwVW8VWsVVs17SSOObdiveJ+WyUeZ9YYAcNHOBM1AMUsIAVxKbYFJtiU2yKrWPr2Dq2jq1j69iuNxT9h+0GjkTP7oUxOWbNFOyggQOcieMABSxgBX06xX+sEZNj1q4JpAsFLGAFG6hgBw306R8/Ca4JpBP1OEABC1jBBioY01XmLWOBA5yJcoACFrCCDVQQm2ATbIKtYCvYCraCrWAr2Aq2gu16m9EcZ2I9wArG5JhpNXCAM7EdoIAFrGADFfQpksPRwAHORI3JMdNrAunCAlawgQp20MABxjt4djWHLRSwgBVsoIIdjOkqu5rDFs5EO0ABC1jBBirYQWyGzbANbAPbwDawDWwD28A2sA1s19uMfkZdbzNeKGADY3LMroavhTEVZ1fD10IBC1jBBirYQZ9OOc+oq13Lnxmudq2FHTRwgDOxHKCABfTpn+LYQAU7aOAAZ2I9wJiusqu1a2EFG6hgBw0c4ExsB4itYWvYGraGrWFr2Bq2hk2xKTbFdr3NaI4NVHAk9pgcs6u1a2EFG6hgBw0c4Ey0A/TJBT+jrgmkCyvYwJgcs6u1a6GBA5yJ4wAFLGAF3eZnyTWBdGEHDRzgTJwHKGBMV9nV2rWwgQp20MABxuSYXa1dCwUsYAUbqGAHDRwgNsEm2ASbYLumoMxRwQ7OxJKTY1dr18IGKthBAweYU3FXa9dCAXNy7GriWthBAweYk2NXE9dCAQtYQWwNW8PWsDVsDZtiU2yak2NXw9fCBirYQQMHmFNx1g/Qp3SaY06OXc1hCxuoYAcNHGBOxV3NYQslptfsWhfwwgq6TR0V7KCBA8ypuKs5bKGAOV11NYctbKCCHTRwgDk5djWHLRQQ28Q2sU1sE9vENrHNtF3NYQsFLGAFfa7jcFSwgzNRcnLsag5b2EAFO2jgAHMq7moOWyjgOeItFxo4wJno31tcKGABK9hABbFVbBVbxdawNWwNW8PWsDVsDZuPup/fPDdv+AqciT7qvlDAAlawgQq6TR0NHKDbzlrtDV+BAhawgg1UsIOnzYe8fDWwwJnor3UtFLCAFWyggh3EZtgM28A2sA1sA9vANrANbAPbwObTaz5w5+1lgQI20CMUxwHOQG8ZCxSwgBVsoIIddFtzHOBM9Dm1hQIWsIINVNBt3dHAAbrtvM5fX15dKGABK9hABTt42nzIy1cOC5yJXh8WCljACjZQwQ5iq9gqtoatYWvYGraGrWFr2Bq2hs3rg4/sXR9sXShgAz1CdRzgTPScXyhgASvYQAU76DY/Hzy7fTDOm8MCPa7/bp7dCxvocYdjBw0c4Ez07F4oYAEr2EBsA9vANrANbBPbxDaxTWwT28Q2sU1sE5tXgvq4Sg9vJAsUsIAVbOA5mXc+rg/vE5vnmOPwPrHACp7/7BwxHN4nFthBAwc4E6+PKV8oYAEriMJz8xxSHN7wFVhA/2fVsYEKdtDAAc5Ez82FAhYQxdV14ttwdZ1cKGD074yrc2thAxXsoIEDnIn9AAVEcXWdNMeZeHWdXBj9O+NqwVpYwQYq2EEDBzgTxwGiuPquuuMAZ+KM/p2x+q4uLGAFG6hgBw0cYHQLjWslroX+z4ajgQOM/p2x2rUuFLCAFWyggh00cCQWFJ4MZ4PP8HatQAOjf2d4u9bCeoACFrCCDVSwgwaiuHpGimMFGxj9O0NaBw0c4EzUAxSwgBVsILZr+YHmGP07Q/oBCljACjZQwejfGVeX18IBzkTPt4UCFrCCfnS6o4EDjP6dsdrALhSwgBVsoIIdNHCA2K6GL8+AGf07Y/V+XahgBw0cYHQLjWt1rfM5YFyray0sYAUbqGAHLfG6fDXHCjbQrwzq2EEDBzgTr8vXhQIWsIINROFnlPk2+Bm1sIPnNpjvhT8PLZyJfse0UMACVrCBCnYQm2EzbH7unMNuwzuL5jkmNrydaP1Xv8kx/zX9Juf89MHwdqLACjZQwQ4aeG7OObA0vJ3oQm8nCnRbcXRbdXRbc3SbOmpsurcTBeYOebfQPGcqhncLBVawgQp20MABzkQ/dxa6zffCz53ue+HnzsIGKug2300v/AsHOBO98C8UsIAV9Lh+zLyudz9mfutzzgcMb/uZ53D/8LafwAYqOBK9bHc/vl62F3qE6ei/hR8SL8Xmh8RL8cIK+onox+FKnAs7aKCfyr5vV+I4Xonjf+FKnAsLWMGWx8ETZ2EHLdFL8bXHgz0e7LGXYkdvNZnntN3wVpPAAZ7b67fj3moSKOAZ9/wW1PBWk8CW6OuMeNm+Pmi38GyY8Qp+fdBuoYAFPAdRvUBfH7RbqGAHDRzgTPR1RhYKWEBs/pWJs4tuXN+rWzgT/SsTCwUsYAUbqGAHsXkX6DnWNq7v1V3oXaALBSxgBRuoYAcNxGbYBjbv4Sy+Zd7DWa7/OhO9h3OhgOeWnSM54/ra3MIGKthBAwc4A6+vzS0UsIAVbKCCHTTQbdVxJp71t9cLK9hABfuJzdHAAc7EM50e87OOAhawgg1UsIMGDnAmVmwVW8VWsVWP2x09wpmx3ubRz6f84W0egRVsoIIdNNA3cjrORD1AAUtug1awgQp20MABskP9AP3S7HvsxXyh3whcf8HAkeipd1xYwfOUu+J66i3soIEjqtz1rbgLR9ao61txCwtYwQYq2EEDB5gV8fpW3EJsE9t1Q3RuWb/uYS5U8OkvGDjAmehDtgsFLGAFsQk2wSbYBJtgK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2hq1ha9gatoatYWvYGjbFptgUm2JTbIpNsSk2xabYOraOrWPr2Dq2jq1j69g6to7NsBk2w2bYDJthM2yGzbAZtoFtYBvYBraBbWAb2Aa2gW1gm9gmtoltYpvYJran9J/YJraZNjsOUMACVrCBCnbQwAFio5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlhi1xKglRi0xaolRS4xaYtQSo5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlhi1xKglRi0xaolRS4xaYtQSo5YYtcSoJd4SMs/GgOEtIYEVbKCCHTRwgDPRa8lCbIbNsBk2w2bYDJthM2wDm1eCsw1heF9F95kK76sIFLCAFWzgeUvlUxneVxF43lL5PIMv0BPotvOe1hfoCXSbOhawgm7rjgq6zRwNdNtwnIl+B92mo4AFPG1nB/HwBXoCT5v6bvod9MLTpr6bfge98LSp76bfQS8U8LSp77HfQS90m+9mVdBtvpvVQLf5bvrd9oXtAN3me+w33gtPm4/DeL9GoIIdNHCAM9FvvBcKWEBsik2xKTbFptgUW8fWsXVsHVvH1rF1bB1bx9axGTbDZm7zn8Uq2EAFO2jgAGfiOEABsQ1sA9vANrANbAPbwDY9rp9G0yP4CXNesLuPUnm/RuAAZ6D3awQKWMAKNlDBDho4QGyCTbAJNsEm2ASbYBNsgs3rgw+aeb9GoIAN9AjVcYAz0XN+oYAFrGADFeyg25rjAGei5/xCAQtYwQYq6LbuaOAAZ6Ln/EIBC1hBt5mjgh00cIAz0XN+oYCnzYfPvV8jsIEKdtDAAc5Ez/mFAmIzbIbNsBk2w2bYDNvANrANbAOb57zPEngXR2AHZ6Jnt08jeGdGYAMV7KCBA5wLp3dmBAroNnOsoNuGo9umYwdP23nbMX3hn8CZ6Dm/UMACVrCBCnYQm2ATbAVbwVawFWwFW8FWsBVsXh+mHyivDxd6fVgoYAEr2EAFO2ig25rjTPT6sFDAAlbQI/jv5jl/oef8QgELWEHfXv+NPecv9FHsc4Z/+qI7gT3xGqXyY3aNUl3YQP9nxbGDBg5wJl6jVBcKWMAKNhCFjyCfM/HTv3sWKKAHa44VbKCCHTRwgDPR3wheKCA2/974OZc/vQfDztn16T0YgQOcif698YUCFtDvNcyxgQp20MABzkQ/1xf6COfh6COcvhe+tvxCAwc4E33OZ6GABaxgA7E1bA1bw9awKTbFptgUm2JTbIrNJ4Wq/1g+KbRwJvqk0EIBC1jBBirYQWwdW8dm2AybYTNshs2wGTbDZtgM28A2sA1sA9vANrANbJ7z1c9Uz/mFM9FzfqGABaxgAxXsoE9tnZXA2zzs7DOf3uYRWMAKNtAn0pqjT5mp40z0RF8oYAEr2ECP2x07aOAAZ6Kn/0IB3WaOFWyggh00cIAz0T84IcOxgBVsoIIdNHCAM9GLwkJsDZsXBZmODVSwgwYOcCYqP5byYyk/lvJjeTIU/+X9tC/+X/20X1jBBmqecn7aLzRwgJyeftovFLCAFWwgtoltYpvYSIbr42G+b9fHw86291mvydILe+xQvSZLLxzgTPQMOBvcp7ewBBbQD9RwbKCC2ASbYBNsngELBSxgBRuoILZyKf7zn/70CPUffzpPRj37Q89T8YISUANagAb0AAsYAXOBRmSNyBqRNSKrR34cMdWAHmABI2Au6EeABJSAGhCRe0TuEblH5B6Re0S2iGwR2SKyRWSLyBaRLSKbR/aXtwLmgnEESEAJqAEtQAN6QEQeEXlE5BmRZ0SeEXlG5OmRzxNPA3qABYyAucBvD/t5v+v3gf28sfXbwEUjaQb5U9BFklSSalJL0qR0SDokHZKOko6SjpKOko6SjpKOko6SDr8PPO+dr9tAJ78LvEiSSpIm+b+tJ/m/fdQXv+lbJEklqSa1JE3qSZY0ktKh6dB0aDo0HZoOTYemQ9Oh6dB09HT0dPR09HT0dPR09HT0dPR09HRYOiwdlg5Lh6XD0mHpsHRYOiwdIx0jHSMdIx0jHSMdIx0jHSMdIx0zHTMdMx0zHTMdMx0zHTMdMx0zHH47t0iS3NFPqkktSZN6kiWNpBl05a+TJKVD0iHpkHRIOiQdkg5JR0lHZl7JzCuZeSUzr2Tm+Y1YP/tP/I5rkSWNpBl0ZeM8SZJK0hnvbEbzO61FmtSTLGkkzSDPxoskqSSlQ9Ph2Xh2nZUrG+tJljSSZtCVjU6SVJJqUkvSpHT0dPR09HRYOiwdlg5Lh6XD0mHpsHRYOiwdIx0jHSMdIx0jHSMdIx0jHSMdIx0zHTMdMx0zHTMdMx0zHTMdMx0zHPU4kiSpJNWklqRJEdlvJLs4SZKfOXpSTWpJfub0k3qSn53jpJHkZ+fjHPfbx0Wn42xw9JvHRafjbGT0W8dFmnQ6zgZBb31eNJJmkGftRZLkjnObPWsvakma1JMsaSS549xLz+SLJKkk1aSWpEnusJMsaSTNIM/kiySpJNWkluSO8+h6Jl/kPXnn0b1a8pxm0NWQdx5dz+SLSlJNakma1JMsaSTNIEuHpcPSYemwdFg6LB2WDkuHpWOkY6RjpGOkY6RjpGOkY6RjpGOkY6ZjpmOmY6ZjpmOmY6ZjpmOmY4bD101cJEnuKCfVoKtxo59Uk7xtw07SpOinbNmS0bIhq2U/Vst2rJbdWC2bsVr2YrVsxWrZidWyEatlH1bLNqyWXVgtm7Ba9mC1bMFq2YHVsgGrZf9Vy/arlt1XLZuvWvZetWy9atl51bLxqmXfVcu2q5ZdVy2brlr2XLVsuWrZcaXZcKXZb6XZbqXZbaXZbKXZa6XZaqXZaaXZaKXZZ6XZZqXZZaXZZKXZY6XZYqXZYaXZYKXZX6XZXqXZXaXZXKXZW6XZWqXZWaXZWKXZV6XZVqXZVaXZVKXZU6XZUqXZUaXZUKXZT6XZTqXZTaXZTKXZS6XZSqXZSaXZSKXZR6XZRqXZRaXZRKXZQ6XZQqXZQaXZQKXZP6XZPqXZPaXZPKXZO6XZOqXZOaXZOKXZN6XZNqXZNaWZoZr9l5rtl5rdl5rNl5q9l5qtl5qdl5p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumeeaea6Z55p5rpnnmnmumef0VmvmuWaea+Z5zzzvmec987xnntOgTX827dl0Z9OcTW82rdl0ZtOYTV82bdl0ZdOUTU82Ldl0ZNOQTT827dh0Y9OMTS82rdh0YtOITR82bdh0YdOETQ82LdhXB/bZRnc1YF9kSSMpOu+u5uuLJKkk1aSWlI6WjpaOlo6WDk2HpkPToenQdFz9jfIYwyznGOa5+2p+MxtQA1qABvSAc+DL/HYj4Bz4Mr/oB3jkugZFHTxyW4OiDhrgkWNQ1GJQ9Gwt8UHRE3xQ1MEj2xoUdagBHnmsQVGHHuCR5xoUdZgLfFD0fIfTB0UdSsAZ+ezL8EFRBw04I59tGD4o6jACzshnz4QPijpIgEdua1DUoQV4ZF2DotfSXQEeua9BUX/35AjwyLYGRR08sj1+4nr+xOLR5jmuE+DDlefYpA9Xno/SPhB6nhUt/8m5GMT1F9rjv6v/9/N/9vn4n93/5xmwj8f/NB8PP7fknP71X7yfGzD8v5/7dbag+a/sYAEjwCP3/3z8m7/967/8+d/++q9//+d/+8df/nL++/gP//dP/+2//8ef/s+f//GXv//bn/7b3//9b3/7pz/9v3/+27/7X/q//+fPf/c//+3P/3j8fx8795e//6/Hn4+A/89f//aXk/7zn/jXx9f/tPgqAf6vHxMbPQNMuxvh8bjaM8K0jCDH7Y14PN22CPEY4fkyRP06hPi57SEeI47lKUT7EKJ9HaKd555HeNyDEKDZ7W3w1dGvbRh1fLkN/esQjxMpN6KPmiFUbkewFj/Ho7S0ryKMzSmh5+iCR3gMNclXEebXEYbGTgzjlHqMhn8IILvTUs73wa5teIxcZ4xWPoaQTYjBif1lgP2BFA7k+OowyPaEsPgtHgO69csTQjZn5WMsP0/sx6Xmy81ouxwfMw9FPb7ejL7bDGu5GfK0K+PTL2Jfx+jn23we4nHr8hTh/p48ak2cFo9xsK8zTDYn52PSqOSv8hiPf/5ZPqZ6OX5+PIr8+Hjs9uUxch8n6WOS62hf70vdJdt5C7OSbTyV3/HxqJbdOeZNZVcMK5ym/Rv7UsfIfWlt87tsztPS82r0GM1+KuOP/foQw3aXozLyLNPnGJ+2Y1NEH0OUeaY+hp++jrHbjtI0L4vj6+2om/O0zdyOx9jI/DLG/pfpB2eZfci7T1tSdrk7syCX51/mc4zdmdrHkWeZzK9j7M7UckQ1LKXYazFazUtkG1+fqXVzpvo7RFf2d7ai9o8ZUzfnxyRfjqeD8UuIzWn6eCalBunxdYzd6XF+TC825PGr1C+jtM2J2rkRPb9W/HSifgyxqaejtKjJ4zHl9VWI7fEoeYF5PEp//bO07VW/59lxcvv6qO5OdcudeeDX6bJN3EcVipNMHpMc5csobXfpf0xz5/486sbxRXFv9odeHtqRt8bSzrvyL/dl/qGX3OYv063t6Jvk193NabXYkMcU9HNp/3iPrOWnx3S7FU2ynLZ2fLkV21uy2p8udP3LW7LzkeDLGJ0bVKvP53q/HaPVPBrtMcP2dQz7+U2djj/0Jrcd+UDdPmR++0YMHsrb5lfpsqvreYo+3SQ/Zug/RticoSMf60edX0eou0tc7MacX0fYHgk98vwcXb4+Erq7ARp5XtT6fJP9MU96322H5C/yGGx7KUYrOcjxOMfL1zHGz8/x/uMquj2iNR+upX94BPu4JybbGzmqV/36aGzPjsFt+izttVybNW/T5/j6Kd/aT3PN9Ke5Zv0PzbU5YyPa42f9+kjsRp988al1VfuQJx/PT9uNP0nlRvDoL8WYR49cO1+V+jLGkJ/n2ih/5PWkSY5CtSL9pXO88cDTbDOEtB1POxhPe/pRPg1k7YaJS80S+rh/+nKYeNj2VuPIW4359amxjeGfYVqXlCk/jjGP8mKMo2YM+TpVpvy0bMzy07KxjdAzS46nQ/E5xPZQTKGOf3g2+HQo9Mdj79sQ987xfYhCiKfhiW+FuDUFMOd2gKPzZPBiiBxFe4ToL4XQHN0s2r/8ReTY1s+8S3iMYrWXYujM+65djP2u3JpUkWN7iY/fZLS5mVbRn8/M2M+nZo7xw7mZ/VYckzHrp0z7ZYJocz0ZI36SKeXrg7GbZHoMh+SoppxLClG9Znvx5Ph6qmk31+QfL/cQZl8ejt9UjVvzXaI/L8PbIO0o+ZRzjLkJsr3OM6Xcn29YPk3n7rdEsgo+hhfaZkvmT6+wsptsunlnvt8VhkdENgd1ux33LtT7Den8uvY8MfLLhrSfH1P98THdhnjH4RiZMY+JhN3hGD/M/e1mPApQ3vuIbs70ur0/nzlvVp8uk/0bIWo+ddX6NP7+OUTZnem5FY/HnS9D3D0aZXNzvg9iOfCkZpuMq7p7Gs7xiQeOL4+HvmHmvv586n4bIucz+tNdw/dCdKbMxibE7mio5CyCPg/ljfKdQ8rolT6PV38O0jbnqcynUcXzvfSXztRR4u5Wp46vT7LWtnPEmftPR8TGpxD64/md3VYozz1tbLZiFyIn73RsdmR7QOeM60KvKq+lfm+Wc5n6av3oNUcIuvZNSdYfP96L/vj5fh/iDRfKToNf77t7Md1m/8whkwc/VcNv5Nz5Jd283O7uT3U7IdqVwv71o+0+Bs9AY/Noq9sek+yGqOXr4YbfxTh+HKNJPhK2crwWo3L/0eTrGLsJp6dH/UcpsJdi3B1yuLkd2xj7Y1rzt2369ZhDtzccD/uj98WeJjTHj2M8l+XvnWMln3BVvj4etrvyMwYt1jYjD9sNMcZQnp+jftmQ9vMfdxfj7sl+czteP0EYvqi7Yribe5Jj0ujyPGjwrR9mlMbswNdn6th17eWjQyub82M790QxlEdtzSCPmZNvbEc98ll9bA7H/pJbef6Y+uW94Wj7IOUpSH8lyM0Hw9/tzL3t2D3FDIuj+phK+3raxlvzvh7/pIvxueXul/Gt7fNUTnj0D+2l33kk4053bFoBfjzfMX48VzF+PFUxfj5TsRuAvVtJt4O4N2cqfj7J8POh+d2I+L2heb/v/PnQ/O13Yb4s5mU3e3RvdO4N7xVt3wEZeWkr88P476ce/93s0b0Bvn2IWwN8ZTf1c7OObw9G3sSVuelm8Gejnz1aF/nxuP4+xM1H658PzP18XK6/YViu/3xUrmyD3B2Vm7tLWuWu+mkzbgcQ6TmS9WB7Hob69PrILszNdN2GuJeuu7ec7qXrbtrp3iD49k2rW6f4NsKtU3z7xtjNU3z/1tnNU3z3WtHdU3z7yljJCYFSynPneLsfQ1v2b6p+HWP/apKfvte+lOc3WH59AU5+nCnbEPcyZffKx80L2/3D0TeFY/sOHbfD/XlO8vM7dLdj2M9jPI+TfOddvqPn2OTRv37/rWzfcBr2dCe5eZlv94IT9xyjyYshNIrQUHsxRMuteJ4uejFEr68d0KKVx6XnRvbvBeGy0EVf/GknCTM3v8t20rrn08r5JstLMR7PsLy+sjnFbr7r+Rgi3fy6d99b3cW4+w6ubfJWf/rUtN0Ko6d+HJsqppsnhVnzUjkfg3Jf3cyV7dtNlbeb6vMCGZ+OqO52Zj51zD3PKH6Osbvuy9MbdI+hzvHl3vTto1OOO40PF+1v1PWRDy0P7F/G2F/pNHs05ENH5a9Xus1Ve/J+5PE80PDp+X77LrBInme71xLLbrpn5Kzzh0buXw7q7lUpxq6PY2xi7Iag7r2EW3YvKd18C3e7L4+h0JwhOdrugOxG82fPEfA5d7cx8+cFwI6fF4Dty043C8B23ul+Adj9NjWvdo85hvLayfoxyPwyyP5F/lwe4fG88/Wd/z5GHtbH3f14LUbNpuryYamHzzFsd2eX91TjtTf5H3O9+YZOe9qT78R4DHbmfKCMr99bL2P7pJyTRg+U14I8JkZazpE8dZx9M0iu6GR1jheDtJzOs1bri0FGTg/Y803zt36cljM++tzd8K0YxhpXzyPi34uRT1Q6yu4k2a5McLAIz+PBbHNc5248pDDr++C+Odt2L0E95vyYkdd+HC9vDQs/PLZmbsLsamMbytTtsPHqIWYZmwfrq2fM81sB9lqMSV/efJpo/NZCJUeeuV3kte3okk+uXXZZOH98d7N95OxaWatOn4J8a9WVrgxK9EcmvhilMxbY7bAXo1hhj6z1V6PkfMiDNwV7H2XkNOqDRV7dlqejO2RzdHdTVffrU929LnXWJxaBe55U+HaYe2Xudzt1s8zV7atTbbCqVNse4t+EuVktf/N769O5118+9/LduAfrq9k0nxZHmL29GoVVmfq0+VoUK5L14cH6ahRWELIyvj7xdusqvWdtJmMWZpjKi1FG3os9WI4Xo8ynbZmbW+X9OlHGkmibYZB9jMlaUx9eiv9GjNEYbtOvn4L2gzqT60iZc7M4W/nxyyr7ELcmDPchbs0Y/mbhLeq1zKf79c+nx26Ei9Ufzi+MvhSi5Msd59cwX5mXqiosRKabh/V9lD7zeFSTzSN//XEXyz7Ercm+Wn/exXL/cJSXDyr3Fo8o/cUoljM6D9ZNHWo/nofdh7j307Q/dh724+HYzMP+7qcZT1E2y/fNn5aybYR77T3bRfNqDgo9eHeJ2W3IvUaQbYhHNWTewHp7MYg93c+YzheD5ATVg0d/5TxrjRhNy9fr/+r2FvotSxqWyVDqh5FyfS3G83zMd2Iow8L6nHnfiPHY/pKj7R9mYz/F+Pnb4ds1DY/sPm3Snn/cb6yLKKwZ97iH+DJG3S3kd7Mub0Pcq8v9xw3824NRWMaqfFhB6vNm7FbhG5Np9ufXM34Jsnsn6k6P4H4zGFVr87mz5Vv7wqyhHqW9HKRkkDZeDpIDjceL63feXgN0/PRyuY1w63K5nam/2Sq4X8v0Xqug93t8PYV6sxt2l7VcK9soXzdbV/txs3UdP2623oe42Wy9Oxql8GpXf62Xv9Vc0aF9eD/s8xHdvQ3Vc3K8P43HlE/zyWP3MtTBMHZ5PsPax5Nju+bkvSP6m1Mjzq9xbN6T38bwj8xfMczKazFmjiA+LhDyUozHM37cJs+j6JcxdnONtxeuLD8tgtsIt4rg9gXGm0VwvwDnzSI43/BKwO7N0sdNU756XOzrZSf9pc2vnxgYo7b+5ctd+xisb1Ge24Q+xWi7N6tuvqi2jXHzRbXf7EveAZWjlq+3Y/esf+tN23Zs1+6dwu8yny5xn18022/JrXdttwek+Np/1wF5lOSXDmoRPm0hT+Xjl4M6fn5Qt2Mf915f3m/HrUO6LWO33pDdR7j1gmz98TVyu/h4yzcI6/MLrt9awHzm3Fb70Dv2rQXMiVFeXMD89iLoPx4T6z8eE9u2J968vu0Xc793fWvlDQtR2Xa1gTes584KUB9fCvhODJY8eQz+fL3Kftv1J9972GjFfvqwsQ9x89Z4e0RzCrjo/PqItrp9b+3mmkl1e6XOELN/vcx+q9vvndxaMuk3MW4tmbSNcXPJpN/FOH4c496SSfsY95ZMavv2rluryLR9e9e9W8qb27GPsT2mt5ZMaq38/HjcjPGDfbm1ZNLtGJslk35zjt1aMqntvh91d8mk/YbcWzKp7WZtbv+48+cn+83teP0EubdkUtPtmxr3lkzab8i9JZPafq7k1jPH7iWr288cv/kO1Y1njt9dcW8tmdR07oPcWapoG+TejMtvd+bWduwmj8rgyx/Sv35+abvnqLtLJm1v+289D+4j3Hke3M4v3NqGfYRb27C9s8zOhAfO/3xpotbq0xcOj9didCaM+6yvxRjZAFPmoS/FeEw85TXuKF8fj7rLtruzztsgj3Min22Hfdkytg0xcxipz2KvheAJe+qXU7W3z4724hlWiFG/PqDNfryKyj7ErbnvNuQPDXFz+nx7PPt/2X/zvd+EN+5svlo5nrbj1Rh8CuWBr8Zo5U6M9uMrSvvxFeU3HZ45FjVLebFJNDveHvhlR1T58XKEvwlx71jsftN89bh8XGztO73QeTP6GGWwF2PwUfZhr24HCzEM+/pz2b/pdW90qT93dn+zY/45yuadp99FaUSxr99G0EO217c7b7nrblG/m++B/ab/v7CszNy85fqbYzJ5F2EeL7+L8Lwt9eUoPLiM2V58c8VKpTHyMaL7apT+9M7Jy++/1IO5vVrKq1HaUxR99S2aWp+j9FejPA2l1PHycbGnKPPVL8e3p7eLWnn1l27Hc5SXzzqWJLBWN7VFtm1XNXs2H7w5YX4XhjblVjfvKem+P/juy3G/25p8qHjw5tXZ7+zUD8LkoOTZTL45xKX+f3FsJjvVjvaOnfpBmJbfk5K2W69At0sEvuvYsDTzg5u+Zafaq+XzOOj8P45XX1KevHRjzxNz31xVItvvHjhfDNLzrt16sReDaE7+ms5Xd8dyFNjGy2t+PO/O60FYN6zbq2t+8BlXM2mvbkm2iT+C6KtboiyDpu0Nv45sSsL2c1XfWJViuxJK9kptz5T9gjs0CtT29dsq+wVMs2u0lOfXVT8tPqq7FzTvDQ3tQ9wa19E2/tAQN9forbvfhLduqn29mKvuxlNuvRSx3YrG4FL7sL7V562oP3883K0beHcRtN2++N3LGmJ/7gX+1hK7z58lGJsYu+WXb67Tuw1yb1h6H+LWsPRvQtwZlt6uA31rjGof4c4Qlfz8sx0/Hibbte9WVgV6/o70uBugHHkb9Sg4T0nW5u0QzwnytP7NN0LUvKS15y9jtnY3QMvxjvb8UzS9fSBzhE77awHyOVyfR/i+ESDXfvjQuPdSgKdJ828EeD4bj5cCsDbUbK8EsJwZtudFAF8K8PwG/TcC8ALK8dIusCLJeG0XRvZ9j+cGm5cC6Es/Ix8Pn68dxMkURHvpTOQVntn7DwPYSz+jHMrKp/147Uwo3HoQ4NOb3OPmO5D1tQiDlB4vRsiPZB1fbsPuKOQzz3i+l7T751L+kvrlkq26Xcfv7nKr270QduP547zl/unA2qLzeF5S51MI3b0D1VjSWz+8ZPfpWrsNosfgQ8PPb4L+EmT3fsqtLw3vt0NyfkE/dBN9Z2fOZe7iFLd+vBok74L683qc3wvC1Fr/MAt9/z5oSo6gT5H+ymn2IcTTSP7nEH33dSgZT/NHT2+Sf1r2/TeHQzgc9dUfZjzdY8+vz/d+jJ//MNsgN7s29jvDyyrP7ZXfS97Cl8ZL+zppuvx4HYl9iFujHX33/vQbQrzhV1FC6IcP1/xyQLcrBfBpOP3wvb7jO0FYKP3DayLfCsKyz9KfRipfD9Jf3pK8zJwTeV8HKT9/bW+7HSyULPb8dPjLduxeLp2TvZnPy9h/frl0G6ZZvvbbnrtafgmy3aGRX6SX5wGYzzv0mzrC8tEfVm3/fNrvvlJSnhbDl6+uEtsI98aj9iFujUf9JsSd8ahjeyuTB3O+NJBDgA8tuLcD3Fts8bj3sCEvBbj1Kubx0/G046fFYvfUV1k3tg6Owqgfz6X246GobYh7g1H7ELeGo/Yhbg1I3Q2xGZLahrg3KLUPcWtYahvi3sDU3RCbUZV9iFuDU9sQ94an9iFuDVDdDaEv/qj3Bqn2IW4NU+1D3BqouhvCXvxR3zBYJaxMIO1pKuFz5du+NyE5VlTlaW3Jc+LtQ5C+mwo48u3iejx3C36aVO67z0k9Zj7zRTZ7+m1/DbLdkpKvgcjTQ/CvQeouZfOefjx/2epcfPtjkLa7V8seZC1Pl6Wq9RtBar7I/kB9NUh2R+mHnsVfgtRdDRKOyVMT5q/HZOyaKXKtTHteK/vXILszNj/k2J5GW8rxKcTuo1JFePPpMZn2YhCa9kt5KqrfC2LZ0lHsacDllyDbHK68EF+fWjh/yeFtEBZX+/Dxwl+CmO4yZ+T4+fHUTv3LD7wPcjP9dkFun6/2jvPVfn6+jnecr+Md5+v4w8/XlnfstT2Vxl9Otd0afFXyPZEqT22N8ukRcrsK39MXRuz5rv3TxWL0H8737CPcme/5TYQb8z2/+UmEtRue+gF++Ul233DSQ5joeP6aY78fo01G9o7ncd/PMTbjT41HmNafn8xfjlG/jHH/oG7urebuHOXlfGnP71R93pnd+XE0FjyYmwOyG8B6TMJNZuRqf0uUL3/g7W3vMe7c9m7rWM11eR5lUV6tqLz8XI9X7wDubom9Y0v294n5Eoc+3wF882aT9Yzb8fVt7/HzO+fjj92Km3fN2x3J5U42l8r9Qo85FKOvBBAehx4Pma+FEKYVnp+ovhUiRxlFxmtbUSeDfPO1rVC+i6tPV6dvheh8SmzM13aErx/V8tqOVF7krPrSjty9jdttRWeG5vllge+EsOxZPtf+fCnE5HA+ryf/jRCW76E/f3zvGwFmzlRPfek4zOO/Ghb7ToDMr2n6w114LUBjZe6noZsyP62CWLYjUTwUlC9D7LYhP5PUnt6e/WUbqvz8gc+2KzLdeuCz7cvnNx/49kFu3hTsg/y8Umil4bk+3Y5/40oq+aWW8vSA88tyjrsV7u4tTGm799fuLUy5D3FvYcrt3e98+pzll6vK2e59pJHvZY8PfQ/6jRDKou99E2L3KtLBepLy9Erhp6loa7thnrxlnVI2m9F3N+Cs6t2eljD6vHLZ3d/EvvxNtif480eRntde/fyzbj/xdKe9b381zRu1D9Mrxzd2xJ5aLsrXO6Llx7m6exHpZq5uQ/w4V4vwStXz9z9/PRi7lfXOTwtzp/Vlw9TvgtTnb7TWL4NsO0cq0zzP73z8sjvbxRezubgfTzfAw+7H6ORbf3696zsxdCrto/3rGNvvMtEoXZ9X7Jjf2A4reW07X539eju2q+g/vZ39/Dmj+umH6bobvfsvu1l+CdH/2OPx9LvY8xeofzkeu9Vse36sXMfTaseft2M3zXR3KmN3Q8rIbjMpr5TT1oUQZXNdsJ+XU/t5ObWfl9PflbGntdK//nig2Ttq4S7IvSbWfTnVg3dDn+/Dfvltd2sqTFbHef5yzi9PLNsg3EaVo2yCbN9Ov5kwvwlyb+5vG+Tu3J/t5pduPwruJphuPgru5nZuPwpug9yc+9sHufkouL3KjIPnhvr1VWZuR8zzJYXS6uZsne84W/utpw95XhPl173ZPuqzluLz8oG/7k17x97s7iJ6YSko2+3O7hbgOGgvHrsg9o5feLzhmGx3h5GHD98a+Lw74zh+/hOP4x0n7M2bq3GM126cu5XsWranlXZfvfl+VOGvYozt+063u/u3Ye5299uuO0pqZ6Hu+twJ/eu27D5JI8xsSnleRL1/Z1tqefry9ZTNLm2fbXJc/DFAIl/fQ+9izKfv5z591vhTjLF7Z+nuHcHYfUPl7pTiPsjNZrzfBLk3rbg9JndvcMbujZS7NzhDxk9vcMZunb27Nzj7IDdvcPZB7t7gbJ/ntT6tCfbl+MbYLT1Ts5jU586mz9+g3E3DP71zbM/rspfxKX3tPZWkv6GS9J9XkjLeUEl2s1S3K8k2yN1Ksg9ys5KU8YZKspsjul1JdguT3awkVd9QSbZB7laSbZB3PCopJ8nzi8ef7zx3002t8P3oMtrXZWD/vMXta+326vPWzQf7+YYH+9Hecba2n5+t7R1na3vH2dr+6LOVNbCn6tdn6/a7TEd+m1vluZH1l7N1d4MlQpDn79j/EqS942xtbzhb9R1nq/78bNV3nK36jrNV33G27p7ry8wx8TL164Gosf3C05FTJu14HsD95VSzd1TX8Y7z9R33Av0d52v/+fna33G+9necr/2PPl8rIwOPsbHNONRuSuvDUMfzHN+n83U7mHW3vv5mMOvmrfjxjrsBe8f5aj8/X+0d56u943y1t9wN7GZgS/YsPCbo+9fPfLsYLWeT9blh9/Mz39i2Hh90Lz8vJH18Z0M0B4G1Py0V8cuGbJsC/6vVMj+9suDzCd+L8Hm9zd/Mad+8TOyC3E673VzS7bQb9uO0262UdzvttkHupt02yM202we5+TLJb3bnXt/ovorc3ZJ9Pbu5Jf0dW9LfsSX6ji3Rd2xJe8eWtHdsSX3HltR3bMl+PO3e60+/CXLvxaP9OPTdY7IfEb95TPazFTePyT7IvWNyv/ewft17OGV3N3BvicTthlTeh6oyj82GlJ8/9P0myL1Z8ilv6Bz4TZB79xXbIHfvK+Y7JrXmzye15jsmteY7JrXmeya1dkek5HLxjymhrzsZZ3nDyNw2yN1eilnesEzFb4LcPOnLG5apmOUNy1TM8uNlKmZ9wzIV+yB3T/p6/OEnfQ6X1Lp5G2IbpB25O+3QTebs7m/eEuTeqo37ELdWbfxNiDurNu5/3Ju3R785ze7dHs133KjNd9yo7Xszb27Jb7pE723JdhVEGu+fphvt9qLtj8l9XhY/nl9m6N8IwVcFj/FUzb4RgtXuHvy03t03Qsz8ftCDu7wUgs+Nfugw/U6IHEQ7Q+gLIR7/7GnJjvLVVszdNNbdXdkGuddzf2wr+o0ltHcBbq1+PdX+0BA/Pg5SNH/R8vy+0Lj/ymOh+bI8v+f3aoj+UojKC4v1GK+F6Kws8dyS/o0Qmi/piLbXjkXlDdLnl1BfDvHaj/q8oGSV10KwLETr/cUQ7MiHz+F9I0TezUobr/2oLReAEj2OF88LXgsuL/2ozZixe+lgcmpq+fo4zO0o7MjVPcsYz2fF7Y3Ie77neZzv7EU2hnxYz+sbAZQZnPZSgHxi1FlfC5CLO8/2swAflnb+zkFkEbCXSmXPBTZ6nT/cgtd+RhHu7Mrzd55rfymEyCshyswBzXo8H8pyOyPqkcW6fngz/PNYyNi+OpxP/Qxl3l5To1iOXxTb9AbuQjx9MrQ/TUrOj8svzO1CeyJ09j6NgOj9FTFK47PS5fnl5anfuHg+XTHk6by4H8OsMAzz9Mignx4Gd30eQmfwYzOefhT9fEj33ySJX+X5G9uf6vWc7xhSmj8eUno8DbzhOV2OXavI3RXIfrMtN0eVxPvCvtyWm6tePaJsRsvvLTq1j3F3dbjf7M/NJbj2531jWUh9/kLSp/P+sSm7T4I8fXu8PL3XPcfnIHP7TPG0QtvzpsyXKsHTHZN+Pq6y+6Dz01jKhwbwT9vxiLKbJGK9zccQ0dPNW9FvRKmsnVfVxqtRet7NVvvQf/ZLlB+vUyG+Fu2XW3JvoYpHkO3rMXdf+pND3vDW3++25u7LOr85NPfetHnUjje05l0V6KcXoUeU+vOr0O51qvtXod1kz/2r0DbKzRUkH1Hs59ePYu+4ftzcEtNXf5/bV+bd6n/3r8y75f/uHtmbMbbHZBfj/q+zPSY3r+6/qdm3XmV6bMlu1PPmu0z7Lbm3/sS5MvXPGy/k2H/V526NbG9YsfIRpfy8Rrb6jhxs7R05uGtNu5uDuxj382e7P2/Jn3svV8nxjrerfpM/95Y8kUPl500cjyjlHQn0jhesHlHazxPoHS82PaL0dySQvuH2QN9ye7Ddn/sJtCtwfHG6Pj+R/frosftE1TSWGx1PcwK/PJHtFsUo58dm43eW56epXx/sdo+H/nWUK53taXb518fD7Zo/T5+v7c+f2yifj+62O/rm23SPKLsl1W6+TrfflrsLED2ijHdc4t/xqsTjOet4R4Uy+XmF2i0keL9C2VsGwOwNA2D2lgEwe8MA2G/O25tv+D22ZddudvMVv99ty71Vrx6b/IZlr84enXfk0HjLUMJ4w1DCeMuj6v7LVXdzaNfwdTeHdjHu59B2f+7n0HYFu8H3vJ4/lfrL1Wz7Caqa9wrtMS309QjYbqmKm18l/k2Qex/4fATZnbQ3v/D5iLK7wb35ic+z7W0TpeYzfK1PL098M0ozRqOP8WoUHVnknj+//c0oN79a+ruje++zpdfrrD8ulXK8Y0RBjp+PKMjxhg9YPKK0N4y67qPcHXWV4+cFdxvjdsG9uyWmr/4+fHew9Of1F3+JIsc7juzucejukb0Z4/VjcvfyLvKOUTARfcMxecco2H5/bl/et1eym5+oFZF3PJRJecdDmZSfP5TJbpbsfpXczZLdr5LlHQ+IUt5xcyvlDbW2vKXWFv3Dz/6bX829Pti3ecy889ncR5DtpFC+jySzffnN2n2QcrD8/VHqJsjuncI8U3Q+tyR+azsa7VLPzfC/bIf+sdsh2Yhe5MPLM98LIm8Ikt2yPwjyXJbK5hxp23sDKkF9amn4XhA+DPd4oHpLEH01SKGzvbWXg/D5W51v2J3Xgxi7M8bPgzw/zH0vyHOn/fMbGL8EmT/O4f12dN4E2WXObnbs3nb85lpx73Pejw3ZFdd73/PeB7n5QW+R3dTYzS96fyfIl5/0/s6R7bsju2v5uvdR70eQ7UL8B4vol+PFIKPEb/yYUOovBpl52tvzt32+FcRKNonYhzfKvhck76gfQeprQcahLA8wN+d93z443fxe+vfCzBd3qeas2Hj+vOqv2zLes0vjHbv0m8HRW5+B/81YLy2crY8v16kT2U2L3V1k7hFl+3brnc/XPmK84aNFjyg//mrRI8Yb3iV/RLF3PJXaGz5c9Igy3/FUOn78seh9jPtPpfsvh91+Kt2+oJifbW7PPd2/JNDYzsMKb40e8jS98LmZQbaTSAdD+mcjR9mE6T9PxGHvSMQxfp6IY7u8RB7ax/DZ7uT/xqF9ms393i8kfB3jvEMqr4bpTy3zvejXYXb3cvc+Wv6I0bZT5Xk7WHYx3lD5Z3/HCTft5yfcHO+otvMd1bYcP6+22xj3q+18R7X9zolfN71j+6LNp0Oe79c/F+1yvGHpqkeUd5y3vqDwD8/bcrzjvC3HW85becN5K+84b/f785bGjNL4xrrW8nVjRtnNIj1m6fMF9LK5SSiyXWj7bvvlb7Yl1zrr9elVw1+D7G5vnxbL0Oc+q/atTtB5ZDY/fwJWft2W3TN8vuHX2+4H2k2K3X13rLzl3bHylnfHyhveHSv7d8du3oBtfx7L3tix/3n69shGVembk227HSMP6/Macv/FduzWUx+Zxzp2eVzmG/J4dx301aev33c8DWB/eudfynaio3HdeEzRZZB+ez0JLS3XBvnw2vIvm7F7j0GyQcueJ21+Oah1e642ztVevtqXR5BtB3ausFEfA0GbILuZV7VcxeDBdmwyePfWWJEc3yzP853ll5pUd0NWJb9/LuX5A+jfi1J73hs86uMuim3rSaGebPdoe7rkFfkxZrrJwe1rY9km/GG1qHp/YaCZW9EP+bhwx/94/K8//8tf//HPf/vXf/nzv/31X//+f89/KOVcSeCxY1ID2gmPk1r0hMepJ/1P/nbSgyxpJM2gcvil9bF9RZKK0yNuqUktSZ0esuKOs0AVSxpJ7jiTpB5JkuSO80ypNakluaM9zoDakyzJHefXc6s7zkHfdiS54zzLWklyxzm33FqSJrnjfBxoluSO81Le3HE++as7zoVcVJJKUk1qSafDm9q1J1nSSJpB/UiSpJJUk1pSOno6ejp6Ono6zB3nTZlJkjvOK5bVJHecg8PmjrNqmjvOqmXuON8RNXecb2jaDBruOH+jIUnuOG8nRk1yx1nmhjvO+4TRkyxpJLnjnGyZR5IklSR3nC/bzJZ0OR7bPN1x9tBOSxrxu80Z9MgS30A7UUDXnO+aPE7YE4f/XRdN/68KdtBdV9wBTr97OFEOxzOTRfw+xP9rASvYQHU8M9sTf6E5jhOH30ucm+65X87+GPHkX+i25lhAt/k84f/753/89c//829/OSvQWaP+/e//EgXp8T//7f/3f+L/8z//8de//e2v//uf/88//vVf/vK//v0ffzmLl9etY/2f/z4e9wv/9Jh0K//j4Xj871keJ8As1h7/u57///oYzRt1zvP/f/6Ddn6EoQ09zv9w/ovRHlv9+D/lrJAScdvjOtearSjnkFIrJWM8yl0TiQiP6cJ/6g/j498XL6rn33mMCz1+2vO/1fxvj/vaMs//1PhP9k+XWflP+k/1OP9Tz//0uIUsHt/O/3Ru0SOp6sjtaf/UPO6I/3c9tzf+34/Zce3/4z/Pa8D/Hw==",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAXLQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjdbuM4DIXfxde5EClSP3mVQVGkbToIEKRFJllgUeTdl7RFOSkgIXV2bqrPjHVMyoey66/hbfty/v28O7x//BnWv76Gl+Nuv9/9ft5/vG5Ou4+DRL8Gp39SHtawGrKfhjQO4HwZ47AmGQGHNesYpxHLMcox6IkeDVTBC5A3sAhrRNUiCCSFIJAFEhhYJEsEdVbmCdA5A4uARaBGcgH0BqmAZjhBLEBgYNPZBKNOl1QxkwAriI53q8G7UECvPgEXQIsgFdCLTqCzZH08OQMuwBZhiwSLBDJIBTSxCWKBhAZ6CUneZ2fABrIsXsohRwapgN7ZCSyiSzeBRbydM1ahMFYxAhvoJWShiMkgFQhoEAqoASawSHIGOl28QRkN5BySAlmTn0CUCQXAG1hEkydSSAV80WG97yOQRcgibBFWP0sarKmOEKVAUtAMKShoRE9Wi1JU4MkkwYFBKqAZTpALIBlYxNs5ozMFolqdskIqMFaqgGAgGbJYK3oyyAXIIlrXBNq3snQxcIHoDFKBJJdgVEgFskWyThcjJS1wglAALAIWQYugXstfLqvBtp3n03G71V3nah+S3elzc9weTsP6cN7vV8M/m/15POnP5+YwjqfNUX6VOraHNxlF8H233ypdVvNs154agnbIODsEhirAP1BIVSG6pgJ2FPycgzR/VQi3Cr6tkGLNISWHLYV7qwC3ZB3EZVWBuaUQ2go+qMVHBdnWUlWA4G8kYltCHjuWBGDOs0S+lUhtCXG7+SmmK0d8W8vcUZAGNgVZ15YCdBYTgLK3QoAxtES6heBcSGgqAPbSyFyXE+a1kIfW/bZAP9siLjLWbM0EvqWge3LbWeCrs/y1s27rgPBwl0J8uE3vroRiu5KuBseqEXNTAzs3hQKYxykQtTXg4U7DjkEj5dpq7NwiCemuKoFxkUQAqA0PbQl4uFmxt31iNgmxKjWbFXv7p4t123FptobnbxqdfSdVZyRPbYXOBhrA1U4LbYVuHQFqHdG1NboWr2tB8rrVtLjHv6shjz+0WgJf3RPgH2gka3n5Hyst04hcn60xUVuj41F0YHmgo3kHxIC3Gr17G2rDytJwW6NbSybTkM5r15Ifr4XcX65l3kYhUWjWcvcjIYemT6nzEgrZ1VoyXb0sgP/BTlrzkFenhZsx4cMSd73AUfwfXuB65pB3hHpjr5uW/SIJzIskMs+3NYSFEjhLxGUS5GdzfSvkSQ43r7vjzUesi4odd5uX/bYcvp8Pr1e/nv79tF/sI9jn8eN1+3Y+blVp/hImf35Je66kvZ7005ceSkeCj3oIepjSSvz/dNFk/gM=",
      "brillig_names": [
        "winner"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "join_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "is_init",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "num_players",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "game_over",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "first_capture",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "join_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec::capsules::CapsuleArray;\n\n    // Define a base slot for your array\n    use dep::aztec::utils::comparison::{compare, Comparator};\n\n    use dep::aztec:: macros::{\n        functions::{initializer, internal }, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n\n    use aztec::{\n        macros::{events::event}\n    };\n    use std::convert::AsPrimitive;\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        join_fee: PublicImmutable<Field, Context>,\n        challenge_fee: PublicImmutable<Field, Context>,\n        slash_fee: PublicImmutable<Field, Context>,\n        deposit_size: PublicImmutable<Field, Context>,\n        is_init: PublicMutable<bool, Context>,\n        num_players: PublicMutable<u32, Context>,\n        deposits: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        game_over: SharedMutable<bool, 1, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        first_capture: SharedMutable<bool, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally: 0 , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    // #[initializer]\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        join_fee: Field,\n        challenge_fee: Field,\n        slash_fee: Field,\n        deposit_size: Field,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.join_fee.initialize(join_fee);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.slash_fee.initialize(slash_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.num_players.write(0);\n        \n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender());\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender());\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n\n    }\n\n    #[view]\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n        let current_block = context.block_number() as u32;\n        // You can now use current_block for your logic\n        if current_block > storage.end.read() {\n            storage.game_over.schedule_value_change(true);\n        }\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[private]\n    fn submit_score() {\n        let score: TallyNote = storage.tally_note.at(context.msg_sender()).get_note().note;\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score.tally)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        let (gameOver, _) = storage.game_over.get_scheduled_value();\n\n        if(gameOver) {\n            storage.final_score.at(sender).schedule_value_change(score);\n            let (winner_score, _) = storage.winner_score.get_scheduled_value();\n            if(winner_score < score) {\n                storage.winner_score.schedule_value_change(score);\n                storage.winner.schedule_value_change(sender);\n            }\n        }\n    }\n\n    #[view]\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        // Ensure the game is initialized\n        if !storage.is_init.read() {}\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger != AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[public]\n    fn slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == context.msg_sender(), \"You are not the challenger for this address\");\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_note = storage.tally_note.at(context.msg_sender()).get_note().note;\n        let mut new_tally = tally_note.tally;\n\n\n        if capture_note.capture_block != 0 {\n            new_tally = tally_note.tally + challenge_block - capture_note.capture_block;\n        }\n\n        // Relinquish the flag\n        // TODO: FIX ME, need block number\n        let new_capture_note = CaptureNote::new(challenger, challenge_block);\n        slot.initialize_or_replace(new_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // emit the old note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        \n        let randomness: Field = unsafe { random() };\n        let challenger_capture_note = CaptureNote {\n            owner: challenger,\n            capture_block: challenge_block,\n            randomness\n        };\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n\n\n    // /// Returns a random u32 in the range [0, n)\n    // #[public]\n    // fn rand_u32(n: u32) -> u32 {\n    //     // let r: Field = random();\n    //     let r_field: Field = rand_oracle();\n    //     let r: u32 = r_field as u32;\n    //     r % n\n    // }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
