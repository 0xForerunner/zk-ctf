{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_join",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACJx4CAAIBHgIAAwAKKgIDBCQCAAQAAACDJQAAAlAnAgIAAC0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUtDgIFACIFAgUtDgIFACIFAgUtDgIFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OAgcAIgcCBy0OAgcAIgcCBy0OAgcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwAQJwIIBAktCAAJLQoECi0KAwstCgUMLQoGDS0KBw4ACAAIACUAAAJiLQIAACcCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAACYi0CAAAtCwYBCyIAAYBEAAckAgAHAAABuicCCAQAPAYIAScCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAABACUAAAOQLQIAAC0LAwEBIgABgEYABC0LBAMKKgMCAQsiAAGARAACJAIAAgAAAgslAAAEoycCAQALLwoAAQACHAoCBAYcCgQBADAKAAEAAyYoAIAEBHgADQAAAIAEgAMkAIADAAACTyoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEF2rtV/+xXZjk8BAIBJiUAAAInLQsEBgsiAAaARAAHJAIABwAAAoQnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAADHCMAAAKdLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJwILAQEkAgAKAAACxyUAAAS1LgIAB4ADKACABAQABCUAAATHLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEYABQ4qBgUHJAIABwAAAwclAAAFVS0OCgEtDggCLQ4FAy0OCQQjAAADjycCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAOQLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAExy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBGAAMtDggEIwAAA48mJQAAAicuCIBFAAUjAAADoA0iAAWAQwAGJAIABgAABBAjAAADtS0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEJiMAAASSLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAExy4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAASSASIABYBGAAYtCgYFIwAAA6AqAQABBQLcbieAdhKdPAQCASYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAATiIwAABO0uAIADgAUjAAAFVC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVALgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAUPKAGABQQAAQMAgAYAAoAGIwAABVQmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZjRbuM4DEX/xc95EEmJkvorg6JI23QQIEiLTLvAoui/LymTclLAwo4H8xKf0NK1KF2JTj6n58Pjx8+H4/nl9dd09+NzerwcT6fjz4fT69P+/fh6lujnFPQDAk13tJNrme5YriDfs17LfEWerwTTHUQFNojBIRkkjySPsEc4OhSDTA7ZoKCDPiLtJgzZAMDBb6FH0CPkEUoO1SBGh2KQyMEfweiggjIlmINDcqgGhRyKQUUH604BHLIBeAS8DWovVsgG5JE2zwptnhtEh2KQvHHyxgwOHsnevWXRoBq0LBr406t3r964WuMYooNH1CpQFLR7FcBkQORQDKIMFYNCNkjgkByqAZODN87ePXukePei3UGgkoO2ESOlgAYQHIoBqu+DQjEgSZBQoRrohJOYn0EeQUVBb0k6rOvVQM3WQJdphuggylGUmaVXlIGxen6GbKBZzJAMqrepZYYc2ED9E1EhG2B0qAY6ngY6nhl6RNuI67J6voF6voGaZIbk4I3VJDN4L3V4lDks6vAZkkM1UG/MkA3QG6N3J4+QdyfvHr27uiXKriy6YRvokTJDMsjgwAYlOtgcFt2eM9hk1mCRqgaI4ufa5keWu7ZnNcgGbaIa8OyEqg+dwbxRS3DwSPVItQiEEDr1GECnJVadmlFnyk7Ue1Dv0dabG2n2LdaGPRPPCUBoszVTj+nQjbRvbVSdao+pJVPQ6qBlwyg7gSsDZKdm0JmqU1vuRjF0WmK9nS+DUNfj/oxm2fz1tZu8qj28Xw4HLWpXZU6K39v+cji/T3fnj9NpN/2zP320Rr/e9ud2fd9f5K5kcDg/y1UEX46ng9LXbukd1rsCgi5B6y6cuEvUdKMB6xpJ1sAkBEtX4NtR4LpCSVq9moJslrCmMM6Dccmj4FoecV0j1pBNIlbgtVGkQR4x+mSWyHFbHtfrUeJaHgMN5kAmwYzLTKTbUZTBKIijDyLCMgZ5ObqRqAOJxKaAYRkCQbl11SCNnHXjNgk50ZflwHKbBwysKW8ZvqJXC4rhm8LAmggVPBEMdV2DBhsEPZFrc/+WQnVnSj3flgcWHwTS1Yr8lkaGvqh5lEn+uxogDnd7ci7bNHL2TQK54jaNGnxOoeK6xminxb4skCKv7jQcLAvn4BbNyLScGLd7DQf+ytwVruZTfvn8/zOHukPl0Fk7c3BweBKjFwHicj0KutXg0fGZ+3RiXXYr1G8ag1WVt0Z3V5bCtFrOymg6+47PzOsVcXR+ystENygkXC1H41RwSYVXJQhGew1y32u0lAL5jbepHhGveYNotE26xSFiXnUoDcp7weLFQFZ4tTjTqL6H0t9TgNbnc+RQ+V+hv6jI8GnLS0LALhF4vR6MJKCbXJxWtkksb1xQto2Cel0T3DaK1C0uB2jeJsHLGVzqtkSWSkC4LRGK/Z2L0qZEcvQFyZG3CNTo9q5pUxLLG3TFbSPonpIfp3+YwneBe/m6fzpebv5K/FKpy3H/eDrY15eP89PV3fd/3/yO/xX5dnl9Ojx/XA6qtPwfKR8/UP40QYZ7/cUpX+Vn5072l34FvSvZIcf7Lx3Mfw==",
      "brillig_names": [
        "_join"
      ]
    },
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZnRbts6DIbfJde9kESJEvcqwzBkXTYECNIiaw9wMPTdR0oknRaw0DnrTfSZsX5LJEUpzu/d98O3559fj+cfD792nz7/3n27HE+n48+vp4f7/dPx4czW37sgHzFyk+64LaNNep2ytm20kLSto816nXG0hfsVadtoEUdbs7a0+xQDQ+MHRelBwBDvdilEA1KI3ClmAVJIZpHxdJABDUCFHA3MIoMaIN0rAyaFGgyaQuPxpCTAD01ioTwAgjiFBIpCNIv4DXiCII4bwE8H6QXRwCwyQmgCqFDMUkgB+aE5CbAls2BOPOYSBFBBlAeYJZslm6UHpINZ0O7BqlBNWZxQ2POZaEAJYKBflWiWaJZkllQVwCxg9+RsYMqlKGAwkCmTQFOoYFAVWjRABQoG1l0GL4ASpgFmiXoPSphKEigGpNAH36EqdK92sJuz3SwZNcAsaN1lFh26ezugQrOnN+ve7Gaym0mfXkMykO6cxlWyrhSBptBTQqCnRAcZKjLkYJANmkJJBqiAdjNa92qWat17knAaVwmBQOtOaALyFbu39WUv0Ht1IAVZXwN4gshZR5JayAlAMRmggoRpQFYAu0ei00GC0kFSHZMAKkgsBjQFGc8AUmhmkRAgMBAOiEFKkhIZSQopNSNZmkreVwKAWUgioJSdmpEEQQmN0Hugq1S3VVeprtJcRaKCUmqDpJISKfGDjSSJlIqRrGQl9W6MklFKxSi7TWoIolB3XxXqzx2ESr24K5WRLDH1NB6UncgouS25DdwGbstuK65XFlszkpKvhEbVe1Tv0RMD+5Yn3hAb9NEPKjqPXvqVFhsZdU9Sp2YEbpPcrbILguyfSmhUXLmY/6Bn8iDzM/Q8GOTPbW7zeIDHAzweOQSn3vfl5W5nx4KvT5fDQU4FV+cEPj087i+H89Pu0/n5dLrb/bc/Pfebfj3uz7192l/4W57B4fydWxb8cTwdhF7ult5hvSunZK3anZmaS5TXGnGiAbIKhkSO2RViKe+WyI1MomRclYB1CawhqgSXZnAJntK1Ql5XqOgCdfFDxLzNmbyg15yJMw05eKhEDavDqJN5NLCMqK1El8DXg2gzTyQLR+U9dU2BptMg8HmUhGsaU3dyMXONBGE1NyeZRcUkiBZXcGV6/yi4UC2jIFgdBfyDJQK3r5FYbl4kET90lVw7FMJ6yWkzZ/hE+PdQXR1HnORoSy2pBq+YvJahaTKXFpqt1sYxXpWYlb6IIbk7MMOmlQJAi0s5IVZcmuD2ypPyzaUnlZtrT8J/UHzmU0nLVHBdYpakGH07QFgSjH+V/kVkMSyRbauRhYkIYLLI8lHmetHCa41ZmvIhzcaRiBYNeqORbs4OgJuzA/I/yI75VN6VHYAfnR3X677VteyYa6S4aMBqOQa6vRznWS2FSF6OE625NM+StKSrLTKtunQ6jPftChlu3hVy/uBdwY8+KVz5Ir45EM/2+pp9tVVaJpLam5lMTqNQbB45XimENwqTMso/UC25Er+oXNeYJOiSGOXqHPlXCmSrFWPZNo/kBzg+zKZtGjV6UOtkJgU+VoNfMvu2hFfnwL/SqNXrcKW0TYOCr3hK6xqzZRKSrzR+97NJIsKySee2TQKX9d62jQI8RRm3jaL4tsYFtG6TwKUGN9o2kSWo/C5nm0T23xhQNk2kZgtIzbhFgPw8TWXTJChYPCltG4HnFNVy4xTeCnzhy/398fLqn60Xkboc999OB7388Xy+v/r26f9H+8b+GXu8PNwfvj9fDqK0/D3GH5/lzMn/AH2R96l8ya8DK8gFvxr8HPk1eCz05UWG8gc=",
      "brillig_names": [
        "_slash"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "claim",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "spend_limit",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "storage_read",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZ3ZjiW3kYbfpa91kdwZfhXDMGRZNgQ0JEOWBhgYevfJ+GNjtydZWXmqbzq/iiYjuSWXCJLnP5/+/uPffv/nX3/6+R+//PvTn/78n09/+/Wnz59/+udfP//yw/e//fTLz6f0P58O/qf0/ulP6btPZTR5zlOc+dnkSfo32d+EZz2qPvXvpH+nKc9c9DnkWbI8+6mn8pPkOao+9e+pf0/9m8747btP7Uj67PJMhz6rPkme+dQ/zmc59Fn1OeVZsz6HPJv+3bo8+xlv8rPpk+Q5ij6nPKf+PYc8KUl8Ej39OPRZ9Snv76noU//OWZ8denpJ+mz6lPf3WvWpf7eiT8lH76qn6/uHvn/o+7l8+Tn176nvpyx6SPIxjqRPef9Ihz7tb3n/yJKPkUXPKFmf8v5RD31KfYymf7eqzzMenU9OLz85velgaArTJFNVkKogVUHy6nlkfUpRzKR/J0nKzAdeMbO8cnJSWfEsQ6GaRFvF1FYxtVXMfuiz6lNKc2rpzqFJmVleQfpKTioU82fDQEc1EBWUqj5FBWmDoCyvppL0qX9rwRI3iHR+scRpFeBPuZzAqRVoCiMZmGRamGmxyCSkYdJxHE78tgoiI27KSsMoJ6dmVFxWXMa5UAoZa25M3EiUphE3cKVuhEYj5DGGx+BPVMll3NxTBw2lxE1eqTmREXIp5LLsMm5TQsVlaFaDCe1KyGUtOTUnMurFyWMMjzG60XQZfx1pMqECharTVMr8lSh1o3Q4VScyyi5DLokJuRQaRjU5NScyah6jeQzUpZDLOJeZ20HGECR0pjRzvWXOEahwPpR4aOG4heuoVNA04u9IyWXFwxWXVQ9XuxF3VkrVyWN0j8GpF+LUKzWj6Vqma5muhTwtZFrqkZwsLZXrqDRQcyIjbolKw4i/NyWPUTwG9xtKLuM6Kh00jZBLoW7E35tSdfIY07VMl5Fr4YGxnh1falyDSsOIa7Bm0DTiGlQaRsVltWDCkjCCC8hUI7WeDLoCJ60ChgInTEAl/cgGJuECbwBSyNVgKnCCBIYCJ6wDpgKnUKArcA8tYBJuQAImmRaGWw96YQzaQtx6lEhpHMXJwo1UnVyWPVx2Gcq1gTj3/NUP/jIqgYYR91lCnIV2gJoTGfF0SWkYcZ+l5DLycGQyjOdKLkvJqTnZ22YuThyDWwNGeaVuxKOOUnWaRs1jNNfSXdZdC38FLYOaExlxU1MaRjw5VPIYZDEwJVByWZLp8wnaqDEvEOj6CWBqoNSMOItKLmsyx08yH2DA0Ij/Q5MCYWgUGkL5OLKTvjUfKTk1o3w4uazIW7OM8Ay9mLY+jYa/Yfhbp8umv5X8rWRvSMfh5LKkb01Z35qqNvcsgzAIfYbQNOou6x5ueNzhsunhpstQwUJNKXPqlLjpdCY04wHqRtllXLNtMnHNKjUnMuIcKQ2j5jGaa+ku664Fnygxceo70sc13ytoKGGYVWJZY+KJtVI34ppXqk7TqLiMUy9UXVY9XHPNzTWjjxyg5uRahmsZLpsumy7jiUM/u4ZcuXtU4hxxaVTkSMhl2WVcH0JcH0ouqy7jBi7EEwel6kRG3WXc/oW4/Q+kiluYEHeUSt2ITIbhkxt248YEyLJWPqdaxWAqVJNUkzSTdFlRZyx1AeMwqAZTAb0aQJYtuekq7ARZuOSu67ATukJKBibJh4EuXzJGUCULVS2erh4zlr2AVgzstd0kfSgMWcNmjKWAeRhUA1Igk5Cs7PM47AMfRzdKyck++pFdlj1c8bjFZdXDVZdxQ+HxNsuIivdyg+exNWNEFeIOSInzi7hcF6OCphG5DNXBmic3eKVhhBoRak5klD1Gdi3FZcW1oH46qBthYS/E+rgiZLks5DLOkdIwQoMXak4eg1xGJsOYqeSyVJxMM+Xk1Jw4BpcpwTgkNI1gIBLqRjBeCHmM5jHQAIVcNlzLcC3TtaAVJhAZkcvQENkWh+FXqRvBICNUncgouyy7luJaimvhacJkex5W2LMycT6UhhE+JaHmREbTY0yPAYOSkMmwwlZqTqYFK+w5QNOIO2GlbsQmPaVqVF3GXYVQc1nzcM01d9cM0xOXQeLaogIaRtwmlZoRzDpCISOlzN+bkmnBgK/UnDhGZ+LaogEio+IyHjKJmJrr664PqQcNlw2XeUqxclaylJajOrkMq4LjAE7HElJ0Y4rcjx2IBnOGotUAhm4llw2XDZeJiU8QZr/JCDvGQcAWSIb1cGlFv6zYHXNIc4TlMk5seyu1YPRJQEi5GVQxqRUgOcKAoRhSTKUFYYVSXKQRFrNttnEVrIwTm6JKxRKOLUYnQsrl0LCIUxyOKaSwzwjKGCoY0hJhYaNhE06B3TuxpaXA9H1agRgxD84JOBy5kRmGFHNhxek4QzojLEFDBnK1ZC6HDkMbW3YKpgiJzTgFkwTD5phDmocjhlfFkNYIi7VG5kLt3A2cZiUgpBNIjjw6GYZ0hHSEVLIpOBxlySTYDYdkUxCtrwPJEYtyRSw/uKB0WS44HEtIS4StIa0RFt+iYgskxx7RekTDEkyxO4qBWDCUzVBGoYw8ZfPIga5sphQIZQVIjmjKgiWkYsiuwBZIjrI+ExyOMI4qRjQKZbRIXRnh0zsacDhKDyOIaANIjpJ0wZCWkJaQSr0JDkdZjQp2R3yFivFidDaKeMUEkiNaquJwxAep2BTrcaTAkMIqrBhSzmaFxw/LDVApTtOougxWfIZeFLCIB6gXUJbwAJMkkySTZFl7nDAU1Oh2Qleoh0FTaGJQO6ErqNHthGowFYZJsJiEG9Mk08KQTu1P0ml8zUdyGkbJZcnD5ezksuLhisvELZKA8IvAhYqeTDGk+DgqoqF9KJIjPg7F4YiPQzGiUSijRerKCj6OWoHTETkUFM/PAELKraaI70cwpOiweVlTZSohKNkUrIHTERYaxZBKNgVDOiMsPFxsHjzH+hRIhvBlJ7btVbizFTHmKg5HZFOxBUa0EspKSGsow4fPVr7TbpADuyMqVrEGTscRUnz4gjOkM8Ki1bIZqsKVLig2BEF87YrIENdmy0dgDZyOGIkVu2MNaQ0pxiXFkEo2G7AFkiMqVnE4ov0qRjQKKbkUTnjDReqv6KkE+itk7qEIjyC3EnjmT1cAkBxRm4KozY7NDZhMscmqwjF/WumBw3GEdIQUeVPsjhRSculA3hRbIDlilqEYUnFdCvqLxWyhGK+oKRC+Ss4mTBeGNZAce0gxWo0MbIHkiNFKcTgix4oebR4pMKTpCFyk/goYNQz9FbOEMnil2bBR4SA43Q5AeEk5FxPtV7EFkiMGOMXhOCLaCOkM6YxXUEgpXkH+CpmcKLoymZxM7JNBVzw5FzB6GIYUOeZ1V8VeAkXJsWANnI5o1YoRrUc0fLyCI6QjlI1QNkOZmfYrmWm/kpn222Gm/XYcLlPTfjvUtN8OtW6eMBRaNjBJN0k3yWi6lWjonqFjVoOpQNlg2H4jceudMBVSNugK+TAwSUkGJqkWpqpr7qRp1IoTGXWXdQ83PO5w2fRw02Xo/ecEDkOZtSi2QHJEt6gY0XJIc0hLDgxpjVfUeEWNV7RQJvsCOL0ZeSXs48LXQxVIjugkBJE3tqM0uC0EC/Km2ALJEXlTDGmOsDmkGMsVQ1pDQ40Xt3hxC2WoRjbnnKNkDQwpBjnF4YhOQrEFRjSKaFh8AeHiMIQyLl84OQy7I0Z4xRo4HUtIJfPAGtIaYdFJsK3qxOGIFYxiCyRHybxgRJuhbIaUQhn2IrIlqjXuJwxDCu+pIu9HPBJ2+pXA4chfqGELJMca0hpSHvoMQ9p18XPSNBrZaRhNl5GsjVpXt06Di6QCqgEpFJMUk1STNO2wsMcAoP6dE5qB9ndd/TvN9hic0AxIgYrBEBjWAw7rAUcySbIw5hM5qRmVw6kbVZdVD9c8bnNZ93A9ZCS+k7M8q/hOGqYUPNs/TVPViLITqpvLG/YJw+6YjsAaOB1zRMshLSEt8Yoa0hqvaPGKFq9ooawj2gBCKttLS+BwnCmwBZIjRTRyKSYRhv4K2Wug6K/AJMKwBYYyXvxnNqc2eE8UkXnF7ojMK9bAiNZDytWrOEI6IuyMV8x4BdmMIWYRRGqp6Ni/qOQy9IAAUqi6BaEfLTt1IzGLglw2DtM2mpO/Yfpbp8nE4pFAzSi5LLksuyy7rLisuKy6rLqsuay5rLusu2y4DF+SEBlNl02Xkct42AFhZ6HSMMImEaFu5DnKniP4PYRKdXLNmN8Juebmb2uuufvbPG/Z85Y9b9nzlqdrnv42cs1kb8N0QsneVry2itcWphJCuTqZZnhRlFxzzU6uufnbvN6K1xsmEEr+tuGah79tuubpbyPXTPa26i2xekuE/UMoVSfTjN2GSqYZG/uV8DFmbFavji0HDkds0VOMaCOk/DkpzumIbk3RpfCZGJJjcg0tp0B/m4z8iiGtOdDTCxOGYYSV/qkAyXGGVJJeGSXpgsMQLhHDFkiOqQRGNAxHiiGVXADR8/Huno5h25BrjS0UHfv5FVGrilzVvHGmw/FgGFK02t6B3RHtVjGkPaQ9pPguFbmJsZWkD7RZxeGInhw40VgVPZqM0OxO61MqFlgw2nRgc6whxdfFFoqOpXsdiIavaiAAZmqCszliiGHrwImcIXagd0IXodgCyRFfkmJIUeqK2HLJryB8TYrdsYa0RtgW0hZh0V8o1sDpOCLaiGgzBbZAcqRQRqZsYIeC4XBMKbA55iMQygaj5FgQycHpk5oCWyA5YhuT4nDsEa1HNDQ5xUUKZXz2RMZpxemI8UCxG8r4rVgDXVlKIU2uDBsaKi9yB84MVF7DDlgFVIoNWtwmBzwWaJMDuxXQ+oYM1orTEQMZt8khozQhmlfWwP4EQWxQMAxpqoEhzRHWm+eAz8KwBUa0GtGqt5LsLXVkb6lDRm3FUNZD2YiUjVA2Q9mMlJHXfCZvRuU4AmvgdEw5MKLliJa9wZQS0uJ1XIrXfJHMCw5HdI6KLTCi9VDWQzpCGXojtJKC6kbbkSEdUjglMqRwSiiiG1QMaQ1pXaTk2ELaIyxGacERb8OSBE0OmxYNuyOFlFyKw3yGzTGFNEVYDHWK/jZscjCcjlg3seFlYNWd2RQyGs6TKE5HjMeKw1DGY7ZpDBljCWfUMLYISqEK1sDpWCNsiwBc3YUtEgPLcUVOpOFwxDkKxelIIcWBETY4DJj+FXFQRHE64oCIYkTDERHF0ICjIbwYPZEccThEcTj2FNgCI9oIZSOkM5TNUEahjKCMWzXs/YbTEWd9FMkxV8eSA70uZPRX9GqRRbmg5KICoZdb1JRqAc7mSEcgXtyBZIiFtuFwTCmwBUa0XANDWkJZCWU1lNVQViNai2gtonVIua3jUKAiPl7eKDQw+htiGsqlQzJl5SONh8xTgTCb8E6iE6cjPhzeB3Rid4SthLcETYzdhtOxhxQ9jGI3hFE9TyCm7ootkBy5Kzacji2kWIsIYi0yCxAaGiMOPkOKxawiciEoyoBYBwjOCLBogMVSEa/ofPwUB9gEsVgRrCkwwrYIO/HiwYjuVZEMZQwQLB62Vg9b+7BsyjpLUPQyyjJKMHnYlj0sfLOV/bgTK5/KxxsmVj6GLsUR6MrHvCYWNpU3FEw4WXMWbI7oXhW7Yw1pjbAtNLSQ9gjbFylnKCM5qCzeFzaxwUtxhhTNnvdvTWwON5yG2CBu2B3lYxAMqWRTMKQlwmIU4WOMJ5Ijlp6CWEDz3qmJ/jfz1qg5YC1U7I48RzSsgdNxhpQiLC1SMsQ6y9A14HS1ob8YZ6wNEa0CyRENUXE4ok0qtsCI1kJZC2kPZT2UjVCGXkMQoz9vmJpiKmVbxUQPntkgN+FvFaTjCISUM0SoWMUaOB3R4Sl2xxJS5FiwhrRG2BavaPEKdI5s6Z7otg1D2QhlI6QzpDOkBOngk+eSoQlsgeQIT4nicESnqxhSyZBgSFuExbfJdng68G0qhhQmbsXpiKTzJoxzKc0BGpThK+TtFgSHbOajTCdyWDZxEJyyhiHNIUUNCSJDiiGtIUWbFEQNKdZAcuwhxTRUEHlTRHIqjvrnwJBSSDFXBsJZaxjSFFJUoSC+QsUaSI4lpJiyCqIK2b5DsLMqogoVQ9pD2kM6QopPT3CGFJ+eIjmiYhVdmZzwVvQcl8gxVmqKOaTZywErNcOQ1pDWGuilUzCiK3rplB7S7pVVIsclciy3pyjWwOlIISWXwm9rGNKUA/0VNR+BNdALVYZ8NrCdGMpqvKJG2BZ6o2JrVGwdEW2ENCpW1nqCFCkjr25Z6yl6csRDq+jJkQmGoHybE9gcpQoFOfN8Io5wpM1wOvYIgMpS7I74ChUjGr5C3hhEsi4EyrpQsTumkKIu+AQW4Wx4ZusMYb/6absAdkf0MIrNET2MYkhRF4IjlI2QzpDOkFJIyV88jhTYAskRvT2fkiIsEQ27IyqAzU0Ex60hOaJzVAwpekTeskTYYq6IT0SRDLG3C1NLwrbxymdjCXu7FGGdUQxpCWlZpOQI6wwGFJz5VoRpSrE7wjSlGFJY4ARlpjuB0xEWQ8UzWkHTgIHYsAWSI5a0isMxR7QcykpISyjD9Q5ofdhibjgdOZuFTYoki0FBLOIVm+MI6eiOM6Qzwk5yhIFCcSryFTJ4cxcewVgMG7fgvMgl38JlkZclPGqYd2jyJTUjWHwSWZiCsQDmY3gnS06VWeeUuLi5wzjk2PoFV8rJsBwaw71RwTBtK8O2bYy0oUySeFGUF7n7UZhbcD8WXuRjkY9VTsGwGLK35GSYDI27c3aPCjMFp4iLrVlYMDPPYPRKxj0YQ6FxC6ZFjtHQGDpRnjLsT5RJQZek8rqEkaW6sK+0T5O8L9aZI0xd9FRfxTPjXSgrcVsqY9mljGmp8lzCU4THjmksr5lnsOgXxqJNeSzhR4THalnz3jEDUBb9wjXKR4yMyj3CizlQLm+Cs8+ZgmEcNB7B+NaMl7h10VlX+aKzLTrbohN9Da4TOnD4qODanwOnj5x7ML5B4xZMixzGN+PpjE0+zqFzpmNhjpuzMKc/I51iSTRe5AVylC0GDdPTFv2SR+VFPhb5khds2DFe8iKWRGGcdDaGXTejvcF/6LzIub0Zw0aYJS5uN1JuUY/Uoh7hO3Re5GORo58swqgjXFN0yKCA64QO7MVxrsZyn5hzD8ZYYLzI8xIe9YKrhBI27BRe0yfuFJinMOQEhjHbeAa3RY78GrfgscjHEh53HeHCIrldrLAxIcn9YgV3raRD7nUqwtM5oU0aL3K0Q2MKzos8L+Fh3uYjN0luGiu4tkfuGiu1C0OO8sFVJ849uC/yPoNHWXiRzyX8hB6UOcaUgiuBEsaUgot4EtatBRfmyI1jxnKflfIix31dxiO4LPKyhEdfhMty5N6x0lA+OCxVWhVuC1Mw5gDGM3gsclj+lTH3aU24B6OdG9eFyRl+R+cZnJAv1Bf8jc4Ij3IukndlvBdlXiTvyi24LfK2yPsi73XhGSx5Vx7BqHdjfJso8yLfuHJbmPOOuVbCwSrnGZwWeVrC50Wel/AoB+MejHIwXuLWJa7cbaY8gtFXGy86x6JzLDrHks656JyLTlrSiW8B88OEXcrOLTgvcvTVmCsmnJ0yRp0a14VnsNzVprzEHYvOscjnohN305UkPIORF2PERTvskhflFpwWeVrkeZFL/SrPYHi4jEcw+jTjJQ0tLYx3oX3C9u9cF57BmG8Y9+C5xJ1LXIzRyhTyIXkhYQouixy3DA70h0PWZcojGHkxbgtTcF/i9iUu8mK8yPGdCovrdKAeYbt37sGoo5GF28IUXMrCI7imhZe4bdHZVvmis9talXkES76UbQl6sq9BmdvCFEwhhz3feZVHeF18K4/gnBf2dWiiWIcminVo0iW4cF3kUg7Kq3wJL+UwhGewlINyD5ZyUF7k6JONuR2OKUzG+YBr2ngES9tQXuSyHldG+glcysIcHmvkDH+A8yLHWpX3GTC34Al5Foac+8MsG6aMeY3MvvmTsaY2XuRYU7NPPslFb5X93Umueqvs5WYewX2R42jYgTziLph6IF+yFlaW/bCHMAXnRS67mZEv3c+chSFHXjJObBgv8gZ5FYYcecmy67cLU/BY5GORz0U+l3RSpLNIvSDv2J7k3IMxpkwSHsFjkaNNKqNNGi9yWuQUcrnrVBnzAWMKRntTLkt4jOOEvMCBfb4EjD5c5ejDKQuzTkI5Y83uHHLctmKMb8F4kSM9ygXvqsItuC5yzEmoCeNdqBcZx2kIQ462h9tWCiGP2MCk+cLBIWOUs3CXchPGvAi2FLk/rcC+kWXcnEiPjJvGixzjJuwYGTeSFtgQMsa4ijl/hsu6Yp6fYRMwrou8uZ1HbjNzrgvP4LAdZYxfxnORzx4cdh6550xsHXKDmcplo4+y7+w42Tdm8LS9BIe9KNOiB3txnN3+kynsRZnCXpRJ7DnKS/iwF5Ujuf2nHGEvkru6jMWeI9yX8GMJT27/KSnsRSWFvehcrc/guoQPe1HBeqHynrIktzc5UzD6H+NFPhb5WOSwNwrLPBb9qtwkVNCXFpmXGrdgfL/G2KXVhWew7NtTDnk/ysKLPC3ytMhzXXiRwzZo3INlA5nyErcucWXL1RSGjQvl0JFHY/I8yjzTeJHLXj9l6OFvvAyxaykvcthPMNYU7D0xxrzOON6Fb9k56gW7+51ncCsLL/K+hEe/oTwW/WN57ww9UzZ+Iv2yd18ZfifjJQw2xyhL+SsvcjgCjUdwX3T2RWdf4o4lLr5fZfQbxks6adFJi04KnbDdOYdOSnnhSKecucOYVWQnibJsOlWuC89gOPGNl7htiStbe4X7Iu+LTikTYSkT5RE8l3TORedc4tISlzyd9TjKwtBZwFImyj0Y/aRxXXgGlyVuWXTWRV4XnfDTYR1XZWu/MO4pdG4LUzDmgcbwBxEY81XjEVwXOfw4WJfJJUTGYwmPObAyDpwYhzwfx8KrnILFd6Mc+nHdsHMPLpE22duvjJMYxjMYBzCMKbgvcfsiH0t4OV6Di9/lyAbsuidTMMLDxttgdzWei1zOIHJdtCSnEJVHcFrkaZHnRY5yUC6LvCzh5Syi8vJembcrL/K+hJezeQSWM6nIuxzIgE+hyYlJ4xaclzByD75wWcJgfQGbf5MTGMYzuC3ytsj7Isc6SHmkhXsw1mvGLVjO3w5hyJF3OYJRDmHoQTnIKUopBzl6oSz5VZ7BWE8ZRxliK4/zEh7rPmXMVWDLanI60ngEI83CcjIS9swGu6Ux0qmMubEx2m0Bo80o4+iSMuZa8JU0HLEw7oscfQL8HQ33PRnLt6C8yOcin4sc/Vtpf/zx3Sf7yae//vbrjz/yLz4tvwH15/98+tf3v/7482+f/vTz758/f/fpf77//DsC/ftf3/+M52/f/3r+71mKP/789/N5KvzHT59/ZPrju4h9XEc9XX6ksU9r4nAFc97VcE56u2o4cT7QkGAjgIbTNNCuNJSNhqOx2V5UHKc91HX02yXB/ZKpOGe6T/JBzcrytAddlmW/1jCTKTj9mR7/nJzfVsAWE1UwLhXMTW3i2lWpzdPiEypOdY9UzCcqTuuPtamzo44WkXu+3Sw7d+6Sij7qVWXw7PtKxRi8rpXSPMcpV0Httgq+RlBV8OWArqId71Axsqug+kgFJvWi4vQNP1PRDlexfB3vUQFzoaio5VlZYPeQqqD0SEVL1lOcvie6UpF3TYuKZYTvGXcVZ1P9UkfatK1ZLCdjtnTVX+Vd8+zZavVc3c1LFbt+M+GEonxoPMG4VLItDrKP9TShpOvi2A5Dw4aA09t6XOvY9X05PtfTrXuZlbHrPmfzL75cl8au6+JfKvIi7bU8KdKSPR3lNDldFkfZjUZHqTEkRl5OV8iXOnatdFRvYmMZVc9Z5pc6Ns0UmwDke0uLhuMrDWU3oJAPKOca6pmO7PMc/vGUZzpG8pnOaaO51LGv2eLzrXMtdl2z4+WGXubLDZ3T+nJD384d84y5I10N0jXtknHk5Mk4zQhXydgNCuyrsoSwH6pfjfV10zzOta916XxT4VU6eG/QZbXE4HQay46HWek5sjIvpy1105XyJZb20VK6LNK6a6S1WonOc+H0AbUy65MZ2Ok8sRGO72V5MmXovQxX0R+qWFKxfG/vUHFaea1tnI6c9kyFf/Wn/+dSRdu00F58QttLbVfVyquxy5YxpqmYc+mK+8OMpEdz4tPpVVxFo2cq8ogJWHqmIjIyluX3Vyr6bkTpyTJyekTW2ehXq8b0cq32/HKt3s5JHdc52epow3UsI8pjHcus57909J0t4PAVLNVoG6fj77Zp5oh5dXpkmjknB9M15EuTRqdvPLxObEzVCUu/bOXj9RY68jftd77IyHjUjU9sylEV1J6pWFJB45GK6kvYWZ8NJl+omJcqxs5SVHL1SXlPlx/aNhnNTUWz9csqmZvPpB5h2zhGfpiMaFz9eDQWnG5Qr9bNiDTLNy7Q7tNYvinhMhnt9WTMTQfKP27o9rsvLALv0NG90+BfJrzWsWmjLdrXOeva5IVeNvbQ8bKxh9IHGHv2xRGLnJ7rw2rxSc+5pL6uWnp9Hkqvz0Pv54SelUbYWPj3JK9LY2d0IreL8g7SZbaR7qeD4mOh9jAv1D0vRNczuHSk7crxiLGJLqdO6civz792uTn9oW6FO0bb5GbXUFuNld+mseM3rK6U0LT+lBYPwNeWPPxm2WVmZvHZ5Oxrqbb3KJmuhNJTJZR9mn+2uccpaaGkPVUSZULLqvyd2WmRnfk0JRRu2PXDeW9K3NR6HOnlMjmV5GdK6uGOzHr046mSXv+/adl7UzJDSf+AMhnjaUrIs5Pyw3ZyxvSCTeV5StwRl2p+vUxSLU+zE/681e3zPiXZtw/UnJ62k+S+e96P9XqZnPbKhymp4e+tc9fHttedP2hOr3p/0s4Ndc/9k3ZeqLv+n72S8MTnXPNDJTc9QPsZQXeLSt+ZuVLZTV7LslUk06Uxo+yaa/j0eU/5dSPZJuSeM2q34iRc7irTm3JtBE07b9TN9UCqxzc1EH2RlfzIQETFu3hac9IepqKOZ6mYNkbw/VeXKmr7gDrp37ZO1qykR+4bqu6X4wu8Xi7QZ7tfqHo/SC09q9bp0yFat5g9VdGeFec8DlfxMCOxiDiXRPVlFcs2nq9VtL61qfi+wzTW1V39Ssl42TyU2nzZPoRZzssGoq3T9jiq+5+P45mRnO9X8s2YR+rXlbNzSd10yKdevq1H/ojdPHx50vW33z+gM+3ftjPlG6vcH8Q3U11nZrf9xM0IlK/LdKtheA+SL3eepLEZ7Wn43hO+C+9ZYcRYfXI7nrX10nsomdclOl7ffIJtdt+0rX9RIv26rY9dr4rD56Kk5nHdq47Xd0ml8fo2qTQ+Yp/UG+XqUzq+LK08a2l12SW/7rT/WsnMr3dEOz/Vh3REX2Rm1off3lqs7VrJ1ur9AV43vr1qhJ+d5qPsfKEkbea6kz5gTrP1V92c0+wcVnfnNJS/9ZwmJd+KwddcXffzO5cVNR/0lq3rXx9p2Kcj+zZpvsbqWS/whZJyPGxpxfex4jKrh0rc/Me3V7UPSMkcD5Usu1xKeVYmpbqr5+ReP0DJuExJPsrrA2je2anu7qff2SHvbqg/+rceQMtyvKu0Z1swv1JyvdskH/T6cLEzqlZyd9Gal682duW0612z23Y9fi3vsIUW39Kay3Ls451W2Xvb8rfn9uKDaYs94uvjZrdV0BMV907u5bSZsDb/3Nosz1T0fPjUrD1UkUJFf6jCB7q+uu3a7eZ97xTjbvZx7+TeRsOZci+HUS8H/Jxf36OS8+ubVG7n5HJb2VaD+3D490EfaVjSMPITDTMa1RyXQ2veuaJurpHzrsO6uUbe5qRETq4nTnc1zGel6cueTqldl2b7gNLs37Q0KZxp1Mp1Tjar/Ls76PMHOKDyBzig7mdm4118Q8m9XfT3lWy20efdiagP2Ef/RWO//uDyzg11b+22baf+tXSi/uSbpbFomA80jMMtnmPdyf91QbTt2Yjs+6763Jx9brudqNn3wPNlzJeO59zyyxaG3MrLFoa8OxF128KwrRmfz4+Urg+lt9fP7OX2+qG9XU5SiZy0cZ0Ten1k2Z3heX1kGbFzbBzzckd/7vkDGvpOSe6+tsh9Wayd+m7r6DGDW87fUHpHVmh4K6d5qeNmgeZr33PumwbK90xbKvqysbD2d+hIOYWVNK9bLPJXWjaN9LSI2Fhd1h1W/9VItzp8ZCp5XOvYHYzCz8yEQ67UZynBtdmSkjKvZx5jewnP8BNB/OMiD1NSvVs/TWHjOiXb3W8zZg3HvP7830iJ32NzpuS6G9o5ofhHQcJLse4yeFdKmluMStuVydaqj1tstdXXa6fpG99OmWE8rssctd2eCqXS47qn5fDuaXq5raK62Yiv4rpUkXdOqD7cSDpyj/Kgr4xos+4mEK5izGsz605Fist50rplLDV6hxIKZxhtjrBtjWC+tfGLbd9fl8ZuE8rNDaN57hu7TWM2G0bzzvl0d8PoXslN0+Reyc0NozurhU9R20MFsfxZlvrvsbAeOXb09GcqUglPz9KXvktF3GuR5rNULN7eQs9S0XLcErd0xe9S0aPzmvQsI2uf8Swj+JEic2U8ysgHNG6exPl8bjzLyIiJ6aBnLgSK4qT8SMXwTW+j9icKyJ3u6yzhPQp8+Uf5WQr8+6LRXszCMwV3z/xur/27d+S3pM1oevfMb0ntZftESf1l+0RJ4wPsE28Uyb1zv9uquXfst+zuz7ppZi27u/de96ncPfe77TzvHfsteTvtu3fud3+Z4a1jv1sV9079lrw3Pd069Vu2l+99xK0r9w79lp2n6e6h37JzNd079Fu2d+/dPPT7hpJ7h373Sm4e+n0rJbcO/d4uk92h3zeyc+/Q7xtK7h36fSsltw793i2T7aHfrZK7h37fUHLv0O9bKbl16Pd+mYzxNCX3Dv3uldw89PtWSm4d+r1dJrtDv29k596h372Sm4d+30jJvUO/t8tkd+h3n5LiS6kvbmh+p5LuHqDytFOq1e3atban2anknVJLT6v45kHo7SB6+xbc9gEHoUt/+SB06R9wEHqv5OZB6L2Sm0v//Szp5kHo0l8/CF36BxyE3ifk5q28/QP2VL5Rwa/vqZxx//5cJ1rl9qKghtfy9CQ/WjDW7padOo7rfTll55X6ECWpF7c99rbpivZKplsfx26g2CoZ8RsTYzn08k4lPivhH5d9qCTsGyfSByip1zO1neWNvFM88clqfqZkxTFTfrLrYcb+jacaUlxjmEp7lIZ7V3rvLu77iDu9Z2y3OnH54G5fWzopyoIWG89XGsrOFZWnL+NPl1V6lAr3q88vXGq3NdDhDmT6wpTwjjR4lzFpOe7zrjS4FeFYPvV3acihIb2qoTxLg999TUctr9bFOhy9Q4PvjTpr81ku/N7Wh+0hpSN8+EtdvGNczsnvoTink4963Jzjp3XWH7V5n4rhKjaGqWM7V0r/31zpXSp8M2Mu7WEqlsM8ozxSUb3Pzef6/pkKv4k87xZtexU+o6/jWXFW32GS2/EsFc1dzXn1vLxPhbeL1p+1zua2ktMPVR+pWH9+qs6HKrxS1+vl36VihoqNhfF42Y1Vdy6oEcfVRjuOZzrCJ3fieKaj+yBw4ngwuRkzR2n06x/G2LmfCnaM6Gpz2f/0dSde8/bkeni9j9U40r5WsjuGf+vQWt2ecbp1XOyNrPS4UWQZWP9Lyb5q2/JbDE+bRzjxn+u45bGt+SPu4dmu4GMiP9fFZiuPVGR6pCLOTZxzjf5QRQ4V45mKON5J9VlGEvn+uvXSm3dMvL5QkR7N3e4e667bn366ZzCr299+ik1p/POq113YNiH3DGZ19+tPNxe9teZvu+i9e2dG3Z11ujvU7u7cu9v/1P4B/c8bubk3VNbt74DGTv1eHn12dw8s1d2pp7vnOGp7/Scfa8uvV2/7iB99fCM396p390tQd6v3jSJ5dVJ3d29T2e30z0fM1o/VrfLVGcG6vYHv5u/elu2vqtxNyc6J8AG/wHvvPoOdf+jWbQbHq5PT7dZpW8T149FFBC9fhdDdkTqWIfK03NwemcIPk9bGXe/POu6dudotQ6f7107fFF32wfttard+c7eO14+M1vH6kdE6vvGR0bu/ursbGm/+6G79gGv26gdcs1c/5Jq9XYHc/NndOl/etrdVcXfTQt0db7q7aaHuzhXd27RQtz8GdXPTwl7JTcf4XslNx/heyeuHHu7+BnDdnSy6+93RB6ye6CNWT2+k5JYDte4uptwuSv9y/vn9Dz/9+tfPv/zw/W8//fLzv8+Yf7CyX3/6/m+ff9Q///H7zz8s//vb//7L/udvv/70+fNP//zrv3795Ycf//77rz+yJv6/T4f+8+ezaYzvzkYx//Ldp3T+XY5zxX+21nL+Xfj/+9nr53Hw35X/PsfC787RrJ5/N/6bD/GV4yCOzwpTOUez85/BAmg8F5eskf7yB2fp/wA=",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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+yuP3l939P6q4xLPdePaW37tvdm+wHO91HO9zHO93HP9red6hef6O8/1957rle71Knr9geRHktUka0h+IvmZ5Jfm627yF+Wtvz+9ofgLf0uuMv8mv1oRtr3lujkthW3q2x6/Ei6/kfxO8kfmmwnqHxtk6H7T6H7X6P5wdd5VFwtWWlD9NohfUYNgUsjfgG+Q/A7Zax1ef4A/chVU8f6QK15t8f5JuPxFspbk78zi/VNTlH9pdGs1ur8DKN4fgMX7J7B4/wIW71pg8f5tafH+mCtebfGqEXIrkloktVPjZKoA1T9mFuVWGl0tja52C/7i/RFYvMpXv3ulinerFrjirdUCV7y1W9hZvKtzxast3joUz7ok9UjqZxZvHU1R1tXo6ml09QMo3tXA4q0DLN66wOKtByze+pYW75pc8WqLtwHFsyHJ1iTbZBZvA01RNtTottbotgmgeNcAi7cBsHgbAot3a2DxbmNp8f6UK15t8W5L8WxE0pikSWbxbqspykYaXWONrkkAxfsTsHi3BRZvI2DxNgYWbxNLi/fnXPFqi7cpxbMZSXOSFpnF21RTlM00uuYaXYsAivdnYPE2BRZvM2DxNgcWbwtLi/eXXPFqi7clxTOfpBVJQWbxttQUZb5G10qjKwigeH8BFm9LYPHmA4u3FbB4C4DFm0qmR/LAiUqrQW6/3H65/XL75fbL7ZfbL7dfbj+T9wunZv9XGqznAS97rod7rl/yXL/ouX7Bc/285/o5z/Uwz/WznutnPNdPe66f8lw/6bl+wnP9uOf6Mc/1o57rRzzXD3uuH/JcP+i5fsBzfb/n+j7P9VDP9b2e63s813d7ru/yXN/pub7Dc/1Tw/XXazzXqz3XP3quf/Bcr/Jcr/Rcf++5/s5zvcJz/a3nernnepnneqnneonnerHnepHneqHn+hvP9QLP9dee6/me66881/M813M913M817M917M81zM91zM819M919M819Ft1l9Xeq4rPNflnuuI5zrsuQ55rqXnWniue3que3iuu3uut/dcd/Ncd/Vcb+e57uK57uy57uS57ui57uC5bu+5LvNcl3quHc91O891W891iee6jee6tee62HNd5Lm+YNv11+d7rs/zXA/xXJ/ruR7suT7Hc3225/osz/WZnuszPNene65P81wP8lyf6rke6Lk+xXM9wHN9sue6v+f6JM910nNd47lOeK6rPddxz3WV57qf57qv57qP5/pEz3Vvz/U2nvtA3rdSvW+1et+KbeK59r574313x/vuTwvPtfeGsfeGsveGc4Hn2nuPynsPy3uP6w/Ppya9H3/2fjza+/Hpvz3X3k9cej+RmfaJTc//lvdDXt4PgXk/JFbfc+39XIn3cyepz6UMz1u3Cum/i0iKSVqTtCEpIWlL0o7EISklKSNpT9KBpCNJJ5LOJF1ItiPpStKNZHuS7iQ9SHqSCBJJEiIJk0RIykkqSCpJoiQxkh1IdiTZiWRnkl1IdlX3n0h2J9mDZE+SvUj2JtmHZF+S/Uj2JzmA5ECSg0gOJjmE5FCSw0gOJzmC5EiSo0iOJjmG5FiSXiTHkRxPcgJJb5ITSfqQ9CXpR1JFEiepJkmQ1JAkSU4i6U9yMskAklNIBpKcSjKI5DSS00nOIDmT5CySs0nOIRlMci7JEJLzSM4nuYDkQpKLSC4muYTkUpLLSC4nuYLkSpKrSK4muYbkWpLrSK4nuYHkRpKbSG4muYXkVpLbSG4nuYPkTpK7SO4muYfkXpKhJPeR3E/yAMmDJA+RPEzyCMmjJI+RPE7yBMmTJE+RPE3yDMmzJMNIniN5nuQFkhdJXiIZTvIyySskr5K8RvI6yRskb5K8RfI2yTsk75K8R/I+yQiSD0g+JPmIZCTJxySjSD4hGU3yaQu3BvLSHxK1m/sqfK4G0P3iItf3/v/7Xuq5WGPovz8jGUsyjmQ8yeckE0i+IJlIMolkMsmXJFNIppJMI5neYt0bIs08ObeV57XQvZ5BfzeTZBbJbJI5JHNJ5pF8RTKf5GuSBSTfkCwkWUSymGQJyVKSZSTLSb4lWUHyHcn3JCtbpMByX2d4nP3PU9g0ulka3WyNbo5GN1ejm6fRfaXRzdfovtboFmh032h0CzW6RRrdYo1uiUa3VKNbptEt1+i+1ehWaHTfaXTfa3QrXZ1KsuZ5+iRr516vor/9geRHktUka0h+IvmZ5BeSX0l+I/md5A+SP0n+IllL8rdKopa0H0ktktokdUjqktQjqU/SgKQhydYk25BsS9KIpHHLDKNXaRz5QaP7UaNbrdGt0eh+0uh+1uh+0eh+1eh+0+h+1+j+0Oj+1Oj+0ujWanR/a3QqEJm6rTS6WhpdbY2ujkZXV6Orp9HV1+gaaHQNNbqtNbptNLptNbpGGl3jlpteDE3ob5uSNCNpTtKCpCVJPkkrkgKSQpIikmKS1iRtSEpI2pK0I3FISknKSNqTdCDpSNKJpDNJF5LtSLqSdCPZnqR7ZjE00TjSVKNrptE11+haaHQtNbp8ja6VRleg0RVqdEUaXbFG11qja6PRlWh0bTW6dhqdo9GVanRlGl17ja6DRtdRo+uk0XXW6LpodNtpdF01um4a3fYaXffNKIYe9Lc9SQSJJAmRhEkiJOUkFSSVJFGSGMkOJDuS7ESyM8kuJLuS7EayO8keJHuS7EWyN8k+JPuS7EeyP8kBJAeSHJRZDD00jvTU6IRGJzW6kEYX1ugiGl25Rleh0VVqdFGNLqbR7aDR7ajR7aTR7azR7aLR7arR7abR7a7R7aHR7anR7aXR7a3R7aPR7avR7afR7a/RHaDRHajRHbQZxXAw/e0hJIeSHEZyOMkRJEeSHEVyNMkxJMeS9CI5juR4khNIepOcSNKHpC9JP5IqkjhJNUmCpIYkSXISSX+Sk0kGkJySWQwHaxw5RKM7VKM7TKM7XKM7QqM7UqM7SqM7WqM7RqM7VqPrpdEdp9Edr9GdoNH11uhO1Oj6aHR9Nbp+Gl2VRhfX6Ko1uoRGV6PRJTW6kzS6/hrdyRrdAI3ulM0ohoH0t6eSDCI5jeR0kjNIziQ5i+RsknNIBpOcSzKE5DyS80kuILmQ5CKSi0kuIbmU5DKSy0muILmS5CqSq0muIbmW5DqS6zOLYaDGkVM1ukEa3Wka3eka3Rka3Zka3Vka3dka3Tka3WCN7lyNbohGd55Gd75Gd4FGd6FGd5FGd7FGd4lGd6lGd5lGd7lGd4VGd6VGd5VGd7VGd41Gd61Gd51Gd/1mFMMN9Lc3ktxEcjPJLSS3ktxGcjvJHSR3ktxFcjfJPST3kgwluY/kfpIHSB4keYjkYZJHSB4leYzkcZInSJ4keYrkaZJnSJ7NLIYbNI7cqNHdpNHdrNHdotHdqtHdptHdrtHdodHdqdHdpdHdrdHdo9Hdq9EN1eju0+ju1+ge0Oge1Oge0uge1uge0ege1ege0+ge1+ie0Oie1Oie0uie1uie0eie3YxiGEZ/+xzJ8yQvkLxI8hLJcJKXSV4heZXkNZLXSd4geZPkLZK3Sd4heZfkPZL3SUaQfEDyIclHJCNJPiYZRfIJyWiST0nGZBbDMI0jz2l0z2t0L2h0L2p0L2l0wzW6lzW6VzS6VzW61zS61zW6NzS6NzW6tzS6tzW6dzS6dzW69zS69zW6ERrdBxrdhxrdRxrdSI3uY41ulEb3iUY3WqP7VKMbsxnF8Bn97ViScSTjST4nmUDyBclEkkkkk0m+JJlCMpVkGsl0khkkM0lmkcwmmUMyl2QeyVck80m+JllA8g3JQpJFJItJlmQWw2caR8ZqdOM0uvEa3eca3QSN7guNbqJGN0mjm6zRfanRTdHopmp00zS66RrdDI1upkY3S6ObrdHN0ejmanTzNLqvNLr5Gt3XGt0Cje4bjW6hRrdIo1us0S3ZjGJYSn+7jGQ5ybckK0i+I/meZCXJKpIfSH4kWU2yhuQnkp9JfiH5leQ3kt9J/iD5k+QvkrUkf6uEz6f/PZJaJLVJ6pDUJamXn2H0Uo0jyzS65RrdtxrdCo3uO43ue41upUa3SqP7QaP7UaNbrdGt0eh+0uh+1uh+0eh+1eh+0+h+1+j+0Oj+1Oj+0ujWanR/a3QqETJ1W2l0tTS62hpdHY2urkZXL399Maj3xbyfKEitVGHs5r4Kf0sC92L99RKknVt57Kyf7wLeMgd4IHbCDW1cn+7ENPj3vn6/X9m8Bw8AdbD+h/Pq43xukI+LS6g7bi9gLKS34yp/Hfe6uSc26r/71KMTw71uVXv9dWPPdRP3OvX/15D225pkG5Jt89fplTTKW5+fnLXQMJ+nSzbKHIGUYivXucYWOpdpI7x7NMrHtmK0fSrzlY21wUHydhAkhn73apzP00Eab6CDlHo6hVq6DlKW0UGa0H5NSZqRNM/3PKfTXeh4ra6H26sJMF4tGIqdAz91MqD2agrEryX4JMjMbRWfVA639Fw381w3z0/P7Xz671YkBSSFntORBpj/PGnDu9AHCDBWnI9UCaX6CycWwL3Yf1Mb7Tuw57FSsPx8O+xsAJ51vDbmBjOGIPl7XFAyiRzMivLxjVO9FrmDmXfVYswlv3sVM+el8Lf+uc1yZgP4z+hBb1+0BjdMsK9S+XpWA2xMzmK49dUGiGMdNxeDuEOAHPDqeewsyV/32tZ9bee+Ou5rqftalr+Bg0v4W7IReKJPNcq2Hgab0pW670SohW6aqdtHSFxSgQDiLTbG6Es8TKdtfnZG357+rQNJR5JOATD6dkBs2wMPuM7/g4y+AxC/LsyMvrMnh7t4rjt6rjtlMPrt6L+7knQj2d7D6Avygmn4pbihtsZrb/d8RoPV5qimmjK+O7DoewCTlgvDHvm4qSeFYQ/mAuvpOTwcT1Ft57kWGYdHT/o3QSJJQvnp+yExbQTGNBX/MLjpc+RSmCGXwsy5VO59C8GTPz03kEsR+rdykgqSyg3kEoIV98jHsyck244anpepu0AmYxhjIiQxz50bjj7XhqHPFfQwO5+KXb/RZG4H4NyBxFD1NvUQlJS/3oXGFnHXyb2xyvG2kkxdeLHY0R1wd8r8YMeO+etv16R0O2lupaJZV2v/jSnkJqXcEdjkdgIHl+Ow3ZHh7ofOVuFv/XO78nT8LWTZuAEOz50NHwwUhmcwYNgEiOEuQAxVn7krb33/2ZkULUlm183Le5ZeVbzU/576TE0QklrguIZUHbdmGEx2BcailhuLzIXanwlbuWu++TbuhrYR3SDUXQoga5KKIUcYEn535vcAIe8Zg9/+2J2BKe4GHKL2sKcJSa4Ct6EJ7YG2keuUNPm2yJ65E1fuaUGy72V4sv/nHiD6hCxhvleFOCH3YvgE3F7AIt8beIIj42Hr6WhDw9jb9IZhw+m4D9ObBvu49yhtPTEb1zbfxn2RBWBroEotCNR+uUAJ2aue+TbunwuUkOUWVNQBuUAJ2dOCQB2YC5SQvS1ofQflAiVkHwsCdXAuUEL2syBQh+QCJWTcgkAdmguUkAkLAnVYLlBCJi0I1OG5QAnZ34JAHZELlJADLAjUkblACTnQgkAdlQuUkIMsCNTRuUAJeZYFt5COyQVKyDMsqKhjc4GiirIgUL1ygRJymAWt77hcoIQcbEFFHZ8LlJBDLAjUCblACXm+BYHqnQuUkBdaEKgTc4ES8mMLhok+uUAJeYkFFdU3FyghL7MgUP1ygRLyCgsCVZULlJBXWRCoeC5QQuZbMExU5wIl5Ft1LfhcRy5QQl5nQeuryQVKyBssCFTSlu+dob8I2s6Ch6q1Znio2knAL5e2Az9UzcIn+ya99vbPZzS4fz78yb7J/sBkOBn4RU4uDE8GNpIUhieDv3S6qU/23T0/+9NYB9C/nUIykOTUfN4n+57M0JwH5ZvdnFUuDWLIpUHMuZTtyb4DNpBLp9G/nU5yBsmZ+bxP9j3Z8C+Yn5WPPfBq5QVz4JUA7W7ksfNs98A7x30d7L6e674OcV/Pc1/Pd18vcF8vdF8vcl8vdl8vcV8v9dQYS/MC7ZX2tIDB+f9+yul5Gt2FGt0lHl1m8R7pKd6zPQV7juf6qIzivYz+7XKSK0iuzOf/fZDBwIHiMmDhXoWmOUz4nQvE73Igfldbgt8QIH5XAPG7hvlgv8rTA672XF/jub4yP703XEv/fR3J9SQ3BNAbzgPG5lpgbG60JLfPB+J3HRC/myzB7wIgftcD8buZuTfc6OkBN3mub/Zc35DRG26h/76V5DaS2wPoDRcCY3MLMDZ3WJLbFwHxuxWI352W4HcxEL/bgPjdxdwb7vD0gDs913d5rm/P6A1303/fQ3IvydAAesMlwNjcDYzNfcyxuc8Tg3s81/d6rodmxOZ++u8HSB4keciNjW7vszxc8n7Pfpdu4EbQw/Rvj5A8SvJY/vrf40tx18yF5usPA/Gu5bHzcfdmwxO23Gzgsu9xhju5TzLdZFH7XsoYqycYsHiKCYunNoAF4q4sR16U/f8+J7h6I/ax5UB7w992Vn4/zHAXHhhv2R78tnPqTny2tan/WxvLKe+e6Lg9Du4tqfW0jXfgvUZvps1yY/87yuanGRpDB3BjSK06mxmzTfqJEZDPz+Sb2WCQsfDm5TOeg3pL47MxzJHxedazlwyHqTYSlTKZSIbLK2OhuKwIV1QkI8nKimgkkSyPVCUqa2SkKhyK1VSKpIzW1FSWh6srK5KxRHVF0tu0ZSIcjiRi8WpZHqqoiotoIlwlkpHKcEhUJcKViUQ4WlFRFQ4nKqLJaCwaClUlw1FRXlkZExWhcCzEFZ9n3fio6wZ565ns5sRnI0uu3fB+oeqkDJcTcqKiKlKeqAiHEqFKkYiUJyUFLRSLUMiS1ZFoIhoKJ0OVoeoUWyt2e1LqIFPXj3vY3BPu9TB6fY7k+fy8tJXJ2v3mDvKdrGHAnH4hHzs8BPWZtReYDvgX8xkNfjEfv+9LwGTg8vslT3GB9t3g7U+/OCDfNn0OGJ/hlhbrcKZifTmf0eCXGYr1FcOLVfn9SsDFKvyttNNQ+FvQZvoqOOkbuvF+1TPFPOe5Tk08Ss716Ido/uY1en2d5I18nvpp5E5U6NsmxcD4vMkUn2FZ4vOmJz4b+5u36PVtkneY4vOSW+do1v6uBbf132Xw+z1mvxG3rd/NN/vDxO+DMUT7qnom0Eapavw9hlwcYUENPs/g9wcW1CCH3x8Cc5KjbpTfwJz8ZwZ4jQHHjyyom/MY/B5pQd1w+P2x4XWjZnhgT5OqT3zEgOMow89tNWsDc1yqvBnFgOMnhuOo6rAkH1vXnzDca9B9vivb94MG52f/fNdo+rdPScaQfJbP96XR2+rn5W3bAB+vZ+vjYjXWgrNxLENNjjPc7zuy5I5fv8cD++V23c3G8E4mDD8HYtjNcAzvYsJwAhDD7oZjeDcThl8AMexpOIaqX49nOAcmGn4OKL8/Z/B7kgV+T2DwezL4vYHMeXSiZ+6c5LmevIF59Ev6tykkU0mm5W/8eyZ+MRgN7BtfAnnDdEvfBJ8OzqnUmpHPaPAMhjfBZxr+JrjyeyYDMVXJVjdP/9lqtA+jwY07cyExSa1ZLuaz3dc57utclYPoDq8C3Cifh4miwPF+FnNOfl7WJ6HM8pwasz3XczZwmsyjf/uKZD7J1/m8jzGaafg7jwuY77whTmKgjXKeu18eNib/FHNhXjANrg0AD/cpYxwN7j/fm/Bi8Y2L+cJ8F5BUcX/jKe6UTv2Rk2EU+qNTbfwXUSj1bZ5vgAW5EBxcdFNTxfMNQwGpPThuAzdtgNvvefc2BRrTRYa//aFwbAbE8QUmHBdbgGNzII4vMuG4xAIcWwBxfIkJx6UW4NgSiONwJhyXWYBjPhDHl5lwXG4Bjq2AOL7ChOO3FuBYAMTxVSYcV1iAYyEQx9eYcPzOAhyLgDi+zoTj9xbgWAzE8Q0mHFdagGNrII5vMuG4ygIc2wBxfIsJxx8swLEEiOPbTDj+aAGObYE4vsOE42oLcGwHxPFdJhzXWICjA8TxPSYcf7IAx1Igju8z4fizBTiWAXEcwYTjLxbg2B6I4wdMOP5qAY4dgDh+yITjbxbg2BGI40dMOP5uAY6dgDiOZMLxDwtw7AzE8WMmHP+0AMcuQBxHMeH4lwU4bgfE8RMmHNdagGNXII6jmXD82wIcuwFx/JQJx7xW5uO4PRDHMUw4bmUBjt2BOH7GhGMtC3DsAcRxLBOOtS3AsScQx3FMONaxAEcBxHE8E451LcBRAnH8nAnHehbgGALiOIEJx/oW4BgG4vgFE44NLMAxAsRxIhOODS3AsRyI4yQmHLe2AMcKII6TmXDcxgIcK4E4fsmE47YW4BgF4jiFCcdGFuAYA+I4lQnHxhbguAMQx2lMODaxAMcdgThOZ8KxqQU47gTEcQYTjs0swHFnII4zmXBsbgGOuwBxnMWEYwsLcNwViONsJhxbWoDjbkAc5zDhmG8BjrsDcZzLhGMrC3DcA4jjPCYcCyzAcU8gjl8x4VhoAY57AXGcz4RjkQU47g3E8WsmHIstwHEfII4LmHBsbQGO+wJx/IYJxzYW4LgfEMeFTDiWWIDj/kAcFzHh2NYCHA8A4riYCcd2FuB4IBDHJUw4OhbgeBAQx6VMOJZagOPBQByXMeFYZgGOhwBxXM6EY3sLcDwUiOO3TDh2sADHw4A4rmDCsaMFOB4OxPE7Jhw7WYDjEUAcv2fCsbMFOB4JxHElE45dLMDxKCCOq5hw3M4CHI8G4vgDE45dLcDxGCCOPzLh2M0CHI8F4riaCcftLcCxFxDHNUw4drcAx+OAOP7EhGMPC3A8Hojjz0w49rQAxxOAOP7ChKOwAMfeQBx/ZcJRWoDjiUAcf2PCMWQBjn2AOP7OhGPYAhz7AnH8gwnHCBBH9ftCT5Ac5u6nfpNF/Z6I+i0M9TsO6jcI1PPz1bPf1XPL1TO31fOi1bOO1XN61TNm1fNR1bM91XMp1TMV1fMA1bPs1HPY1DPE1POv1LOb1HOH1DNz1PNe1LNK1HM21DMi1PMN1Hfz1ffK1Xei1fd51XdR1fco1XcA1ffX1Hev1PeG1Hde1Pc11HcN1Ofk1We81eeT1Wdr1edC1Wca1efx1GfJ1Oeg1Gd41OdP1Gcn1Pv+6j1r9X6req9Qvc+l3qNR7y+oe+Pqvq66J6nup6l7Qeo+huLgij8q7qPmdjVzqnlJnfXqnFI9VvUHldsqLqkF/vGr8jbuD3ihc6kcmEu13FzKXKj9mbCVSAy4bKxA24g2cBZTgk7tgXWc44fBVHDQP9TmDbhfGytxySOR8WBuGDKPqRhtaBiVhjeM/5xo6CluAfBXCaO501FGLUj2mOmn42ym03G6BadjjOF0jAFPxx2Ap+P03OloRcPY4X/0dAwhT8cdc6ej3NGCZN/J9NNxDtPpONOC03EnhtNxJ+DpuDPwdJyZOx2taBg7/4+ejmHk6bhL7nSUu1iQ7LuafjrOZTodZ1twOu7KcDruCjwddwOejrNzp6MVDWO3/9HTMYI8HXfPnY5ydwuSfQ/uZEecEnvAT4mwWJDPA6Jff/e0p3DYTgkbCmdP08dKG95/2wsIosKvtouj2tfJS1+ZOCAaE2qvvVthixId8wbkazHA35rkutXI3a8O2M5GuKYeKgbGdx9gfEuYaZ3wt/6Jwb4MdHa+4X7vXHtdTqP7zL7A3DEdQ5U7+zHkzgLD/W7JlDv7AXPHdAxV7uzPkDsLDfd7dl2e3NkfmDumY6hy5wCG3FlsuN/PMvWdA4C5YzqGKncOZMidJYb7rfJmZ4bcORCYO6ZjqHLnIIbcWWZB7uzCkDsHAXPHdAxV7hzMkDsHtzLf70MY/D7EAr8PZfD7UAv8PozB78Ms8PtwBr8Pt8DvIxj8PsICv49k8PtIC/w+isHvoyzw+2gGv4+2wO9jGPw+xgK/j2Xw+1gL/O7F4HcvC/w+jsHv4yzw+3gGv4+3wO8TGPw+wQK/ezP43dsCv09k8PtEC/zuw+B3Hwv87svgd18L/O7H4Hc/C/yuYvC7ygK/4wx+xy3wu5rB72oL/E4w+J2wwO8aBr9rLPA7yeB30nC/1XtOJ+Xjv27UCPg5wZOA71+1s+frRmwf0m5c23wb+yPrxtZAlVoQqJNzgRKyVz3zbRyQC5SQ5RZU1Cm5QAnZ04JADcwFSsjeFrS+U3OBErKPBYEalAuUkP0sCNRpuUAJGbcgUKfnAiVkwoJAnZELlJBJCwJ1Zi5QdHvGgkCdlQsUsX4LAnV2LlBEJi0I1Dm5QBFHsSBQg3OBov5vwS2kc3OBotHXgooakgsUVZQFgTovFyghh1nQ+s7PBYoOagsq6oJcoKj/WxCoC3OBorZiQaAuygWKstWCQF2cC5SQH1swTFySCxSBYEFFXZoLlJCXWRCoy3KBEvIKCwJ1eS5QQl5lQaCuyAVKyHwLhokrc4ES8q26FlR9LlBCXmdB67s6Fyghb7AgUNfkAiXkTRYE6tpcoIS8xYJAXZcLlJC3WRCo63OBEvIOCwJ1Qy5QQt5lQaBuzAVKyHssCNRNuUAJOdSCQN2cC5SQ91sQqFtygRLyQQsCdWsuUEI+bEGgbssFSshHLQjU7blACfm4BYG6IxcoIRtZ8H7UnblACfmUBRV1Vy5QQj5jQaDuzgVKyGEWBOqeXKCEfN6CQN2bC5SQL1oQqKG5QAk53IJA3ZcLlJCvWBCo+3OBEvJIC3jUA7lA0S0kCwL1YC5QQr5hQet7KBcoId+yIFAP5wIl5DsWBOqRXKCEfM+CQD2aC5SQIywI1GO5QAn5oQWBejwXKCFHWhCoJ3KBEnKUBYF6MhcoIUdbEKincoEScowFgXo6Fyghx1oQqGdygRJyvAWBejYXKCEnWBCoYblACTnRgkA9lwuUkJMtCNTzuUAJOcWCQL2QC5SQ0ywI1Iu5QAk5w4JAvZQLlJCzLAjU8FyghJxjQaBezgVKyHkWBOqVXKCEnG9BoF7NBUrIBRYE6rVcoIRcaEGgXs8FSsjFFgTqjVyghFxqQaDebAW2EW1gcX5e3g4ktTL2DYuKSKSmMlQjw7JKhGLxaLmIlMcrojIqy6PliVA0HK6JRqKVsXisUsRkJFwjk+WxcNLd+C2c47KgBxZE+DNzCT+F41ZgDN9uZbbfDVy/azHkJArDdwzHsCFT7rxrSe6g/X7PcL8bkc8zGfx+33C/x5HPXzD4PQLsN7qX7U4+n5WP228Q7XUaA44fGJ4/Kr9VrNFzyofAOWU2cE5R+DUnqePup/5bfTVsrXut4pW6/tBzLdy/Sf3/fUT/NpLkY5JRrdL3Q8ZH9fNG+Fkg1Ag4C3zSChuf2i6Oal/Hxbyeq89caLw/Mrxeo/nrcjQPu6/gxLQBsE9n2sgySID2Eipx65PUzeNP3Fa1eZIBnGihVIFzYgHcSzDhwHZnZHU9O5pCfv7/XPMKZdpodPPiApNhmgkjp5nRTNPMaHeaUQvNhhSuC4Cn7N5k6z6t8HYuAMbpU8MZ6r4MMdm3FZ6hjjEcx/0YcNyPAcfPDMdxfwYc92fAcazhOB7AgOMBDDiOMxzHAxlwPJABx/GG43gQA44HMeD4ueE4HsyA48EMOE4wHMdDGHA8hAHHLwzH8VAGHA9lwHGi4TgexoDjYQw4TjIcx8MZcDycAcfJhuN4BAOORzDg+KXhOB7JgOORDDhOMRzHoxhwPIoBx6mG43g0A45HM+A4zXAcj2HA8RgGHKcbjuOxDDgey4DjDMNx7MWAYy8GHGcajuNxDDgex4DjLMNxPJ4Bx+MZcJxtOI4nMOB4AgOOcwzHsTcDjr0ZcJxrOI4nMuB4IgOO8wzHsQ8Djn0YcPzKcBz7MuDYlwHH+Ybj2I8Bx34MOH5tOI5VDDhWMeC4wHAc4ww4xhlw/MZwHKsZcKxmwHGh4TgmGHBMMOC4yHAcaxhwrGHAcbHhOCYZcEwy4LjEcBxbM+B4kuGfSV1qeEzaMMTkLcNjsszwb3QpDN9l6A/LLfD7PQa/v7XkG3xov1dYEO+3Gfz+zgK/32Hw+3uw36lVF+z/M7X9+1yTXLeQ3/PxPsHE714rgXuVAL/trr6AWuDJae9C5/lK8PemUmtVK0aDV7XC7/sDMBm4/P6h1XqAQfuyNpFV9f77m8iPuSYif2RqIqtbMRq8mqGJrDG8iSi/1zA1EbStjevn5Q1pgJ/Aoj15mmd9rP8htaFfn01vnj/hGocMdTeyEUtkvgXZ1H9iauo/t2I0+GeGpv6L4U1d+f1LQE3dr/8/uAdQbTAGP7Qy8xD/1fDbHOqhk9+3wj9IDnlI/NbKzgb6G1MD/b0Vo8G/MzTQPwxvoMrvPyxpoKrR/8rQQH8BNtBfgfH+s5XZ8Ug9G6k2aF/TJ/a/LG3GfzE147WtGA1ey9CM/za8GSu//7akGatD40+GZvwHsBn/iYx3gdnx+CdvCvDx+BsYDy+Gfv3dyoJ4bGV4PLYCxqOWBfGoZXg8agHjUduCeNQ2PB61gfGoY0E86hgejzrAeNS1IB51DY9HXWA86lkQj3qGx6MeMB71LYhHfcPjUR8YjwYWxKOB4fFoAIxHQwvi0dDweDQExmNrC+KxteHx2BoYj20siIeysZbB8dgGyT9oj6K8YH6SyI5fdgnx7S3X3yhXr457vS3FsxFJY5ImJE1JmpE0J2lB0pIkn6QVSQFJIUkRSTFJa5I2JCUkbUnakTgkpSRlJO1JOpB0JOlE0pmkC8l2JF1JuqXebUj9uoMypkGGrpFG11ija6LRNdXomml0zTW6FhpdS40uX6NrpdEVaHSFGl2RRles0bXW6NpodCUaXVuNrp1G52h0pRpdmUbXXqProNF11Og6aXSdNbouGt12Gl1Xja6bq/OuUvd1N/dV+FtpTcdvs9wW0HjXvZspZCPQXsrHxpC91uHVxP9eIRcv2dTvXpH/YC+b+dtLeOIom/vZK5SWE7LFlu8lMvJLttzCvSqS/8pVmb9le0U1eS9bbcleUW0NyYLN36sySz3Kws3dqzJrbcuizdsrtIE+IYs3Z6/KDfYc2XrT96reSP+SbTZ1r8qN9kJZsml7iU3oq7LtpuwlNqlHy3Yb36t8E/u9dDa2V2STzw5ZusG9IsnNOIdk2Yb2qtysM022z75XdDPPR9khy16x5GaftbKjfi+xBee27KTbS2zRDCA7/3svuYXzhOySuVdii2cTuV36XmEfc47s6tkrlPQ1M8luQMIf5KejusFmvYT02rt9AaPB2xfgPrecMn57XABldwConJ+0UhgqG1F3lVIYdgcXQWHe+jgHVQTC10qw3lXxYtHDLbCemXc2eriB9ep6ahgo+lYsrpMI2QNYQD3BwUUnnyqaHsBiTPndw9ITqSssj2IJr72igNFgAT+RYgkBPJGk4SeSwlDCT6RYQlp6InWF2R2r1pjLciKF3AILZ55IIc2JFA7gROoKPJFCwAIKMwUX1YBSdiJ9jgCbWV4e/rTs7jYg9BuiSCpQDmxmOgyFvyVVjMsZJplySyeZ7WD9Jx722ltRwGhwBXySiYcrgMVfafgkozCshE8y8XAlc/EjGmi54Q00CsYwtdAHLzLHY8DaC3IC3g5mdzykMZdlAt7Bbcw7Zk7AO2gm4B0DmIBxJ5CQOwCTckem4KILEenzTswTsPC3pGqOMYbpbWfDp1YVl50t8Jsrx3cG5vguhud4tiEFMfyg9toVfGAHxXa6wM6aaNJr724FnAbD2U40uRswgLsbznYUhrvD2U40ubvhbEc1ul0LzG7Ge4CbcWqhfUbm+J6Wsp0uMLujNRpzWdjOXm5j3juT7eylYTt7B8B2cCeQkHsBk3JvpuCiCxHp8z6GT4KqOe7JMPXvazjbUXHZ1wK/uXJ8X2CO72d4jmcbUoS/JZFDyv6WvrfTGXbWhNKeKndAAaPBB8DZTkgcACyCAw1nOwrDA+FsJyQONJztqEa3f4HZzfggS9gOMscPtpTtdIbZLZMac1nYziFuYz40k+0comE7hwbAdnAnkJCHAJPyUKbgogsR6fNhhk+CqjkezDD1H24421FxOdwCv7ly/HBgjh9heI5nG1KEvyWRQ8qRlrKdTrCzJpHGdo4qYDT4KDjbSYijgEVwtOFsR2F4NJztJMTRhrMd1eiOLDC7GR9jCdtB5vixlrKdTjC7qwNjO73cxnxcJtvppWE7xwXAdnAnkJC9gEl5HFNw0YWI9Pl4wydB1RyPZZj6TzCc7ai4nGCB31w5fgIwx3sbnuPZhhThb0nkkHKipWynI+ysqUh7JkafAkaD+8DZToXsAyyCvoazHYVhXzjbqUjzW/hcOr8Rje7EArObcT9L2A4yx6ssZTsdYXZXBPYslbjbmKsz2U5cw3aqA2A7uBNIyDgwKauZgosuRKTPCcMnQdUcqxim/hrD2Y6KS40FfnPleA0wx5OG53i2IUX4WxI5pJxkKdvpgHtvJ+q1t38Bo8H98e/tRPsDi+Bkw9mOwvBk/Hs70ZMNZzuq0Z1UYHYzHmAJ20Hm+CmWsp0OMLsTlRpzWdjOQLcxn5rJdgZq2M6pAbAd3Akk5EBgUp7KFFx0ISJ9HmT4JKia4ykMU/9phrMdFZfTLPCbK8dPA+b46YbneLYhRfhbEjmknGEp22kPO2siMa+9ZxYwGnwmnO1EYmcCi+Asw9mOwvAsONuJxM4ynO2oRndGgdnN+GxL2A4yx8+xlO20h9kdiWrMZWE7g93GfG4m2xmsYTvnBsB2cCeQkIOBSXkuU3DRhYj0eYjhk6BqjucwTP3nGc52VFzOs8Bvrhw/D5jj5xue49mGFOFvSeSQcoGlbKcMdtbE0z7JdmEBo8EXwtlOXF4ILIKLDGc7CsOL4Gwnnua38Ll0fiMa3QUFZjfjiy1hO8gcv8RStlMGszse2CfZLnUb82WZbOdSDdu5LAC2gzuBhLwUmJSXMQUXXYhIny83fBJUzfEShqn/CsPZjorLFRb4zZXjVwBz/ErDczzbkCL8LYkcUq6ylO2U4thOtdfeqwsYDb4az3aqrwYWwTWGsx2F4TV4tlN9jeFsRzW6qwrMbsbXWsJ2kDl+naVspxQ3EMc15rKwnevdxnxDJtu5XsN2bgiA7eBOICGvByblDUzBRRci0ucbDZ8EVXO8jmHqv8lwtqPicpMFfnPl+E3AHL/Z8BzPNqQIf0sih5RbLGU7Du6TbHGvvbcWMBp8K/6TbPFbgUVwm+FsR2F4G/6TbPHbDGc7qtHdUmB2M77dEraDzPE7LGU7Du7DTlUac1nYzp1uY74rk+3cqWE7dwXAdnAnkJB3ApPyLqbgogsR6fPdhk+CqjnewTD132M421FxuccCv7ly/B5gjt9reI5nG1KEvyWRQ8pQS9lOO9hZE017AvV9BYwG3wdnO1FxH7AI7jec7SgM74eznai433C2oxrd0AKzm/EDlrAdZI4/aCnbaQezuzKwJ1A/5DbmhzPZzkMatvNwAGwHdwIJ+RAwKR9mCi66EJE+P2L4JKia44MMU/+jhrMdFZdHLfCbK8cfBeb4Y4bneLYhRfhbEjmkPG4p22nLxHaeKGA0+AkGtvMEsAieNJztKAyfZGA7TxrOdlSje7zA7Gb8lCVsB5njT1vKdtpayHaecRvzs5ls5xkN23k2ALaDO4GEfAaYlM9awnaQPg8zfBJUzfFphqn/OcPZjorLcxb4zZXjzwFz/HnDczzbkCL8LYkcUl6wlO2UwM6aqrRnsr1YwGjwi3C2UxV7EVgELxnOdhSGL8HZTlXsJcPZjmp0LxSY3YyHW8J2kDn+sqVspwRmd1Vgz2R7xW3Mr2aynVc0bOfVANgO7gQS8hVgUr7KFFx0ISJ9fs3wSVA1x5cZpv7XDWc7Ki6vW+A3V46/DszxNwzP8WxDivC3JHJIedNSttMGx3YiXnvfKmA0+C0824m8BSyCtw1nOwrDt/FsJ/K24WxHNbo3C8xuxu9YwnaQOf6upWynDW4gDmvMZWE777mN+f1MtvOehu28HwDbwZ1AQr4HTMr3mYKLLkSkzyMMnwRVc3yXYer/wHC2o+LygQV+c+X4B8Ac/9DwHM82pAh/SyKHlI8sZTutYWdNIu29nZFcbEcZPBLOdhKxkcAi+NhwtqMw/BjOdhKxjw1nO6rRfVRgdjMeZQnbQeb4J5ayndYwuxOBvbcz2m3Mn2ayndEatvNpAGwHdwIJORqYlJ8yBRddiEifxxg+Carm+AnD1P+Z4WxHxeUzC/zmyvHPgDk+1vAczzakCH9LIoeUcZaynWLYWVNd47V3fAGjwePhbKe6ZjywCD43nO0oDD+Hs53qms8NZzuq0Y0rMLsZT7CE7SBz/AtL2U4xzO7qhMZcFrYz0W3MkzLZzkQN25kUANvBnUBCTgQm5SSm4KILEenzZMMnQdUcv2CY+r80nO2ouHxpgd9cOf4lMMenGJ7j2YYU4W9J5JAy1VK2UwQ7a2TaezvTChgNngZnOzI2DVgE0w1nOwrD6XC2I2PTDWc7qtFNLTC7Gc+whO0gc3ympWynCGa3DOy9nVluY56dyXZmadjO7ADYDu4EEnIWMClnMwUXXYhIn+cYPgmq5jiTYeqfazjbUXGZa4HfXDk+F5jj8wzP8WxDivC3JHJI+cpStlMIO2viaWxnfgGjwfPhbCcemw8sgq8NZzsKw6/hbCce+9pwtqMa3VcFZjfjBZawHWSOf2Mp2ymE2R0PjO0sdBvzoky2s1DDdhYFwHZwJ5CQC4FJuYgpuOhCRPq82PBJUDXHbxim/iWGsx0VlyUW+M2V40uAOb7U8BzPNqQIf0sih5RllrKdAthZE4167V1ewGjwcjjbiUaXA4vgW8PZjsLwWzjbiUa/NZztqEa3rMDsZrzCEraDzPHvLGU7BTC7o5Uac1nYzvduY16ZyXa+17CdlQGwHdwJJOT3wKRcyRRcdCEifV5l+CSomuN3DFP/D4azHRWXHyzwmyvHfwDm+I+G53i2IUX4WxI5pKy2lO20gp01kTS2s6aA0eA1cLYTia4BFsFPhrMdheFPcLYTif5kONtRjW51gdnN+GdL2A4yx3+xlO20gtkdCYzt/Oo25t8y2c6vGrbzWwBsB3cCCfkrMCl/YwouuhCRPv9u+CSomuMvDFP/H4azHRWXPyzwmyvH/wDm+J+G53i2IUX4WxI5pPxlKdvJh501Mem1d20Bo8Fr4WwnJtcCi+Bvw9mOwvBvONuJpfktfC6d34hG91eB2c1YjeqoOOd5FtpnZI5vBfQ5SLaTD8v3mNCYy8J2ahWue61dmJfObNQ/ZLId9UfcbAd3AglZqxCXlLULeYKLLkSkz3XAzQddcKqytyrEHwx1C3kPLuFvSRWXuhb4zZXjdYE5Xs/wHM82pAh/SyKHlPrAvAmS7bSEnTWVwmtvg0JGg9XmWLZTKRoAi6AhsDi5MGxYiGY7laIh86GBaHT1C81uxltbwnaQOb6NpWynJYztVCQ15rKwnW3dxtwok+1sq2E7jQJgOy2BbGdbYFI2KuQJLroQkT43NnwSVM1xG4apv4nhbEfFpYkFfnPleBNgjjc1PMezDSnC35LIIaWZpWynBeysiac9gbp5IaPBzeFsJ17THFgELQxnOwrDFnC2E69pYTjbUY2uWaHZzbilJWwHmeP5lrKdFrgvsgf2BOpWbmMuyGQ7rTRspyAAttMCyHZaAZOyoJAnuOhCRPpcaPgkqJpjPsPUX2Q421FxKbLAb64cLwLmeLHhOZ5tSBH+lkQOKa0tZTvNYWdNKO29nTaFjAa3gbOdkGgDLIISw9mOwrAEznZCosRwtqMaXetCs5txW0vYDjLH21nKdprD2I4M7L0dx23MpZlsx9GwndIA2E5zINtxgElZWsgTXHQhIn0uM3wSVM2xHcPU395wtqPi0t4Cv7lyvD0wxzsYnuPZhhThb0nkkNLRUrbTDHfWVHvt7VTIaHAnONsR1Z2ARdDZcLajMOwMZzuiurPhbEc1uo6FZjfjLpawHWSOb2cp22mG+55aXGMuC9vp6jbmbplsp6uG7XQLgO0ATyDZFZiU3Qp5gosuRKTP2xs+CarmuB3D1N/dcLaj4tLdAr+5crw7MMd7GJ7j2YYU4W9J5JDS01K20xR21lSkfZJNFDIaLOBsp6JGAItAGs52FIYSznYqaqThbEc1up6FZjfjkCVsB5njYUvZTlPc93YC+yRbxG3M5ZlsJ6JhO+UBsJ2mQLYTASZleSFPcNGFiPS5wvBJUDXHMMPUX2k421FxqbTAb64crwTmeNTwHM82pAh/SyKHlJilbKcJ7KyRac9k26GQ0eAd4GxHyh2ARbCj4WxHYbgjnO3INL+Fz6XzG9HoYoVmN+OdLGE7yBzf2VK20wT3SbbAnsm2i9uYd81kO7to2M6uAbCdJkC2swswKXct5AkuuhCRPu9m+CSomuPODFP/7oazHRWX3S3wmyvHdwfm+B6G53i2IUX4WxI5pOxpKdtpDHxosNfevQoZDd6rEL/v3oYzFOX33oXrAQbty8IqVEPZs9DsprePJawCmZf7Mjd6REz2ZcjxIBtqI6aGul8ho8H7MTTU/Q1vqMrv/QNqqMLfkqow9i/kKTiU30EW2bbIx9977DygkNHgAxhOxAOAHf1AwwtWYXggQxEcaPg9WlWkBzLQn32A8T7I8NsFKncOYmr2qYWu7YOA8TnYcIqfjTEIf0siGcMhhue4ivEhDIMcMg/VkFCUt/6WuXeh7V5dj6fO86B2hljf59jKg63jXh9K8TyM5HCSI0iOJDmK5GiSY0iOJelFchzJ8SQnkPQmOZGkD0lfkn4kVSRxkmqSBEkNSZLkJJL+JCeTDCA5hWQgyakkgzLfYznUfT/FqztMoztcoztCoztSoztKoztaoztGoztWo+ul0R2n0R2v0Z2g0fXW6E7U6PpodH01un4aXZVGF9foqjW6hEZXo9ElNbqTNLr+Gt3JGt0Aje4UjW6gRneqRjeo8N/v3ZW6r7u5r8LfSms6fpvloYDGm3of8DDQXsrHwyF7rcPrCP97hVy85JF+94r8B3t5lL+9hCeO8mg/e4XSckIes+V7iYz8ksdu4V4VyX/lquy1ZXtFNXkvj9uSvaLaGpLHb/5elVnqUZ6wuXtVZq1t2Xvz9gptoE/IEzdnr8oN9hzZZ9P3qt5I/5J9N3Wvyo32Qtlv0/YSm9BXZdWm7CU2qUfL+Mb3Kt/Efi+rN7ZXZJPPDpnY4F6R5GacQ7JmQ3tVbtaZJpPZ94pu5vkoT8qyVyy52Wet7K/fS2zBuS1P1u0ltmgGkAP+vZfcwnlCnpK5V2KLZxM5MH2vsI85R57q2SuU9DUzyUGW3tEeBJv1EmmfOj6tkNHg0wrRnzpOyNNwAZSnA0DlvKOtMDwdeEc7heHp4CJQOVQrL9giEL5WIrBPj57hFtiZmXc2zij896dHzyzk//QorpMIeQawgM4EBxedfKpozgAWY8rvMyw9kU6F5VEs4bX3rEJGg8+Cn0ixxFnAE+lsw08kheHZ8BMpljjb0hPpVJjdsWqNuSwn0jlugQ3OPJHO0ZxIgwM4kU4FnkjnAAtoMFNw0W8EI30+F9jM8vLwp+XpbgNCvxGMpAJDgM1Mh6Hwt6SK8RCGSWaIpZPMQFj/iYe99p5XyGjwefBJJh4+D1j85xs+ySgMz4dPMvHw+czFj2igQwxvoBeAMUwt9MGLzPELgbUX5AQ8EGZ3PKQxl2UCvshtzBdnTsAXaSbgiwOYgHEnkJAXAZPyYqbgogsR6fMlzBOw8Lekao4XMkxvlxo+taq4XGqB31w5fikwxy8zPMezDSmI4Qe11+XgAzsotnMK7KyJJr32XlHIaPAVcLYTTV4BDOCVhrMdheGVcLYTTV5pONtRje7yQrOb8VXgZpxaaJ+ROX61pWznFJjd0RqNuSxs5xq3MV+byXau0bCdawNgO7gTSMhrgEl5LVNw0YWI9Pk6wydB1RyvZpj6rzec7ai4XG+B31w5fj0wx28wPMezDSnC35LIIeVGS9/bGQA7a9J/d/ymQkaDb4KznZC4CVgENxvOdhSGN8PZTkjcbDjbUY3uxkKzm/EtlrAdZI7fainbGQCzO7jfHb/Nbcy3Z7Kd2zRs5/YA2A7uBBLyNmBS3s4UXHQhIn2+w/BJUDXHWxmm/jsNZzsqLnda4DdXjt8JzPG7DM/xbEOK8Lckcki521K2czLsrEmksZ17ChkNvgfOdhLiHmAR3Gs421EY3gtnOwlxr+FsRzW6uwvNbsZDLWE7yBy/z1K2czLM7urA2M79bmN+IJPt3K9hOw8EwHZwJ5CQ9wOT8gGm4KILEenzg4ZPgqo53scw9T9kONtRcXnIAr+5cvwhYI4/bHiOZxtShL8lkUPKI5aynf6ws6Yi7ZkYjxYyGvwonO1UyEeBRfCY4WxHYfgYnO1UpPktfC6d34hG90ih2c34cUvYDjLHn7CU7fSH2V0R2LNUnnQb81OZbOdJDdt5KgC2gzuBhHwSmJRPMQUXXYhIn582fBJUzfEJhqn/GcPZjorLMxb4zZXjzwBz/FnDczzbkCL8LYkcUoZZynZOwr23E/Xa+1who8HP4d/biT4HLILnDWc7CsPn8e/tRJ83nO2oRjes0Oxm/IIlbAeZ4y9aynZOgtmdqNSYy8J2XnIb8/BMtvOShu0MD4Dt4E4gIV8CJuVwpuCiCxHp88uGT4KqOb7IMPW/YjjbUXF5xQK/uXL8FWCOv2p4jmcbUoS/JZFDymuWsp0k7KyJxLz2vl7IaPDrcLYTib0OLII3DGc7CsM34GwnEnvDcLajGt1rhWY34zctYTvIHH/LUraThNkdiWrMZWE7b7uN+Z1MtvO2hu28EwDbwZ1AQr4NTMp3mIKLLkSkz+8aPgmq5vgWw9T/nuFsR8XlPQv85srx94A5/r7hOZ5tSBH+lkQOKSMsZTs1sLMmnvZJtg8KGQ3+AM524vIDYBF8aDjbURh+CGc78TS/hc+l8xvR6EYUmt2MP7KE7SBzfKSlbKcGZnc8sE+yfew25lGZbOdjDdsZFQDbwZ1AQn4MTMpRTMFFFyLS508MnwRVcxzJMPWPNpztqLiMtsBvrhwfDczxTw3P8WxDivC3JHJIGWMp20ng2E61197PChkN/gzPdqo/AxbBWMPZjsJwLJ7tVI81nO2oRjem0OxmPM4StoPM8fGWsp0EbiCOa8xlYTufu415Qibb+VzDdiYEwHZwJ5CQnwOTcgJTcNGFiPT5C8MnQdUcxzNM/RMNZzsqLhMt8JsrxycCc3yS4TmebUgR/pZEDimTLWU71bhPssW99n5ZyGjwl/hPssW/BBbBFMPZjsJwCv6TbPEphrMd1egmF5rdjKdawnaQOT7NUrZTjfuwU5XGXBa2M91tzDMy2c50DduZEQDbwZ1AQk4HJuUMpuCiCxHp80zDJ0HVHKcxTP2zDGc7Ki6zLPCbK8dnAXN8tuE5nm1IEf6WRA4pcyxlO3HYWRNNewL13EJGg+fC2U5UzAUWwTzD2Y7CcB6c7UTFPMPZjmp0cwrNbsZfWcJ2kDk+31K2E4fZXRnYE6i/dhvzgky287WG7SwIgO3gTiAhvwYm5QKm4KILEenzN4ZPgqo5zmeY+hcaznZUXBZa4DdXji8E5vgiw3M825Ai/C2JHFIWW8p2qpjYzpJCRoOXMLCdJcAiWGo421EYLmVgO0sNZzuq0S0uNLsZL7OE7SBzfLmlbKfKQrbzrduYV2SynW81bGdFAGwHdwIJ+S0wKVdYwnaQPn9n+CSomuNyhqn/e8PZjorL9xb4zZXj3wNzfKXhOZ5tSBH+lkQOKassZTv9YGdNVdoz2X4oZDT4BzjbqYr9ACyCHw1nOwrDH+Fspyr2o+FsRzW6VYVmN+PVlrAdZI6vsZTt9IPZXRXVmMvCdn5yG/PPmWznJw3b+TkAtoM7gYT8CZiUPzMFF12ISJ9/MXwSVM1xDcPU/6vhbEfF5VcL/ObK8V+BOf6b4TmebUgR/pZEDim/W8p2+uLYTsRr7x+FjAb/gWc7kT+ARfCn4WxHYfgnnu1E/jSc7ahG93uh2c34L0vYDjLH11rKdvriBuKwxlwWtvN3qjEX5aUzm781bEf9ETfbwZ1AQv6NbLxFPMFFFyLS562KsM0HXXCqOa5lmPprFfEeXMLfkiouykbT/ebKca+dfveqbXiOZxtShL8lkUNKHWDeBMl2+sDOmkTaezt1ixgNVptj2U4iVhdYBPWAxcmFYb0iNNtJxOoxHxqIRlenyOxmXB/cjFML7TMyxxsAfQ6S7fSBsZ1EVGMuC9tp6DbmrTPZTsOif7OdrQNgO32AbKchMCm3LuIJLroQkT5vY/gkqJpjA4apf1vD2Y6Ky7YW+M2V49sCc7yR4TmebUgR/pZEDimNLWU7J8LOmuoar71NihgNbgJnO9U1TYBF0NRwtqMwbApnO9U1TQ1nO6rRNS4yuxk3s4TtIHO8uaVs50QY26lOaMxlYTst3MbcMpPttNCwnZYBsJ0TgWynBTApWxbxBBddiEif8w2fBFVzbM4w9bcynO2ouLSywG+uHG8FzPECw3M825Ai/C2JHFIKLWU7vWFnjUx7b6eoiNHgIjjbkbEiYBEUG852FIbFcLYjY8WGsx3V6AqLzG7GrS1hO8gcb2Mp2+kNYzsysPd2StzG3DaT7ZRo2E7bANhObyDbKQEmZdsinuCiCxHpczvDJ0HVHNswTP2O4WxHxcWxwG+uHHeAOV5qeI5nG1KEvyWRQ0qZpWznBNhZE09jO+2LGA1uD2c78Vh7YBF0MJztKAw7wNlOPNbBcLajGl1ZkdnNuKMlbAeZ450sZTsnwNhOPDC209ltzF0y2U5nDdvpEgDbOQHIdjoDk7JLEU9w0YWI9Hk7wydB1Rw7MUz9XQ1nOyouXS3wmyvHuwJzvJvhOZ5tSBH+lkQOKdtbynaOh5010ajX3u5FjAZ3h7OdaLQ7sAh6GM52FIY94GwnGu1hONtRjW77IrObcU9L2A4yx4WlbOd4GNuJVmrMZWE70m3MoUy2IzVsJxQA2zkeyHYkMClDRTzBRRci0uew4ZOgao6CYeqPGM52VFwiFvjNleMRYI6XG57j2YYU4W9J5JBSYSnbOQ521kTS2E5lEaPBlXC2Q3pgEUQNZzsKwyic7USiUcPZjmp0FUVmN+OYJWwHmeM7WMp2joOxnUhgbGdHtzHvlMl2dtSwnZ0CYDvHAdnOjsCk3KmIJ7joQkT6vLPhk6BqjjswTP27GM52VFx2scBvrhzfBZjjuxqe49mGFOFvSeSQspulbKcX7KyJSa+9uxcxGrw7nO3E5O7AItjDcLajMNwDznZiaX4Ln0vnN6TRFZndjPe0hO0gc3wvS9lOLxjbiQmNuSxsZ2+3Me+TyXb21rCdfQJgO72AbGdvYFLuU8QTXHQhIn3e1/BJUDXHvRim/v0MZzsqLvtZ4DdXju8HzPH9Dc/xbEOK8Lckckg5wFK2cyzsrKkUXnsPLGI0+EA426kUBwKL4CDD2Y7C8CA426kUBxnOdlSjO6DI7GZ8sCVsB5njh1jKdo6FsZ2KpMZcFrZzqNuYD8tkO4dq2M5hAbCdY4Fs51BgUh5WxBNcdCEifT7c8ElQNcdDGKb+IwxnOyouR1jgN1eOHwHM8SMNz/FsQ4rwtyRySDnKUrZzDO4pBWlPoD66iNHgo+FsJ15zNLAIjjGc7SgMj4GznXjNMYazHdXojioyuxkfawnbQeZ4L0vZzjG4pxQE9gTq49zGfHwm2zlOw3aOD4DtHANkO8cBk/L4Ip7gogsR6fMJhk+Cqjn2Ypj6exvOdlRcelvgN1eO9wbm+ImG53i2IUX4WxI5pPSxlO0cDTtrQmnv7fQtYjS4L5zthERfYBH0M5ztKAz7wdlOSPQznO2oRtenyOxmXGUJ20HmeNxStnM07gnUgb23U+025kQm26nWsJ1EAGznaCDbqQYmZaKIJ7joQkT6XGP4JKiaY5xh6k8aznZUXJIW+M2V40lgjp9keI5nG1KEvyWRQ0p/S9nOUbizptpr78lFjAafDGc7ovpkYBEMMJztKAwHwNmOqB5gONtRja5/kdnN+BRL2A4yxwdaynaOgrEdEdeYy8J2TnUb86BMtnOqhu0MCoDtAE8geSowKQcV8QQXXYhIn08zfBJUzXEgw9R/uuFsR8XldAv85srx04E5fobhOZ5tSBH+lkQOKWdaynaOhJ01FWmfZDuriNHgs+Bsp6LmLGARnG0421EYng1nOxU1ZxvOdlSjO7PI7GZ8jiVsB5njgy1lO0fivrcT2CfZznUb85BMtnOuhu0MCYDtHAlkO+cCk3JIEU9w0YWI9Pk8wydB1RwHM0z95xvOdlRczrfAb64cPx+Y4xcYnuPZhhThb0nkkHKhpWznCNhZI9OeyXZREaPBF8HZjpQXAYvgYsPZjsLwYjjbkWl+C59L5zei0V1YZHYzvsQStoPM8UstZTtH4D7JFtgz2S5zG/PlmWznMg3buTwAtnMEkO1cBkzKy4t4gosuRKTPVxg+CarmeCnD1H+l4WxHxeVKC/zmyvErgTl+leE5nm1IEf6WRA4pV1vKdg7HfRgj7Xs71xQxGnxNEX7faw1nKMrva4vWAwzal4VVqIZydZHZTe86S1gFMi+vZ270iJhcz5DjQTbUw5ga6g1FjAbfwNBQbzS8oSq/bwyooQp/S6rCuLGIp+BQfgdZZIcW4jDw2ntTEaPBNzGciDcBO/rNhheswvBmhiK42fB7tKpIb2agP9cB432L4bcLVO7cwtTsUwtd27cA43Or4RQ/G2MQ/pZEMobbDM9xFePbGAY5ZB6qIWHbvPXLe/jerupT/UHtvGCmiNuBAa3lsfMOt9HcmfmGgvqHSzN0d7o670K/oXA7MIJ3bPpe1RvZS94JHj+V6N7lyttMPDdmdx5jUt4BxMRbRHdlJuNdRf+usszEQybLRmyVG3PmLmAS310ESwbhxfTuTShmv7bfCcQBiek9m4Hpxv63vJje42maDTx4ejEV/pZcu+H9QtVJGS6vqSwXFVWR8kRFOJQIVYpEpDwpyeBQLELQJKsj0UQ0FE6GKkPVa7H2/ZNjqcaWOkjW5q0/QNT1vfQ6lOS+onWNMCguPtQTdxkNh0KVYZUf0YSQkQQdAaFQIh4R1aKqOlQTi8hYMhKKhKsT1XHKpSqZFMmq6lgyum4vr733FzEafL9m1vRr/P3AGfsBw7m4wvABzazpF8MHwBPB1nnBfO5lKNPbxnlYfNMmgge9AwD6pgUwkNJ7GniN3kybqzcl+R7cAhK6MdAfBBbzQ+DxMIXrQ57JZXNzgUY3WS1FUsRCokpUVldUxmOJUDxalQwny8OJ8JbiurFkR+L6MBOuD7u4Bslrkc3I2zwfcU/kR1UNcjSMBxnuXjxo+N3dLS0OsRl++7XxMcPvfKnEfIzhnYHHmZrC4xtotsLfko8yYfEEExZP+Dh4NmYzV14c3/P/tads9L4aVw6c0NPsPjDU9RvdS4HxlkgM/1vueT7CdM/zyQ0xHOFvyceYGuKTG2A4G9lmo/dQlc1PMjSG3uDGkFp1NjNmmzPI+PX5qSIzGwwyFt68fEpzb3tz47MxzJHxedp7XzIcptpIVMpkIhkur4yF4rIiXFGRjCQrK6KRRLI8UpWorJGRqnAoVlMpkjJaQ3d7w9WVFclYoroi6W3aMhEORxKxeLUsD1VUxUU0Ea4SyUhlmMhvIlyZSISjFRVV4XCiIpqMxoiwEg2OivLKypioCIVjIa74PO1hmqhDYWN3Nrx72nIoPGPjofAM86HwDMOhcKIhh0LWJK785ztySWTTedbQQ+FEpqbzLOBQ2NhtPmR8hhl6KHDFZ9h/0e3H59zbj8/rbj8KfyvrvX/k+yB+9wLeymT5EF8KQ/QnHrgw9LvXC4bHQxXMCwwH+4tMQ86LjLdFn2fC4iUmLF5ivC3KlRd9Db8typUD/Sy4LfoCw21RYLxlv9xt0cz1T/9GYeId/IZzMuAXmBricEYGrGweztAYqiy5LfoCcCh6ucjMBlPFxLBeDuC2KDI+rwAZcD8gA+aKzyua+KA/4IWMz6tM/fNVAA4bu1ODxOE1Jhxe24Tb5CYf5BpzYXnsHRJet3FIeJ15SHidYUiIBzQk+Px0LLTJvQHcCzkkxJkOoTc2YUjw+ylbZHzeLMId7MghgSs+bxbpv2OUqvXUd21aNlt37Y2b8Lk25bs9b9Hr2yTvFKXnELovvwP++kVRXvr3tbjsfsuQA3bDK8T6SFPvuee41+8SLu+RvE8yguQDkg9JPiIZSfIxySiST0hGk3xKMobkM5KxJONIxpN8TjKB5AuSiSSTSCaTfEkyhWQqyTSS6SQzSGaSzCrKS//CqTKmQYbuPY3ufY1uhEb3gUb3oUb3kUY3UqP7WKMbpdF9otGN1ug+1ejGaHSfaXRjNbpxGt14je5zjW6CRveFRjdRo5uk0U3W6L7U6KZodFM1umka3XSNboZGN1Ojm1X078f0lrqvu7mvwt9Kazp+D9x3AXulHvn7Hmgv5eP7kL3W4TXC/16h1G3XD/zuFVl/C/dDf3sJ7+3gj/zsFUq/tTxyy/cSmbepP97CvehGz79ueY/asr2iutvnn2zJXlH9rfjRm79XZbbb+p9u7l6V2d8iGLN5e4U29HbDZ5uzV+WG37oYu+l7bfSttXGbulflRnuhHL9pe4lN6Kvy803ZS2xSj5YTNr5X+Sb2e/nFxvaKbPLZISducK9IcjPOITlpQ3tVbtaZJidn3yu6meej/DLLXrHkZp+1cop+L7EF57acqttLbNEMIKf9ey+5hfOEnJ65V2KLZxM5I32vsI85R8707BVK+pqZ5Cwg6VNz47C89cRplktiZrikZppLcqa4pGeyS4ImuqRogkuSxrukaaxLosa4pGq0S7JGuaRrpEvCPnRJ2QiXpKnZTc2CagX5EI9ZsPkzkfYQj9lFjAarzVGf10sZPxuXVHIOkCBwYahsRN3RTmE4B1iYQf54Da6hJAL78Zq5boHNy7zbMtcNrFc3r4j/x2twnUTIucACmgcOLjr5VNHMBRZjyu+54GIM6kSaCcujWMJr71dFjAZ/BT+RYomvgCfSfMNPJIXhfPiJFEvMt/REmgmzO1atMZflRPraLbAFmSfS15oTaUEAJ9JM4In0NbCAFjAFF9WAUnYiff4G2Mzy8vCn5Ry3AW3uJ6M2ZiuSCiwENjMdhsLfkirGCxkmmYWWTjIzYP0nHvbau6iI0eBF8EkmHl4ELP7Fhk8yCsPF8EkmHl7MXPyIBrrQ8Aa6BIxhaqEPXmSOLwXWXpAT8AyY3fGQxlyWCXiZ25iXZ07AyzQT8PIAJmDcCSTkMmBSLmcKLroQkT5/yzwBC39Lqua4lGF6W2H41KrissICv7lyfAUwx78zPMezDSmI4Qe11/fgAzsotjMddtZEk157VxYxGrwSznaiyZXAAK4ynO0oDFfB2U40ucpwtqMa3fdFZjfjH8DNOLXQPiNz/EdL2c50mN3RGo25LGxntduY12SyndUatrMmALaDO4GEXA1MyjVMwUUXItLnnwyfBFVz/JFh6v/ZcLaj4vKzBX5z5fjPwBz/xfAczzakCH9LIoeUXy19b2ca7KwJpX37/rciRoN/g7OdkPgNWAS/G852FIa/w9lOSPxuONtRje7XIrOb8R+WsB1kjv9pKduZBrNbJjXmsrCdv9zGvDaT7fylYTtrA2A7uBNIyL+ASbmWKbjoQkT6/Lfhk6Bqjn8yTP15xWazHRUXZaPpfnPluNdOv3ttVWx2jmcbUoS/JZFDSi1g3gTJdqbCzppEGtupXcxosNocy3YSojawCOoAi5MLwzrFaLaTEHWYDw1Eo6tVbHYzrgtuxqmF9hmZ4/WQtZcXHNuZChsOqwNjO/XdxtygOC+d2dQv/jfbUX/EzXamAtlOfWBSNijmCS66EJE+NzR8ElTNsR7D1L+14WxHxWVrC/zmyvGtgTm+jeE5nm1IEf6WRA4p21rKdqbAzpqKtGdiNCpmNLgRnO1UyEbAImhsONtRGDaGs52KNL+Fz6XzG9Hoti02uxk3sYTtIHO8qaVsZwqM7VQE9iyVZm5jbp7Jdppp2E7zANjOFCDbaQZMyubFPMFFFyLS5xaGT4KqOTZlmPpbGs52VFxaWuA3V463BOZ4vuE5nm1IEf6WRA4prSxlO1/i3tuJeu0tKGY0uAD/3k60AFgEhYazHYVhIf69nWih4WxHNbpWxWY34yJL2A4yx4stZTtfwthOolJjLgvbae025jaZbKe1hu20CYDtfAlkO62BSdmmmCe46EJE+lxi+CSommMxw9Tf1nC2o+LS1gK/uXK8LTDH2xme49mGFOFvSeSQ4ljKdibDzppIzGtvaTGjwaVwthOJlQKLoMxwtqMwLIOznUiszHC2oxqdU2x2M25vCdtB5ngHS9nOZBjbiUQ15rKwnY5uY+6UyXY6athOpwDYzmQg2+kITMpOxTzBRRci0ufOhk+Cqjl2YJj6uxjOdlRculjgN1eOdwHm+HaG53i2IUX4WxI5pHS1lO1Mwj2BOu2TbN2KGQ3uBmc7cdkNWATbG852FIbbw9lOPM1v4XPp/EY0uq7FZjfj7pawHWSO97CU7UzCPaQ4sE+y9XQbs8hkOz01bEcEwHYmAdlOT2BSimKe4KILEemzNHwSVM2xB8PUHzKc7ai4hCzwmyvHQ8AcDxue49mGFOFvSeSQErGU7UzEsZ1qr73lxYwGl+PZTnU5sAgqDGc7CsMKPNuprjCc7ahGFyk2uxlXWsJ2kDketZTtTMSxnbjGXBa2E3Mb8w6ZbCemYTs7BMB2JgLZTgyYlDsU8wQXXYhIn3c0fBJUzTHKMPXvZDjbUXHZyQK/uXJ8J2CO72x4jmcbUoS/JZFDyi6Wsp0vcJ9ki3vt3bWY0eBd8Z9ki+8KLILdDGc7/wQd/0m2+G6Gsx3V6HYpNrsZ724J20Hm+B6Wsp0vcJ9kq9KYy8J29nQb816ZbGdPDdvZKwC28wWQ7ewJTMq9inmCiy5EpM97Gz4Jqua4B8PUv4/hbEfFZR8L/ObK8X2AOb6v4TmebUgR/pZEDin7Wcp2JuB+XTTtCdT7FzMavD+c7UTF/sAiOMBwtqMwPADOdqLiAMPZjmp0+xWb3YwPtITtIHP8IEvZzgQY26kM7AnUB7uN+ZBMtnOwhu0cEgDbmQBkOwcDk/KQYp7gogsR6fOhhk+CqjkexDD1H2Y421FxOcwCv7ly/DBgjh9ueI5nG1KEvyWRQ8oRlrKdz5nYzpHFjAYfycB2jgQWwVGGsx2F4VEMbOcow9mOanRHFJvdjI+2hO0gc/wYS9nO5xaynWPdxtwrk+0cq2E7vQJgO58D2c6xwKTsZQnbQfp8nOGToGqOxzBM/ccbznZUXI63wG+uHD8emOMnGJ7j2YYU4W9J5JDS21K2Mx521lSlPZPtxGJGg0+Es52q2InAIuhjONtRGPaBs52qWB/D2Y5qdL2LzW7GfS1hO8gc72cp2xkPYztVgT2TrcptzPFMtlOlYTvxANjOeCDbqQImZbyYJ7joQkT6XG34JKiaYz+GqT9hONtRcUlY4DdXjieAOV5jeI5nG1KEvyWRQ0rSUrYzDsd2Il57TypmNPgkPNuJnAQsgv6Gsx2FYX8824n0N5ztqEaXLDa7GZ9sCdtB5vgAS9nOOBzbCWvMZWE7p7iNeWAm2zlFw3YGBsB2xgHZzinApBxYzBNcdCEifT7V8ElQNccBDFP/IMPZjorLIAv85srxQcAcP83wHM82pAh/SyKHlNMtZTtjcb8umvbezhnFjAafAWc7idgZwCI403C2ozA8E852ErEzDWc7qtGdXmx2Mz7LEraDzPGzLWU7Y3G/LhrYezvnuI15cCbbOUfDdgYHwHbGAtnOOcCkHFzME1x0ISJ9PtfwSVA1x7MZpv4hhrMdFZchFvjNleNDgDl+nuE5nm1IEf6WRA4p51vKdj6DnTXVNV57LyhmNPgCONuprrkAWAQXGs52FIYXwtlOdc2FhrMd1ejOLza7GV9kCdtB5vjFlrKdz2BspzqhMZeF7VziNuZLM9nOJRq2c2kAbOczINu5BJiUlxbzBBddiEifLzN8ElTN8WKGqf9yw9mOisvlFvjNleOXA3P8CsNzPNuQIvwtiRxSrrSU7YyBnTUy7b2dq4oZDb4KznZk7CpgEVxtONtRGF4NZzsydrXhbEc1uiuLzW7G11jCdpA5fq2lbGcMjO3IwN7buc5tzNdnsp3rNGzn+gDYzhgg27kOmJTXF/MEF12ISJ9vMHwSVM3xWoap/0bD2Y6Ky40W+M2V4zcCc/wmw3M825Ai/C2JHFJutpTtfIr7ddE0tnNLMaPBt8DZTjx2C7AIbjWc7SgMb4WznXjsVsPZjmp0Nxeb3Yxvs4TtIHP8dkvZzqe4XxcNjO3c4TbmOzPZzh0atnNnAGznUyDbuQOYlHcW8wQXXYhIn+8yfBJUzfF2hqn/bsPZjorL3Rb4zZXjdwNz/B7DczzbkCL8LYkcUu61lO2Mxj2BOuq1d2gxo8FD4WwnGh0KLIL7DGc7CsP74GwnGr3PcLajGt29xWY34/stYTvIHH/AUrYzGsZ2opUac1nYzoNuY34ok+08qGE7DwXAdkYD2c6DwKR8qJgnuOhCRPr8sOGToGqODzBM/Y8YznZUXB6xwG+uHH8EmOOPGp7j2YYU4W9J5JDymKVs5xPYWRNJYzuPFzMa/Dic7USijwOL4AnD2Y7C8Ak424lEnzCc7ahG91ix2c34SUvYDjLHn7KU7XwCYzuRwNjO025jfiaT7TytYTvPBMB2PgGynaeBSflMMU9w0YWI9PlZwydB1RyfYpj6hxnOdlRchlngN1eODwPm+HOG53i2IUX4WxI5pDxvKdsZBTtrYtJr7wvFjAa/AGc7MfkCsAheNJztKAxfhLOdWJrfwufS+Y1odM8Xm92MX7KE7SBzfLilbGcUjO3EhMZcFrbzstuYX8lkOy9r2M4rAbCdUUC28zIwKV8p5gkuuhCRPr9q+CSomuNwhqn/NcPZjorLaxb4zZXjrwFz/HXDczzbkCL8LYkcUt6wlO18DDtrKoXX3jeLGQ1+E852KsWbwCJ4y3C2ozB8C852KsVbhrMd1ejeKDa7Gb9tCdtB5vg7lrKdj2FspyKpMZeF7bzrNub3MtnOuxq2814AbOdjINt5F5iU7xXzBBddiEif3zd8ElTN8R2GqX+E4WxHxWWEBX5z5fgIYI5/YHiOZxtShL8lkUPKh5aynZG4pxSkPYH6o2JGgz+Cs514zUfAIhhpONtRGI6Es514zUjD2Y5qdB8Wm92MP7aE7SBzfJSlbGck7ikFgT2B+hO3MY/OZDufaNjO6ADYzkgg2/kEmJSji3mCiy5EpM+fGj4JquY4imHqH2M421FxGWOB31w5PgaY458ZnuPZhhThb0nkkDLWUrbzEeysCaW9tzOumNHgcXC2ExLjgEUw3nC2ozAcD2c7ITHecLajGt3YYrOb8eeWsB1kjk+wlO18hHsCdWDv7XzhNuaJmWznCw3bmRgA2/kIyHa+ACblxGKe4KILEenzJMMnQdUcJzBM/ZMNZzsqLpMt8JsrxycDc/xLw3M825Ai/C2JHFKmWMp2PsSdNdVee6cWMxo8Fc52RPVUYBFMM5ztKAynwdmOqJ5mONtRjW5KsdnNeLolbAeZ4zMsZTsfwtiOiGvMZWE7M93GPCuT7czUsJ1ZAbAd4AkkZwKTclYxT3DRhYj0ebbhk6BqjjMYpv45hrMdFZc5FvjNleNzgDk+1/AczzakCH9LIoeUeZaynQ9gZ01F2ifZvipmNPgrONupqPkKWATzDWc7CsP5cLZTUTPfcLajGt28YrOb8deWsB1kji+wlO18gPveTmCfZPvGbcwLM9nONxq2szAAtvMBkO18A0zKhcU8wUUXItLnRYZPgqo5LmCY+hcbznZUXBZb4DdXji8G5vgSw3M825Ai/C2JHFKWWsp2RsDOGpn2TLZlxYwGL4OzHSmXAYtgueFsR2G4HM52ZJrfwufS+Y1odEuLzW7G31rCdpA5vsJStjMC90m2wJ7J9p3bmL/PZDvfadjO9wGwnRFAtvMdMCm/L+YJLroQkT6vNHwSVM1xBcPUv8pwtqPissoCv7lyfBUwx38wPMezDSnC35LIIeVHS9nO+7gPY6R9b2d1MaPBq4vx+64xnKEov9cUrwcYtC8Lq1AN5cdis5veT5awCmRe/szc6BEx+Zkhx4NsqO8xNdRfihkN/oWhof5qeENVfv8aUEMV/pZUhfFrMU/BofwOssjeLcJh4LX3t2JGg39jOBF/A3b03w0vWIXh7wxF8Lvh92hVkf7OQH9+Asb7D8NvF6jc+YOp2acWurb/AMbnT8MpfjbGIPwtiWQMfxme4yrGfzEMcsg8DHJIeNszJMhoOBSqDCubogkhI4nqUDQUSsQjolpUVYdqYhEZS0ZCkXB1ojpO9lfJpEhWVceS0XV7ee1dW8xo8FpNEfg1fi2w+P82fEhQGP6tKQK/GP4NnpS3zgvmDbm3i3gOuzwsvmlTeF5rT4NAT1PAQErvG4NeozfT5upNST61/+aejhsDXe2JwnWr1tj7Hilc1b6XbmEu0Bu9slqKpIiFRJWorK6ojMcSoXi0KhlOlocT4S3FdWPJjsS1FhOutVxc63h0mcvkZuRtnrVbr3uto2qQo2F4ixsFRl5rbGfm8rsWo99+bazLjKHwt6RKzLqt8bGpx9QU6m2g2Qp/S9ZhwqI+Exb1fRw8G7OZKy/O6vn/2lOqN2IfWw6c3dPsPqAOvroMvRQYb4nEUA0VSnQMJ28zMdhYTnn35OjfKEy8A1aDDTEc4W/JukwNscEGGM5GtpEb+99RNjdgaAzngBtDatXZzJhtziDj1+eGrc1sMMhYePOyoeeg3tL4bAxzZHy29uwlw2GqjUSlTCaS4fLKWCguK8IVFclIsrIiGkkkyyNVicoaGakKh2I1lSIpozU1leXh6sqKZCxRXZH0Nm2ZCIcjiVi8WpaHKqriIpoIV4lkpDJM5DcRrkwkwtGKiqpwOFERTUZjRFiJBkdFeWVlTFSEwrEQV3y29jBN1KGw0TsbnmXLobCNjYfCNsyHwjYMh8JgQw6FrElc+c+H95PIprOtoYfCYKamsy3gUNjYbT5kfBoZeihwxafRf9Htx8bu7ccmutuPwt/Keu8f+T6I7zfygM2FI/ApDGtbgqHfvZoaHg9VME0ZDvZmTENOM8bbok2YsGjOhEVzxtuiXHkxxPDbolw5cJ4Ft0WbMtwWBcZbnpe7LZq5/unfKEy8g18LTgbclKkhtmBkwMrmFgyN4XxLbos2BQ5FLVub2WDOZ2JYLQO4LYqMTz6QAZ8HZMBc8cnXxAf9AS9kfFox9c9WABw2dqcGiUMBEw4Fm3Cb3OSDXGMuLI+9Q0KhjUNCIfOQUMgwJFwQ0JDg89Ox0CZXBNwLOSRcwHQIFW3CkOD3U7bI+BS3xh3syCGBKz7FjHdbZrnsG/34qlmwx1dFJTJ3WsN6ezQtRmpf9UgwdWAPy/v3AuH6nx4KHwJqm29jG/SgUoupmFAOq73a/A8VZwmwOJkLUf4vF2IJshBt7ZilFgSqbS5QQvaqZ76N7XKBErLcgopycoESsqcFgSrNBUrI3ha0vrJcoITsY0Gg2ucCJWQ/CwLVIRcoIeMWBKpjLlBCJiwIVKdcoIRMWhCozrlACdnfgkB1yQVKyAEWBGq7XKCEHGhBoLrmAiXkIAsC1S0XKCHPsuAW0va5QAl5hgUV1T0XKKooCwLVIxcoIYdZ0Pp65gIl5GALKkrkAiXkEAsCJXOBEvJ8CwIVygVKyAstCFQ4FyghP7ZgmIjkAiXkJRZUVHkuUEJeZkGgKnKBEvIKCwJVmQuUkFdZEKhoLlBC5lswTMRygRLyrbrm27hDLlBCXmdB69sxFyghb7AgUDshA6W+4Nskb/13y5SxpRlBqwV2gOt7Z8LXigq0n8q2mcBfp1X7tW1t9teDODCcAcawHQOG7QzHcDoYQ4cBQ8dwDKeBMSxlwLDUcAyngjEsY8CwzHAMp4AxbM+AYXvDMfwSjGEHBgw7GI7hZDCGHRkw7Gg4hpPAGHZiwLCT4RhOBGPYmQHDzoZj+AUYwy4MGHYxHMMJYAy3Y8BwO8Mx/ByMYVcGDLsajuF4MIbdGDDsZjiG48AYbs+A4faGYzgWjGF3Bgy7G47hZ2AMezBg2MNwDMeAMezJgGFPwzH8FIyhYMBQGI7haDCGkgFDaTiGn4AxDDFgGDIcw1FgDMMMGIYNx/BjMIYRBgwjhmM4EoxhOQOG5YZj+BEYwwoGDCsMx/BDMIaVDBhWGo7hB2AMowwYRg3HcAQYwxgDhjHDMXwfjOEODBjuYDiG74Ex3LG12Z9W5MDwXTCGO7U2/IOEGQuzb7giT7Mwe4ck397rc0rFrKl7vTPhvQvJrgp3kt1J9iDZk2Qvkr1J9iHZl2Q/kv1JDiA5kOSg1uv2OLi1u2nqFyfUpk6GbheNbleNbjeNbneNbg+Nbk+Nbi+N7mBXpxa60GZm/NAC6gOWm/vTeBu2ct0PQvi1UX3gNeo2FxR+bYHYHQKyS/2Qkzd/DvHkTx5HHsl02/3icCiwqXpxOJSxjmYw1JH6QCz6B0uAH7KVhwL9PYwp5ocFkPuHAXE4nAmHwxlzfzpD7jsMuQ/8cLQ8HOjvEUwxP4I79wmHnQ3FQe1RB+zrVOSPUlHfmAaqm3Vf5BEy9YF4ZB2WoeuQ/AZ+wD7tg+Z+/T2SqQ6PDOAMOhKIw1FMOBzFeAZNYTiD2jOcQcAP9cujgP4ezRTzowPI/aOBOBzDhMMxjLn/JUPud2DIfeCXMeQxQH+PZYr5sQHMX7sYioPaAz1/TQLPX5MZ5q+O4DrsxDB/Ab/Qk/bFFr/+9mKqw14BnEG9gDgcx4TDcYxn0ESGM6gzwxkE/BKRPA7o7/FMMT8+gNw/HojDCUw4nMCY+18w5H4XhtwHfvlLngD0tzdTzHsHMH/taigOag/0/PU5eP6awDB/bQeuw64M8xfwC4RpX6Tz6++JTHV4YgBn0IlAHPow4dCH8Qwaz3AGdWM4g4BfWpR9gP72ZYp53wByvy8Qh35MOPRjzP1xDLm/PUPuA79sKvsB/a1iinlVAPPXbobioPZAz1+fgeevsQzzV3dwHfZgmL+AX1hO++KuX3/jTHUYD+AMigNxqGbCoZrxDBrDcAb1ZDiDgF+SltVAfxNMMU8EkPsJIA41TDjUMOb+pwy5LxhyH/jldlkD9DfJFPNkAPPX7obioPZAz1+fgOev0QzzlwTXYYhh/gI+ICHtQQF+/T2JqQ5PCuAMOgmIQ38mHPoznkGjGM6gMMMZBHwog+wP9PdkppifHEDunwzEYQATDgMYc/9jhtyPMOQ+8GEacgDQ31OYYn5KAPPXHobioPZAz18fgeevkQzzVzm4DisY5i/gA1nSHkzi19+BTHU4MIAzaCAQh1OZcDiV8Qz6kOEMqmQ4g4APgZGnAv0dxBTzQQHk/iAgDqcx4XAaY+5/wJD7UYbcBz68R54G9Pd0ppifHsD8taehOKg90PPX++D5awTD/BUD1+EODPMX8AFQaQ9C8uvvGUx1eEYAZ9AZQBzOZMLhTMYz6D2GM2hHhjMI+NApeSbQ37OYYn5WALl/FhCHs5lwOJsx999lyP2dGHIf+LAweTbQ33OYYn5OAPPXXobi4PV5K7DPewN8jlet24vTzn0swXNfS+zczxI797fEzgMssfNAS+w8CGin4q7qoY/eH9Vumpe+0PbvzIAz2sZdLLBxVwts3M0CG3e3wMY9LLBxTwts3IupxyNsDFdEWfblsje373/Xvri9QyHGvWWqJ3hnlcFU1+eSDCE5j+R8kgtILiS5iORikktILiW5jORykitIriS5qnVe+oOgB7f+98Ohz9Xohmh052l052t0F2h0F2p0F2l0V2p0V7k6NdAV5q2/AeBd6GZ6cWvjk1Gq/+PF4urW616vyQy6+ofMyRd9Z+pi0Lswaq+rgXdkrrGE+dhi5yWW2HmpJXZeZomdl1ti5xWW2Inol/HYP1N12h3YzLvjfvsn8I6GHMwUG7TPwDsk8lxLfAbecZFDLPEZeAdHnmeJz8A7QvJ8S3wG3mGSF1jiM/COlbzQEp+Bd8DkRQH5LLZsydTFlUCudC3Tu/jefcE4pJa8Chj7a1GfKKxJxpT/LfL+/Sth3l8H8/4qmPfXwLy/Aub99S/vr355f+1rSfP1141rb/m19ybMVZ7rpZ79l3mul3uuv/Vcr/Bcf+e5/t5zvdK9vp7+d24guZHkJpKbSW4huZXkNhJ186cob/19C+9Cz+bXm3/zR60I295yXf2msE19Cvh2wuUOkjtJ7sq8yaT+sUGG7g6N7k6N7i5X5111sWClBdVvo7wd1SCSQt4BvHF2J2SvdXjdBX4rPqjivSFXvNrivZtwuYfkXpKhmcV7t6Yo79Ho7tXohgZQvDcAi/duYPHeAyzee4HFO9TS4r0xV7za4r2PcLmf5AGSBzOL9z5NUd6v0T2g0T0YQPHeCCze+4DFez+weB8AFu+DlhbvTbni1RbvQ4TLwySPkDyaWbwPaYryYY3uEY3u0QCK9yZg8T4ELN6HgcX7CLB4H7W0eG/OFa+2eB8jXB4neYLkyczifUxTlI9rdE9odE8GULw3A4v3MWDxPg4s3ieAxfukpcV7S654tcX7FOHyNMkzJM9mFu9TmqJ8WqN7RqN7NoDivQVYvE8Bi/dpYPE+AyzeZy0t3ltzxast3mGEy3Mkz5O8kFm8wzRF+ZxG97xG90IAxXsrsHiHAYv3OWDxPg8s3hcsLd7bcsWrLd4XCZeXSIaTvJxZvC9qivIljW64RvdyAMV7G7B4XwQW70vA4h0OLN6XgUWQSqZH8sCJSqtBbr/cfrn9cvvl9svtl9svt19uP5P3C6Vm/24F63lAV8/1dp7rLp7rzp7rTp7rjp7rDp7r9p7rMs91qefa8Vy381y39VyXeK7beK5be66LPddFnutCz3WB57qV5zrfc93Sc93Cc93cc93Mc93Uc93Ec93Yc93Ic72t5/qnhuuv13iuV3uuf/Rc/+C5XuW5Xum5/t5z/Z3neoXn+lvP9XLP9TLP9VLP9RLP9WLP9SLP9ULP9Tee6wWe66891/M91195rud5rud6rud4rmd7rmd5rmd6rmd4rqd7rqc1XM9zd3Nfhc+V2y+3X26/3H65/XL75fbL7Zfbz/z91Cw4qHD9XHiq53qg5/oUz/UAz/XJnuv+nuuTPNdJz3WN5zrhua72XMc911We636e676e6z6e6xM917091yd4ro/3XB/nue7luT7Wc32M5/poz/VRnusjPddHeK4P91wf5rk+1HP9pOd9KO9Hubwf9fJ+FOxZz7X30yPeT5d4P33ygufa+4a19w1t7xveL3uuve+Red9D877Hdpfn2vv1K+/Xs7xf3xrqufZ+48P7jRDvN0Ye9Fx7P2Tu/RC690Pqj3quvZ9r9X7uNfW52OF569Yr9N+vkrxG8jrJGyRvkrxF8jbJOyTvkrxH8j7JCJIPSD4k+YhkJMnHJKNIPiEZTfIpyRiSz0jGkowjGU/yOckEki9IJpJMIplM8iXJFJKpJNNIppPMIJlJMotkNskckrkk80i+IplP8jXJApJvSBaSLCJZTLKEZCnJMpLlJN+SrCD5juR7kpUkq0h+IPmRZDXJGpKfSH4m+YXkV5LfSH4n+YPkT5K/SNaS/K3eeG1DeJLUIqlNUoekLkk9kvokDUgakmxNsg3JtiSNSBqTNCFpStKMpDlJC5KWJPkkrUgKSApJikiKSVqTtCEpIWlL0o7EISklKSNpT9KBpCNJJ5LOJF1ItiPpStKNZHuS7iQ9SHqSCBJJEiIJk0RIykkqSCpJoiQxkh1IdiTZiWRnkl1IdiXZjWR3kj1I9iTZi2Rvkn1I9iXZj2R/kgNIDiQ5iORgkkNIDiU5jORwkiNIjiQ5iuRokmNIjiXpRXIcyfEkJ5D0JjmRpA9JX5J+JFVt1uW0WrXy1q/d3Ffhc2HPnbjI9b3//76Xel5bnHKnmiRBUkOSJDmJpD/JySQDSE4hGUhyKskgktNITic5o826D2Q08+TcVp7XQvf6TPq7s0jOJjmHZDDJuSRDSM4jOZ/kApILSS4iuZjkEpJLSS4juZzkCpIrSa4iuZrkGpJrSa5r4/6P/ecnTNqsd/Y/P3Gh0Z2t0Z2j0Q3W6M7V6IZodOdpdOdrdBdodBdqdBdpdBdrdJdodJdqdJdpdJdrdFdodFdqdFdpdFdrdNdodNdqdNe5OpVkzfP0SdbOvb6e/vYGkhtJbiK5meQWkltJbiO5neQOkjtJ7iK5m+QekntJhpLcR3I/yQMkD5I8RPIwySMkj5I8RvI4yRMkT5I8RfI0yTOZCXi9xpEbNLobNbqbNLqbNbpbNLpbNbrbNLrbNbo7NLo7Nbq7NLq7Nbp7NLp7NbqhGt19Gt39Gt0DGt2DGt1DGt3DGt0jGt2jGt1jGt3jGt0TGt2TGt1TGt3TGt0zm1EMz9LfDiN5juR5khdIXiR5iWQ4ycskr5C8SvIayeskb5C8SfIWydsk75C8S/IeyfskI0g+IPmQ5COSkSQfk4wi+YRkNMmnmcXwrMaRYRrdcxrd8xrdCxrdixrdSxrdcI3uZY3uFY3uVY3uNY3udY3uDY3uTY3uLY3ubY3uHY3uXY3uPY3ufY1uhEb3gUb3oUb3kUY3UqP7WKMbpdF9otGN1ug+3YxiGEN/+xnJWJJxJONJPieZQPIFyUSSSSSTSb4kmUIylWQayXSSGSQzSWaRzCaZQzKXZB7JVyTzSb4mWUDyDclCkkUkizOLYYzGkc80urEa3TiNbrxG97lGN0Gj+0Kjm6jRTdLoJmt0X2p0UzS6qRrdNI1uukY3Q6ObqdHN0uhma3RzNLq5Gt08je4rjW6+Rve1RrdAo/tGo1uo0S3S6BZvRjEsob9dSrKMZDnJtyQrSL4j+Z5kJckqkh9IfiRZTbKG5CeSn0l+IfmV5DeS30n+IPmT5C+StSR/q6Qvof9NkloktUnqkNQtyTB6icaRpRrdMo1uuUb3rUa3QqP7TqP7XqNbqdGt0uh+0Oh+1OhWa3RrNLqfNLqfNbpfNLpfNbrfNLrfNbo/NLo/Nbq/NLq1Gt3fGp1KjEzdVhpdLY2utkZXR6OrW7LpxVCP/ra++nuShiRbk2xDsi1JI5LGJE1ImpI0I2lO0oKkJUk+SSuSApJCkiKSYpLWJG1ISkjakrQjcUhKScpI2pN0yCyGehpH6mt0DTS6hhrd1hrdNhrdthpdI42usUbXRKNrqtE10+iaa3QtNLqWGl2+RtdKoyvQ6Ao1uiKNrlija63RtdHoSjS6thpdO43O0ehKNboyja69RtdhM4qhI/1tJ5LOJF1ItiPpStKNZHuS7iQ9SHqSCBJJEiIJk0RIykkqSCpJoiQxkh1IdiTZiWRnkl1IdiXZjWR3kj1I9swsho4aRzppdJ01ui4a3XYaXVeNrptGt71G112j66HR9dTohEYnNbqQRhfW6CIaXblGV6HRVWp0UY0uptHtoNHtqNHtpNHtrNHtotHtqtHtptHtrtHtodHtuRnFsBf97d4k+5DsS7Ifyf4kB5AcSHIQycEkh5AcSnIYyeEkR5AcSXIUydEkx5AcS9KL5DiS40lOIOlNciJJH5K+JP1IqkjimcWwl8aRvTW6fTS6fTW6/TS6/TW6AzS6AzW6gzS6gzW6QzS6QzW6wzS6wzW6IzS6IzW6ozS6ozW6YzS6YzW6XhrdcRrd8RrdCRpdb43uRI2uj0bXV6Prp9FVaXTxzSiGavrbBEkNSZLkJJL+JCeTDCA5hWQgyakkg0hOIzmd5AySM0nOIjmb5BySwSTnkgwhOY/kfJILSC4kuYjkYpJLSC4luSyzGKo1jiQ0uhqNLqnRnaTR9dfoTtboBmh0p2h0AzW6UzW6QRrdaRrd6RrdGRrdmRrdWRrd2RrdORrdYI3uXI1uiEZ3nkZ3vkZ3gUZ3oUZ3kUZ3sUZ3iUZ3qUZ32WYUw+X0t1eQXElyFcnVJNeQXEtyHcn1JDeQ3EhyE8nNJLeQ3EpyG8ntJHeQ3ElyF8ndJPeQ3EsylOQ+kvtJHiB5kOQhkodJHskshss1jlyh0V2p0V2l0V2t0V2j0V2r0V2n0V2v0d2g0d2o0d2k0d2s0d2i0d2q0d2m0d2u0d2h0d2p0d2l0d2t0d2j0d2r0Q3V6O7T6O7X6B7Q6B7U6B7S6B7W6B7xFIN6srj3EwWplSqM3dxX4W9J4F6sv6qDtHMrj52PlriAt8wBHoidcEOL8+lNiVb/3tfv8x3m9+QBoA7W/3CjfOCj4EpwcSnpgdsLGAvp7bjKX8e9bu6JjfrvfPqjte51l7z11409+ibuder/73Ha7wmSJ0meKlmnV1KQtz4/OWvh8RKeLvl0CaPB/9k8D5fIuoD2qbc+cOp/d1MC+gz93bMkw0ie8wS0UV4wAX2GKaDPZ860SrGV61xjC53LtBF+HDxfgj1b0fapVqZsrA0OkvdIQGLod68XSniOhBfcI4Ej4X+lDvRHPXzsXwR3iczOWZrlKHzR00XLMjrnS/Rvw0leJnmlZL0+tdB5uqYebq+XgHn6KkOT48APODrI4UD8XmPO7Vc9Ofya5/plz/UrJem5/Tr99xskb5K85ZkK6uetf2Sdd5k85mnMhT3mI9VXObHoksc3RKBsfLHEfBuB/ZP1vsTrJXbYiaTSmTbmhluGIPl7hmcyiRxu3y7BN2H1+rY73NZx/9u2exL1PHa+4942eNd9fc99fd99HeG+flCygcIR/pZ8HjydpAL1rufGVEo3wn17QK1aGX4g7pcgm4Da633NfR3hc22Mnbzjmdre3QA7+ZD+7SOSkSQfB8BO3gNi+yGw0Yz6H2QnHwHx+4SZnYzy5PAnnuuRnuuPM9jJaPrvT0nGkHz2/3ATegTuUK3x2ju2hNFgtTmqqaaMHwtM2nHApOXCcFwJbvJLYTiOucB6eg6P9z1FNdpzLTIOj/H0b5+TTCD5oiR9PySmz4MxTcV/Irjpc+TSRIZcmsicS+WeXPrAkz/jN5BLk+jfJpN8STJlA7mEYHjjND1O+FsSyXqmGp6XKRZqMobTmAjJNA9zVE+XSGGQl4fHQ32iY2kr3H6taT/1KQl0Png/eSG2cLk3Dzhuw8rUhTdW090hakbmG8DTS9bfEkjpZpTwvReWCjK60X3D9LEd9E/RAD62E3J9ltOBDWQGcGhtB/wIECKu3mLjOGCnM9zx4Kq9Ma3wd5FmAnNnfg/zMfyMAcNZQAwXWIDhWAYMZwMxXGgBhuMYMJwDxHCxBRiOZ8BwLhDDJRZg+DkDhvOAGC6zAMMJrfCE6uBWuHh8ZThJVxh+wYDhIUAM51uA4UQGDA8FYvi1BRhOYsDwMCCGCyzAcDIDhocDMfzGAgy/ZMDwCCCGCy3AcAoDhkcCMVxkAYZTGTA8CojhYgswnMaA4dFADJdYgOF0BgyPAWK41AIMZzBgeCwQw2UWYDiTAcNeQAyXW4DhLAYMjwNi+K0FGM5mwPB4IIYrLMBwDgOGJwAx/M4CDOcyYNgbiOH3FmA4jwHDE4EYrrQAw68YMOwDxHCVBRjOZ8CwLxDDHyzA8GsGDPsBMfzRAgwXMGBYBcRwtQUYfsOAYRyI4RoLMFzIgGE1EMOfLMBwEQOGCSCGP1uA4WIGDGuAGP5iAYZLGDBMAjH8FYih+izw2Lz1nwNWn/FTn1FTn7FSnxFSn3FRn9FQnwtQ72ur92XV+4rqfTH1vo56X0LdV1f3hdV9TXVfTt1XUvdFFK9XvFTxKsUL1Fyr5jI1V6hzUfV11ZdUXam8+NXz+crUAj9OL4R8nN5vuDiEgJ+lDaE/I83xxaffGL749DuwLmq5dZG5kLhyYIvEgMvGP9A2opu1+nYg8NtKUn0zbRJDwv8JBrIW2D5V6MBg/9M4/mT4htYfwC9Y/GVPE5JcBW5DE/qLwcZ/lskTy9r//olF+4Ai4W/903jWMjTwv3MTi/zbgmaR1xZsI9d3l9EJupKZSiAmDBUc9ANpvAH3/fAlXPJIZDxsnS5saBhbtcXb+M8CTxcSOV3UAia6ad8tTu3FkSz/PHSiLb451gYmofe5AWpfJ28dDbNx4lC/CGC6jXWQDcTWQJVaEKi6uUAJ2aue+TbWywVKyHILKqp+LlBC9rQgUA1ygRKytwWtr2EuUEL2sSBQW+cCJWQ/CwK1TS5QQsYtCNS2uUAJmbAgUI1ygRIyaUGgGucCJWR/CwLVJBcoIQdYEKimuUAJOdCCQDXLBUrIQRYEqnkuUEKeZcEtpBa5QAl5hgUV1TIXKKooCwKVnwuUkMMsaH2tcoEScrAFFVWQC5SQQywIVGEuUEKeb0GginKBEvJCCwJVnAuUkB9bMEy0zgVKyEssqKg2uUAJeZkFgSrJBUrIKywIVNtcoIS8yoJAtcsFim7PWDBMOLlACflWXfNtLM0FSsjrLGh9ZblACXmDBYFqjwyU+q5egcdI70IbPgLwCAv3h7STXns7tGU0WG1eK2Nfv8Z3AH4JsSPwW8BcGHYEfnEwhWFH8BcHM39Jvafnl9Tf9/x6+p8l2X9JvRPZ1JmkC8l2bbP/krrwt/75MiYS01T8u4K/EcyRS10Zcqkrcy6Ve3LpA0/+qHzJlkvd6N+2J+lO0mMDuYR4OkHHtmb/onxPYHwUjrXygjnw3gE+BaCRx07hHnjSfQ25r2H3NeK+lruvFe5rpfsadV9j7usO7uuO7utOnhpjaV6gvdK+8R1yjfbqyjW6qEa3o0eXWbxHeopXeApWeq6PyijenenfdiHZVSWup3hTC/0okBBwoNgZOFDsDj5QuPALA/HbBYjfHpbgFwHitysQvz2ZD/bdPT1gD8/1np7r3dqm94a96L/3JtmHZN8AekM5MDZ7AWOznyW5XQHEb28gfvtbgl8lEL99gPgdwNwb9vP0gP091wd4rvfN6A0H0n8fRHIwySEB9IYoMDYHAmNzqCW5HQPidxAQv8MswW8HIH4HA/E7nLk3HOrpAYd5rg/3XB+S0RuOoP8+kuQokqMD6A07AmNzBDA2xzDH5hhPDI70cjzP9dEZsTmW/rsXyXEkx7ux0e19lodLHuvZb6e22W8EnUD/1pvkRJI+7t518tZz18yF5usnAPGu5bGzr3uzoZ8tNxu47OvbFn9XrwpcJKlkU/teyhirfgxYxJmwiG8AC8RdWY68+PH/91m51Ruxjy0HVlvwcyMnMNyFB8ZbIjFMHWLeAyFzber/1sZyyrsnOm59wb0ltaptvAPvNXozbZYb+99RNlczNIY14MaQWpv7DORNORBQPifamtlgkLHw5mXCc1BvaXw2hjkyPjWe+MhwmGojUSmTiWS4vDIWisuKcEVFMpKsrIhGEsnySFWiskZGqsKhWE2lSMpoTU1lebi6siIZS1RXJL1NWybC4UgiFq+W5aGKqriIJsJVIhmpDIdEVSJcmUiEoxUVVeFwoiKajMaioVBVMhwV5ZWVMVERCsdCXPGp0cQH9ZEbjvpJAutH+d8gbz1735yc3Njeaze8X6g6KcPllC2ioipSnqgIhxKhSpGIlCclARGKRQiGZHUkmoiGwslQZag6xVCTbh9OxUhd9/Uw2H7u9Un02p/k5Lbpsa0Nji3y3buTgHcqBrTFDkxBfU5vANNQc0pbRoNPaYvfdyAwGbj8HugpLtC+G7zl6xcH5FvF/YHxOdXSYj2VqVgHtWU0eBBDsZ5meLEqv08LuFiFv5V2Ggp/C9pMTwcnfUM33qd7ppj+nuvUxKMk7NFHNH9zBr2eSXJWW576UZPsyQy3ipLA+JzNFJ+TssTnbE98NvY359DrYJJzmeIz0K1z9J2KIW2xPYMjL4cw+H0es98IZjmkrdkfoD4fjCHaV9UzgTZKVePnMeTiBRbU4MkMfl9oQQ1y+H0RMCc56kb5DczJf2aAMxhwvNiCuiln8PsSC+qGw+9LDa8bNcMDe5pUfeJiBhwvM/zcVrM2MMelypvLGHC83HAcVR2+U4Kt68sZ7jXoPtOW7TtRobbZP9N2Bf3blSRXkVzdlu+LsmPz8/L2boWP1wLgL9JeY8HZeA1DTV5ruN/js+SOX7+vA/bLqT3MxvBzJgyvB2I43XAMJzBheAMQw5mGY/gFE4Y3AjGcbTiGql9fx3AO3GT4OaD8vp7B75st8PsGBr9vAb83kDmP3uSZO2/2XN+ygXn0Vvq320huJ7mj7ca/W+MXgyuAfeNW4Ps2d1r6Jvid4JxKrbvaMhp8F8Ob4HcDk4HL77sZiKlKtrp5+s+To324Aty4MxcSk9S6x8X8Xvd1qPt6n8pBdIdXAVas0ZbPrQ9tm/3pL/d4To17PddDN3Ca3E//9gDJgyQPteV9dNPdhr/z+DDznTfESQy0Ud7v7peHjck/xVyYl97g0HFvRCxpWSvcfsXufigs3Ke1cTTN/3z/xIvvI24cH1Wv3obxiKdhpHTqjxz3/xHd+FKBQTeQusJsClLM5Hc9wXOC18HYGUp9c+0R4DT3KLDJAfNGImLhbQzoXFHN/BGGhq724Hhboj+wgS9yb5uhMX3M8LfjFI4nA3FczITj4xbgOACI4xImHJ+wAMdTgDguZcLxSQtwHAjEcRkTjk9ZgOOpQByXM+H4tAU4DgLi+C0Tjs9YgONpQBxXMOH4rAU4ng7E8TsmHIdZgOMZQBy/Z8LxOQtwPBOI40omHJ+3AMezgDiuYsLxBQtwPBuI4w9MOL5oAY7nAHH8kQnHlyzAcTAQx9VMOA63AMdzgTiuYcLxZQtwHALE8ScmHF+xAMfzgDj+zITjqxbgeD4Qx1+YcHzNAhwvAOL4KxOOr1uA44VAHH9jwvENC3C8CIjj70w4vmkBjhcDcfyDCce3LMDxEiCOfzLh+LYFOF4KxPEvJhzfsQDHy4A4rmXC8V0LcLwciOPfTDi+ZwGOVwBxzGvFg+P7FuB4JRDHrZhwHGEBjlcBcazFhOMHFuB4NRDH2kw4fmgBjtcAcazDhONHFuB4LRDHukw4jrQAx+uAONZjwvFjC3C8HohjfSYcR1mA4w1AHBsw4fiJBTjeCMSxIROOoy3A8SYgjlsz4fipBTjeDMRxGyYcx1iA4y1AHLdlwvEzC3C8FYhjIyYcx1qA421AHBsz4TjOAhxvB+LYhAnH8RbgeAcQx6ZMOH5uAY53AnFsxoTjBAtwvAuIY3MmHL+wAMe7gTi2YMJxogU43gPEsSUTjpMswPFeII75TDhOtgDHoUAcWzHh+KUFON4HxLGACccpFuB4PxDHQiYcp1qA4wNAHIuYcJxmAY4PAnEsZsJxugU4PgTEsTUTjjMswPFhII5tmHCcaQGOjwBxLGHCcZYFOD4KxLEtE46zLcDxMSCO7ZhwnGMBjo8DcXSYcJxrAY5PAHEsZcJxngU4PgnEsYwJx68swPEpII7tmXCcbwGOTwNx7MCE49cW4PgMEMeOTDgusADHZ4E4dmLC8RsLcBwGxLEzE44LLcDxOSCOXZhwXGQBjs8DcdyOCcfFFuD4AhDHrkw4LrEAxxeBOHZjwnGpBTi+BMRxeyYcl1mA43Agjt2ZcFxuAY4vA3HswYTjtxbg+AoQx55MOK6wAMdXgTgKJhy/swDH14A4SiYcv7cAx9eBOIaYcFxpAY5vAHEMM+G4ygIc3wTiGGHC8Qcgjup3q2aSHObup36TRf2eiPotDPU7Duo3CNTz89Wz39Vzy9Uzt9XzotWzjtVzetUzZtXzUdWzPdVzKdUzFdXzANWz7NRz2NQzxNTzr9Szm9Rzh9Qzc9TzXtSzStRzNtQzItTzDdR389X3ytV3otX3edV3UdX3KNV3ANX319R3r9T3htR3XtT3NdR3DdTn5NVnvNXnk9Vna9XnQtVnGtXn8dRnydTnoNRneNTnT9RnJ9T7/uo9a/V+q3qvUL3Ppd6jUe8vqHvj6r6uuiep7qepe0HqPobi4Io/Ku6j5nY1c6p5SZ316pxSPVb1B5XbKi6ZC/2TsT/iYl8O/P2mcvRvaaF/Q0z9fpPCDl2Lq4G1WMutxcyFxJUDWyQGXDauQduIPnzUL4x6f4ES8YNlymm0nWuANv5kT/FIrsS0oXh+YrDxn4U+HX/+7z8dJUeAVbP4meF0/CV3OspfLCjwX00/He9lOB1/ZTgdfwXa+FvudLSieH6z5XT8/b//dAxxBFg1i98ZTsc/cqej/MOCAv/T9NNxKMPp+CfD6fgn0Ma/cqejFcXzly2n49r//tMxzBFg1SzWMpyOf+dOR/m3BQWe1w5sI9rA+9zTEf4zlcxveSBOcRWc2owB92vjVrjkkch42DoR2NAwtmqHt/GfhZ4IarX7r58IIhwBVo1HYYduaLXb5SaC2u3Mt7EO90SAOBnrwE/GsHi4LQ+Ifv2ta0/hsJ2MNhROXVtOxnrAsQ14Mkob3metx3Ay1gcmzlZuvqhXta+Tl75qgW1H3rhs0M7o+IeeL8nLU4KmZI+V+MewJvnPqnm+BBePhrh4sLyzo3ytw3BrYLjhtwaU3zMZ8nAmMHe2BtYydzyEv/VPHtZlyMNXLMjDWQx5OAuYh9sA8/AVC/KwHkMevmZBHs5myMPZwDzcFpiHr1mQh/UZ8vANC/JwDkMezgHmYSNgHr5hQR42YMjDtyzIw7kMeTgXmIeNgXn4lgV52JAhD9+xIA/nMeThPGAeNgHm4TsW5OHWDHn4ngV5+BVDHn4FzMOmwDx8z4I83IYhD0dYkIfzGfJwPjAPmwHzcIQFebgtQx5+aEEefs2Qh18D87A5MA8/tCAPGzHk4UgL8nABQx4uAOZhC2AejrQgDxsz5OEoC/LwG4Y8/AaYhy2BeTjKgjxswpCHoy3Iw4UMebgQmIf5wDwcbUEeNmXIwzEW5OEihjxcBMzDVsA8HGNBHjZjyMOxFuThYoY8XAzMwwJgHo61IA+bM+TheAvycAlDHi4B5mEhMA/HW5CHLRjycIIFebiUIQ+XAvOwCJiHEyzIw5YMeTjRgjxcxpCHy4B5WAzMw4kW5GE+Qx5OtiAPlzPk4XJgHrYG5uFkC/KwFUMeTrEgD79lyMNvgXnYBpiHUyzIwwKGPJxmQR6uYMjDFcA8LAHm4TQL8rCQIQ9nWJCH3zHk4XfAPGwLzMMZFuRhEUMezrIgD79nyMPvgXnYDpiHsyzIw2KGPJxjQR6uZMjDlcA8dIB5OMeCPGzNkIfzLMjDVQx5uAqYh6XAPJxnQR62YcjD+Rbk4Q8MefgDMA/LgHk434I8LGHIwwUW5OGPDHn4IzAP2wPzcIEFediWIQ8XWpCHqxnycDUwDzsA83ChBXnYjiEPF1uQh2sY8nANMA87AvNwsQV56DDk4VIL8vAnhjz8CZiHnYB5uNSCPCxlyMPlFuThzwx5+DMwDzsD83C5BXlYxpCHKyzIw18Y8vAXYB52AebhCgvysD1DHn5vQR7+ypCHvwLzcDtgHiLjUSvPzidWN65tvo1dkQ/etTVQpRYEqlsuUEL2qme+jdvnAiVkuQUV1T0XKCF7WhCoHrlACdnbgtbXMxcoIftYECiRC5SQ/SwIlMwFSsi4BYEK5QIlZMKCQIVzgRIyaUGgIrlACdnfgkCV5wIl5AALAlWRC5SQAy0IVGUuUEIOsiBQ0VyghDzLgltIsVyghDzDgoraIRcoqigLArVjLlBCDrOg9e2UC5SQgy2oqJ1zgRJyiAWB2iUXKCHPtyBQu+YCJeSFFgRqt1yghPzYgmFi91yghLzEgoraIxcoIS+zIFB75gIl5BUWBGqvXKCEvMqCQO2dC5SQ+RYME/vkAiXkW3XNt3HfXKCEvM6C1rdfLlBC3mBBoPbPBUrImywI1AG5QAl5iwWBOjAXKCFvsyBQB+UCJeQdFgTq4FyghLzLgkAdkguUkPdYEKhDc4EScqgFgTosFygh77cgUIfnAiXkgxYE6ohcoIR82IJAHZkLlJCPWhCoo3KBEvJxCwJ1dC5QQjay4P2oY3KBEvIpCyrq2FyghHzGgkD1ygVKyGEWBOq4XKCEfN6CQB2fC5SQL1oQqBNygRJyuAWB6p0LlJCvWBCoE3OBotszFvCoPrlA0S0kCwLVNxcoId+woPX1ywVKyLcsCFRVLlBCvmNBoOK5QAn5ngWBqs4FSsgRFgQqkQuUkB9aEKiaXKCEHGlBoJK5QAk5yoJAnZQLlJCjLQhU/1yghBxjQaBOzgVKyLEWBGpALlBCjrcgUKfkAiXkBAsCNTAXKCEnWhCoU3OBEnKyBYEalAuUkFMsCNRpuUAJOc2CQJ2eC5SQMywI1Bm5QAk5y4JAnZkLlJBzLAjUWblACTnPgkCdnQuUkPMtCNQ5uUAJucCCQA3OBUrIhRYE6txcoIRcbEGghuQCJeRSCwJ1XjuwjZkGhkVFJFJTGaqRYVklQrF4tFxEyuMVURmV5dHyRCgaDtdEI9HKWDxWKWIyEq6RyfJYOOlu+nxJXt7rJLXAjqs9UTaeDwYRjeFj5KvCsTYYw8dKsHFG7XUBLh6SIx7PuPFA5/QzQAwvtCSn0Rgic/oiZgyFvyUVfne3xcfmYsP9vpZ8vpHB70vAfqNz+0+Kd8+2uP260l7dGHC81PD8UfmtYl0L7PdlwHPrBYHDUOHXnKSOu5/6b/U1sLXutYpX6voyz7Vw/yb1/3c5/dsVJFeSXNUufT9kfJjOhhByRrm6HTY+tV0c1b6Oi3m9vPUzn3eh8b7c8HqdWrIuR/Ow+wpOTL1ziPC3ZKaNLIMEaC+hErc+Sd08/sR9vIQnGcCJFkoVOCcWXfLwWMCfj1Fivo1r6tnRYF4v+Z9rhKFMG41uhFxgMkxGYeRkdA3TZHSNOxmpxXHX4GEgs2pAtjZsh7fTa6PfOF1rONut0xYfk63b4dnudYbjWJcBx20YcLzecBzrMeC4LQOONxiOY30GHBsx4Hij4Tg2YMCxMQOONxmOY0MGHJsw4Hiz4ThuzYBjUwYcbzEcx20YcGzGgOOthuO4LQOOzRlwvM1wHBsx4NiCAcfbDcexMQOOLRlwvMNwHJsw4JjPgOOdhuPYlAHHVgw43mU4js0YcCxgwPFuw3FszoBjIQOO9xiOYwsGHIsYcLzXcBxbMuBYzIDjUMNxzGfAsTUDjvcZjmMrBhzbMOB4v+E4FjDgWMKA4wOG41jIgGNbBhwfNBzHIgYc2zHg+JDhOBYz4Ogw4Piw4Ti2ZsCxlAHHRwzHsQ0DjmUMOD5qOI4lDDi2Z8DxMcNxbMuAYwcGHB83HMd2DDh2ZMDxCcNxdBhw7MSA45OG41jKgGNnBhyfMhzHMgYcuzDg+LThOLZnwHE7BhyfMfxbL8rvCxn8ftYCvy9i8HuYJd9yQvv9nAXxPp/B7+ct8PsCBr9fAPudWnXB/j9T27/PNcl1i+vpE373ehG418qeuLiqL+kVeHLau+Bf+gJ/HyS1XmrHaPBL7fD7DgcmA5ffw9utBxi0L2sTWVXvv7+JvJxrIvJlpibySjtGg19haCKvGt5ElN+vMjeR+ti9Q2pDv5ia3kRewxWQDHXH7RXtmWturzE1t9fbMRr8OkNze8Pw5qb8foOpuaFp4HC3EaMfGji8nZmH2ZuG0/3i/Ly871vh4xyVdhyyjfL/+w/Zt4C1UdLDyINRIvMtyEP2LaZD9u12jAa/zXDIvmP4Iav8fseSQ1YNA28yHLJvABvJm8B4v2v4IZuk9x3V/e9a4DgjD4n32tnZQN9jaqDvt2M0+H2GBjrC8Aaq/B5hSQNVjf5dhgb6DrCBvguM9wftzI5HtkfN/7dO7B9a2ow/ZGrGH7VjNPgjhmY80vBmrPweaUkzVofGBwzNeASwGX8AjPfHhjdjlTcfM8RjJDAeHwPjMcqCeIwyPB6jgPH4xIJ4fGJ4PD4BxmO0BfEYbXg8RgPj8akF8fjU8Hh8CozHGAviMcbweIwBxuMzC+LxmeHx+AwYj7EWxGOs4fEYC4zHOAviMc7weIwDxmO8BfEYb3g8xgPj8bkF8fi8Hf4bdMh4fA6Mh7rBWZQXzG9S2fHTPiG+veX6G7Pq1XGvJ1A8vyCZSDKJZDLJlyRTSKaSTCOZTjKDZCbJLJLZJHNI5pLMI/mKZD7J1yQLSL4hWUiyiGQxyRKSpSTLSJaTfEuyguS7dq4xqZ/kUMY0yNB9odFN1OgmaXSTNbovNbopGt1UjW6aRjddo5uh0c3U6GZpdLM1ujka3VyNbp5G95VGN1+j+1qjW6DRfaPRLdToFml0izW6JRrdUo1umUa3XKP7VqNbodF95+q8q9R93c19Ff5WWtPx2ywnABrvunfPhPwCtJfycSJkr3V4TfK/V8jFS072u1fkP9jLL/3tJTxxlFP87BVKywk5dcv3Ehn5Jadt4V4VyX/lqpy+ZXtFNXkvZ2zJXlFtDcmZm79XZZZ6lLM2d6/KrLUtZ2/eXqEN9Ak5Z3P2qtxgz5FzN32v6o30LzlvU/eq3GgvlF9t2l5iE/qqnL8pe4lN6tHy643vVb6J/V4u2NhekU0+O+Q3G9wrktyMc0gu3NBelZt1pslF2feKbub5KBdn2SuW3OyzVi7R7yW24NyWS3V7iS2aAeSyf+8lt3CekMsz90ps8Wwiv03fK+xjzpErPHuFkr5mJvkdkPAH+Wmc72CzXkJ67f2+HaPB37fDfU42Zfz3uADKlQBQOT/ZozBUNqLuKqUwXAkugsK89XEOqgiEr5VgvavixWKVW2A/ZN7ZWOUG1qv7QcNA0bdicZ1EyFXAAvoBHFx08qmiWQUsxpTfqyw9kVbA8iiW8Nr7YztGg3+En0ixxI/AE2m14SeSwnA1/ESKJVZbeiKtgNkdq9aYy3IirXEL7KfME2mN5kT6KYATaQXwRFoDLKCfmIKLakApO5E+/wxsZnl5+NNypduA0G+IIqnAL8BmpsNQ+FtSxfgXhknmF0snmW9h/Sce9tr7aztGg3+FTzLx8K/A4v/N8ElGYfgbfJKJh39jLn5EA/3F8Ab6OxjD1EIfvMgc/wNYe0FOwN/C7I6HNOayTMB/uo35r8wJ+E/NBPxXABMw7gQS8k9gUv7FFFx0ISJ9Xss8AQt/S6rm+AfD9Pa34VOrisvfFvjNleN/Iwcqx+wczzakIIYf1F5bOdgDOyi2sxx21kSTXntrOYwGq82xbCearAUMYG3HbLajMFQ2YtlONFnb4T00EI1uK8fsZlzHwTbj/xQk2Gdkjtd1sM0zKLazHDYsRGs05rKwnXrOutf6Tl46s1H/kMl21B9xs53lQLZTz8ElZX2HJ7joQkT63MDBNh90wanmWNfBHwwNHd6DS/hbUsWloQV+c+V4Q2COb214jmcbUoS/JZFDyjbAvAmS7SyDnTWhtKeYbeswGrytg2Y7IbEtsAgaOWazHYWhshHLdkKikcN7aCAa3TaO2c24sYNtxqmF9hmZ402APgfJdpbB2I5MasxlYTtNnXWvzZy8dGaj/iGT7ag/4mY7y4Bsp6mDS8pmDk9w0YWI9Lm5g20+6IJTzbGJgz8YWji8B5fwt6SKSwsL/ObK8RbAHG9peI5nG1KEvyWRQ0o+MG+CZDtLcd8SS2M7rRxGg1s58G+JiVbAIigAJhYXhspG8LfERIHDe2ggGl2+Y3YzLnSwzTi10D4jc7wI6HOQbGcpjO1UB8Z2ip11r62dvHRmo/4hk+2oP+JmO0uBbKfYwSVla4cnuOhCRPrcxsE2H3TBqeZY5OAPhhKH9+AS/pZUcSmxwG+uHC8B5nhbw3M825Ai/C2JHFLaAfMmSLazBHbWVKQ9E8NxGA12HDTbqZAOsAhKgYnFhaGyEct2KtL8Fj6Xzm9Eo2vnmN2MyxxsM04ttM/IHG8P9DlItrMExnYqAnuWSgdn3WtHJy+d2ah/yGQ76o+42c4SINvp4OCSsqPDE1x0ISJ97uRgmw+64FRzbO/gD4bODu/BJfwtqeLS2QK/uXK8MzDHuxie49mGFOFvSeSQsh0wb4JkO4tx7+1EvfZ2dRgN7urA39uJdgUWQTdgYnFhqGwEv7cT7ebwHhqIRredY3Yz3t7BNuPUQvuMzPHuQJ+DZDuLcQ8XrNSYy8J2ejjrXns6eenMRv1DJttRf8TNdhYD2U4PB5eUPR2e4KILEemzcLDNB11wqjl2d/AHg3R4Dy7hb0kVF2mB31w5LoE5HjI8x7MNKcLfksghJQzMmyDZziLYWROJee2NOIwGRxw024nEIsAiKAcmFheGykYs24nEyh3eQwPR6MKO2c24wsE249RC+4zM8Uqgz0GynUUwthOJasxlYTtRZ91rzMlLZzbqHzLZjvojbrazCMh2og4uKWMOT3DRhYj0eQcH23zQBaeaY6WDPxh2dHgPLuFvSRWXHS3wmyvHdwTm+E6G53i2IUX4WxI5pOwMzJsg2c5C3BOo0z7JtovDaPAuDvwJ1HIXYBHsCkwsLgyVjVi2E0/zW/hcOr8RjW5nx+xmvJuDbcaphfYZmeO7A30Oku0sxD2kOLBPsu3hrHvd08lLZzbqHzLZjvojbrazEMh29nBwSbmnwxNcdCEifd7LwTYfdMGp5ri7gz8Y9nZ4Dy7hb0kVl70t8Jsrx/cG5vg+hud4tiFF+FsSOaTsC8ybINnONzi2U+21dz+H0eD9HDjbqd4PWAT7AxOLC0NlI5jtVO/v8B4aiEa3r2N2Mz7AwTbj1EL7jMzxA4E+B8l2vsGxnbjGXBa2c5Cz7vVgJy+d2ah/yGQ76o+42c43QLZzkINLyoMdnuCiCxHp8yEOtvmgC041xwMd/MFwqMN7cAl/S6q4HGqB31w5figwxw8zPMezDSnC35LIIeVwYN4EyXYW4D7JFvfae4TDaPARDvyTbPEjgEVwJDCxuDBUNoI/yRY/0uE9NBCN7nDH7GZ8lINtxqmF9hmZ40cDfQ6S7SzAfZKtSmMuC9s5xln3eqyTl85s1D9ksh31R9xsZwGQ7Rzj4JLyWIcnuOhCRPrcy8E2H3TBqeZ4tIM/GI5zeA8u4W9JFZfjLPCbK8ePA+b48YbneLYhRfhbEjmknADMmyDZzte4XxdNewJ1b4fR4N4O/NdFRW9gEZwITCwuDJWNWLYTFSc6vIcGotGd4JjdjPs42GacWmifkTneF+hzkGznaxjbqQzsCdT9nHWvVU5eOrNR/5DJdtQfcbOdr4Fsp5+DS8oqhye46EJE+hx3sM0HXXCqOfZ18AdDtcN7cAl/S6q4VFvgN1eOVwNzPGF4jmcbUoS/JZFDSg0wb4JkO/OZ2E7SYTQ46eDZThJYBCcBE4sLQ2Ujmu2c5PAeGohGV+OY3Yz7O9hmnFpon5E5fjLQ5yDZznwL2c4AZ93rKU5eOrNR/5DJdtQfcbOd+UC2M8DBJeUpjh1sB+nzQAfbfNAFp5rjyQ7+YDjV4T24hL8lVVxOtcBvrhw/FZjjgwzP8WxDivC3JHJIOQ2YN0Gyna9gZ01V2jPZTncYDT7dQbOdqtjpwCI4A5hYXBgqG7Fspyp2hsN7aCAa3WmO2c34TAfbjFML7TMyx88C+hwk2/kKxnaqAnsm29nOutdznLx0ZqP+IZPtqD/iZjtfAdnO2Q4uKc9xeIKLLkSkz4MdbPNBF5xqjmc5+IPhXIf34BL+llRxOdcCv7ly/Fxgjg8xPMezDSnC35LIIeU8YN4EyXbm4dhOxGvv+Q6jwec7cLYTOR9YBBcAE4sLQ2UjmO1ELnB4Dw1EozvPMbsZX+hgm3FqoX1G5vhFQJ+DZDvzcGwnrDGXhe1c7Kx7vcTJS2c26h8y2Y76I262Mw/Idi52cEl5icMTXHQhIn2+1ME2H3TBqeZ4kYM/GC5zeA8u4W9JFZfLLPCbK8cvA+b45YbneLYhRfhbEjmkXAHMmyDZzlzcr4umvbdzpcNo8JUO/NdFY1cCi+AqYGJxYahsxLKdROwqh/fQQDS6Kxyzm/HVDrYZpxbaZ2SOXwP0OUi2Mxf366KBvbdzrbPu9TonL53ZqH/IZDvqj7jZzlwg27nWwSXldQ5PcNGFiPT5egfbfNAFp5rjNQ7+YLjB4T24hL8lVVxusMBvrhy/AZjjNxqe49mGFOFvycuAGN4EzJsg2c4c2FlTXeO192aH0eCbHTTbqa65GVgEtwATiwtDZSOW7VTX3OLwHhqIRneTY3YzvtXBNuPUQvuMzPHbgD4HyXbmwNhOdUJjLgvbud1Z93qHk5fObNQ/ZLId9UfcbGcOkO3c7uCS8g6HJ7joQkT6fKeDbT7oglPN8TYHfzDc5fAeXMLfkioud1ngN1eO3wXM8bsNz/FsQ4rwtyRySLkHmDdBsp3ZsLNGpr23c6/DaPC9DprtyNi9wCIYCkwsLgyVjVi2I2NDHd5DA9Ho7nHMbsb3OdhmnFpon5E5fj/Q5yDZzmwY25GBvbfzgLPu9UEnL53ZqH/IZDvqj7jZzmwg23nAwSXlgw5PcNGFiPT5IQfbfNAFp5rj/Q7+YHjY4T24hL8lVVwetsBvrhx/GJjjjxie49mGFOFvSeSQ8igwb4JkO7Nwvy6axnYecxgNfsyB/7po7DFgETwOTCwuDJWNWLYTjz3u8B4aiEb3qGN2M37CwTbj1EL7jMzxJ4E+B8l2ZuF+XTQwtvOUs+71aScvndmof8hkO+qPuNnOLCDbecrBJeXTDk9w0YWI9PkZB9t80AWnmuOTDv5geNbhPbiEvyVVXJ61wG+uHH8WmOPDDM/xbEOK8Lckckh5Dpg3QbKdmbgnUEe99j7vMBr8vAN/AnX0eWARvABMLC4MlY1YthONvuDwHhqIRvecY3YzftHBNuPUQvuMzPGXgD4HyXZmwthOtFJjLgvbGe6se33ZyUtnNuofMtmO+iNutjMTyHaGO7ikfNnhCS66EJE+v+Jgmw+64FRzfMnBHwyvOrwHl/C3pIrLqxb4zZXjrwJz/DXDczzbkCL8LYkcUl4H5k2QbGcG7KyJpLGdNxxGg99w0GwnEn0DWARvAhOLC0NlI5btRKJvOryHBqLRve6Y3YzfcrDNOLXQPiNz/G2gz0GynRkwthMJjO2846x7fdfJS2c26h8y2Y76I262MwPIdt5xcEn5rsMTXHQhIn1+z8E2H3TBqeb4toM/GN53eA8u4W9JFZf3LfCbK8ffB+b4CMNzPNuQIvwtiRxSPgDmTZBsZzrsrIlJr70fOowGf+ig2U5Mfggsgo+AicWFobIRy3ZiaX4Ln0vnN6LRfeCY3YxHOthmnFpon5E5/jHQ5yDZznQY24kJjbksbGeUs+71Eycvndmof8hkO+qPuNnOdCDbGeXgkvIThye46EJE+jzawTYfdMGp5vixgz8YPnV4Dy7hb0kVl08t8Jsrxz8F5vgYw3M825Ai/C2JHFI+A+ZNkGxnGuysqRRee8c6jAaPddBsp1KMBRbBOGBicWGobMSynUoxzuE9NBCN7jPH7GY83sE249RC+4zM8c+BPgfJdqbB2E5FUmMuC9uZ4Kx7/cLJS2c26h8y2Y76I262Mw3IdiY4uKT8wuEJLroQkT5PdLDNB11wqjl+7uAPhkkO78El/C2p4jLJAr+5cnwSMMcnG57j2YYU4W9J5JDyJTBvgmQ7U3FPKUh7AvUUh9HgKQ78KQU1U4BFMBWYWFwYKhvBTymomerwHhqIRvelY3YznuZgm3FqoX1G5vh0oM9Bsp2puKcUBPYE6hnOuteZTl46s1H/kMl21B9xs52pQLYzw8El5UyHJ7joQkT6PMvBNh/47QWyb7qDPxhmO7wHl/C3pIrLbAv85srx2cAcn2N4jmcbUoS/JZFDylxg3gTJdqbAzppQ2ns78xxGg+c5aLYTEvOARfAVMLG4MFQ2YtlOSHzl8B4aiEY31zG7Gc93sM04tdA+I3P8a6DPQbKdKbgnUAf23s4CZ93rN05eOrNR/5DJdtQfcbOdKUC2s8DBJeU3Dk9w0YWI9Hmhg20+6IJTzfFrB38wLHJ4Dy7hb0kVl0UW+M2V44uAOb7Y8BzPNqQIf0sih5QlwLwJku18iTtrqr32LnUYDV7qoNmOqF4KLIJlwMTiwlDZiGU7onqZw3toIBrdEsfsZrzcwTbj1EL7jMzxb4E+B8l2voSxHRHXmMvCdlY4616/c/LSmY36h0y2o/6Im+0ATyC5wsEl5XcOT3DRhYj0+XsH23zQBaea47cO/mBY6fAeXMLfkiouKy3wmyvHVwJzfJXhOZ5tSBH+lkQOKT8A8yZItjMZdtZUpH2S7UeH0eAfHTTbqaj5EVgEq4GJxYWhshHLdipqVju8hwai0f3gmN2M1zjYZpxaaJ+ROf4T0Ocg2c5k3Pd2Avsk28/OutdfnLx0ZqP+IZPtqD/iZjuTgWznZweXlL84PMFFFyLS518dbPNBF5xqjj85+IPhN4f34BL+llRx+c0Cv7ly/Ddgjv9ueI5nG1KEvyWRQ8ofwLwJku1Mgp01Mu2ZbH86jAb/6aDZjpR/AovgL2BicWGobMSyHZnmt/C5dH4jGt0fjtnNeK2DbcaphfYZmeN/A30Oku1Mwn2SLbBnsuWVuliU5qUzG/UPmWxH/RE325kEZDvKB797pZJyq1Ke4KILEelzrVJs80EXnGqOqlmgD4bapbwHl/C3pIpL7VLz/ebK8drAHK9jeI5nG1KEvyWRQ0pdYN4EyXYm4j6Mkfa9nXqljAbXK8XvWx9YUFx+1y9dDzBoXxZWoRqKKgiTm14DcNNLLbTPyLxsyNzoETFpyJDjQTbUL5ga6taljAZvzdBQtzG8oSq/twmooQp/S6rC2KaUp+BQfgdZZBPa4TDw2rttKaPB2zKciNsCO3ojwwtWYdiIoQgalZo9TakibVSKpz8NgPFubPjtApU7jZmafWqha7sxMD5NDKf42RiD8LckkjE0NTzHVYybMgxyyDxUQ0JR3vpb5t6FtrtLHk+d50HtDLG+z7GVB1vHvW5G8WxO0oKkJUk+SSuSApJCkiKSYpLWJG1ISkjakrQjcUhKScpI2pN0IOlI0omkM0kXku1IupJ0I9mepDtJD5KeJKI0L/39lGbu+yleXXONroVG11Kjy9foWml0BRpdoUZXpNEVa3StNbo2Gl2JRtdWo2un0TkaXalGV6bRtdfoOmh0HTW6ThpdZ42ui0a3nUbXVaPrptFtr9F11+h6aHQ9NTpR+u/37krd193cV+FvpTUdv81S1YbfvVLvAzYH7aV8bAHZax1eLf3vFXLxkvl+94r8B3vZyt9ewhNHWeBnr1BaTsjCLd9LZOSXLNrCvSqS/8pVWbxle0U1eS9bb8leUW0NyTabv1dllnqUJZu7V2XW2pZtN2+v0Ab6hGy3OXtVbrDnSGfT96reSP+SpZu6V+VGe6Es27S9xCb0Vdl+U/YSm9SjZYeN71W+if1edtzYXpFNPjtkpw3uFUluxjkkO29or8rNOtNkl+x7RTfzfJTbZdkrltzss1Z21e8ltuDclt10e4ktmgHk9v/eS27hPCG7Z+6V2OLZRPZI3yvsY86RPT17hZK+ZiYpSu28oy1gs14i7VPHspTRYLU56q5XyniJC6AMAUDlvKOtMFQ2bgXGMAQugqA+PYor3kRgnx4NuwUWKc1LZ5vh0n9/ejRSyv/pUVwnETIMLKAIOLjo5FNFEwYWY8rvsKUnUk9YHsUSXnvLSxkNLoefSLFEOfBEqjD8RFIYVsBPpFiiwtITqSfM7li1xlyWE6nSLbBo5olUqTmRogGcSLhOImQlsICiTMFFvxGM9DkGbGZ5efjTMuQ2IPQbwUgqsAOwmekwFP6WVDHegWGS2aHUzkmmB6z/xMNee3csZTR4R/gkEw/vCCz+nQyfZBSGO8EnmXh4J+biRzTQHQxvoDuDMUwt9MGLzPFdgLUX5ATcA2Z3PKQxl2UC3tVtzLtlTsC7aibg3QKYgHEnkJC7ApNyN6bgogsR6fPuzBOw8Lekao67MExvexg+taq47GGB31w5vgcwx/c0PMezDSmI4Qe1117gAzsottMddtZEk1579y5lNHhvONuJJvcGBnAfw9mOwnAfONuJJvcxnO2oRrdXqdnNeF9wM04ttM/IHN/PUrbTHWZ3tEZjLgvb2d9tzAdksp39NWzngADYDu4EEnJ/YFIewBRcdCEifT7Q8ElQNcf9GKb+gwxnOyouB1ngN1eOHwTM8YMNz/FsQ4rwtyRySDnE0vd2toedNem/O35oKaPBh8LZTkgcCiyCwwxnOwrDw+BsJyQOM5ztqEZ3SKnZzfhwS9gOMsePsJTtbA+zO7jfHT/SbcxHZbKdIzVs56gA2A7uBBLySGBSHsUUXHQhIn0+2vBJUDXHIxim/mMMZzsqLsdY4DdXjh8DzPFjDc/xbEOK8LckckjpZSnb6QY7axJpbOe4UkaDj4OznYQ4DlgExxvOdhSGx8PZTkIcbzjbUY2uV6nZzfgES9gOMsd7W8p2usHsrg6M7ZzoNuY+mWznRA3b6RMA28GdQEKeCEzKPkzBRRci0ue+hk+Cqjn2Zpj6+xnOdlRc+lngN1eO9wPmeJXhOZ5tSBH+lkQOKXFL2U5X2FlTkfZMjOpSRoOr4WynQlYDiyBhONtRGCbgbKcizW/hc+n8RjS6eKnZzbjGEraDzPGkpWynK8zuisCepXKS25j7Z7KdkzRsp38AbAd3Agl5EjAp+zMFF12ISJ9PNnwSVM0xyTD1DzCc7ai4DLDAb64cHwDM8VMMz/FsQ4rwtyRySBloKdvZDvfeTtRr76mljAafin9vJ3oqsAgGGc52FIaD8O/tRAcZznZUoxtYanYzPs0StoPM8dMtZTvbwexOVGrMZWE7Z7iN+cxMtnOGhu2cGQDbwZ1AQp4BTMozmYKLLkSkz2cZPgmq5ng6w9R/tuFsR8XlbAv85srxs4E5fo7hOZ5tSBH+lkQOKYMtZTtdYGdNJOa199xSRoPPhbOdSOxcYBEMMZztKAyHwNlOJDbEcLajGt3gUrOb8XmWsB1kjp9vKdvpArM7EtWYy8J2LnAb84WZbOcCDdu5MAC2gzuBhLwAmJQXMgUXXYhIny8yfBJUzfF8hqn/YsPZjorLxRb4zZXjFwNz/BLDczzbkCL8LYkcUi61lO10hp018bRPsl1WymjwZXC2E5eXAYvgcsPZjsLwcjjbiaf5LXwund+IRndpqdnN+ApL2A4yx6+0lO10htkdD+yTbFe5jfnqTLZzlYbtXB0A28GdQEJeBUzKq5mCiy5EpM/XGD4JquZ4JcPUf63hbEfF5VoL/ObK8WuBOX6d4TmebUgR/pZEDinXW8p2OuHYTrXX3htKGQ2+Ac92qm8AFsGNhrMdheGNeLZTfaPhbEc1uutLzW7GN1nCdpA5frOlbKcTbiCOa8xlYTu3uI351ky2c4uG7dwaANvBnUBC3gJMyluZgosuRKTPtxk+CarmeDPD1H+74WxHxeV2C/zmyvHbgTl+h+E5nm1IEf6WRA4pd1rKdjrCzppI3GvvXaWMBt8FZzuR+F3AIrjbcLajMLwbznYi8bsNZzuq0d1ZanYzvscStoPM8XstZTsdYXZHqjTmsrCdoW5jvi+T7QzVsJ37AmA7uBNIyKHApLyPKbjoQkT6fL/hk6BqjvcyTP0PGM52VFwesMBvrhx/AJjjDxqe49mGFOFvSeSQ8pClbKcD7KyJpj2B+uFSRoMfhrOdqHgYWASPGM52FIaPwNlOVDxiONtRje6hUrOb8aOWsB1kjj9mKdvpALO7MrAnUD/uNuYnMtnO4xq280QAbAd3Agn5ODApn2AKLroQkT4/afgkqJrjYwxT/1OGsx0Vl6cs8Jsrx58C5vjThud4tiFF+FsSOaQ8Yynbac/Edp4tZTT4WQa28yywCIYZznYUhsMY2M4ww9mOanTPlJrdjJ+zhO0gc/x5S9lOewvZzgtuY34xk+28oGE7LwbAdnAnkJAvAJPyRUvYDtLnlwyfBFVzfJ5h6h9uONtRcRlugd9cOT4cmOMvG57j2YYU4W9J5JDyiqVspwx21lSlPZPt1VJGg1+Fs52q2KvAInjNcLajMHwNznaqYq8ZznZUo3ul1Oxm/LolbAeZ429YynbKYHZXBfZMtjfdxvxWJtt5U8N23gqA7eBOICHfBCblW0zBRRci0ue3DZ8EVXN8g2Hqf8dwtqPi8o4FfnPl+DvAHH/X8BzPNqQIf0sih5T3LGU7pTi2E/Ha+34po8Hv49lO5H1gEYwwnO0oDEfg2U5khOFsRzW690rNbsYfWMJ2kDn+oaVspxQ3EIc15rKwnY/cxjwyk+18pGE7IwNgO7gTSMiPgEk5kim46EJE+vyx4ZOgao4fMkz9owxnOyouoyzwmyvHRwFz/BPDczzbkCL8LYkcUkZbynYc2FmTSHtv59NSRoM/hbOdROxTYBGMMZztKAzHwNlOIjbGcLajGt3oUrOb8WeWsB1kjo+1lO04MLsTgb23M85tzOMz2c44DdsZHwDbwZ1AQo4DJuV4puCiCxHp8+eGT4KqOY5lmPonGM52VFwmWOA3V45PAOb4F4bneLYhRfhbEjmkTLSU7bSDnTXVNV57J5UyGjwJznaqayYBi2Cy4WxHYTgZznaqayYbznZUo5tYanYz/tIStoPM8SmWsp12MLurExpzWdjOVLcxT8tkO1M1bGdaAGwHdwIJORWYlNOYgosuRKTP0w2fBFVznMIw9c8wnO2ouMywwG+uHJ8BzPGZhud4tiFF+FsSOaTMspTttIWdNTLtvZ3ZpYwGz4azHRmbDSyCOYazHYXhHDjbkbE5hrMd1ehmlZrdjOdawnaQOT7PUrbTFma3DOy9na/cxjw/k+18pWE78wNgO7gTSMivgEk5nym46EJE+vy14ZOgao7zGKb+BYazHRWXBRb4zZXjC4A5/o3hOZ5tSBH+lkQOKQstZTslsLMmnsZ2FpUyGrwIznbisUXAIlhsONtRGC6Gs514bLHhbEc1uoWlZjfjJZawHWSOL7WU7ZTA7I4HxnaWuY15eSbbWaZhO8sDYDu4E0jIZcCkXM4UXHQhIn3+1vBJUDXHpQxT/wrD2Y6KywoL/ObK8RXAHP/O8BzPNqQIf0sih5TvLWU7bWBnTTTqtXdlKaPBK+FsJxpdCSyCVYazHYXhKjjbiUZXGc52VKP7vtTsZvyDJWwHmeM/Wsp22sDsjlZqzGVhO6vdxrwmk+2s1rCdNQGwHdwJJORqYFKuYQouuhCRPv9k+CSomuOPDFP/z4azHRWXny3wmyvHfwbm+C+G53i2IUX4WxI5pPxqKdtpDTtrImls57dSRoN/g7OdSPQ3YBH8bjjbURj+Dmc7kejvhrMd1eh+LTW7Gf9hCdtB5viflrKd1jC7I4Gxnb/cxrw2k+38pWE7awNgO7gTSMi/gEm5lim46EJE+vy34ZOgao5/Mkz9eWVmsx0VF2Wj6X5z5bjXTr97bVVmdo5nG1KEvyWRQ0otYN4EyXaKYWdNTHrtrV3GaLDaHMt2YrI2sAjqAIuTC8M6ZWi2E0vzW/hcOr8Rja5WmdnNuC64GacW2mdkjtdD1l5ecGynGDYcxoTGXBa2U99tzA3K8tKZTf2yf7Md9UfcbAd3AglZH5iUDcp4gosuRKTPDQ2fBFVzrMcw9W9tONtRcdnaAr+5cnxrYI5vY3iOZxtShL8lkUPKtpaynSLYWVMpvPY2KmM0uBGc7VSKRsAiaGw421EYNoaznUrR2HC2oxrdtmVmN+MmlrAdZI43tZTtFMHYTkVSYy4L22nmNubmmWynmYbtNA+A7RQB2U4zYFI2L+MJLroQkT63MHwSVM2xKcPU39JwtqPi0tICv7lyvCUwx/MNz/FsQ4rwtyRySGllKdsphJ018bQnUBeUMRpcAGc78ZoCYBEUGs52FIaFcLYTryk0nO2oRteqzOxmXGQJ20HmeLGlbKcQxnbigT2BurXbmNtksp3WGrbTJgC2UwhkO62BSdmmjCe46EJE+lxi+CSommMxw9Tf1nC2o+LS1gK/uXK8LTDH2xme49mGFOFvSeSQ4ljKdgpgZ00o7b2d0jJGg0vhbCckSoFFUGY421EYlsHZTkiUGc52VKNzysxuxu0tYTvIHO9gKdspgLEdGdh7Ox3dxtwpk+101LCdTgGwnQIg2+kITMpOZTzBRRci0ufOhk+Cqjl2YJj6uxjOdlRculjgN1eOdwHm+HaG53i2IUX4WxI5pHS1lO20wp011V57u5UxGtwNznZEdTdgEWxvONtRGG4PZzuienvD2Y5qdF3LzG7G3S1hO8gc72Ep22kFYzsirjGXhe30dBuzyGQ7PTVsRwTAdoAnkOwJTEpRxhNcdCEifZaGT4KqOfZgmPpDhrMdFZeQBX5z5XgImONhw3M825Ai/C2JHFIilrKdfNhZU5H2SbbyMkaDy+Fsp6KmHFgEFYazHYVhBZztVNRUGM52VKOLlJndjCstYTvIHI9aynbycd/bCeyTbDG3Me+QyXZiGrazQwBsJx/IdmLApNyhjCe46EJE+ryj4ZOgao5Rhql/J8PZjorLThb4zZXjOwFzfGfDczzbkCL8LYkcUnaxlO20hJ01Mu2ZbLuWMRq8K5ztSLkrsAh2M5zt/BN0ONuRaX4Ln0vnN6LR7VJmdjPe3RK2g8zxPSxlOy1xn2QL7Jlse7qNea9MtrOnhu3sFQDbaQlkO3sCk3KvMp7gogsR6fPehk+CqjnuwTD172M421Fx2ccCv7lyfB9gju9reI5nG1KEvyWRQ8p+lrKdFrgPY6R9b2f/MkaD9y/D73uA4QxF+X1A2XqAQfuysArVUPYrM7vpHWgJq0Dm5UHMjR4Rk4MYcjzIhtqcqaEeXMZo8MEMDfUQwxuq8vuQgBqq8LekKoxDyngKDuV3kEXWrBSHgdfeQ8sYDT6U4UQ8FNjRDzO8YBWGhzEUwWFlZk9TqkgPY6A/BwLjfbjhtwtU7hzO1OxTC13bhwPjc4ThFD8bYxD+lkQyhiMNz3EV4yMZBjlkHqohoShv/S1z70Lb/WIJT53nQe0Msb7PsZUHW8e9PorieTTJMSTHkvQiOY7keJITSHqTnEjSh6QvST+SKpI4STVJgqSGJElyEkl/kpNJBpCcQjKQ5FSSQSSnkZxOcgbJmSRnleWlv5+ijGmQoTtaoztGoztWo+ul0R2n0R2v0Z2g0fXW6E7U6PpodH01un4aXZVGF9foqjW6hEZXo9ElNbqTNLr+Gt3JGt0Aje4UjW6gRneqRjdIoztNoztdoztDoztTozur7N/v3ZW6r7u5r8LfSms6fpvlUYDGm3of8GjQXsrHYyB7rcPrWP97hVy8ZC+/e0X+g708zt9ewhNHebyfvUJpOSFP2PK9REZ+yd5buFdF8l+5Kk/csr2imryXfbZkr6i2hmTfzd+rMks9yn6bu1dl1tqWVZu3V2gDfULGN2evyg32HFm96XtVb6R/ycSm7lW50V4oazZtL7EJfVUmN2UvsUk9Wp608b3KN7Hfy/4b2yuyyWeHPHmDe0WSm3EOyQEb2qtys840eUr2vaKbeT7KgVn2iiU3+6yVp+r3EltwbstBur3EFs0A8rR/7yW3cJ6Qp2fuldji2USekb5X2MecI8/07BVK+pqZ5Flldt7RPgs26yXSPnV8dhmjwWrzWhn7+jX+bFwA5TkAUDnvaCsMlY2oO8YpDM8BF0FQnx7FFW8isE+PDnYL7NzMOxuDy/796dFzy/g/PYrrJEIOBhbQueDgopNPFc1gYDGm/B5s6Yl0JiyPYgmvvUPKGA0eAj+RYokhwBPpPMNPJIXhefATKZY4z9IT6UyY3bFqjbksJ9L5boFdkHkina85kS4I4ETCdRIhzwcW0AVMwUU1oJSdSJ8vBDazvDz8aXmO24BqgXMQSQUuAjYzHYbC35IqxhcxTDJIv4OcZM6A9Z942GvvxWWMBl8Mn2Ti4YuBxX+J4ZOMwvAS+CQTD1/CXPyIBnqR4Q30UjCGqYU+eJE5fhmw9oKcgM+A2R0PacxlmYAvdxvzFZkT8OWaCfiKACZg3Akk5OXApLyCKbjoQkT6fCXzBCz8Lama42UM09tVhk+tKi5XWeA3V45fBczxqw3P8WxDCmL4Qe11DfjADortnA47a6JJr73XljEafC2c7UST1wIDeJ3hbEdheB2c7UST1xnOdlSju6bM7GZ8PbgZpxbaZ2SO32Ap2zkdZne0RmMuC9u50W3MN2WynRs1bOemANgO7gQS8kZgUt7EFFx0ISJ9vtnwSVA1xxsYpv5bDGc7Ki63WOA3V47fAszxWw3P8WxDivC3JHJIuQ2YN0GyndNgZ036747fXsZo8O1wthMStwOL4A7D2Y7C8A442wmJOwxnO6rR3VZmdjO+0xK2g8zxuyxlO6fB7A7ud8fvdhvzPZls524N27knALaDO4GEvBuYlPcwBRddiEif7zV8ElTN8S6GqX+o4WxHxWWoBX5z5fhQYI7fZ3iOZxtShL8lkUPK/ZaynUGwsyaRxnYeKGM0+AE420mIB4BF8KDhbEdh+CCc7STEg4azHdXo7i8zuxk/ZAnbQeb4w5aynUEwu6sDYzuPuI350Uy284iG7TwaANvBnUBCPgJMykeZgosuRKTPjxk+Carm+DDD1P+44WxHxeVxC/zmyvHHgTn+hOE5nm1IEf6WRA4pT1rKdk6FnTUVac/EeKqM0eCn4GynQj4FLIKnDWc7CsOn4WynIs1v4XPp/EY0uifLzG7Gz1jCdpA5/qylbOdUmN0VgT1LZZjbmJ/LZDvDNGznuQDYDu4EEnIYMCmfYwouuhCRPj9v+CSomuOzDFP/C4azHRWXFyzwmyvHXwDm+IuG53i2IUX4WxI5pLxkKdsZCDtrElGvvcPLGA0eDmc7iehwYBG8bDjbURi+DGc7iejLhrMd1eheKjO7Gb9iCdtB5virlrKdgTC7E5Uac1nYzmtuY349k+28pmE7rwfAdnAnkJCvAZPydabgogsR6fMbhk+Cqjm+yjD1v2k421FxedMCv7ly/E1gjr9leI5nG1KEvyWRQ8rblrKdU2BnTSTmtfedMkaD34GznUjsHWARvGs421EYvgtnO5HYu4azHdXo3i4zuxm/ZwnbQeb4+5aynVNgdkeiGnNZ2M4ItzF/kMl2RmjYzgcBsB3cCSTkCGBSfsAUXHQhIn3+0PBJUDXH9xmm/o8MZzsqLh9Z4DdXjn8EzPGRhud4tiFF+FsSOaR8bCnbGQA7a+Jpn2QbVcZo8Cg424nLUcAi+MRwtqMw/ATOduJpfgufS+c3otF9XGZ2Mx5tCdtB5vinlrKdATC744F9km2M25g/y2Q7YzRs57MA2A7uBBJyDDApP2MKLroQkT6PNXwSVM3xU4apf5zhbEfFZZwFfnPl+Dhgjo83PMezDSnC35LIIeVzS9nOyTi2U+21d0IZo8ET8GynegKwCL4wnO0oDL/As53qLwxnO6rRfV5mdjOeaAnbQeb4JEvZzsm4gTiuMZeF7Ux2G/OXmWxnsobtfBkA28GdQEJOBibll0zBRRci0ucphk+CqjlOKsMfDFMNZzsqLlMt8Jsrx6cCc3ya4TmebUgR/pZEDinTLWU7/WFnTSTutXdGGaPBM+BsJxKfASyCmYazHYXhTDjbicRnGs52VKObXmZ2M55lCdtB5vhsS9lOf5jdkSqNuSxsZ47bmOdmsp05GrYzNwC2gzuBhJwDTMq5TMFFFyLS53mGT4KqOc5mmPq/MpztqLh8ZYHfXDn+FTDH5xue49mGFOFvSeSQ8rWlbOck2FkTTXsC9YIyRoMXwNlOVCwAFsE3hrMdheE3cLYTFd8YznZUo/u6zOxmvNAStoPM8UWWsp2TYHZXBvYE6sVuY16SyXYWa9jOkgDYDu4EEnIxMCmXMAUXXYhIn5caPgmq5riIYepfZjjbUXFZZoHfXDm+DJjjyw3P8WxDivC3JHJI+dZStpNkYjsryhgNXsHAdlYAi+A7w9mOwvA7BrbzneFsRzW6b8vMbsbfW8J2kDm+0lK2k7SQ7axyG/MPmWxnlYbt/BAA28GdQEKuAiblD5awHaTPPxo+CarmuJJh6l9tONtRcVltgd9cOb4amONrDM/xbEOK8Lckckj5yVK2UwM7a6rSnsn2cxmjwT/D2U5V7GdgEfxiONtRGP4CZztVsV8MZzuq0f1UZnYz/tUStoPM8d8sZTs1MLurAnsm2+9uY/4jk+38rmE7fwTAdnAnkJC/A5PyD6bgogsR6fOfhk+Cqjn+xjD1/2U421Fx+csCv7ly/C9gjq81PMezDSnC35LIIeVvS9lOAsd2Imn2tmc0WG0OZjsRtSfKxq3am812FIbKRjDbiWzVnvfQQDS6v8vMbsa12mObcWqhfUbmeG2gz0GynQRuIA5rzGVhO3Xcxly3fV46s6nT/t9sR/0RN9vBnUAUfGBS1m3PE1x0ISJ9rgduPuiCU82xdnv8wVCf+eAS/pZUcalvgd9cOV4fmOMNDM/xbEOK8LckckhpCMybINlONeysSaS9t7N1e0aDt4aznURsa2ARbGM421EYbgNnO4nYNoazHdXoGrY3uxlvawnbQeZ4I0vZTjWM7SQCe2+nsduYm2SyncYattMkALaDO4GEbAxMyibteYKLLkSkz00NnwRVc2zEMPU3M5ztqLg0s8BvrhxvBszx5obneLYhRfhbEjmktLCU7cRhZ011jdfelu0ZDW4JZzvVNS2BRZBvONtRGObD2U51Tb7hbEc1uhbtzW7GrSxhO8gcL7CU7cRhbKc6oTGXhe0Uuo25KJPtFGrYTlEAbAd3AglZCEzKovY8wUUXItLnYsMnQdUcCxim/taGsx0Vl9YW+M2V462BOd7G8BzPNqQIf0sih5QSS9lOFeyskWnv7bRtz2hwWzjbkbG2wCJoZzjbURi2g7MdGWtnONtRja6kvdnN2LGE7SBzvNRStlMFYzsysPd2ytzG3D6T7ZRp2E77ANgO7gQSsgyYlO3b8wQXXYhInzsYPgmq5ljKMPV3NJztqLh0tMBvrhzvCMzxTobneLYhRfhbEjmkdLaU7fSDnTXxNLbTpT2jwV3gbCce6wIsgu0MZzsKw+3gbCce285wtqMaXef2ZjfjrpawHWSOd7OU7fSDsZ14YGxne7cxd89kO9tr2E73ANgO7gQScntgUnZvzxNcdCEife5h+CSommM3hqm/p+FsR8WlpwV+c+V4T2COC8NzPNuQIvwtiRxSpKVspy/srIlGvfaG2jMaHIKznWg0BCyCsOFsR2EYhrOdaDRsONtRjU62N7sZRyxhO8gcL7eU7fSFsZ1opcZcFrZT4Tbmyky2U6FhO5UBsB3cCSRkBTApK9vzBBddiEifo4ZPgqo5ljNM/THD2Y6KS8wCv7lyPAbM8R0Mz/FsQ4rwtyRySNnRUrbTB3bWRP6Pve+Ak6J4vl+icIAiOQfvhDtAndm8Rsw5IwgCshEQBMQcUIxIEgkCoiBizjnnnHPOOeec9V+lu0ff0Dfcsa/21/3/Mn7KG7p3a9+rru5+NbOhRrWzebkg4M3h1U44vjlwEmxheLXDMdwCXu2E41sYXu3wQrdZudmL8ZaWVDvIHN/K0mpnJKzaCZes2hmYX5i39lY7AzXVztYlqHZwO5DjDgQm5dblMoOLnohIztsYrgR5cdxKQPVva3i1w+OyrQW8pXJ8W2COb2d4jtcmUpziDhcpUra3tNoZAdtrEq6Kd4dyQcA7wKudhLsDcBLsaHi1wzHcEV7tJGrwdoo8dLwRC9325WYvxjtZUu0gc3xnS6udEbBqJ+Fo4IpUO7vkF+ZdvdXOLppqZ9cSVDu4HchxdwEm5a7lMoOLnohIzrsZrgR5cdxZQPXvbni1w+OyuwW8pXJ8d2CO72F4jtcmUpziDhcpUva0tNoZDttrYo6Kd69yQcB7waudmLMXcBLsbXi1wzHcG17txJy9Da92eKHbs9zsxXgfS6odZI7va2m1MxxW7URzGrgi1c6g/MK8n7faGaSpdvYrQbWD24EcdxAwKfcrlxlc9EREch5suBLkxXFfAdU/xPBqh8dliAW8pXJ8CDDH9zc8x2sTKU5xh4sUKUMtrXYOgO01qRrfQD2sXBDwMHi1k8oOA06CAwyvdjiGB8CrnVT2AMOrHV7ohpabvRgPt6TaQeb4CEurnQNg1U6qZN9APTK/MB/orXZGaqqdA0tQ7eB2IMcdCUzKA8tlBhc9EZGcRxmuBHlxHCGg+pOGVzs8LkkLeEvleBKY4ynDc7w2keIUd7hIkZK2tNoZBttrgjXu7WTKBQFn4NVO0MkAJ0HW8GqHY5iFVztBJ2t4tcMLXbrc7MU4Z0m1g8zx0ZZWO8Ng1Y5bsns7Y/IL81hvtTNGU+2MLUG1g9uBHHcMMCnHlssMLnoiIjkfZLgS5MVxtIDqH2d4tcPjMs4C3lI5Pg6Y4+MNz/HaRIpT3OEiRcrBllY7Q3F7TVrFO6FcEPAEeLXjpCcAJ8FEw6sdjuFEeLXjpCcaXu3wQndwudmL8SRLqh1kjh9iabUzFFbtOCkNXJFqZ3J+YT7UW+1M1lQ7h5ag2gHuQO5kYFIeWi4zuOiJiOR8mOFKkBfHQwRU/+GGVzs8LodbwFsqxw8H5vgRhud4bSLFKe5wkSLlSEurnf1he020xjvZjioXBHwUvNqJZo8CToKjDa92OIZHw6udaPZow6sdXuiOLDd7MT7GkmoHmePHWlrt7A+rdqIleyfbcfmFeYq32jlOU+1MKUG1g9uBHPc4YFJOKZcZXPRERHI+3nAlyIvjsQKq/wTDqx0elxMs4C2V4ycAc3yq4Tlem0hxijtcpEg50dJqZwhsr3FrfCfbSeWCgE+CVzuuexJwEpxseLXDMTwZXu24NXg7RR463oiF7sRysxfjUyypdpA5fqql1c4QWLXjluw72U7LL8zTvNXOaZpqZ1oJqh3cDuS4pwGTclq5zOCiJyKS8+mGK0FeHE8VUP3TDa92eFymW8BbKsenA3N8huE5XptIcYo7XKRImWlptTN4AxxuFe+sckHAs8rxfmcbXqEw79nlKwMM8itSVfCCMrPc7EXvDEuqCmRezhFe6BFjMkcgx0u5oO4ntKCeWS4I+EyBBXWu4Qsq855bogXVKe5weWLMLZeZcCjepZxkgzbAxUDFO69cEPA8gR1xHnBFn2/4hOUYzheYBPMNv0bLk3S+QPlzBnC8Fxh+uYBzZ4HQYl840HN7AXB8zjK8xK+tYnCKO1xkxbDQ8BznMV4oIOSQecgioXNg5SVz9UDj/rGpzDwPQHEGRe9zNFBi2yt/vojGczHZ2WRLyM4hO5dsKdkysvPIlpOdT7aC7AKyC8kuIruY7BKyS8kuI7uc7AqyK8muIrua7Bqya8muI7ue7AayG8luIrvZe49lUf5+itq2WNN2tqZtiabtHE3buZq2pZq2ZZq28zRtyzVt52vaVmjaLtC0Xahpu0jTdrGm7RJN26Watss0bZdr2q7QtF2pabtK03a1pu0aTdu1mrbrNG3Xa9pu0LTdqGm7SdN2c/mq9+565/8OzP91ijtqLDrFLpaLAAtv4T7gYpAv5ng2xNd/8VpSvK9gPl7uOcX6ClfH3j23OF+OMo7u0mJ8BWvkhLtszX05nvxyz1tDX9HcKrnqLl8zX3FN3rvnr4mvuHYOuSvq7ytWy3x0L6ivr1itc9u9sH6+gj7rhHtRfXzFfNcc9+K6+0qvZv1yL6mrr9hq10L30rr5cuqwrrqX1cWXU6c12r189b4idVzv3StW5ytc573DvdLXVzhXj33IvcrPV6xee5p7de2+4vXcH91ravGVyNV7r3Wv1fty1mDfdq/T+XLWSAO416/qy11DPeHe4PWVWWNt4t5Y01eoCJ3j3qT4CuaK0kzuzeV2XtG+Gab1MjXedXxLuSBgdo666lUAfwtuAN1bAUGVvKLNMWSM2HcdZ2rwdoo8SvnuUdzkzZTs3aO35SfY7eWBmtXmbeWrvnv09nL5d4/iVhLHvQ04gW4HDy46+XjS3AacjAXet1m6I90Ey6NERsV7R7kg4DvgO1IicwdwR7rT8B2JY3gnfEdKZO60dEe6CYY7kdbAFdmR7spPsLu9O9Jdmh3p7hLsSDcBd6S7gBPobqHBRd8IRnK+B7iYBQL43fLW/AKEvhGMLAXuBS5muhg6xR0uj/G9AkrmXkuVzI2w9ScVUvHeVy4I+D64kkmF7gNO/vsNVzIcw/vhSiYVul948iMW0HsNX0AfAMewcKA3XmSOPwice6VUwDfCcKeCGrgiCvih/ML8sFcBP6RRwA+XQAHjdiDHfQiYlA8LDS56IiI5PyKsgJ3iDpcXxwcF1NujhqtWHpdHLeAtleOPAnP8McNzvDaRghA/KF+PgzfsUlU7N8D2mnhOxftEuSDgJ+DVTjz3BHAAnzS82uEYPgmvduK5Jw2vdnihe7zc7MX4KfBiXDjQnJE5/rSl1c4NMNzxrAauSLXzTH5hftZb7TyjqXaeLUG1g9uBHPcZYFI+KzS46ImI5Pyc4UqQF8enBVT/84ZXOzwuz1vAWyrHnwfm+AuG53htIsUp7nCRIuVFS+/tXA/ba2r+7vhL5YKAX4JXO0HnJeAkeNnwaodj+DK82gk6Lxte7fBC92K52YvxK5ZUO8gcf9XSaud6GO7S/e74a/mF+XVvtfOaptp5vQTVDm4HctzXgEn5utDgoicikvMbhitBXhxfFVD9bxpe7fC4vGkBb6kcfxOY428ZnuO1iRSnuMNFipS3La12roPtNZka1c475YKA34FXOxnnHeAkeNfwaodj+C682sk47xpe7fBC93a52Yvxe5ZUO8gcf9/Sauc6GO50yaqdD/IL84feaucDTbXzYQmqHdwO5LgfAJPyQ6HBRU9EJOePDFeCvDi+L6D6Pza82uFx+dgC3lI5/jEwxz8xPMdrEylOcYeLFCmfWlrtXAvba6I1vhPjs3JBwJ/Bq52o+xlwEnxueLXDMfwcXu1Ea/B2ijx0vBEL3aflZi/GX1hS7SBz/EtLq51rYbijJfsula/yC/PX3mrnK02183UJqh3cDuS4XwGT8muhwUVPRCTnbwxXgrw4fimg+r81vNrhcfnWAt5SOf4tMMe/MzzHaxMpTnGHixQp31ta7VyDu7cTV/H+UC4I+Af8vZ34D8BJ8KPh1Q7H8Ef8vZ34j4ZXO7zQfV9u9mL8kyXVDjLHf7a02rkGhjsT08AVqXZ+yS/Mv3qrnV801c6vJah2cDuQ4/4CTMpfhQYXPRGRnH8zXAny4vizgOr/3fBqh8fldwt4S+X478Ac/8PwHK9NpDjFHS5SpPxpabVzNWyvCSdUvH+VCwL+C17thBN/ASfB34ZXOxzDv+HVTjjxt+HVDi90f5abvRj/Y0m1A83xCjurnathYxWOa+CKVDsNKvL5UBGoWdlwh7fa4QdJVzu4HchxG1TgkrJhhczgoiciknOjCuzig55wvDgGKvAbQ+MK2Y3LKe5weVwaW8BbKscbA3O8ieE5XptIcYo7XKRIaQrMm1JWO1fB9ppUjXeyrVMhCJidY6udlLsOcBI0A05OqRg2q0BXO6kavJ0iDx1vxELXtMLsxbg5eDEuHGjOyBwvs7TauQpW7aRK9k62FvmFuaW32mmhqXZalqDauQpY7bQAJmXLCpnBRU9EJOdWhitBXhzLBFT/uoZXOzwu61rAWyrH1wXm+HqG53htIsUp7nCRIqW1pdXOlbhqJ63iXb9CEPD6+GonvT5wErQxvNrhGLbBVzvpNoZXO7zQta4wezFua0m1g8zxdpZWO1fiqp2UBq5ItdM+vzB38FY77TXVTocSVDtXAqud9sCk7FAhM7joiYjk3NFwJciLYzsB1d/J8GqHx6WTBbylcrwTMMc7G57jtYkUp7jDRYqULpZWO1fg3smWUvF2rRAE3BVe7YRTXYGToJvh1Q7HsBu82gmnuhle7fBC16XC7MW4uyXVDjLHe1ha7VyBeydbUgNXpNrpmV+Ye3mrnZ6aaqdXCaqdK4DVTk9gUvaqkBlc9EREcu5tuBLkxbGHgOrfwPBqh8dlAwt4S+X4BsAcLzc8x2sTKU5xh4sUKRWWVjuXw/aaeI1voN6wQhDwhvBqJ+5sCJwEfQyvdjiGfeDVTtzpY3i1wwtdRYXZi3FfS6odZI5XWlrtXA6rdmIl+wbqqvzC3M9b7VRpqp1+Jah2LgdWO1XApOxXITO46ImI5NzfcCXIi2OlgOofYHi1w+MywALeUjk+AJjjGxme47WJFKe4w0WKlI0trXYuE6p2NqkQBLyJQLWzCXASOIZXOxxDR6DacQyvdnih27jC7MXYtaTaQeZ40NJq5zILq51QfmEOe6udkKbaCZeg2rkMWO2EgEkZtqTaQXKOGK4EeXEMCqj+qOHVDo9L1ALeUjkeBeZ4zPAcr02kOMUdLlKkxC2tdi6F7TXJGt/JlqgQBJyAVzvJRAI4CTY1vNrhGG4Kr3aSiU0Nr3Z4oYtXmL0Yb2ZJtYPM8c0trXYuhVU7yZJ9J9sW+YV5S2+1s4Wm2tmyBNXOpcBqZwtgUm5ZITO46ImI5LyV4UqQF8fNBVT/QMOrnX/HxQLeUjk+EJjjWxue47WJFKe4w0WKlG0srXYuwVU7YRXvthWCgLfFVzvhbYGTYDvDqx2O4Xb4aie8neHVDi9021SYvRhvb0m1g8zxHSytdi7BVTshDVyRamfH/MK8k7fa2VFT7exUgmrnEmC1syMwKXeqkBlc9EREct7ZcCXIi+MOAqp/F8OrHR6XXSzgLZXjuwBzfFfDc7w2keIUd7hIkbKbpdXOxbhfF61xb2f3CkHAu8OrnUxid+Ak2MPwaodjuAe82skk9jC82uGFbrcKsxfjPS2pdpA5vpel1c7FuB+gLNm9nb3zC/M+3mpnb021s08Jqp2LgdXO3sCk3KdCZnDRExHJeV/DlSAvjnsJqP5Bhlc7PC6DLOAtleODgDm+n+E5XptIcYo7XKRIGWxptXMRbK9JZ1W8QyoEAQ+BVzvp7BDgJNjf8GqHY7g/vNpJZ/c3vNrhhW5whdmL8VBLqh1kjg+ztNq5CFbtpDMauCLVzgH5hXm4t9o5QFPtDC9BtXMRsNo5AJiUwytkBhc9EZGcRxiuBHlxHCag+kcaXu3wuIy0gLdUjo8E5viBhud4bSLFKe5wkSJllKXVzoWwvcatcW8nWSEIOAmvdtxEEjgJUoZXOxzDFLzacRMpw6sdXuhGVZi9GKctqXaQOZ6xtNq5EFbtuCW7t5PNL8w5b7WT1VQ7uRJUOxcCq50sMClzFTKDi56ISM6jDVeCvDhmBFT/GMOrHR6XMRbwlsrxMcAcH2t4jtcmUpziDhcpUg6ytNq5APfrojWqnXEVgoDHwaudVGIccBKMN7za4RiOh1c7qcR4w6sdXugOqjB7MT7YkmoHmeMTLK12LsD9umjJqp2J+YV5krfamaipdiaVoNq5AFjtTAQm5aQKmcFFT0Qk50MMV4K8OE4QUP2TDa92eFwmW8BbKscnA3P8UMNzvDaR4hR3uEiRcpil1c4K3DdQx1W8h1cIAj4cXu3E44cDJ8ERhlc7HMMj4NVOPH6E4dUOL3SHVZi9GB9pSbWDzPGjLK12VsCqnXhMA1ek2jk6vzAf4612jtZUO8eUoNpZAax2jgYm5TEVMoOLnohIzscargR5cTxKQPUfZ3i1w+NynAW8pXL8OGCOTzE8x2sTKU5xh4sUKcdbWu2cD9trwjWqnRMqBAGfAK92wvETgJNgquHVDsdwKrzaCcenGl7t8EJ3fIXZi/GJllQ7yBw/ydJq53xYtRMuWbVzcn5hPsVb7ZysqXZOKUG1cz6w2jkZmJSnVMgMLnoiIjmfargS5MXxJAHVf5rh1Q6Py2kW8JbK8dOAOT7N8ByvTaQ4xR0uUqScbmm1sxy21yRcFe/0CkHA0+HVTsKdDpwEMwyvdjiGM+DVTqIGb6fIQ8cbsdCdXmH2YjzTkmoHmeOzLK12lsOqnYSjgStS7czOL8xneKud2Zpq54wSVDvLgdXObGBSnlEhM7joiYjkPMdwJciL4ywB1X+m4dUOj8uZFvCWyvEzgTk+1/Acr02kOMUdLlKkzLO02jkPttfEHBXv/ApBwPPh1U7MmQ+cBAsMr3Y4hgvg1U7MWWB4tcML3bwKsxfjsyypdpA5vtDSauc8WLUTzWngilQ7i/IL82JvtbNIU+0sLkG1cx6w2lkETMrFFTKDi56ISM5nG64EeXFcKKD6lxhe7fC4LLGAt1SOLwHm+DmG53htIsUp7nCRIuVcS6udZbhvKajxDdRLKwQBL4VXO6nsUuAkWGZ4tcMxXAavdlLZZYZXO7zQnVth9mJ8niXVDjLHl1ta7SzDfUtBRgNXpNo5P78wr/BWO+drqp0VJah2lgGrnfOBSbmiQmZw0RMRyfkCw5UgL47LBVT/hYZXOzwuF1rAWyrHLwTm+EWG53htIsUp7nCRIuViS6udpbC9Jljj3s4lFYKAL4FXO0HnEuAkuNTwaodjeCm82gk6lxpe7fBCd3GF2YvxZZZUO8gcv9zSamcp7huoS3Zv54r8wnylt9q5QlPtXFmCamcpsNq5ApiUV1bIDC56IiI5X2W4EuTF8XIB1X+14dUOj8vVFvCWyvGrgTl+jeE5XptIcYo7XKRIudbSaudc3F6TVvFeVyEI+Dp4teOkrwNOgusNr3Y4htfDqx0nfb3h1Q4vdNdWmL0Y32BJtYPM8RstrXbOhVU7TkoDV6TauSm/MN/srXZu0lQ7N5eg2gHuQO5NwKS8uUJmcNETEcn5FsOVIC+ONwqo/lsNr3Z4XG61gLdUjt8KzPHbDM/x2kSKU9zhIkXK7ZZWO+fA9ppojXey3VEhCPgOeLUTzd4BnAR3Gl7tcAzvhFc70eydhlc7vNDdXmH2YnyXJdUOMsfvtrTaOQf3uZ2MBq5ItXNPfmG+11vt3KOpdu4tQbVzDrDauQeYlPdWyAwueiIiOd9nuBLkxfFuAdV/v+HVDo/L/Rbwlsrx+4E5/oDhOV6bSHGKO1ykSHnQ0mpnCWyvcWt8J9tDFYKAH4JXO677EHASPGx4tcMxfBhe7bg1eDtFHjreiIXuwQqzF+NHLKl2kDn+qKXVzhLcO9lK9p1sj+UX5se91c5jmmrn8RJUO0uA1c5jwKR8vEJmcNETEcn5CcOVIC+Ojwqo/icNr3Z4XJ60gLdUjj8JzPGnDM/x2kSKU9zhIkXK05ZWO2fj3oxR43M7z1QIAn6mAu/3WcMrFOb9bMXKAIP8ilQVvKA8XWH2ovecJVUFMi+fF17oEWPyvECOl3JBXSy0oL5QIQj4BYEF9UXDF1Tm/WKJFlSnuMPlifFihcyEQ/Eu5SRbVI6LgYr3pQpBwC8J7IgvAVf0lw2fsBzDlwUmwcuGX6PlSfqyQPnzHHC8XzH8cgHnzitCi33hQM/tV4Dj86rhJX5tFYNT3OEiK4bXDM9xHuPXBIQcMg9ZJLQMrDzUzfd1np/8gEaB0qiI14ED2lDB+UZ+oXnTe0OBO6Z62t7Mt6kH+obC68ARfKPuvtKr8eW+CZafbLq7XIF6xnN1uAOCSfkGMCbqJHrLm4xvVaw6y7yJh0yW1WB1V0fmLWASv10BSwZHjenbdZjMxWJ/ExgHZEzfqUdMV/daakzfURbNZko81Zg6xR3u3/7+gumcG4pkYxEnmgxHMtFQMBOMOZlwJOcS4GAiTKHJpcPxTDwYygVjwfTfWHz/5lhhYStsJH8HVm4gfP4u/X2P7P2K/xbCUtXi7ynj7sZDwWAsxPkRzzhuOENbQDCYSYWdtJNMB7OJsJvIhYPhUDqTTlEuJd2ck0umE7n4f75UvB9UCAL+QKM1iwX/AVBjf2h4Lc4x/FCjNYuN4YdgRVAWKM37Xt4Tum0cwMa3hiL4SBUA6IsWwIF01d1ABV1PzOm6JN9Ha1CEri7oHwEn88dgeViI68eKcqlvLpB0c9Ouk3MSQSfpxNLRWCqRCabiyVwoFwllQmsa19UlOzKunwjF9ZN8XEtZ1yIXI3Xx/DS/I3/Gc1BiwfhI4OrFR4Zf3V3TyeHUg3exGD83/MoXJ+bnAncGvhBaFL7wWWyd4g73M6FYfCkUiy+L2HhWh1kqL45y/0/XlNVeV5PKgaNds9eB9/K80WspcLxdZAz/f7nm+anQNc+v/Cocp7jD/VxoQfzKp8JZjZvVXkNlzF8JLAzHgBeGwtG4nmNWHyFTLOevK8xcYJBjoebl15pr2/Udn9XFHDk+36jXJUMhmhuZmJvL5EKRWCKYcqOhaDQXzsWi8XAmFwknM7GsG06GgolszMm58Sxd7Q2lY9FcIpOO5tRF282EQuFMIpV2I8FoMuXEM6GkkwvHQlT8ZkKxTCYUj0aToVAmGs/FE1SwUhkcdyKxWMKJBkOJoNT4fKNUmqhNYXVXNlSftmwK39q4KXwrvCl8K7ApHGvIplBrEsf+/YxcDrnofGfopnCs0KLzHWBTWN1lPuT4fG/opiA1Pt//f3T58Yf85ccfdZcfneKOWq/9I++DFOsLeClT5E18hRii3/EgFcNiff1k+HjwhPlJYGP/WUjk/Cx4WfRHoVj8IhSLXwQvi0rlxRTDL4tK5cDxFlwW/UngsihwvN3j114W9R7/rt+omKjC71fJCvgnoQXxV8EKmDH/KrAwnGDJZdGfgKLotwozF5gThCqs30pwWRQ5Pr8DK+DjgRWw1Pj8rhkf9Bu8kOPzh9D6+QcgDqu7UoOMw59CcfizDpfJTd7INXBheayKhL9sFAl/CYuEvwREwtQSiYQi3x0LXeT+BvpCioSpQpvQ33UQCcW+yxY5Pv9U4DZ2pEiQGp9/BK88VZKPygB+3QhsaPZVB+bMGNG8G2xYvK//vh0zJ8Kb8TUQ4N3Q8PFmzg0FeDcynDfjayTAu7HhvBlfYwHeTQznzfiaCPBuajhvxtdUgPc6hvNmfOsI8G5mOG/G10yAd3ML9rHmArzLDOfN+MoEeLewYLxbCPBuaThvxtdSgHcrw3kzvlYCvNc1nDfjW1eA93oWzO/1BHi3Npw342stwHt9w3kzvvUFeLcxnDfjayPAu63hvBlfWwHe7SxY19oJ8G5vOG/G116AdwfDeTO+DgK8OxrOm/F1FODdyYL53UmAd2fDeTO+zgK8u1gw3l0EeHc1nDfj6yrAu5sF491NgHd3w3kzvu4CvHsYzpvx9RDg3dNw3oyvpwDvXhbM714CvHsbzpvx9RbgvYEF472BAO9yw3kzvnIB3hUWjHeFAO8NDefN+DYU4N3HcN6Mr48A776G82Z8fQV4V1owvysFeFcZzpvxVQnw7mc4b8bXT4B3fwvyvL8A7wGG82Z8AwR4b2TBeG8kwHtjw3kzvo0FeG9iwXhvIsDbMZw343MEeLuG82Z8rgDvoOG8GV9QgHfIcN6MLyTAO2w4b8YXFuAdsWA9jwjwjhrOm/FFBXjHDOfN+GICvOOG82Z8cQHeCQvmd0KA96aG82Z8mwrw3syC8d5MgPfmhvNmfJsL8N7CcN6MbwsB3lsazpvxbSnAeyvDeTO+rQR4D7RgXRsowHtrw3kzvq0FeG9jwXhvI8B7W8N5M75tBXhvZzhvxredAO/tLcjz7QV472A4b8a3gwDvHQ3nzfh2FOC9k+G8Gd9OArx3Npw349tZgPcuhvNmfLsI8N7VcN6Mb1cB3rsZzpvx7SbAe3fDeTO+3QV472GBbtlDgPeehvNmfHsK8N7LcN6Mby8B3ntbkOd7C/Dex3DejG8fAd77Gs6b8e0rwHuQ4bwZ3yAB3vtZML/3E+A92HDejG+wAO8hFoz3EAHe+xvOm/HtL8B7qOG8Gd9QAd7DLMjzYQK8DzCcN+M7QID3cAvGe7gA7xGG82Z8IwR4j7RgvEcK8D7QcN6M70AB3qMM5834RgnwThrOm/ElBXinDOfN+FICvNOG82Z8aQHeGQvW84wA76zhvBlfVoB3znDejC8nwHu0BXk+WoD3GMN5M74xArzHGs6b8Y0V4H2Q4bwZ30ECvMcZzpvxjRPgPd5w3oxvvADvgw3nzfgOFuA9wYJ9bIIA74mG82Z8EwV4TzKcN+ObJMD7EMN5M75DBHhPNpw345sswPtQC9a1QwV4H2Y4b8Z3mADvww3nzfgOF+B9hAV5foQA7yMN5834jhTgfZQF432UAO+jDefN+I4W4H2M4bwZ3zECvI+1IM+PFeB9nOG8Gd9xArynWDDeUwR4H284b8Z3vADvEwznzfhOEOA91YI8nyrA+0TDeTO+EwV4n2TBeJ8kwPtkw3kzvpMFeJ9iOG/Gd4oA71MtyPNTBXifZjhvxneaAO9phvNmfNMEeJ9uOG/Gd7oA7+mG82Z80wV4zzCcN+ObIcB7puG8Gd9MAd6zDOfN+GYJ8J5twf49W4D3GYbzZnxnCPCeY8F4zxHgfabhvBnfmQK85xrOm/HNFeA9z3DejG+eAO/5hvNmfPMFeC8wnDfjWyDA+yzDeTO+swR4LzScN+NbKMB7kQX79yIB3osN5834FgvwPttw3ozvbAHeSyzI8yUCvM8xnDfjO0eA97mG82Z85wrwXmpBni8V4L3McN6Mb5kA7/MsGO/zBHgvN5w341suwPt8w3kzvvMFeK8wnDfjWyHA+wLDeTO+CwR4X2g4b8Z3oQDviyxYzy8S4H2x4bwZ38UCvC8xnDfju0SA96UW5PmlArwvM5w347tMgPflFoz35QK8rzCcN+O7QoD3lRaM95UCvK8ynDfju0qA99WG82Z8VwvwvsaCPL9GgPe1hvNmfNcK8L7OcN6M7zoB3tcbzpvxXS/A+wYL5vcNArxvNJw347tRgPdNhvNmfDcJ8L7Zgjy/WYD3LYbzZny3CPC+1XDejO9WAd63Gc6b8d0mwPt2w3kzvtsFeN9hOG/Gd4cA7zsN58347hTgfZcF+9hdArzvNpw347tbgPc9Foz3PQK87zWcN+O7V4D3fYbzZnz3CfC+33DejO9+Ad4PWDC/HxDg/aDhvBnfgwK8H7JgvB8S4P2w4bwZ38MCvB+xYLwfEeD9qOG8Gd+jArwfs2C8HxPg/bjhvBnf4wK8n7BgvJ8Q4P2k4bwZ35MCvJ8ynDfje0qA99MW5PnTAryfMZw343tGgPezhvNmfM8K8H7OcN6M7zkB3s8bzpvxPS/A+wXDeTO+FwR4v2jBev6iAO+XDOfN+F4S4P2y4bwZ38sCvF8xnDfje0WA96sWzO9XBXi/ZjhvxveaAO/XDefN+F4X4P2G4bwZ3xsCvN80nDfje1OA91uG82Z8bwnwftuC9fxtAd7vGM6b8b0jwPtdC8b7XQHe7xnOm/G9J8D7fQvG+30B3h8YzpvxfSDA+0MLxvtDAd4fGc6b8X0kwPtjw3kzvo8FeH9iOG/G94kA708tmN+fCvD+zHDejO8zAd6fWzDenwvw/sJw3ozvCwHeXxrOm/F9KcD7Kwvy/CsB3l8bzpvxfS3A+xsLxvsbAd7fGs6b8X0rwPs7C8b7OwHe3xvOm/F9L8D7B8N5M74fBHj/aDhvxvejAO+fLJjfPwnw/tlw3ozvZwHevxjOm/H9IsD7Vwvy/FcB3r8Zzpvx/SbA+3cLxvt3Ad5/GM6b8f0hwPtPC8b7TwHefxnOm/H9JcD7b8N5M76/BXj/YzhvxvePAO9AH7N5Mz42NO8GhvNmfA0EeDc0nTfleEMB3o0M5834Ggnwbmw4b8bXWIB3E8N5M74mArybWjC/mwrwXsdw3oxvHQHezQznzfiaCfBubjhvxtdcgHeZ4bwZX5kA7xYWrGstBHi3NJw342spwLuV4bwZXysB3utakOfrCvBez3DejG89Ad6tDefN+FoL8F7fcN6Mb30B3m0M58342gjwbms4b8bXVoB3OwvW83YCvNsbzpvxtRfg3cGC8e4gwLuj4bwZX0cB3p0sGO9OArw7G86b8XUW4N3FgvHuIsC7q+G8GV9XAd7dLBjvbgK8uxvOm/F1F+Ddw3DejK+HAO+ehvNmfD0FePcynDfj6yXAu7fhvBlfbwHeG1iwnm8gwLvccN6Mr1yAd4UF410hwHtDw3kzvg0FePexYLz7CPDuazhvxtdXgHelBeNdKcC7ynDejK9KgHc/C8a7nwDv/obzZnz9BXgPMJw34xsgwHsjC/J8IwHeGxvOm/FtLMB7E8N5M75NBHg7FuS5I8DbNZw343MFeActGO+gAO+Q4bwZX0iAd9hw3owvLMA7YjhvxhcR4B21YH5HBXjHDOfN+GICvOOG82Z8cQHeCcN5M76EAO9NLZjfmwrw3sxw3oxvMwHem1sw3psL8N7CcN6MbwsB3ltaMN5bCvDeynDejG8rAd4DLRjvgQK8tzacN+PbWoD3NhaM9zYCvLc1nDfj21aA93YWjPd2Ary3N5w349tegPcOhvNmfDsI8N7RcN6Mb0cB3jsZzpvx7STAe2fDeTO+nQV472I4b8a3iwDvXQ3nzfh2FeC9m+G8Gd9uArx3N5w349tdgPcehvNmfHsI8N7TcN6Mb08B3nsZzpvx7SXAe2/DeTO+vQV472M4b8a3jwDvfQ3nzfj2FeA9yHDejG+QAO/9DOfN+PYT4D3YcN6Mb7AA7yGG82Z8QwR47284b8a3vwDvoYbzZnxDBXgPM5w34xsmwPsAw3kzvgMEeA83nDfjGy7Ae4ThvBnfCAHeIw3nzfhGCvA+sA/OV2Py0VHhrh7oeBwIHC8V76g+goBH9cH7TQIHUIp3ss/KAIP8it2UlLgZmwIvLoWjoZd/NBgPh+PBUCoZC7rJcCoWzSUy6WQuGE8FM0knG3eimVgwGYon42E3lU7GnVQmGYzEMslwNuoGkbmUVnzRK6adRM5JRuLJWJYcOVmHTlLxbC4aTKbSYSeYcV03G6b/BbOZcCKVibqpKL16JOXS83RjHUylE9FYjJ6ZzqTCYTeSCCYzKTfmMvlwLh4LpdxUiKCGYpFcMJsLOwkKBtHMUQhCqez2+bxcJYbhRDJLblOhaCibIrC5YCSaTNCz0tFsKBpOcXwjoWAuGg5R3IJOKJzMpcORuJMIxtPh8PbAGGYM35QYX0ZgvmQN5834sgK8c4bzZnw5Ad6jDefN+EYL8B5jOG/GN0aA91jDeTO+sQK8DzKcN+M7SID3OMN5M75xArzHG86b8Y0X4H2w4bwZ38ECvCcYzpvxTRDgPdFw3oxvogDvSYbzZnyTBHgfYjhvxneIAO/JhvNmfJMFeB9qOG/Gd6gA78MM5834DhPgfbjhvBnf4QK8jzCcN+M7QoD3kYbzZnxHCvA+ynDejO8oAd5HG86b8R0twPsYw3kzvmMEeB9rOG/Gd6wA7+MM5834jhPgPcXSm7pThG7qHt9HEPDxAjd1TzD8pi7zPqHPygCD/Ipg5ZuvaYFJNrVEN3WLvdGJzKUT++BulOrG2s3l0rlYJpbNhYLBdCyWioXSkUgqnaYb1qmUS02ZeIICQK1OjF4lGIvGQ/FQOu2k3Ggm9+8N0xM0N3VdJxqLRBPJHL0AxSTouG4om8sRf/KXCSejTiQVCaaioUw0niNabpoikInEgrlwNhF0gxlgDE8yfFNifCcJzJeTDefN+E4W4H2K4bwZ3ykCvE81nDfjO1WA92mG82Z8pwnwnmY4b8Y3TYD36YbzZnynC/CebjhvxjddgPcMw3kzvhkCvGcazpvxzRTgPctw3oxvlgDv2YbzZnyzBXifYThvxneGAO85hvNmfHMEeJ9pOG/Gd6YA77mG82Z8cwV4zzOcN+ObJ8B7vuG8Gd98Ad4LDOfN+BYI8D7LcN6M7ywB3gsN5834FgrwXmQ4b8a3SID3YsN5M77FArzPNpw34ztbgPcSS29uLhG6uXlOH0HA5wjc3DzX8JubzPvcPisDDPIrgpVvQp4oMMmWlujmZrE3/JC5tKwP7oahdqwjOSeXS8WS2XQ2kg0l3WgqEg5Gwsl4NBtOxePJjJMJ0SOyqVwwkQ0GIzGXXigSCcXisXQ6Gz8pn5er3CBOxkLhbCoVCkZDYTebS7qJlBOKupmEG3LSmXAsFYymYuF4nG7MZoLRbDZNjTm6ZxuPUUTc5EnAGJ5n+KbE+M4TmC/LDefN+JYL8D7fcN6M73wB3isM5834VgjwvsBw3ozvAgHeFxrOm/FdKMD7IsN5M76LBHhfbDhvxnexAO9LDOfN+C4R4H2p4bwZ36UCvC8znDfju0yA9+WG82Z8lwvwvsJw3ozvCgHeVxrOm/FdKcD7KsN5M76rBHhfbThvxne1AO9rDOfN+K4R4H2t4bwZ37UCvK8znDfju06A9/WG82Z81wvwvsFw3ozvBgHeNxrOm/HdKMD7JsN5M76bBHjfbOlNvpuFbvLd0kcQ8C0CN/luNfwmH/O+tc/KAIP8imDlm3HLBCbZbSW6yVfsjS9kLt3eB3fjTDfWdKcynAwmUxF6aDgXiYXovqZLL+Hk6HYmgwllIplkwgmnQtFwIpcKxlJpJ5Ry+PVyqWTsvHxerhLDdCKXTKVj8XAkE3GIZiSYDSadUMxNU0DcnBuOZJ1MKh7MxolOIuqmg5Gcmw3RLdMUB+g8YAzvMHxTYnx3CMyXOw3nzfjuFOB9l+G8Gd9dArzvNpw347tbgPc9hvNmfPcI8L7XcN6M714B3vcZzpvx3SfA+37DeTO++wV4P2A4b8b3gADvBw3nzfgeFOD9kOG8Gd9DArwfNpw343tYgPcjhvNmfI8I8H7UcN6M71EB3o8ZzpvxPSbA+3HDeTO+xwV4P2E4b8b3hADvJw3nzfieFOD9lOG8Gd9TAryfNpw343tagPczhvNmfM8I8H7WcN6M71kB3s9ZerPrOaGbXc/3EQT8vMDNrhcMv9nFvF/oszLAIL8iWPmm1O0Ck+zFEt3sKvYGEDKXXuqDu4GkG+tgNhKKOE4uHo2lM3SXLMw3zaLhSDoSyaRiwVDGpXtrQSceiWZSmVjMjWcT4ZQTp8DEciG6w3dHPi9XudkVdJ1cNhqKJFPhdCycobtwqXQu5qTSQbp7GEpEonGHUDvBYCaTSLg5up2YCUecaDJF7ZFE5g5gDF82fFNifC8LzJdXDOfN+F4R4P2q4bwZ36sCvF8znDfje02A9+uG82Z8rwvwfsNw3ozvDQHebxrOm/G9KcD7LcN5M763BHi/bThvxve2AO93DOfN+N4R4P2u4bwZ37sCvN8znDfje0+A9/uG82Z87wvw/sBw3ozvAwHeHxrOm/F9KMD7I8N5M76PBHh/bDhvxvexAO9PDOfN+D4R4P2p4bwZ36cCvD8znDfj+0yA9+eG82Z8nwvw/sLSmz5fCN30+bKPIOAvBW76fGX4TR/m/VWflQEG+RXByjdnXhKYZF+X6qZPkTdCkLn0TR/cjRTdWBOIlJsLpoO5UDxNqLLJZC4WzeVykaSTiYZjobSbSCfCIbqplIyHM5EEvbAbC2XCmWw0lYqHX87npTeGbjKTCObCUXIezySSFMikk84S71TWiQfdSDbtJt2cQ4FOZLOpFN0qi2Yy2Ug0GXQTFMfsy8AYfmv4psT4vhWYL98ZzpvxfSfA+3vDeTO+7wV4/2A4b8b3gwDvHw3nzfh+FOD9k+G8Gd9PArx/Npw34/tZgPcvhvNmfL8I8P7VcN6M71cB3r8Zzpvx/SbA+3fDeTO+3wV4/2E4b8b3hwDvPw3nzfj+FOD9l+G8Gd9fArz/Npw34/tbgPc/hvNmfP8I8A70NZs342ND825gOG/G10CAd0PDeTO+hgK8GxnOm/E1EuDduK+dNz8aA8dLxdukryDgJn3xfpsCB1CKd9O+KwMM8iuClW9SfCOwia4DXlwKxyoX7ou8IYDMpWZ9cTcUdGPtBmPRdDgXDIWcSDrkEM9gNuQkY7lUNh5JZZx0LpTNBjNOMhfJuSEC4LqJWMbJ5EKEJJnJ8UV75rtKDDPZTDwRd5LZYCqTcZPhYJAQOuQ0Ec+l4+lIPBdxIrFYOhlJRtLZUCqYjsfi8UgunXFSkWDoW+DNj+aGb0qMr7nAplRmOG/GVybAu4XhvBlfCwHeLQ3nzfhaCvBuZThvxtdKgPe6hvNmfOsK8F7PcN6Mbz0B3q0N5834WgvwXt9w3oxvfQHebQznzfjaCPBuazhvxtdWgHc7w3kzvnYCvNsbzpvxtRfg3cFw3oyvgwDvjobzZnwdBXh3Mpw34+skwLuz4bwZX2cB3l0M5834ugjw7mo4b8bXVYB3N0tvAnQTugnQva8g4O4CNwF6GH4TgHn36LsywCC/Ilj5Yn0zgUnWs1Q3AYq8MI7MpV59cRfWtWOdjNB9g4ybiQWD6Vw6muBft0nm0jG+8RGJJGIpgkivksik06FUjh6boM5sMpFOk/Nkqnk+L70xDEbdYCSTdJ2kk8040VAwFnHiyVTSiWZcCmYomY66UWrOpLKZUDiRi4SITSaZiIRCoVg8EmsOjGFvwzclxtdbYL5sYDhvxreBAO9yw3kzvnIB3hWG82Z8FQK8NzScN+PbUIB3H8N5M74+Arz7Gs6b8fUV4F1pOG/GVynAu8pw3oyvSoB3P8N5M75+Arz7G86b8fUX4D3AcN6Mb4AA740M5834NhLgvbHhvBnfxgK8NzGcN+PbRIC3YzhvxucI8HYN5834XAHeQcN5M76gAO+QpRfDQ0IXw8N9BQGHBS6GRwy/GM68I31XBhjkVwQrX7TuJTDJoiW6GF7sBWJkLsX64i4wa8c664SisXCWLp5HMpFMLBpNZ1JBuvqfzNFtgHAsF8u6CQp9LhoNBhORaDaWDifSbjieTTuJUDjSO5+Xq1wMD0Ydoh2Oh8MpujgfjLjxYCIUCSWi8Ww44UboPkMwEg+78VAkFo6F6OK9m6HI5qJuKBdNpzK9gTGMG74pMb64wHxJGM6b8SUEeG9qOG/Gt6kA780M5834NhPgvbnhvBnf5gK8tzCcN+PbQoD3lobzZnxbCvDeynDejG8rAd4DDef9Lz4B3lsbzpvxbS3AexvDeTO+bQR4b2s4b8a3rQDv7Qznzfi2E+C9veG8Gd/2Arx3MJw349tBgPeOhvNmfDsK8N7JcN6MbycB3jtbelF4Z6GLwrv0FQS8i8BF4V0NvyjMvHftuzLAIL8iWPnibUxgku1WqovCRV4oRebS7n1xF1p1Y+1G49GEmw4lo8lwhBxF0uFsOptKplPpWC7p5KLBdCiSCyei1JGga810DTwVimQJRigYygWD8XxeemPoJjIZApkLJeOZcDTtRtKOG4vmUqlIKhHJhjPpSMyJx3M5ghbOuKlMPJyOpnLJSCyTzqRpAOLAGO5h+KbE+PYQmC97Gs6b8e0pwHsvw3kzvr0EeO9tOG/Gt7cA730M58349hHgva/hvBnfvgK8BxnOm/ENEuC9n+G8Gd9+ArwHG86b8Q0W4D3EcN6Mb4gA7/0N58349hfgPdRw3oxvqADvYYbzZnzDBHgfYDhvxneAAO/hhvNmfMMFeI8wnDfjGyHAe6SlF0dHCl0cPbCvIOADBS6OjjL84ijzHmXJxVG+iLm7wCRLlujiaLEXDJG5lOqLu+CoG2uXHAWdeCyUiNADg1F6Zi4Vz+YSyViQLv4miZKTSyVywRDxyMVDbpoeSpSDbsxJxtzMHvm8XCWGqVw8mKGgxTKxcMKhiBG2dJouJDvZqEsXmSNuMJtO0qXlSCToOtlgLJqleMTT2XguEs9G9gDGMG34psT40gLzJWM4b8aXEeCdNZw348sK8M4Zzpvx5QR4jzacN+MbLcB7jOG8Gd8YAd5jDefN+MYK8D7IcN6M7yAB3uMM5834xgnwHm84b8Y3XoD3wYbzZnwHC/CeYDhvxjdBgPdEw3kzvokCvCcZzpvxTRLgfYjhvBnfIQK8J1t6kXCy0EXCQ/sKAj5U4CLhYYZfJGTeh1lykZAv5qUEJtnhpbpIWOSFM2QuHdEXd+FNN9bBXCySII/xWDKXCmbDkVAqEo/m4nQtNBdLRbKuG03F40FyGg/ngm4oFozloomc60bokelwKp3Py4ar5FA2mwqmU5FE3M1mwpFoOJFMZVOZrBN3M2m6kBlNx6N0nSgbDoVj2Vgm40aD8VQymEkm0+FQKpYGxvBIwzclxnekwHw5ynDejO8oAd5HG86b8R0twPsYw3kzvmMEeB9rOG/Gd6wA7+MM5834jhPgPcVw3oxvigDv4w3nzfiOF+B9guG8Gd8JArynGs6b8U0V4H2i4bwZ34kCvE8ynDfjO0mA98mG82Z8JwvwPsVw3ozvFAHep1p6sexUoYtlp/UVBHyawMWyaYZfLGPe0yy5WMYXtY4QmGSnl+hiWbEXkJC5NL0v7gKUdqxD4Xgy7oTisWwuHUrEU9EMv0cw7cYSkWA6nglGnUQq66ZC8WQoQxcQE8lkJpFORJNuJuGGnNiR+bxcJYYZN5WMRolKmLAlXMeN0X+5ZDSRTQdTGccJBpP0XyZMUUs6TiLJn9OO5zLhbDCaTedSRwJjOMPwTYnxzRCYLzMN5834ZgrwnmU4b8Y3S4D3bMN5M77ZArzPMJw34ztDgPccw3kzvjkCvM80nDfjO1OA91zDeTO+uQK85xnOm/HNE+A933DejG++AO8FhvNmfAsEeJ9lOG/Gd5YA74WG82Z8CwV4L7L0otEioYtGi/sKAl4scNHobMMvGjHvsy25aMQXd6YLTLIlJbpoVOyFFGQundMXdyFGO9bBdCYXD7puKBJLpZLxRMJxc6FcNhZKhumSWThGJJOJaMyhK1XpCJ+GYrlQxo1n46GEG8vMyOflqheNEtFINOKmM5lENhx33Vw4G3FTcSeTSScpuqkwoctm3Vg46CST2WiSrmw5bjoYdWPpaDYemQGM4bmGb0qM71yB+bLUcN6Mb6kA72WG82Z8ywR4n2c4b8Z3ngDv5YbzZnzLBXifbzhvxne+AO8VhvNmfCsEeF9gOG/Gd4EA7wsN5834LhTgfZHhvBnfRQK8LzacN+O7WID3JYbzZnyXCPC+1NKLJ5cKXTy5rK8g4MsELp5cbvjFE+Z9uSUXT/gixzkCk+yKUl08KfKCAjKXruyLuyChG+tgLhdOhoKJYDwdy7npWCoeCkaS2awTT2dzbtaNRNxYLhyNZFP0hyjkEqEMXZmJRsJh/knc4Ln5vFwlhk40l0yFiW80QVCC/JVF2WQ6HoungtFoLJUJualcKBuMZ0N0uScWDSeT/OBMIpXKUF+NCx7FxvAqwzclxneVwHy52nDejO9qAd7XGM6b8V0jwPtaw3kzvmsFeF9nOG/Gd50A7+sN5834rhfgfYPhvBnfDQK8bzScN+O7UYD3TYbzZnw3CfC+2XDejO9mAd63GM6b8d0iwPtWSy8i3Cp0EeG2voKAbxO4iHC74RcRmPftllxE4GL/SoFJdkeJLiIUW1gjc+nOvrjCXDfWwVgoGItn0k6ILjfk3GQqGgvGIuFgPByMEvNQyg0HY9m46yRTkUw4Ew/GEsm4E3SzuVQmmErHr8rn5SoXERIh/onCaCYbzGVcJ0dQMxknFspRpBJOMhGL5txoIk1/nBDhS7jpcCwWiRGncDATDiWvAsbwLsM3JcZ3l8B8udtw3ozvbgHe9xjOm/HdI8D7XsN5M757BXjfZzhvxnefAO/7DefN+O4X4P2A4bwZ3wMCvB80nDfje1CA90OG82Z8Dwnwfthw3ozvYQHej1haTD8iVEw/2lcQ8KMCxfRjhhfTzPsxS4ppLnrvFJhkj5eqmC6ywETm0hN9cQWqbqyDVI678Ww2HIumE6lc1gnzr1Nlspl0OJVLZlPRXIwoUSUeCYZjuXQ0FsrEEulEMpaIRjJu8N9C9TFdMR2MJUOReDiRSBPhYCoVppZcJpaMhCKRTMxNxdNuMO3GYuFEOOekkxnHSUbiOeKQSAaz2eBdwBg+afimxPieFJgvTxnOm/E9JcD7acN5M76nBXg/YzhvxveMAO9nDefN+J4V4P2c4bwZ33MCvJ83nDfje16A9wuG82Z8LwjwftFw3ozvRQHeL1laVL4kVFS+3FcQ8MsCReUrhheVzPsVS4pKLv6eEJhkr5aqqCyy0ELm0mt9cYWabqyDCYIfTrkx103k0vyjJgk3nojTc3OJbDSWyGaJVTYeyzjZaCKejYbcbDySSwVDoYybpOr1yXxerlJURqnuTRAYx40lw0Enm0plU2nC7MRjMTcbCvE3VybSTjKeoZvJyZTr5hKJSNalx2QjCTf4JDCGrxu+KTG+1wXmyxuG82Z8bwjwftNw3ozvTQHebxnOm/G9JcD7bcN5M763BXi/YzhvxveOAO93DefN+N4V4P2e4bwZ33sCvN+3tLh6X6i4+qCvIOAPBIqrDw0vrpj3h5YUV1wEvSYwyT4qVXFVZMGBzKWPVc5FFiy6sQ664WjUjYSyyXAy5qQzqXjCcalOTIay0YibjYUdJ5TKOtFYJkzY3FQqmaS7gLlgMp7LJuOh8Ov5vFyluMq5VI3STcwokc9FUjkKZDDtZDOZRIq8RbLxkBNMht1cOhYnsJF4IpSM5ZJumMhFYuns68AYfmL4psT4PhGYL58azpvxfSrA+zPDeTO+zwR4f244b8b3uQDvLwznzfi+EOD9peG8Gd+XAry/Mpw34/tKgPfXlhYZXwsVGd/0FQT8jUCR8a3hRQbz/taSIoOLgY8FJtl3pSoyihTeyFz6vi9OuOvGOhhPheIJ1w2l3IybDobTsXQyGImmssEw3f1JptNRYhfJhd1gNB7LRp1YKpxN8J2jVCTJP1H/ST4vVykyYiknHYlS0eWG42GH7ijFo0EnnEzkQtFcjuC6sUQ4GAkTbCcXDDlpAht1E26MXjaWjEU/AcbwB8M3Jcb3g8B8+dFw3ozvRwHePxnOm/H9JMD7Z8N5M76fBXj/YjhvxveLAO9fDefN+H4V4P2bpWL7NyGx/XtfQcC/C4jtPwwX28z7D0vENovi7wUm2Z+lEttFClBkLv3VFydgdWPtJmIZ14lFQlRBJKL0jzg5C7uJRCIYJ5WecZLReCKYDaWD6VgwTHcSoplQku5mhCLRYDaW+1co/qER2y4VBKFMLpPkb9JIJNxMLpLO0u0IuveRII6Om0mnIpFoOBXNcYATCbo9QkVBOpVMZCg07g/AGP5t+KbE+P4WmC//GM6b8f0jwDtQaTZvxseG5t3AcN6Mr4EA74aG82Z8DQV4N6q0U3Q2Ao6XirdxpSDgxpV4v02AAyjFu0nlygCD/IpgZXH4l8Bm0hS8uBSOVQRTkUIMmUvrVOKEnG6s3XQ4HSJJTfI1kXAidPXYCUWTYScUo+ZkNJl14xk3EwxHghlynCGZHU7nkvFsJhtzcpl0nMUS810lhmF6xXA4E0k5cSeXTrJ2z6Ri0XAiRfgJXzQZTaeC4WA0GwqGU9lMKhEm3Rxx3XjOCYaSfwNFZzPDNyXG10xgU2puOG/G11yAd5nhvBlfmQDvFobzZnwtBHi3tFR8tRQSX60qBQG3EhBf6xouvpj3upaILxZJ6whMsvVKJb6KFCTIXGpdiRM0urEORhM5N5VM07XEKF1OjAXdTDwYSSZC/F7gCF35TLspNxRM56JBupoZ4+uMdIkx7KTC4WQ2Ewo2y+flKrfXE+kIPS1K/FOJUIbfFh0POk4mHEs7qWAykUhTEPlHfELxbJaurIay2UyYnhJKpSJuMFNDMBUbw/UN35QY3/oC86WN4bwZXxsB3m0N58342grwbmepCGknJELaVwoCbi8gQjoYLkKYdwdLRAiLhdYCk6xjiURIsRszMpc6VeI2du1Y01Uk4uekk9FI1iHZkqLXj8acbJpUF13simfTkWw6GosGo8lYOEdXvtLpbCpNT8gR4lxs/XxerhJD14kH6W6tS7IolQtn3XQ0S2GiS1WZTMSJpxOJaCZHr0X3RLO5VCKect0I8SP5RAGLOqn1gTHsbPimxPg6C8yXLobzZnxdBHh3tXQz7iq0GXerFATcTWAz7m74Zsy8u1uyGfOm2UlgkvUo0WZc7AaFzKWelbgNTjvWkZCTodd14zG6dOCw53AyFo9mkxk3mghGM5EMuyO0yWA0Go8mc5FwOB6mu1HhYNKNBzvn83KVzTgVCsUyBJGUSzgXDGbTRDAbzCXIQ5bubkWC0WAsFI3m4m7MSTqkZeJ0VSOcJJ2TiWTjNTbQYmPYy/BNifH1EpgvvS3dlHoLbUobVAoC3kBgUyo3fFNi3uWWbEq8efQUmGQVpdqUilyokbm0YSVuoa/LWKdC6XAmlsiE3WTCjUXi6VQ4kQ5F3FiatrVwMhKknTfnBkNRJ55LJ9LpXvm8bLiasXbC8VQ06xKxTDzsUgjS2WQwnIvmMoQ4lU0HQ27QCcfIa4zuCYSivYAx7GPp4txHaHHuWykIuK/A4lxp+OLMvCstWZx5Ed1QYHGuKtXi7Dnqu2Ahc6lfJW7B0401Ykz6CYx1f/XeaTwUpF2HHxfPOG44kw7Gg8FMKuzQ5dR0MJsIu4lcOBgOpTPpFPlMujknl0wncvH/fJVyQe0vtKAOqBQEPEBgQd3I8AWVeW8ksKByspUFVi4quqPwWsUmtkRcChMaHRc1mTdW8g2+cmyEm4EuY2uUx1gA3Vhpq42DU9whNghqUm6S9+8wL4lB2FhgVdlY+OIPivfqJEU9jxq8i8XoGn4BjRPTFZAUQfDWXFgE2O/UvF90LByhWISEYhESjIWU1AwbvqZIzYcT3f9T3unV4BPL/ZNcs9c/5hwW2EOA4+0iY8iCiq0uinl1vlaXU6pPiX0LFRNVXEb81LJT3OG6QhuBCrqemN3VvQ5jjggsDKeAF4bC0bieY1YfAVcs52ilmQsMcizUvIwqAmVNx2d1MUeOT0y9DhYK0dzIxNxcJheKxBLBlBvlezHhXCwaD2foFlEyE8u64WQomOCPM/APRcUiIf4p30QmHc2pi7abCYXCmUQq7dItnWTKiWdCSScXjoWCTjJDt4AyoXg0mgyFMtF4Lp6gqxLJXCjuRGKxhBMNhhJBqfGJacanvhvh6i6bIMcnLrR+xgFxWN3lJWQcEkJxSOTj4CcSTN7INXBheayKhE1tFAmbCouETQVEwqklEgmrq55KuchtBvSFFAmnCm1Cm9VBJKxWBBC+tOvknATtqE4sHY2lEplgKk77aC4SyoSQ47N5JW5jR4oEqfHZvIirTKubN4UruI2w87E+98NW6wt5NXiLSuyGVBijLYoYo9UJlzUco9XOyfrcs1ydL+QYbVmJi506Rlsq4sp7SyuwhmO3OnjIq62qGNwqfztroO52llPc4dZ2Wwd5r7JYX8BbY9qv+nGKO9w1nbT/VzEs1tfWho8HT5itBQTyNkLFwjaCt5YGCsViW6FYbOsTi2IxS+XFNMNvN0nlwOmG324K53mjbzcBx9s9fe3tJu/x7/qNiokq/LaTvJK0tdCCuJ3glSTGvJ3AwjDdkttNWwNF0faVZi4w04WuVGxfgttNyPHZAXi76XTglSSp8dmhDrcXAvUcr7q8a7dw2LIp7GjjprCj8Kawo8CmMMOQTaHWJI7l/j2Qi85Ohm4KM4QWnZ0Am8LqLvMhx2dnQzcFqfHZWdkUSvW5IfWyaJEfC3FVvLtUCgLeRVM2Fgt+F+BisCtwEkjFcFfNJlJsDHcVfkezU9zx74a/q8ClYOSih8yd3cCXggsH+nZEGMh5d8PfVV9bDjrFHUgxC12/9gCPB/pyIeceEKPLc253AYG+J7hYaRZYmYP8b96v/86f82v9jY3zv6/ZUHm9NypWvt6b+fO96HX3JtunIB6UxyPHfB9gLFmsdVZiKYl7L0PeIOh/BOV8uyuvDvDfXvnzfSkug8j2IxtMNoRsf7KhZMPIDiAbTjaCbCTZgWSjyJJkKbI0WYYsS5YjG002hmws2UFk48jGkx1MNoFsItkkskPIJlfmwRRUPINp5mkbpGnbT9M2WNM2RNO2v6ZtqKZtmKbtAE3bcE3bCE3bSE3bgZq2UZq2pKYtpWlLa9oymraspi2naRutaRujaRuraTtI0zZO0zZe03awpm2Cpm2ipm2Spu0QTdvkfJt69M7/HZj/6xR31Fh0it3E9gX4yv57HchxB4F8Mcf9IL7+i9fg4n0FC/fxhhTrK7zynuD+xfly1PuLQ4vxFax5r3LYmvtyvPc9D1hDX3SRaJV7qMPXzFdcdz92xJr4iuvv7Y6sv69YbfeJD6yvr1jt95xH1c9X0O/+dbI+vmL+98JTdfe12vdqpOvqK7batdDN1M2XU4d11c3WxZdTpzXaza3eV6SO6707enW+wnXeO9wxvr74G2zr7musn69YvfY096DafcXruT+642rxlcjVe691x+t9OWuwb7sH63w5a6QB3Amr+nLXUE+4E72+MmusTdxJNX2FitA57iGKr2CuKM3kTq7EFX2sG98LrCycJueLmEn5omZCvsgZny96DsoXQWPyRVEuXyRl8kUTr628VvPaz3sJ70281/HeyXsx7+2sFVh7sJZhbcRai7Uba0E+Snm3YzJMf2Zq3O04tFIQMDtHXXEtgD8Ul1TuYcACQSqGjBF1Ra4Qw8OAE5MnQadAaT5miltQMqJXetRYHJ6fYEdUBmpWwIfnB1ZtO0JTFaMvt+NWEsc9HDiBjgAPLjr5eNIcDpyMBd6HgydjqXakQ2B5lMioeI+sFAR8JHxHSmSOBO5IRxm+I3EMj4LvSInMUZbuSIfAcCfSGrgiO9LR+Ql2jHdHOlqzIx1Tgh3pEOCOdDRwAh0jNLjoNyEgOR8LXMwCAfxueVh+AULfTEeWAscBFzNdDJ3iDpfH+DgBJXOcpUpmEmz9SYVUvFMqBQFPgSuZVGgKcPIfb7iS4RgeD1cyqdDxwpMfsYAeZ/gCegI4hoUDvfEic3wqcO6VUgFPguFOBTVwRRTwifmF+SSvAj5Ro4BPKoECxu1AjnsiMClPEhpc9EREcj5ZWAE7xR0uL45TBdTbKYarVh6XUyzgLZXjpwBz/FTDc7w2kYIQPyhfp4E37FJVOxNhe008p+KdVikIeBq82onnpgEH8HTDqx2O4enwaieeO93waocXutMqzV6Mp4MX48KB5ozM8RmWVjsTYbjjWQ1ckWpnZn5hnuWtdmZqqp1ZJah2cDuQ484EJuUsocFFT0Qk59mGK0FeHGcIqP4zDK92eFzOsIC3VI6fAczxOYbneG0ixSnucJEi5UxL7+1MgO01wRpf7zO3UhDwXHi1E3TmAifBPMOrHY7hPHi1E3TmGV7t8EJ3ZqXZi/F8S6odZI4vsLTamQDD7eY0cEWqnbPyC/NCb7VzlqbaWViCage3AznuWcCkXCg0uOiJiOS8yHAlyIvjAgHVv9jwaofHZbEFvKVyfDEwx882PMdrEylOcYeLFClLLK12DobtNZka1c45lYKAz4FXOxnnHOAkONfwaodjeC682sk45xpe7fBCt6TS7MV4qSXVDjLHl1la7RwMw50uWbVzXn5hXu6tds7TVDvLS1Dt4HYgxz0PmJTLhQYXPRGRnM83XAny4rhMQPWvMLza4XFZYQFvqRxfAczxCwzP8dpEilPc4SJFyoWWVjvjYXtNtMZ3YlxUKQj4Ini1E3UvAk6Ciw2vdjiGF8OrnWgN3k6Rh443YqG7sNLsxfgSS6odZI5famm1Mx6GO1qy71K5LL8wX+6tdi7TVDuXl6Dawe1AjnsZMCkvFxpc9EREcr7CcCXIi+OlAqr/SsOrHR6XKy3gLZXjVwJz/CrDc7w2keIUd7hIkXK1pdXOONy9nbiK95pKQcDX4O/txK8BToJrDa92OIbX4u/txK81vNrhhe7qSrMX4+ssqXaQOX69pdXOOBjuTEwDV6TauSG/MN/orXZu0FQ7N5ag2sHtQI57AzApbxQaXPRERHK+yXAlyIvj9QKq/2bDqx0el5st4C2V4zcDc/wWw3O8NpHiFHe4SJFyq6XVzkGwvSacUPHeVikI+DZ4tRNO3AacBLcbXu1wDG+HVzvhxO2GVzu80N1aafZifIcl1Q4yx++0tNo5CIY7HNfAFal27sovzHd7q527NNXO3SWodnA7kOPeBUzKu4UGFz0RkZzvMVwJ8uJ4p4Dqv9fwaofH5V4LeEvl+L3AHL/P8ByvTaQ4xR0uUqTcb2m1Mxa216RqvJPtgUpBwA/Aq52U+wBwEjxoeLXDMXwQXu2kavB2ijx0vBEL3f2VZi/GD1lS7SBz/GFLq52xMNypkr2T7ZH8wvyot9p5RFPtPFqCage3AznuI8CkfFRocNETEcn5McOVIC+ODwuo/scNr3Z4XB63gLdUjj8OzPEnDM/x2kSKU9zhIkXKk5ZWO2Nw1U5axftUpSDgp/DVTvop4CR42vBqh2P4NL7aST9teLXDC92TlWYvxs9YUu0gc/xZS6udMThBnNLAFal2nssvzM97q53nNNXO8yWodnA7kOM+B0zK54UGFz0RkZxfMFwJ8uL4rIDqf9HwaofH5UULeEvl+IvAHH/J8ByvTaQ4xR0uUqS8bGm1Mxr3TraUiveVSkHAr+DfyZZ6BTgJXjW82uEYvop/J1vqVcOrHV7oXq40ezF+zZJqB5njr1ta7YzGvdkpqYErUu28kV+Y3/RWO29oqp03S1Dt4HYgx30DmJRvCg0ueiIiOb9luBLkxfF1AdX/tuHVDo/L2xbwlsrxt4E5/o7hOV6bSHGKO1ykSHnX0monB9tr4jW+gfq9SkHA78GrnbjzHnASvG94tcMxfB9e7cSd9w2vdnihe7fS7MX4A0uqHWSOf2hptZOD4Y6V7BuoP8ovzB97q52PNNXOxyWodnA7kON+BEzKj4UGFz0RkZw/MVwJ8uL4oYDq/9TwaofH5VMLeEvl+KfAHP/M8ByvTaQ4xR0uUqR8bmm1kxWqdr6oFAT8hUC18wVwEnxpeLXDMfxSoNr50vBqhxe6zyvNXoy/sqTaQeb415ZWO1kLq51v8gvzt95q5xtNtfNtCaod3A7kuN8Ak/JbS6odJOfvDFeCvDh+LaD6vze82uFx+d4C3lI5/j0wx38wPMdrEylOcYeLFCk/WlrtZGB7TbLGd7L9VCkI+Cd4tZNM/AScBD8bXu1wDH+GVzvJxM+GVzu80P1YafZi/Isl1Q4yx3+1tNrJwHAnS/adbL/lF+bfvdXOb5pq5/cSVDu4HchxfwMm5e9Cg4ueiEjOfxiuBHlx/FVA9f9peLXD4/KnBbylcvxPYI7/ZXiO1yZSnOIOFylS/ra02knjqp2wivefSkHA/+CrnfA/yElQZXa1wzFkjOBqJ6zydoo8dLwRC93flWYvxg2qsItx4UBzRuZ4QyDnUlY7aZwgDmngilQ7jar++9u4KlCzsmlUtWq1ww+SrnbSwGqnETApG1fJDC56IiI5NwEvPugJx4tjwyr8xtBUeONyijtcHpemFvCWyvGmwBxfx/Acr02kOMUdLlKkNAPmTSmrnRRsr8nUuLfTvEoQMDvHVjuZRHPgJCgzvNrhGJbBq51MoszwaocXumZVZi/GLSypdpA53tLSaicFq3YyJbu30yq/MK/rrXZaaaqddUtQ7aSA1U4rYFKuWyUzuOiJiOS8nuFKkBfHlgKqv7Xh1Q6PS2sLeEvleGtgjq9veI7XJlKc4g4XKVLaWFrtJGF7TTqr4m1bJQi4LbzaSWfbAidBO8OrHY5hO3i1k862M7za4YWuTZXZi3F7S6odZI53sLTaScKqnXRGA1ek2umYX5g7eaudjppqp1MJqp0ksNrpCEzKTlUyg4ueiEjOnQ1Xgrw4dhBQ/V0Mr3Z4XLpYwFsqx7sAc7yr4Tlem0hxijtcpEjpZmm1Mwq217g17u10rxIE3B1e7biJ7sBJ0MPwaodj2ANe7biJHoZXO7zQdasyezHuaUm1g8zxXpZWO6Ng1Y5bsns7vfML8wbeaqe3ptrZoATVzihgtdMbmJQbVMkMLnoiIjmXG64EeXHsJaD6KwyvdnhcKizgLZXjFcAc39DwHK9NpDjFHS5SpPSxtNo5ELbXpGpUO32rBAH3hVc7qURf4CSoNLza4RhWwqudVKLS8GqHF7o+VWYvxlWWVDvIHO9nabVzIKzaSZWs2umfX5gHeKud/ppqZ0AJqp0DgdVOf2BSDqiSGVz0RERy3shwJciLYz8B1b+x4dUOj8vGFvCWyvGNgTm+ieE5XptIcYo7XKRIcSytdkbivoE6ruJ1qwQBu/BqJx53gZMgaHi1wzEMwqudeDxoeLXDC51TZfZiHLKk2kHmeNjSamckrNqJxzRwRaqdSH5hjnqrnYim2omWoNoZCax2IsCkjFbJDC56IiI5xwxXgrw4hgVUf9zwaofHJW4Bb6kcjwNzPGF4jtcmUpziDhcpUja1tNoZAdtrwjWqnc2qBAFvBq92wvHNgJNgc8OrHY7h5vBqJxzf3PBqhxe6TavMXoy3sKTaQeb4lpZWOyNg1U64ZNXOVvmFeaC32tlKU+0MLEG1MwJY7WwFTMqBVTKDi56ISM5bG64EeXHcUkD1b2N4tcPjso0FvKVyfBtgjm9reI7XJlKc4g4XKVK2s7TaGQ7baxKuinf7KkHA28OrnYS7PXAS7GB4tcMx3AFe7SRq8HaKPHS8EQvddlVmL8Y7WlLtIHN8J0urneGwaifhaOCKVDs75xfmXbzVzs6aameXElQ7w4HVzs7ApNylSmZw0RMRyXlXw5UgL447Caj+3QyvdnhcdrOAt1SO7wbM8d0Nz/HaRIpT3OEiRcoellY7B8D2mpij4t2zShDwnvBqJ+bsCZwEexle7XAM94JXOzFnL8OrHV7o9qgyezHe25JqB5nj+1ha7RwAq3aiOQ1ckWpn3/zCPMhb7eyrqXYGlaDaOQBY7ewLTMpBVTKDi56ISM77Ga4EeXHcR0D1Dza82uFxGWwBb6kcHwzM8SGG53htIsUp7nCRImV/S6udYbhvKajxDdRDqwQBD4VXO6nsUOAkGGZ4tcMxHAavdlLZYYZXO7zQ7V9l9mJ8gCXVDjLHh1ta7QzDfUtByb6BekR+YR7prXZGaKqdkSWodoYBq50RwKQcWSUzuOiJiOR8oOFKkBfH4QKqf5Th1Q6PyygLeEvl+ChgjicNz/HaRIpT3OEiRUrK0mpnKGyvCda4t5OuEgSchlc7QScNnAQZw6sdjmEGXu0EnYzh1Q4vdKkqsxfjrCXVDjLHc5ZWO0Nx30Bdsns7o/ML8xhvtTNaU+2MKUG1MxRY7YwGJuWYKpnBRU9EJOexhitBXhxzAqr/IMOrHR6XgyzgLZXjBwFzfJzhOV6bSHGKO1ykSBlvabWzP26vSat4D64SBHwwvNpx0gcDJ8EEw6sdjuEEeLXjpCcYXu3wQje+yuzFeKIl1Q4yxydZWu3sD6t2nJQGrki1c0h+YZ7srXYO0VQ7k0tQ7QB3IPcQYFJOrpIZXPRERHI+1HAlyIvjJAHVf5jh1Q6Py2EW8JbK8cOAOX644Tlem0hxijtcpEg5wtJqZwhsr4nWeCfbkVWCgI+EVzvR7JHASXCU4dUOx/AoeLUTzR5leLXDC90RVWYvxkdbUu0gc/wYS6udIbjP7ZTsnWzH5hfm47zVzrGaaue4ElQ7Q4DVzrHApDyuSmZw0RMRyXmK4UqQF8djBFT/8YZXOzwux1vAWyrHjwfm+AmG53htIsUp7nCRImWqpdXOYNhe49b4TrYTqwQBnwivdlz3ROAkOMnwaodjeBK82nFr8HaKPHS8EQvd1CqzF+OTLal2kDl+iqXVzmDcO9lK9p1sp+YX5tO81c6pmmrntBJUO4OB1c6pwKQ8rUpmcNETEcl5muFKkBfHUwRU/+mGVzs8LqdbwFsqx08H5vh0w3O8NpHiFHe4SJEyw9JqZz/cmzFqfG5nZpUg4JlVeL+zDK9QmPesqpUBBvkVqSp4QZlRZfaiN9uSqgKZl2cIL/SIMTlDIMdLuaAOElpQ51QJAp4jsKCeafiCyrzPLNGC6hR3uDwxzqySmXAo3qWcZPtW4mKg4p1bJQh4rsCOOBe4os8zfMJyDOcJTIJ5hl+j5Uk6T6D8mQ0c7/mGXy7g3JkvtNgXDvTcng8cnwWGl/i1VQxOcYeLrBjOMjzHeYzPEhByyDwspUjYWxEJbjwUDMZCjCmecdxwJh2MB4OZVNhJO8l0MJsIu4lcOBgOpTPpFOFPujknl0wncvH/fKl4F1YJAl6omQTFgl8InPyLDBcJHMNFmklQbAwXgZVyWaA0N+T2rpTZ7ALY+NZQ4YuV8YOrKeBAuuqNQRV0PTGn65J8i9dgd1xd0BcDJ/PZwAmixpX9Tl3DXKAbvW7adXJOIugknVg6GkslMsFUPJkL5SKhTGhN47q6ZEfGdYlQXJfk49pYafMeJi9G6uJ5Tn5HPpfnoMSCsVhAVi02vOxc08nh1IN3sRiXGi7JOTGXClyyWCa0KCzzWWyd4g73XKFYnCcUi/OK2HhWh1kqL5a6/6drSno1+MRyYJlr9jrAG99SgbUUON4uMoYsKth0FU6gnjFYXU6pPiXWb1RMVIG13K/CcYo73KVCC+JynwpnNW7c1b0OY14usTmAF4bC0bieY1YfIVMs5/OrzFxgkGOh5uX5yka9puOzupgjx2eF4ssNhWhuZGJuLpMLRWKJYMqNhqLRXDgXi8bDmVwknMzEsm44GQomsjEn58az2VgklI5Fc4lMOppTF203EwqFM4lU2o0Eo8mUE8+Ekk4uHAtR8ZsJxTKZUDwaTYZCmWg8F09QwUplcNyJxGIJJxoMJYJS47NCqTRRm8LqrmyoPm3ZFC6wcVO4QHhTuEBgU1huyKZQaxLH/n3zfg656Fxo6KawXGjRuRCwKazuMh9yfC4ydFOQGp+L/j+6/Hhx/vLjJbrLj05xR63X/pH3QYr1BbyUKfLugkIMG1kSw2J9XWr4ePCEuVRgY79MSORcJnhZ9BKhWFwuFIvLBS+LSuXFCsMvi0rlwAUWXBa9VOCyKHC83QvWXhb1Hv+u36iYqMLvCskK+FKhBfEKwQqYMV8hsDBcaMll0UuBoujKKjMXmAuFKqwrS3BZFDk+VwEr4AuAFbDU+FylGR/0G7yQ43O10Pp5NSAOq7tSg4zDNUJxuKYOl8lN3sg1cGF5rIqEa20UCdcKi4RrBUTCRSUSCUW+Oxa6yF2HvM8HFAkXCW1C19VBJBT7Llvk+FxfhdvYkSJBanyuF7zaMjlffaO/vmoy7Our4i4yd26Are3xGmPEfvkrwXjDfi+w6gGKa/Uait7z1m1kPsYb0UKlodBkQhFmXzf+D03Om4CTU3giuv/LE/Em5ES0dcXsbcFA3bx2oBx3/6bmY7xl7UA5bsSCGXXr2oFy3E0sGKjb1g6U4w63YOm7fe1AOe5ICwbqjrUD5bijLBioO9cOlOOmLBiou9YOlONmLBiou9cOlOPmLBioe9YOlOOOsWCg7l07UI57kAUDdd/agXLc8RYM1P1rB8pxJ1gwUA+sHSjHPdSCS0gPrh0oxz3Eghn10NqBohllwUA9vHagHPdyC5a+R9YOlOMeYcGMenTtQDnuURYM1GNrB8pxj7FgoB5fO1COe5wFA/XE2oGiYtICMfHk2oFy3BMsmFFPrR0oxz3RgoF6eu1AOe7JFgzUM2sHynFPtWCgnl07UI7b3gIx8dzagXLcW5uYj/H5tQPluNMtWPpeWDtQjjvTgoF6ETlQ/AHf9QIrP1vGYHt7Bq0hmIDU586coo64g+bJ2A4B/jot+7u5yuyPB0nEcBI4hrcIxPAWw2M4ERzDWwVieKvhMZwAjuFtAjG8zfAYHgyO4e0CMbzd8BiOB8fwDoEY3mF4DMeBY3inQAzvNDyGB4FjeJdADO8yPIZjwTG8WyCGdxsewzHgGN4jEMN7DI/haHAM7xWI4b2GxzAHjuF9AjG8z/AYZsExvF8ghvcbHsMMOIYPCMTwAcNjmAbH8EGBGD5oeAxT4Bg+JBDDhwyPYRIcw4cFYviw4TEcBY7hIwIxfMTwGB4IjuGjAjF81PAYjgTH8DGBGD5meAxHgGP4uEAMHzc8hsPBMXxCIIZPGB7DA8AxfFIghk8aHsNh4Bg+JRDDpwyP4VBwDJ8WiOHThsdwf3AMnxGI4TOGx3AIOIbPCsTwWcNjOBgcw+cEYvic4THcDxzD5wVi+LzhMRwEjuELVWa/W1EihvuCY/hileFvJPQcGL+haEBzYHwHXTnfK3OKx6x1/vwlivfLZK+QvUr2GtnrZG+QvUn2FtnbZO+QvUv2Htn7ZB+QfVj1n4+PqvJOC784wU57edpe1rS9oml7VdP2mqbtdU3bG5q2NzVtH+Xb+EBPtEM8P7SAeoNlfX8azx/lfz8IUSxGfsNr3IH+KlWNN34WG7uPQbj4h5zU/PlYyZ+ARB65NbEXG4dPgIuqGodPBOfRJIF5xG+IRf9gCfBNtu4nQL6fCo35pyXI/U+BcfhMKA6fCeb+RIHcv1Ug94FvjnY/A/L9XGjMP5fOfYrDS4bGgX00BnM9GPmjVLRuTADNm/8+yPOfrrkNPA9vR89D4g18g32NN5oXy/cLoXn4RQn2oC+AcfhSKA5fCu5B4wX2oDsE9iDgm/rdL4F8vxIa869KkPtfAePwtVAcvhbM/XECuX+nQO4DP4zhfg3k+43QmH9TAv31sqFxYB9o/TUWrL8OEtBfd4Hn4d0C+gv4gZ4aH2wplu+3QvPw2xLsQd8C4/CdUBy+E9yDxgjsQfcI7EHADxG53wH5fi805t+XIPe/B8bhB6E4/CCY+6MFcv9egdwHfvjL/QHI90ehMf+xBPrrFUPjwD7Q+isL1l85Af11H3ge3i+gv4AfIKzxQbpi+f4kNA9/KsEe9BMwDj8LxeFnwT0oI7AHPSCwBwE/tOj+DOT7i9CY/1KC3P8FGIdfheLwq2DupwVy/0GB3Ad+2NT9Fcj3N6Ex/60E+utVQ+PAPtD6KwnWXykB/fUQeB4+LKC/gB9YrvHB3WL5/i40D38vwR70OzAOfwjF4Q/BPWiUwB70iMAeBPyQtPsHkO+fQmP+Zwly/09gHP4SisNfgrl/oEDuPyqQ+8APt7t/Afn+LTTmf5dAf71maBzYB1p/jQDrr5EC+usx8Dx8XEB/Ab8gocYXBRTL9x+hefhPCfagf4BxCPSTiQP77SXBnyIwXGAPekJgDwJ+KYOrjlOxfBsIjXmDfvK53wAYh4ZCcWgomPsHCOT+kwK5D/wyDbchcMwbCY15o37y+uv1KjPjwD7Q+msoWH8NE9BfT4Hn4dMC+gv4hSw1vpikWL6NheZh4xLsQY2B61EToTg0EdyD9hfYg54R2IOAXwLjNgGOeVOhMW9agtxvCozDOkJxWEcw94cI5P6zArkP/PIedx3gmDcTGvNmJdBfb1SZGQf2gdZf+4H112AB/fUceB4+L6C/gF8AVeOLkIrl21xoHjYvwR7UHLgelQnFoUxwDxoksAe9ILAHAb90yi0DjnkLoTFvUYLcbwGMQ0uhOLQUzP19BXL/RYHcB35ZmNsSOOathMa8VQn015tVZsZB5dwAzPktAOdU8j9fkjjfrrIjnu9YgvNdS3C+ZwnO9y3B+YElOD8E4uTalb/0Uf1R7daBmgca/0sCcUZjfNkCjK9YgPFVCzC+ZgHG1y3A+IYFGN8UWuMRGEPRuIhfKbxr/f7/5RfnOxgU9O0W1gRVq6xLNeV6ZK3J1idrQ9aWrB1Ze7IOZB3JOpF1JutC1pWsG1n3foGaXwS9br9Vvxx6PU1ba03b+pq2Npq2tpq2dpq29pq2bpq27vk2FnSdAisvAKgHejHt0M/4ZHT5f2osevT7729P76Bzh1f5oq9MdQBcTeK7MOyrB/DKVE9LrsjYgrOjJTg7WYKzsyU4u1iCs6slOBHrZSrxr6qucQXWe3W82PUTeEXDXVdobNCcgVdI3PUs4Qy84uK2toQz8AqOu74lnIFXhNw2lnAGXmFy21rCGXjFym1nCWfgFTC3fYk4O2t2uIWTbsBaqZfQXXzVLzgOhcPtjsPu9gLVsrlsLvHvBZHAqr8Spv46mPqrYOqvgam/Aqb++pf6q1/qr3190mbl+bqN1vxcvQjTXTn/VPH/mXL+uXL+hXL+pXL+lXL+tXL+Tf58A3qdcrIKsg3J+pD1Jaskq+r338WfzoGV1y3UA63NNzD/4g8fYTHf7n/ztxDbwruA+1Fc+pMNINvIe5GJO5t52vpr2gZo2jbKt6lHE2ywagxqsQtlP9QCkXPc/sALZwMgvv6L10bASVDKyVu+dvJqJ+/GFJdNyBwy1zt5N9ZMyk00bY6mzS3B5C0HTt6NgZN3E+DkdYCT17V08lasnbzayRukuITIwmQR7+QNaiZlSNMW1rRFSjB5K4CTNwicvCHg5A0DJ2/E0sm74drJq528UYpLjCxOlvBO3qhmUsY0bXFNW6IEk3dD4OSNAidvDDh548DJm7B08vZZO3m1k3dTistmZJuTbeGdvJtqJuVmmrbNNW1blGDy9gFO3k2Bk3cz4OTdHDh5t7B08vZdO3m1k3dListWHBuyrb2Td0vNpNxK0zZQ07Z1CSZvX+Dk3RI4ebcCTt6BwMm7taWTt3Lt5NVO3m0oLtuSbUe2vXfybqOZlNtq2rbTtG1fgslbCZy82wAn77bAybsdcPJub+nkrVo7ebWTdweKy45kO5Ht7J28O2gm5Y6atp00bTuXYPJWASfvDsDJuyNw8u4EnLw7g983wMfyADhR6Wi21t9af2v9rfW31t9af2v9rfW31p/J/oIF7f9Vz5V1wJfK+RfK+efK+WfK+afK+SfK+cfK+UfK+YfK+QfK+fvK+XvK+bvK+TvK+dvK+VvK+ZvK+RvK+evK+WvK+avK+SvK+cvK+UvK+YvK+QvK+fPK+XPK+bPK+TPK+dPKudN75fkmyvnGyvlGyvkA5by/ct5POa9SziuV877KeR/lfEPlvEI5L1fON1DOeyvnvZTznsp5D+W8u3LeTTnvqpx3Uc47K+edlPOOynkH5by9ct5OOW+rnLdRztdXzg/dYOX5ZOX8EOV8knI+UTmfoJwfrJyPV87HKecHKedjlfMxyvlo5TynnGeV84xynlbOU8p5UjkfpZwfqJyPVM5HKOfDlfMDlPNhyvlQ5Xx/5XyIcj5YOd9POR+knN9cvvL8JuX8RuX8BuX8euX8OuX8WuX8GuX8auX8KuX8SuX8CuX8cuX8MuX8UuX8EuX8YuX8IuX8QuX8AuV8hXJ+vnK+XDk/TzlfppwvVc7PVc7PUc6XKOdnK+eLlfNFyvkWynUg9VaqeqtVvRW7tXKu3r1R7+6od3+2V87VC8bqBWX1gvPOyrl6jUq9hqVe49pIOVff/qy+PVp9+7SrnKvvuFTfkam+YzOinKtv8lLfBKa+SSyhnKvvK1Hfd1J4X8q1gf+OXejfu5LtRrY72R5ke5LtRbY32T5k+5INItuPbDDZELL9yYaSDSM7gGw42QiykWQHko0iS5KlyNJkGbIsWY5sNNkYsrFkB5GNIxtPdjDZBLKJZJPIDiGbTHYo2WFkh5MdQXYk2VFkR5MdQ3Ys2XFkU8iOJzuBbCrZiWQnkZ1MdgrZqWSnkU0jO51sOtkMsplks8hmk51BNofsTLK5ZPPI5pMtIDuLbCHZIrLFZGeTLSE7h+xcsqVky8jOI1tOdj7ZCrILyC4ku4jsYrJLyC4lu4zscrIryK4ku4rsarJryK4lu47serIbyG4ku4nsZrJbyG4lu43sdrI7yO4ku4vsbrJ7yO4lu4/sfrIHyB4ke4jsYbJHyB4le4zscbInyJ4ke4rsabJnyJ4le47sebIXyF4ke4nsZbJXyF4le43sdbI3yN4ke4vsbbJ3yN4le4/sfbIPyD4k+4jsY7JPyD4l+4zsc7IvyL4k+4rsa7JvyL4l+47se7IfyH4k+4nsZ7JfyH4l+63ffznNR8PAymNg/q9T5NEM6i/lrF33/u/XvcL3pfxO//6D7E+yv8j+JvunH5Ogx5M1JGtE1pisCVlTsnXImpE17//fDZH1lZxroPztlD8vo8e1IGtJ1opsXbL1yFqTrU/WhqwtWTuy9mQdyDqSdSLrTNaFrCtZN7LuZD3IepL1IuvdP/9ihRso/GLNPG0tNG0tNW2tNG3ratrW07S11rStr2lro2lrq2lrp2lrr2nroGnrqGnrpGnrrGnromnrqmnrpmnrrmnroWnrqWnrpWnrnW/jJGsT0CdZz/z5BvTYcrIKsg3J+pD1JaskqyLrR9afbADZRmQbk21C5pC5ZEGyEFmYLEIWJYuRxckSZJuSbUa2OdkWZFuSbUU20JuAG2iIlGvaKjRtG2ra+mja+mraKjVtVZq2fpq2/pq2AZq2jTRtG2vaNtG0OZo2V9MW1LSFNG1hTVtE0xbVtMU0bXFNW0LTtqmmbTNN2+aati00bVtq2rbStA2sx2TYmh67Ddm2ZNuRbU+2A9mOZDuR7Uy2C9muZLuR7U62B9meZHuR7U22D9m+ZIPI9iMbTDaEbH+yoWTDyA4gG042gmwk2YHeybC1hsg2mrZtNW3badq217TtoGnbUdO2k6ZtZ03bLpq2XTVtu2nadte07aFp21PTtpembW9N2z6atn01bYM0bftp2gZr2oZo2vbXtA3VtA3TtB2gaRuuaRuhaRupaTuwHpNhFD02SZYiS5NlyLJkObLRZGPIxpIdRDaObDzZwWQTyCaSTSI7hGwy2aFkh5EdTnYE2ZFkR5EdTXYM2bFkx5FNITveOxlGaYgkNW0pTVta05bRtGU1bTlN22hN2xhN21hN20GatnGatvGatoM1bRM0bRM1bZM0bYdo2iZr2g7VtB2maTtc03aEpu1ITdtRmrajNW3HaNqO1bQdp2mbomk7vh6T4QR67FSyE8lOIjuZ7BSyU8lOI5tGdjrZdLIZZDPJZpHNJjuDbA7ZmWRzyeaRzSdbQHYW2UKyRWSLyc4mW0J2Dtm5ZEu9k+EEDZGpmrYTNW0nadpO1rSdomk7VdN2mqZtmqbtdE3bdE3bDE3bTE3bLE3bbE3bGZq2OZq2MzVtczVt8zRt8zVtCzRtZ2naFmraFmnaFmvazta0LdG0naNpO1fTtrQek2EZPfY8suVk55OtILuA7EKyi8guJruE7FKyy8guJ7uC7Eqyq8iuJruG7Fqy68iuJ7uB7Eaym8huJruF7Fay28huJ7uD7E7vZFimIXKepm25pu18TdsKTdsFmrYLNW0Xadou1rRdomm7VNN2mabtck3bFZq2KzVtV2narta0XaNpu1bTdp2m7XpN2w2aths1bTdp2m7WtN2iabtV03abpu12TdsdmrY76zEZ7qLH3k12D9m9ZPeR3U/2ANmDZA+RPUz2CNmjZI+RPU72BNmTZE+RPU32DNmzZM+RPU/2AtmLZC+RvUz2CtmrZK+RvU72hncy3KUhcrem7R5N272atvs0bfdr2h7QtD2oaXtI0/awpu0RTdujmrbHNG2Pa9qe0LQ9qWl7StP2tKbtGU3bs5q25zRtz2vaXtC0vahpe0nT9rKm7RVN26uattc0ba9r2t6ox2R4kx77FtnbZO+QvUv2Htn7ZB+QfUj2EdnHZJ+QfUr2GdnnZF+QfUn2FdnXZN+QfUv2Hdn3ZD+Q/Uj2E9nPZL+Q/Ur2G9nv3snwpobIW5q2tzVt72ja3tW0vadpe1/T9oGm7UNN20eato81bZ9o2j7VtH2maftc0/aFpu1LTdtXmravNW3faNq+1bR9p2n7XtP2g6btR03bT5q2nzVtv2jaftW0/aZp+70ek+EPeuyfZH+R/U32DyfpAHoMWUOyRmSNyZqQNSVbh6wZWXOyMrIWZC3JWpGtS7YeWWuy9cnakLUla0fWnqwDWUeyTmSdB3hA/6Eh8qem7S9N29+atn80bUzM29ZA09ZQ09ZI09ZY09ZE09ZU07aOpq2Zpq25pq1M09ZC09ZS09ZK07aupm09TVtrTdv6mrY2mra2mrZ2mrb2mrYOmraOmrZOmrbOA+o+GbrQY7uSdSPrTtaDrCdZL7LeZBuQlZNVkG1I1oesL1klWRVZP7L+ZAPINiLbmGwTMofMJQuShcjCZBGyKFmMLO6dDF00RLpq2rpp2rpr2npo2npq2npp2npr2jbQtJVr2io0bRtq2vpo2vpq2io1bVWatn6atv6atgGato00bRtr2jbRtDmaNlfTFtS0hTRtYU1bRNMW1bTFNG1xZTLwN3uq7ygoHIWJMTD/1ynucIG+RL/VvhKIs4GCMzEgH/B2awNeAycy4KIBzfWgy4M9V/Vb9C+tB2UC0BjLP3Rld+BXsQzAjcs3m+B8AcfCVVdc5tsrEPDNz2JjuhkgpqFYIpGkF/lXvik5xP++oClJ7Pw5v9bfCofCudPov/PC8zanx21BtiXZVgP+a2drn49NbcdAzBgE/5XxQq9RiFVt4+kUd1izgG8+QGgBLxwNwYDVxafYSTdwgMyCMTC/YPBk6RBYOaEkB7JB4H874dA4N7UEZ6NAiSdwsZMOSb5KiDyaM3By/vvd2TZwbgjk3N8SzsDJyJccSsLZKe5wNwLGr3UjOxbdjQN24NzEEpyOJThdYK6zD/T6s6JJIHBhE5y/S8nXLU3wcQyCxxtdjfPVouk98WtlCIjxWsf8GM4QiGEYiPF6C2I4UyCGESDGGy2I4SyBGEaBGG+2IIazBWIYA2K81YIYniEQwzgQ4+0WxHCOQAwTQIx3WhDDMwViuCkQ490WxHCuQAw3A2K814IYzhOI4eZAjPdbEMP5AjHcAojxQQtiuEAghlsCMT5sQQzPEojhVkCMj1oQw4UCMRwIxPi4BTFcJBDDrYEYn7QghosFYrgNEOPTFsTwbIEYbgvE+KwFMVwiEMPtgBiftyCG5wjEcHsgxhctiOG5AjHcAYjxZQtiuFQghjsCMb5qQQyXCcRwJyDG1y2I4XkCMdwZiPFNC2K4XCCGuwAxvm1BDM8XiOGuQIzvWhDDFQIx3A2I8X0LYniBQAx3B2L80IIYXigQwz2AGD+2IIYXCcRwTyDGTy2I4cUCMdwLiPFzC2J4iUAM9wZi/NKCGF4qEMN9gBi/BsewcKDfJ7lvwA6cgyzBuZ8lOAdbgnOIJTj3twTnUEtwDrME5wGW4BxuCc4RluAcaQnOAy3BOcoSnElLcKYswZm2BGfGEpxZS3DmLME52hKcYyzBOdYSnAdZgnOcJTjHW4LzYEtwTrAE50RLcE6yBOchluCcDMbpvdZb7PXZ8+gacr+eOH8ryF+znvg4HmpBHPsD43iBUBwPsyCOA4BxvFAojodbEMeNgHG8SCiOR1gQx42BcbxYKI5HWhDHTYBxvEQojkdZEEcHGMdLheJ4tAVxdIFxvEwojsdYEMcgMI6XC8XxWAviGALG8QqhOB5nQRzDwDheKRTHKRbEMQKM41VCcTzegjhGgXG8WiiOJ1gQxxgwjtcIxXGqBXGMA+N4rVAcT7QgjglgHK8TiuNJFsRxU2AcrxeK48kWxHEzYBxvEIrjKRbEcXNgHG8UiuOpFsRxC2AcbxKK42kWxHFLYBxvForjNAviuBUwjrcIxfF0C+I4EBjHW4XiON2COG4NjONtQnGcYUEctwHG8XahOM60II7bAuN4h1AcZ1kQx+2AcbxTKI6zLYjj9sA43iUUxzMsiOMOwDjeLRTHORbEcUdgHO8RiuOZFsRxJ2Ac7xWK41wL4rgzMI73CcVxngVx3AUYx/uF4jjfgjjuCozjA0JxXGBBHHcDxvFBoTieZUEcdwfG8SGhOC60II57AOP4sFAcF1kQxz2BcXxEKI6LLYjjXsA4PioUx7MtiOPewDg+JhTHJRbEcR9gHB8XiuM5FsRxX2AcnxCK47kWxHEQMI5PCsVxqQVx3A8Yx6eE4rjMgjgOBsbxaaE4nmdBHIcA4/iMUByXWxDH/YFxfFYojudbEMehwDg+JxTHFRbEcRgwjs8LxfECC+J4ADCOLwjF8UIL4jgcGMcXheJ4kQVxHAGM40tCcbzYgjiOBMbxZaE4XmJBHA8ExvEVoTheakEcRwHj+KpQHC+zII5JYBxfE4rj5RbEMQWM4+tCcbzCgjimgXF8QyiOV1oQxwwwjm8KxfEqC+KYBcbxLaE4Xm1BHHPAOL4tFMdrLIjjaGAc3xGK47UWxHEMMI7vCsXxOgviOBYYx/eE4ni9BXE8CBjH94XieIMFcRwHjOMHQnG80YI4jgfG8UOhON5kQRwPBsbxI6E43mxBHCcA4/ixUBxvsSCOE4Fx/EQojrdaEMdJwDh+KhTH2yyI4yHAOH4mFMfbLYjjZGAcPxeK4x0WxPFQYBy/EIrjnRbE8TBgHL8UiuNdFsTxcGAcvxKK490WxPEIYBy/ForjPRbE8UhgHL8RiuO9FsTxKGAcvxWK430WxPFoYBy/E4rj/eA4Fo6GYJwPAMemqpEdnB8Ecr7UEs4PATk/3sQOzg8DOX/b1Ox1MbBOINB8HZy/dcnXkc3w6+IjAZncaQzG+ShgbLK5/44AcFyCG+F8xTcxO6dbtQ8E2rfH+etCvr7qgM/pxwJ25PTjwJxuBRyX7hsDc9o1O6ev7B4I3NQd5y9H+vVKAf36RAAbxwbgODLvq4h3IzDvJ4Fz5ErgOH+zicwag86bpwJ24HzaEpzPWILzWUtwPmcJzuctwfmCJThftATnS5bgfNkSnK9YgvNVS3C+ZgnO1y3B+YYlON+0BOdbluB82xKc71iC811LcL5nCc73hXCir/F/EMDV2Bdaci/nQyDnTcGc0Xm4MeFb0Qgfw4+AMVxhSd58DOT8ZVM7OH8C5PxqE7PnyjOE7/Om+Bh+Cozh5xbcRx3bDHsf9TCB+6ifBWRzEcH78Gb46/Ofg8ca5Uu9L+sUeUiMB3M9QiAPvwiYPZ/5PuV9HbD3kD8XuIf8ZcDs/GHeX3TAz+evwGON8qXek3aKPCTGg7l+KZCHXwfMns98T/Uk4Ps/+T7yZQL3z78JmJ0/zPtygfvn34LHGuULff8cPR7M9QqBPPwOnIeFA43ze0tw/mAJzh8twfmTJTh/tgTnL5bg/NUSnL9ZgvN3S3D+YQnOPy3B+ZclOP+2BOc/luBkhzbgbGAJzoaW4GxkCc7GluBsYgnOppbgXMcSnM0swdncEpxlluBsYQnOlpbgbGUJznUtwbmeJThbW4JzfUtwtrEEZ1tLcLazBGd7S3B2sARnR0twdrIEZ2dLcHaxBGdXS3B2swRnd0tw9rAEZ09LcPayBGdvS3BuYAnOcktwVliCc0NLcPaxBGdfS3BWWoKzyhKc/SzB2d8SnAMswbmRJTg3tgTnJpbgdCzB6VqCM2gJzpAlOMOW4IxYgjNqCc6YJTjjluBMWIJzUyGcDT04i/2cQwMg583+BzlvbgnnRkDOW5SIs1Pc4W7ZABe/zQfYwXkrIOdNB9ix1g60ZE/Y2hKc21iCc1tLcG5nCc7tLcG5gyU4d7QE506W4NzZEpy7WIJzV0tw7mYJzt0twbmHJTj3tATnXpbg3NsSnPtYgnNfS3AOsgTnfpbgHGwJziGW4NzfEpxDLcE5zBKcB1iCc7glOEdYgnOkJTgPtATnKEtwJi3BmbIEZ9oSnBlLcGYtwZmzBOdoS3COsQTnWEtwHmQJznGW4BxvCc6DLcE5wRKcEy3BOckSnIdYgnOyJTgPtQTnYZbgPNwSnEdYgvNIS3AeZQnOoy3BeYwlOI+1BOdxluCcYgnO4y3BeYIlOKdagvNES3CeZAnOky3BeYolOE+1BOdpluCcZgnO0y3BOd0SnDMswTnTEpyzLME52xKcZ1iCc44lOM+0BOdcS3DOswTnfEtwLhDC2RCM8ywFZ7GfXVynvR2cFwI5X9RKhnMvMOdFNfPRdYo4bm9Vz/jFao2f26ltvcciVpuvzm3XYFzjel9d2q5RjsR1vrquma9ENLeqr25t1zh3Ha+v7m2LmAfBmr56tC1qTjmqr55ti5yf4ZW+erUteq4HC756F+8rlP3PmbsBxFeOvbnlIF/kza0A+CqsjRt6fWXW2Jf76Kq43DX19ZiOo7Nmvh7Xx8tZE19P1BL7RK7+vp6sfRzj9fX1lF9OxOrn62nf/Arn6uPrmdXlarjuvp5dfd5H6urrubrMIaduvp6v23x06uLrhbrO7djqfb1Y93UivTpfL9VnzYn5+3q5futX0M/XKzV9hYpYC92AcvTK/y34doo73MUNcDj7ANfsvsA1uxK4ZlcB1+x+wDW7P3DNHgBcszcCrtkbA9fsTYBrtgNcs13gmh0Ertkh4JodBq7ZEeCaHa2vfvWpTWPA2jQOrE0TwNp0U2BtuhmwNt0cWJtuAaxNtyy2PlJq062Kr7Wqa9OBxfuqrk23Btam2wBr020Bvgq16XZt7bhudzZQ220P1HY7ALXdjkBttxNQ2+0M1Ha7ALXdrkBttxtQ2+0O1HZ7ALXdnkBttxdQ2+0N1Hb7ALXdvkBtNwio7fYDarvBQG03BKjt9gdqu6FAbTcMqO0OAGq74UBtNwKo7UYCtd2BQG03CqjtkkBtlwJqu7Ql2m4JUNtlgNouC9R2OaC2Gw3UdmOA2m4sUNsdBNR244DabjxQ2x0M1HYTgNpuIlDbTQJqu0OA2m4yUNsdCtR2hwG13eFAbXcEUNsdCdR2RwG13dFAbXcMUNsdC9R2xwG13RSgtjseqO1OAGq7qUBtdyJQ251kibY7B6jtTgZqu1OA2u5UoLY7DajtpgG13elAbTcdqO1mALXdTKC2mwXUdrOB2u4MoLabA9R2ZwK13VygtpsH1HbzgdpuAVDbnQXUdguB2m4RUNstBmq7s4HabglQ250D1HbnArXdUqC2WwbUducBtd1yoLY73xJtdy5Q260AarsLgNruQqC2uwio7S4GartLgNruUqC2uwyo7S4HarsrgNruSqC2uwqo7a4GartrgNruWqC2uw6o7a4HarsbgNruRqC2uwmo7W4GartbgNruVqC2uw2o7W4Hars7gNruTqC2uwuo7e4Gart7gNruXku03VKgtrsPqO3uB2q7B4Da7kGgtnsIqO0eBmq7R4Da7lWgtnsNqO1eB2q7N4Da7k2gtnsLqO3eBmq7d4Da7l2gtnsPqO3eB2q7D4Da7kOgtvsIqO0+Bmq7T4Da7lOgtvsMqO0+B2q7L4Da7kugtvsKqO2+Bmq7byzRdsuA2u5boLb7Dqjtvgdqux+A2u5HoLb7CajtfgZqu1+A2u5XoLb7Dajtfgdquz+A2u5PoLb7C6jt/gZqu3+A2i7QDqftGtTXl4+2a1h/X7Vqu0Zr4qsWbde4HU7bNVlDXzpt13TNfa2i7dYpxpdH2zUrzlcNbde8WF+Ktitrh9BQ//lq0Q6jx9hXy3Y4bdcK4Kug7dZtZ4e2Ow+o7dZrh9N2rdvhtN367XDark07nLZr2w6n7dq1w2m79u1w2q5DO5y269gOp+06tcNpu87tcNquSzuctuvaDqfturXDabvu7XDarkc7nLbrCdR2vYDarjdQ220A1HblQG1XAdR2GwK1XR+gtusL1HaVQG1XBdR2/YDarj9Q2w0AaruNLNF2y4HabmOgttsEqO0coLZzgdouCNR2IaC2CwO1XQSo7aJAbRcDars4UNslgNpuU6C22wyo7TYHarstgNpuS6C22wqo7QYCtd3WQG23DVDbbQvUdtsBtd32QG23A1Db7QjUdjsBtd3OQG23C1Db7QrUdrtZou3OB2q73YHabg+gttsTqO32Amq7vYHabh+gttsXqO0GAbXdfkBtNxio7YYAtd3+QG03FKjthgG13QFAbTccqO1GALXdSKC2OxCo7UYBtV0SqO1SQG2XBmq7DFDbZYHaLgfUdqOB2m4MUNuNBWq7g4Dabpwl2m4FUNuNB2q7g4HabgJQ200EartJQG13CFDbTQZqu0OB2u4woLY7HKjtjgBquyOB2u4ooLY7GqjtjgFqu2OB2u44oLabAtR2xwO13QlAbTcVqO1OBGq7k4Da7mSgtjsFqO1OBWq704DabhpQ250O1HbTgdpuhiXa7gKgtpsJ1HazgNpuNlDbnQHUdnOA2u5MoLabC9R284Dabj5Q2y0AaruzgNpuIVDbLQJqu8VAbXc2UNstAWq7c4Da7lygtlsK1HbLgNruPKC2Ww7UducDtd0KoLa7AKjtLgRqu4uA2u5ioLa7BKjtLgVqu8ss0XYXArXd5UBtdwVQ210J1HZXAbXd1UBtdw1Q210L1HbXAbXd9UBtdwNQ290I1HY3AbXdzUBtdwtQ290K1Ha3AbXd7UBtdwdQ290J1HZ3AbXd3UBtdw9Q290L1Hb3AbXd/UBt9wBQ2z0I1HYPAbXdw0Bt9whQ2z1qiba7CKjtHgNqu8eB2u4JoLZ7EqjtngJqu6eB2u4ZoLZ7FqjtngNqu+eB2u4FoLZ7EajtXgJqu5eB2u4VoLZ7FajtXgNqu9eB2u4NoLZ7E6jt3gJqu7eB2u4doLZ7F6jt3gNqu/eB2u4DoLb7EKjtPgJqu4+B2u4TS7TdxUBt9ylQ230G1HafA7XdF0Bt9yVQ230F1HZfA7XdN0Bt9y1Q230H1HbfA7XdD0Bt9yNQ2/0E1HY/A7XdL0Bt9ytQ2/0G1Ha/A7XdH0Bt9ydQ2/0F1HZ/A7XdP0BtF2iP03YNivWlaLuG7REa6j9fjdpj9Bj7atwep+2aAHwVtF3T9jLarkH+L8i3e0kDVPyyOR2+YuP4XVNysk4g0AjM+1IY71yO8aH4pprJ5E1jcPwuw8Uvi4xfcCOcrzYby4xFQ/BYXN4Ax/n87nZwvgLIeXFnO+rwKxvU8OU6RRxXdcbp2Ou74nTsDV3XYFxr0bE3dl2jHNHq2JvWzJdWx97cdY1zdxUde0vXIuaBR8fe2rWoOVVDx97Wtcj5qejY27sWPderdewdXRH71n++7uyK2QPZ111dUfup494N8FVYG+/pirtel+qGu16X7oa7Xpfphrtel+2Gu16X64a7Xje6G+563ZhuuOt1Y7vhrtcd1G21eV/n63XjutVhDtXxet34bnWaj3W6Xndw3XzV6XrdhLr6qsP1uol197Xa63WT6uNrNdfrDumGu3cRUI5e+b8F305xh3sV8B7LvcA1+76uuDX7/q64NfuBrrg1+8GuuDX7oa64Nfvhrrg1+5GuuDX70a64Nfuxrrg1+/GuuDX7ia64NfvJrrg1+6muuDX76a64NfuZrrg1+9n66lef2vQ5YG36PLA2fQFYm74IrE1fAtamLwNr01eAtemrwNr0NWBt+jqwNn0DWJu+CaxN3wLWpm93teO63dVAbfcOUNu9C9R27wG13ftAbfcBUNt9CNR2HwG13cdAbfcJUNt9CtR2nwG13edAbfcFUNt9CdR2XwG13ddAbfcNUNt9C9R23wG13fdAbfcDUNv9CNR2PwG13c9AbfcLUNv9CtR2vwG13e9AbfcHUNv9CdR2f1mi7a4Baru/gdruH6C2CwDvtTQA3mtpCLzX0gh4r6Ux8F5LE+C9lqbAey3rAO+1NAPea2kOvNdSBrzX0gJ4r6Ul8F5LK+C9lnXr58tX261XX18+2q51/X3Vqu3WXxNftWi7Nt1w2q7tGvrSabt2a+5rFW3XvhhfHm3XoThfNbRdx2J9KdquUzeEhvrPV+duGD3Gvrp0w2m7rgBfBW3XrZsd2u5aoLbr3g2n7XoA30fTE6jtegG1XW+gttsAqO3KgdquAqjtNgRquz5AbdcXqO0qgdquCqjt+gG1XX+gthsA1HYbAbXdxkBttwlQ2zlAbecCtV0QqO1CQG0XBmq7CFDbRYHaLgbUdnGgtksAtd2mQG23mSXa7jqgttscqO22AGq7LYHabiugthsI1HZbA7XdNkBtty1Q220H1HbbA7XdDkBttyNQ2+0E1HY7A7XdLkBttytQ2+0G1Ha7A7XdHkBttydQ2+0F1HZ7A7XdPkBtty9Q2w0Carv9gNpuMFDbDQFqu/2B2m4oUNsNs0TbXQ/UdgcAtd1woLYbAdR2I4Ha7kCgthsF1HZJoLabDNR2hwK13WFAbXc4UNsdAdR2RwK13VFAbXc0UNsdA9R2xwK13XFAbTcFqO2OB2q7E4DabipQ250I1HYnAbXdyUBtdwpQ250K1HanAbXdNKC2Ox2o7aZbou1uAGq7GUBtNxOo7WYBtd1soLY7A6jt5gC13ZlAbTcXqO3mAbXdfKC2WwDUdmcBtd1CoLZbBNR2i4Ha7mygtlsC1HbnALXduUBttxSo7ZYBtd15QG23HKjtzgdquxVAbXcBUNtdCNR2FwG13cVAbXcJUNtdaom2uxGo7S4DarvLgdruCqC2uxKo7a4CarurgdruGqC2uxao7a4DarvrgdruBqC2uxGo7W4CarubgdruFqC2uxWo7W4DarvbgdruDqC2uxOo7e4Caru7gdruHqC2uxeo7e4Darv7gdruAaC2exCo7R4CaruHgdruEUu03U1AbfcoUNs9BtR2jwO13RNAbfckUNs9BdR2TwO13TNAbfcsUNs9B9R2zwO13QtAbfciUNu9BNR2LwO13StAbfcqUNu9BtR2rwO13RtAbfcmUNu9BdR2bwO13TtAbfcuUNu9B9R27wO13QdAbfchUNt9BNR2H1ui7W4GartPgNruU6C2+wyo7T4HarsvgNruS6C2+wqo7b4GartvgNruW6C2+w6o7b4HarsfgNruR6C2+wmo7X4GartfgNruV6C2+w2o7X4Hars/gNruT6C2+wuo7f4Gart/gNou0B2n7Rp0R2io/3w17I7RY+yrUXectmsM8FXQdk2626HtbgFqu6bdcdpune44bdesO07bNe+O03Zl3XHarkV3nLZr2R2n7Vp1x2m7dbvjtN163XHarnV3nLZbvztO27XpjtN2bbvjtF277jht1747Ttt16I7Tdh2747Rdp+44bde5O07bdemO03Zdu+O0XbfuOG3XvTtO2/XojtN2PYHarhdQ2/UGarsNgNquHKjtKizRdrcCtd2GQG3XB6jt+gK1XSVQ21UBtV0/oLbrD9R2A4DabiOgttsYqO02AWo7B6jtXKC2CwK1XQio7cJAbRcBarsoUNvFgNouDtR2CaC22xSo7TYDarvNgdpuC6C22xKo7bYCaruBQG23NVDbbQPUdttaou1uA2q77YDabnugttsBqO12BGq7nYDabmegttsFqO12BWq73YDabnegttsDqO32BGq7vYDabm+gttsHqO32BWq7QUBttx9Q2w0GarshQG23P1DbDQVqu2FAbXcAUNsNB2q7EUBtNxKo7Q4EartRQG2XBGq7lCXa7nagtksDtV0GqO2yQG2XA2q70UBtNwao7cYCtd1BQG03DqjtxgO13cFAbTcBqO0mArXdJKC2OwSo7SYDtd2hQG13GFDbHQ7UdkcAtd2RQG13FFDbHQ3UdscAtd2xQG13HFDbTQFqu+OB2u4EoLabCtR2J1qi7e4AaruTgNruZKC2OwWo7U4FarvTgNpuGlDbnQ7UdtOB2m4GUNvNBGq7WUBt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",
      "debug_symbols": "7L3NjjW9bqV5L2fsQVASKdK30oOCu9tdMGDYhSpXT4y6995BiVzKzLOVsfeOt4AGvsnJJ7/z5lrxIzIiJEr6z7/93//8f/7P//pf/uXf/p9//x9/+8f/4z//9n/+93/513/9l//6X/713/+vf/qPf/n3f3v81//823H+DxX92z/SPzx+2vhZj/mT5s8yf9b5s82fPH/K/Nnnz6lXp16bem3qtanXpl6bem3qtanXpl6bem3q8dTjqcdTj6ceTz2eejz1eOrx1OOpJ1NPpp5MPZl6MvVk6snUk6knU0+mXp96fer1qdenXp96fer1qdenXp96ferp1NOpp1NPp55OPZ16OvV06unU06lnD71y/qT5s8yfdf5s8yfPnw89Pn8+9Pr5U+dP85/lOOZPmj/L/FnnzzZ/8vwp82efP8/jKyfYBDoCKKAE1IAWwAES0ANCmUK5hHIJ5RLKJZRLKJdQLqFcQrmEcgnlGso1lGso11CuoVxD2WOHT+gBGmATPH4cKKAE1IAWwAGh3EK5hXILZQ5lDmUOZQ5lDmUOZQ5lDmUOZQ5lCWUJZQllCWUJZQllCWUJZQllCeUeyj2Ueyj3UO6h3EO5h3IP5R7KPZQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lC2ULZQtlC2ULZQtlM+4Iz2hB2iADahn7A2ggBJQA1oAB0hAD9CAUD5jsJQTKKAE1IAWwAES0AM0wCaUUC6hXEK5hPIZg4VP4AAJ6AEaYBPOGBxAASWgBoRyDeUayjWUzxgsdoJNOGNwAAWUgBrQAjhAAnpAKLdQ5lDmUOZQ5lDmUOZQ5lDmUOZQ5lCWUJZQllCWUJZQllCWUJZQllCWUO6h3EO5h3IP5R7KPZR7KPdQ7qHcQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lD2ULZQtlC2ULZQtlC2ULZQtlC2aZyO44ACigBNaAFcIAE9AANCGUKZQplCmUKZQplCmUKZQplCmUK5RLKJZRLKJdQLqFcQrmEcgnlEsollGso11CuoVxDuYZyDeUayjWUIwZbxGCLGGxnDFY6oQTUgBbAARLQAzTAJpwxOCCUOZQ5lDmUOZQ5lDmUOZQ5lCWUJZQllCWUJZQllCWUJZQllCWUeyj3UO6h3EO5h3IP5R7KPZR7KPdQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lC2ULZQtlC2ULZQtlC2ULZQtlC2qczHEUABJaAGtAAOkIAeoAGhTKFMoUyhTKFMoUyhTKFMoUyhTKFcQrmEcgnlEsollEsol1AuoVxCuYRyDeUayjWUayjXUK6hXEO5hnIN5RrKLZQjBjlikCMGOWKQIwY5YpAjBjlikCMGOWKQIwY5YpAjBjlikCMGOWKQIwY5YpAjBjlikCMGOWKQIwY5YpAjBjlikCMG2WOQT7AJHoMOFFACakAL4AAJ6AGh3ENZQ1lD+YzBdpxQA1oAB0hAD9AAm3DG4AAKCGULZQtlC+UzBtt5Ec4YHKABNkDOGBxAASWgBrQADpCAHqABoXzGYGsnUEAJOJXlhBbAARLQAzTAJpwxOIACSkAol1AuoVxC+YzBZidogE04Y3AABZSAGtACOEACQrmGcg3lFspnDPJxQgmoAS2AAySgB2iATThjcEAocyhzKHMocyhzKHMocyhzKEsoSyhLKEsoSyhLKEsoSyhLKEso91DuodxDuYdyD+Ueyj2Ueyj3UO6hrKGsoayhrKGsoayhrKGsoayhrKFsoWyhbKFsoWyhbKFsoWyhbKFsU7kfRwAFlIAa0AI4QAJ6gAaEMoUyhTKFMoUyhTKFMoUyhTKFMoVyCeUSyiWUSyiXUC6hXEK5hHIJ5RLKNZRrKNdQrqFcQ/mMQS4nSEAP0ACbcMbgAAooATWgBYRyC+UWyi2UWyhzKHMocyhzKHMocyhzKHMocyhzKEsoSyhLKEsoSyhLKEsoSyhLKEso91DuodxDuYdyD+Ueyj2Ueyj3UO6hrKGsoayhrKGsoayhrKGsoayhrKFsoWyhbKFsoWyhbKFsoWyhbKFsU1mPI4ACSkANaAEcIAE9QANCmUKZQplCmUKZQplCmUKZQplCmUK5hHIJ5RLKJZRLKJdQLqFcQrmEcgnlGso1lGso11CuoRwxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMagRgxoxqBGDGjGoEYMaMWgeg3wCBZSAGtACOEACeoAG2AQKZQplCmUKZY9BOYEDJKAHaIBN8Bh0oIASUANCuYRyCeUSyiWUSyjXUK6hXEO5hnIN5RrKNZRrKNdQrqHcQrmFcgvlFsotlFsot1BuodxCuYUyhzKHMocyhzKHMocyhzKHMocyh7KEsoSyhLKEsoSyhLKEsoSyhLKEcg/lHso9lM8YlOOEFsABEtADNMAmnDE4gAJKQChrKJ8xKPUECegBGmATzhgcQAEloAa0gFC2ULZQtlC2qUzHcSRRUkmqSS2JkySpJ2lSelB6UHpQelB6UHpQelB6UHpQelB6lPQo6VHSo6RHSY+SHiU9SnqU9CjpUdOjpkdNj5oeNT1qetT0qOlR06OmR0uPlh4tPVp6tPRo6dHSo6VHS4+WHpwenB6cHpwenB6cHpwenB6cHpwekh6SHpIekh6SHpIekh6SHpIekh49PXp69PTo6dHTo6dHT4+eHj09enpoemh6aHpoemh6aHpoemh6aHpoelh6WHpYelh6WHpYelh6WHpYemScU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnFPGOWWcU8Y5ZZxTxjllnJeM85JxXjLOS8Z5yTgvGecl47xknJeM85JxXjLOS8Z5yTgvGecl47xknJeM85JxXjLOS8Z5yTgvGecl47xknJeM85JxXjLOS8Z5yTgvGecl47xknJeM85JxXjLOS8Z5yTgvGecl47xknJeM85JxXjLOS8Z5yTgvGecl47xknJeMc68QEjnJ43wQJZWkmtSSOEmSepImpYekh6SHpIfHuTq1JE6SpJ6kSRbkcT6IkkpSevT06OnR06OnR0+Pnh6aHpoemh6aHpoemh6aHpoemh6aHpYelh6WHpYelh6WHpYelh6WHhYeXlQ0iZJKUk1qSZwkST1Jk9KD0oPSg9KD0oPSg9KD0oPSg9KD0qOkR0mPkh4lPUp6lPQo6VHSo6RHSY+aHjU9anrU9KjpUdOjpkdNj5oeNT1aerT0aOnR0qOlR0uPlh4tPVp6tPTg9OD04PTg9PA4NydOkqSepEkW5HE+iJJKUk1KD0kPSQ9JD0kPSY+eHj09enr09Ojp0dOjp0dPj54ePT00PTQ9ND00PTQ9ND00PTQ9ND00PSw9LD0sPSw9LD0sPSw9LD0sPSw8vHBpEiWVpJrUkjhJknqSJqUHpQelB6UHpQelB6UHpQelB6UHpUdJj5IeJT1KepT0KOlR0qOkR0mPM877+UT0sqZJlHQWOotTTWpJnCRJPUmTLOiM80mUlB4tPVp6tPRo6dHSo6VHSw9OD04PTg9OD04PTg9OD04PTg9OD0kPSQ9JD0kPSQ9JD0kPSQ9JD0mPnh49PXp69PTo6dHTo6dHT4+eHj09ND00PTQ9ND00PTQ9ND00PTQ9ND0sPSw9LD0sPSw9LD0sPSw9LD0sPLw4ahIllaSa1JI4SZJ6kialB6UHpQelB6UHpQelB6UHpQelB6VHSY+SHiU9SnqU9CjpUdKjpEdJj5IeNT1qemScc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8Y5Z5xzxjlnnHPGOWecc8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGuWScS8a5ZJxLxrlknEvGec847xnnPeO8Z5z3jPOecd4zznvGec847xnnPeO8Z5z3jPOecd4zznvGec847xnnPeO8Z5z3jPOecd4zznvGec849+qvbk6S1JM0yYI8zgdRUkmqSS0pPWp61PSo6XHGuR4nnXE+iZJKUk1qSZwkST1Jk9KD04PTg9OD04PTg9OD04PTg9OD00PSQ9JD0kPSQ9JD0kPSQ9JD0kPSo6dHT4+eHj09enr09Ojp0dOjp0dPD00PTQ9ND00PTQ9ND00PTQ9ND00PSw9LD0sPSw9LD0sPSw9LD0sPCw8vJFNyoqSSVJNaEidJUk/SJAui9KD0oPSg9KD0oPSg9KD0oPSg9CjpUdKjpEdJj5IeJT1KepT0KOlR0qOmR02Pmh41PWp61PSo6VHTo6ZHTY+WHi09Wnq09Gjp0dKjpUdLj5YeLT04PTg8vPrHJ1z7BSpOp0hz0iQL8osxiJJKUk1qSZwkSelR06OmR0uPlh4tPVp6tPRo6dHSo6VHS4+WHpwenB6cHpwenB6cHpwenB6cHpwekh6SHpIekh6SHpIekh6SHpIekh49PXp69PTo6dHTo6dHT4+eHj09enp40vNp+p70BpWkmtSSOEmSetLpIU6nx/nI81qhSZRUkmpSS+IkSepJmjQ9ihcNTaKkkvTwsMOpJXGSJPUkTXp4WPGFCo4kSipJNaklcZIk9SRNSo+Symeqs+okSeffNidNsqAzfidR0qkiTjWpJXGSJPUkTbKgM35tLM9ASSXp9PAr7isLHH4BfW2Bw8/JVxeY2IEKtERfZWBiPZEdG5ATfU2AQx0ZKMAOVKAl+voAEwlYgBUItw63DrcOtw63DjeFm8JN4aZwU7gp3BRuCjeFm8LN4GZwM7gZ3AxuBjeDm8HN4Gbp5mU9gQQswApsQAYKsAMVCDeCG8GN4EZwI7gR3AhuBDeCG8GtwK3ArcCtwK3ArcDN1/Kgw5GBAjyPYa5ZokBL9HU9JhKwACuwARkoQLg1uHkU0pk/xqo5EwlYgBXYgAwUYAcqEG6+/gdVRwIWYAU2IAPdrTt2oAIt0WN+IgELsAIbkIFw63DrcOtw8+j2ZTjGEjwTG5CBAuxABVqiR/dEAsLN4GZwM7gZ3AxuBjdLNy/mCSRgAVZgAzJQgB2oQLgR3AhuBDeCG8GN4EZwI7gR3AhuBW4FbgVuBW4FbgVuBW4FbgVuBW4VbhVuFW4VbhVuFW4VbhVuFW4Vbg1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDDeGG8ON4cZwY7gx3BhuDDeGm8BN4CZwE7gJ3ARuAjeBm8BN4Nbh1uHW4dbh1uHW4dbh1uHW4dbhpnBTuCGXFOSSglxSkEsKcklBLinIJQW5pCCXFOSSglwy1h0ic2xABgqwAzVwLD00VqoaCWRgAVZgAzJQgB2oQEskuBHcCG4EN4IbwY3gRnAjuBHcCtwK3ArcCtwK3ArcCtwK3ArcCtwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BrcGG4MN4Ybw43hxnBjuDHcGG4MN4GbwE3gJnATuAncBG4CN4GbwK3DrcOtw63DrcOtw63DrcOtw63DTeGmcFO4KdwUbgo3hZvCTeGmcDO4GdwMbgY3g5vBzeBmcDO4Wbo15JKGXNKQS7wYic6VwYpXIwUy8HQr1bEDFWiJY3nBgQQ83Yq7jUUGBzaguzVHAXagu3VHSxxLDg50N3MswNOtHo4NyMDTrfppei6ZqMDTrfoxeC6ZSMACrMAGdF0/Tc8PVRxdwQ/d88PECmxAP14/Ic8PEztQgZbo+eFcXqV4QVJgAZ5uzU/T88NEBp5ubfzbDlSgJXp+mEjA0615I/D8MLEBGSjADlSgJXp+mOhufqk9P0yswAZkoAA7UIGW6PlhItw8PzRvRp4fJjYgAwXYgQq0RM8PzRuM54eJBViBDchAAXagAi3QK5gCCViAFdiADBRgByoQbgQ3ghvBjeBGcCO4EdwIbgQ3gluBW4FbgVuBW4FbgVuBW4FbgVuBW4VbhVuFW4VbhVuFW4VbhVuFW4Vbg1uDW4Nbg1uDW4Nbg1uDW4NbgxvDjeHGcGO4MdwYbgw3hhvDjeEmcBO4CdwEbgI3gZvATeAmcBO4dbh1uHW4dbh1uHW4dbh1uHW4dbgp3BRuCjeFm8JN4aZwU7gp3BRuyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJTJyiTi6mzlWYAMyUIAdqEBLHLlkIAHhVuBW4FbgVuBW4Oa55Fwlp3gJ1UTPJRMJWIAVeOqeSzMUGQsbn09eGUsbD3SF5liAFdiADBRgByrQ3fwGjOWOBxLQ3fy2jEWPBzYgA92tO7ru+S0tY7HjgQQswFNX/Dp4JhA/Y88E4pfEM4H48XomED8yzwTixp4JBnommEjA0038yDwTTGxABrqb31gP/+6H4+Hf/XA8/M8a9+KVUo+OUsfTovsJefhPbEAGCrADFehufgwe/hNLtpKxMPLABmQgWpTH/EQFWqBXTAUSsAAr8HQ7B95LHwsmDxTg6abj3yrQEj3mJxKwACuwARkoQLgR3Dzmz4Ha4lVUge7WHAvQ3aqj64pjByrQEj26tTsSsAAr0L8Dxp8xUIAdqEBLxFdHH18dAwuQR+1D8ZKpRxe6Ywcq0BI95Cf6SZhjAVZgAzJQgB2owNPNR5i9gCqQgKebDwV7DRX5CLAXUZEP7XoVVaAAO1CBlugh77Ie8YNaEidJUg/y8POhXq9kCiRgAVZgAzJQgB2owHTzmqZAAhZgBTYgAwXYgQqEG8GN4EZwI7gR3AhuBDeCG8GN4FbgVuBW4FbgVuBW4FbgVuBW4FbgVuFW4VbhVuFW4VbhVuFW4VbhVuHW4Nbg1uDW4Nbg1uDW4Nbg1uDW4MZwY7gx3BhuDDeGG8ON4cZwY7gJ3ARuAjeBm8BN4CZwE7gJ3ARuHW4dbh1uHW4dbh1uHW4dbh1uHW4KN4Wbwk3hpnBTuCncFG4KN+QSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy6xzCX1yFxSj8wl9chcUo/MJfXIXFKPzCX1yFxSj8wl9chcUo8DbgQ3ghvBjeBGcCO4EdwIbgQ3gluBW4FbgVuBW4FbgVuBW4FbgVuBW4VbhVuFW4VbhVuFW4VbhVuFW4Vbg1uDW4Nbg1uDW4Nbg1uDW4NbgxvDjeHGcGO4MdwYbgw3hhvDjeEmcBO4CdwEbgI3gZvATeAmcBO4dbh1uHW4dbh1uHW4dbh1uHW4dbgp3BRuCjeFm8JN4aZwU7gp3BRuBjeDm8HN4GZwM7gZ3AxuBjfkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLhl1kWcJdR11kQNHSA98WJSzsLp6XWRgBTYgAwXo3V5OmmRBvknTWXZdvSgysADdqjk2oFv5KfiGTRM7UIGW6Bs3TSRgAVZgA8JN4aZwU7j5Vk5n8W0dWxhOJGABVmADereOkyT1JE2ySSX3V/NyyHKY43mkZ5Fv9cLHQuSoQEv0LZwmnkd6FrdWL3wMrMAGZKC7NccOVKC7yYm+rdNEArqbn4Vv7jTR3fyEfIOniQI83YqTJlmQ7/M0iJJK0qlY/BL5Rk7Fr4Bv5TT3dzuABCzA80iLn6BvrDaRgQLswNONnSzIt1gbdFr5v/NN1gbVpJbESZLkJkNGgZboUTzRD9MvvsfrxFPB76lvqTbIgjxei98aj9eJBXgeaPVr6vE68bSqfnk9Xid2oHv5NfV4re7m8Vr9xDxezyKO6uWIgRXYgAwUYAcq0N380D1eq7cqj9fmh+6R2fwgfcO15gfpW65N7EAFWqDXIAYS0MWqowA7UIGW6KE6kYD+Z81RgZboMTfR/4wdvX2JYx0bCNUauznVGts51Rr7OdUaGzrVGjs61RpbOtUaezrVGps61Rq7OtVa06OmR02Pmh41PWp61PRo6dHSo6VHS4+WHi09Wnp4uLXueF4QcypJNaklcZIk9SRNsqDc3BC7G2J7Q+xviA0OscMhtjjEHofY5BC7HGKbQ+xziI0OsdMhtjocGxq2gZbosTbxFGJvLB5r5+BoHVsbsrcbjyr2duORcg4g1rFVofi/9SfbxAY8T068wXr8TOxABVrg2LpwIgEL0N3IsQEZ6G7meOr283DGxoUTT93u/9afehMrsAEZfybADlQg3ArcPAInFmAD8thPq3pV3aSepEkW5IE3yMWLYwFWoAD98Pwa+qOuN0cCFmAFNiADBdiBfjH8yPxZN9Cjb6K7iWMBVqC7dUcGCrADFWiJHoYTCViAFehu6shAAbqbtyUPx4mW6AE58XRTv6UekhMr8HRTvxf+iJwowA483dRvloftQA/biQR0N78BHrYTG9Dd/Iw9mCd2oAIt0R+REwlYgO7mF2rsU+qnOXYhPaOHxz6kAwlYgJ4Bq6MAO1CBrnueEI9dSAcS0HXF0RW6owItcew2OpCABViBDejHq44C7EBNHLuNmmMBVmADnjnAP6HGnocTO1CBluhPx4kEPJ+Ph19ffxhOFGAHum5xtETf+XAiAQuwAhuQgS7m9803O5xIwAIUYAcqEGIdYh1ivsehfyyOXQ4nNiADBdiBCrRE3/NworuxYwHWsRthza0Pa+59WHPzw5q7H9bc/rDm/oc1N0CsuQNi9Vqzx7uiYwU2IAMF2IEKtECvNQt03e7oCurYxxaHNXc9rLntYR37Hg6ipJLkiubYgAwUYAdq4th49HD0VzrXHe+mA0+F4tSTNMmC/Bk5iJL8xbE6VmADMlCAPXG8jjZHV2DHNrZ+rF4GNkmSzgs6/lqTLOgMtUmUVJLcxG/R2Gl0IAM1cewl6vdw7CY6sALPw/QLcT7sJklST9IkCxp7+/otGrv7DizACmxABgqwAxVoiQo3hZvHnX+2e7VXYAOebv7p6tVegd5O/Fb4/r/+PezVXrX4hfM9gCcS0N3c2ANw4unmn7le+FX9+8ILv/zLyuu+JmmSTfKir0mU5IrF8TxS/xj2Mq7q73hexjXRd/6deB5pdQXf/XdiBTYgA133PEEvzar+MeylWdU/hr00K7ABGSjADlSgJXoQTjzdPLV5wVZgBZ5unka8YCtQgB14unnD9IKtiR6cE2lsSFq9XmtSTToDwU/c43WQJPUkTbIgfzR6cHr5VmABVqAA/TDPRuglWYGu4PfTQ3ZiBbaxe1jN3Q9rbn9Yc//Dmhsg1twBseYWiDX3QKy5CWLNXRBrboNYcx/Emhsh1twJseZWiDX3Qqy5GWLN3RBrbodYcz/Emhsi1twRseaWiNXXtaojGjxCJ1qiR+i4/h6hEwvwvGT+5eoFYYH+ZeXX3x+REztQgRboBWHVv4i9ICzwdPMvYi8Iq/5F7AVh9Sy/rV4QFihAd1NHBVpi7N5WNbZvqxr7t1WNDdzq2EVxECe54tmmvbyr+pe3l3dV/xb28q7ABmTgeaT+Ye3lXYEKtESP5ok0NhGrXsflH9tjpSo/gFiVquaqVDVXpapellXF/9h7bSYyUIAdqEBL9HCcSMAChBvDjeHGcPMdu8Vvmz9XJ1qih+5EAhZgi2sQ69BVjXXoqhdiVfG77m+3Ey3Rn7ITCViA59l4t4EXYgUy8Dwb77rwQqxAi5sUC8VXjYXiq5deeb+AV15NakkuXhwF2IEKtEQP2YnnqQwxD9mJFdjGaopVY+XJqrHyZNVYebJqrDxZNVaerBYrT1aLlSerxcqT1WLlyWqx8mS1WHmyWqw8WS1WnqwWK09WO9KD0oPSg9KD0oPSg9LD33i9d8QrrAIV6NfsDGevsAokYAFWYAMyUIAdqEC4Vbj5w3kcrz+cJ1ZgAzJQgB2oQEv0h7P3uniFVWAB1rGMZfUCq0mcJEk9SYM89L3Hxuul6vyv55F65Hm9VGAHKvA8Uu968XqpQAIWYAWebt7J4vVSgQLsQAVaoof8RAK6m184D3nvb/F6qeqdLF4vFSjADlSgJfqL9UQCFmAFwk3hpnBTuCncFG4GN4Obwc3gZnAzuBncDG4GNwu35vVSgQQswApsQAYKsAMVCDeCG8GN4EZwI7gR3AhuBDeCG8GtwK3ArcCtwK3ArcCtwK3ArcCtwK3CrcKtwq3CzTPD2ZnXvF4q0N2KYwcq0BI9Mxg7ErAAK7ABGSjADnQ3cbRETxVnZ17zIqnACmxAt1BHAXagAm3mneZFUoEELMAKbEAGCrAnxl6u7YjNXNsRu7m2I7ZzbUfs59qO2NC1HSNJDJkOVKAljiQxkICnk18Wf60f1JK808utRq/XwA58WJ3vji13gmy5E2TLnSBb7gTZcifIljtBttwJsuVOkC13gmy5E2TLnSBb7gTZcifIljtBttwJsuVOkC13gmy5E2TLnSBb7gTZcifI5vVO7exPbV7vFFiA3k1YHBuQgQLsQAVaYjmABHQ3P5xSgQ14npY4SVJP0iQL8o2kBrlic/QjZUc/0vEPFGiJ7QD6kapjAVZgAzLQ3cyxAxVoYxuoRrFdVKPYLqpRbBfVKLaLamP7x0GcJEk9SZPSQ9JD0kPSQ9JD0kPSQ9JD0sN72s7ezuZVUo38TvUDSMACrMAGZKAAO1CBcFO4KdwUbt7HTX7zvZN7IgMF2IGa6L3a5O1gzJB2kiT/I78g3mk20QK95CmQgAVYgQ3oh2iOAuxA7+g8HC3Ro3kiAU+3s5uxeSVUO0uCmldCBXagAl33PE2vhGpn52PzSqh2VuA0r4RqxY/X47b4kXncVjc+4zZQgB3ovcp+ZMUS6wEkoPcsV0e38MOpbuGH4+F99g82X/etVT8cD+/mJ+ThPdDDeyIBC7ACG9D7yP0YRif5QI024mVSE713fKJb+PF6//jECnSL8W8ZKMAOVKAlygEkYAFWINwEbt6d3vyaeX/6RHfze+xhPtDDvPml9oBmv5se0BMZKMBTl/1uekBPtEQP6IkUydrrqAIrsAEZKMAO1EQPaPa7eT6vAyuwAf0s/B57N/nEDlSgd4Wcp+l1VIEELMAKbEAGCtCvzhmFXlIVSMACrMAG9LNgRwF2oAIt0aPb38+8vqr5y5IXWLWz9695hVWgAl3hbDteZBXoYwZ+Qh7HEyvwPN6zX695pVWgADtQgZboIT3R3YpjAVZgAzJQgN6t65fP43hcB4/jibg6Hsf+NuU1WIEMFKCfhV9fj+OJluhxLH6pPY4nFqC7+aX2OJ7IQHfzQ/c4Fr8BHsfdL7XHcfcL5XE8kYCnbvfr4HE8UYAd6Lp+bh6xo5V4xE6swAYUoI+5OPpH90QC+giPn5t/dE9sQAYKsAMVaIFerhV4HuTZp9W8MCuQgQL0k2dHBVqih+lEP4vqWIAV2IAMFGAHKtAS/UP6HEVtrVSgn4U4MlCAHehnMf7MEj14JxKwACvQR039So5h6IEC7EAFWuIYnB5IwAKsQD+LgR2oQEv04PVPUK/fCizACvSz8Ps2RqkHCrADFWiJ/vU8kYA+ZHc4MlCAHejDduRoiR6mEwlYgBXYgAx0t+LYgQq0RH8IqzcuD+mJBViBUejQvFIrUIAdqEBL9JifSMAC9BIMb2f+EFaPQn8IT1Sgn8V51b1+q50FXs3rtwILsAIbkIEC7EB3OxuM128170riUTLi/8AfrN6V5PVbgZboL9MTXaE4FmAFNiADBdiBmsfgHWIDvUNsIgELsAJxFqOqa6AA/SzOO+/1W4EELMA6azYbjzrMgQwUYAcq0BJHHeZAAvpUBr/dXnE5UYB+dQYq0M/ibFFe4BVIQD8LP2N/3E5swHMY0zuHvAIssAMVaIneC+ZdGl4BFliAFdiADBRgT/ShbO/j8KounyDRvISL/aXXa7gCFehH5v/WDqAfmV8HK8AK9CPz62AMFGAHKtACvZAr0N3MsQArsAEZKMAeZ+wVXux9El7iFViAFXjqeobxIq9AAXZgTLppvjzYRK/DnEjAAqzABmTgeXXOJWSaV39NrAeQgH4W1bECG5CBZwSM06wdqEBL9HrqiQQswJo49gjyQx+bBA1koAA7UIGWOLYKGkjAAoSbwG3sF+SXZGwYNLADFWiJY9Ogga7bHBuQgQLsQAW6rrdf3yhoIgEL0N28pfpmQRMZaKnrOwJNJGAB4tANh+7bAg033xdoYgcq0MLYK7oCKXFs9uEfI2OJrGADj/0+vH91rJJ1+LfJWCYruC7cFmZndZaF+8IKrkPfj80npR7+FTNWxgqWhXX5937M/lEzlsQKpoXLwnXhtjAvPLyqc19YFx6+580Za2YF08LDtzjXhdvCvPByjtwX1oUNLMfCtHBZuC68XFtZrq3HkHfJjN0GJxKwACuwARkowA5UINwUbgo3hZvCTeGmcFO4KdwUbh563jU1diCcSMACrMAGZKAAO1CB6Tb2IpxIwAKswAZkoAA7UIFwI7gR3AhuBDeCG8GN4EZwI7gR3ArcCtwK3ArcCtwK3ArcCtwK3ArcKtwq3CrcKtwq3CrcKtwq3CrcKtwa3BrcGtwa3BrcGtwa3BrcGtwa3BhuDDeGG8ON4cZwY7gx3BhuDDeBm8BN4CZwE7gJ3ARuAjeBm8Ctw63DrcOtw63DrcOtw63DrcOtw03hpnBTuCncFG4KN4Wbwk3hhlyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXDK2BfUxn7EvqI+AjI1BJ1riyCUDCViAFdiADBQg3BRuCjeDm8HN4GZwM7iNXCKOAuxABdpEHtuFTnQ3dSzACjzdzvEW9jo0PQdO2OvQAjtQgZbouWQiAQuwAhsQbgQ3ghvBjeBW4FbgVuBW4FbgVuBW4FbgVuBW4FbhVuFW4VbhVuFW4VbhVuFW4Vbh1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDGcGO4MdwYbgw3hhvDjeHGcGO4CdwEbgI3gZvATeAmcBO4CdwEbh1uHW4dbh1uHW4dbh1uHW4dbh1uCjeFm8JN4aZwU7gp3BRuCjeFm8HN4GZwM7gZ3AxuBjeDm8HN0s2r1wIJWIAV2IAMFGAHKhBuyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxSkEsKcklBLinIJQW5pCCXlJFLyLED3e1wtMSRSwYSsAArsAEZKMAOhBvBrcCtwK3ArcCtwK3ArcCtwK3ArcCtwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BjeHGcGO4MdwYbgw3hhvDjeHGcBO4CdwEbgI3gZvATeAmcBO4Cdw63DrcOtw63DrcOtw63DrcOtw63BRuCjeFm8JN4aZwU7gp3BRuCjeDm8HN4GZwM7gZ3AxuBjeDm6VbPQ4gAQuwAhuQgQLsQAXCDbmkIpdU5JKKXFKRSypySUUuqcglFbmkIpdU5JKKXFKRSypySUUuqcglFbmkIpdU5JI6ckk7ceSSgQQswApsQAa6mzp2oALd7czVXt+nfSABC7ACG5CBAuxAuI1c4jhyyUDKYxi5ZCDcGG4MN8a5Mc6N4ea5ZPxbwbkJzm30gfi/Hb0d/cTR2zGQgAVYgQ3IQAF2oALhpnBTuCncFG4KN4Wbwk3hpnBTuBncDG4GN4Obwc3gZnAzuBncLN3acQAJWIAV2IAMFGAHKhBuBDeCG8GN4EZwI7gR3AhuBDeCW4FbgVuBW4FbgVuBW4FbgVuBW4FbhVuFW4VbhVuFW4VbhVuFW4VbhVuD28gExdEzATtWYAMyUIAdqEBL9EwwkYBwY7gx3BhungnOWkv2EsJABVriyAQDCehu1bECG1AjVbSRKhxHqhhIwAKsQBcbyEAB+qGbowIt0VPFWW7IXjcYWIAV2IAMFGAHKtASPVWon7yniokFWIENyEABultzVKAFejVhIAELsAIb0N3UUYAdqEBL9FQxkYAFWIENCDeCG8GN4EZwK3ArcCtwK3ArcCtwK3DzVHGWR7LXIwZaoieFiafCWT/JXmMY2IEKtEQP/4kELMAKbEB3q44C7EAFWqKH/0QCups4VmADupufpof/xA5UoCV6+E8kINwEbgK386PCzsmU7PWIgR2oJ45/a4lnfgik/LdnfgiswIZ/y0ABupsfb1egJZ6xaeT34ozNwAbMz3VG5wCjc4DROcDoHBB0Dgg6BwSdA4LOAUHngKBzQNDRKOhoFHQ0CjoaBR2Ngo5GQUejoKNR0NEo6GgUdDQKOhoFHY2CjkZBR6PXGNpZj8heYxhYgQ3IQAF2oALPO3TWDbJXHgYSsAArsAEZKMAOVCDcmrs1RwIWYAU2IAMFCLcGt+ZuZ/P0xersnBzBvlpdYAFWYAMyUIAdqEBLFLhJfhqN4saJFehu6shAAXagAi3R43giAc9zK36PPY4nNiADBdiBCrTE8zkfSEC4KdwUbgo3hZvCTeGmcPOsUTwCzBX8xpor+PW1DlSgBXqdYyABC7ACG5CBAuxABcKN4EZwI7gR3AhuBDeCG8GN3E0dLbEcwAp0BXPsQAVaosf8RAIWYAU2IANPt3MVQPZ17gIVaIke8xMJWIAV2ICn2znfib3+MrAD87O64yO+4yPeSy/tXKGfvfIysAIbkIEC7EAF+rn5HfKYn0jAAqzABmSgADtQgXDrcOtw63DrcOtw63DrcPPorn6hPI6r31iP4+bX1+N4IgMF2IEKtMTzfT2QgAUIN4Obwc3gZnAzuFm6eYFlIAELsAIb0N2aowB7okf3RFdgxwZkoAA7UIGW6HE8kYAF6G7d0RXU0RI9jicSsAArsAEZKEA/XnNUoCV6HE8kYAFWYAOebuyX2uN4Ygcq0BL92T2RgAVYgQ0IN4Ybw43hxnATuAncBG4CN4GbwE3g5nHM3mA8jidaokfsRFfw2+2xObEDFWiJ/jyeSMACrMAGdDdvUR7HEztQge7mTcPjeCIBC7ACG5CBAuxAd/NW4nHs6MWNgQQswApsQAaebufka/bixkAFWqJH90QCFmAFNiAD4UZwI7gR3ArcCtwK3ArcCtwK3ArcCtw8P/irpRc3TvT8MLECXYEdO1CBlugxP5GABViBDchA1z1blJcbmj+avdwwkIEC7EAFWqJH7EQC+pF5I/CIndiADBRgByrQEv3J691uXm4YWIAV2IAMFGAHKtASFW4KN4Wbwk3hpnBTuCncFG4KN4Obwc2ju3uD8eie2IB9ongJoZ39nuIlhIEFWIENyEABdqACLdEj9pyELl5CGFiAFehu6shAAXagAi3RI3YiAQvQ3cyxARkowA5UoCV6xE483c6uSvESwsAKbEAGCrADFWiJHt0T4dbg1uDW4Nbg1uDW4Nbg1uDGcGO4Mdw8P6i3KM8PExmoiR7z6u3BY35iBTYgAwXYgQq0RI/5ia4rjg3IQAF2oAIt0aN7IgELEG4KN4Wbwk3hpnBTuBncPLrVG61H98QKbEAGCrADFWiBXgBo5zx38QJAOzt9xQsAAyuwARkowA5UoCVSDKHKKACcWICn2zlTXrwAMJCBAuxABVqiZ4KJ57md3bDiBYCBFdiADBRgByrQEj0TTIRbhVuFW4VbhVuFW4VbhVuFW4Nbg1uDm2eCc6a8eAFgIAM10aPbvD14dE+swAZkoAA7UIGW6E//gf48Nm8P/jyeWIHtnNl4zsYXr7NLloX7wrqwgX3D3WBauCxcF168bPytN0qjhcvC42+9gVlbmBeWhfvCurAlj903g2nhsnBbePztmY69JC6ZFh5/25zrwm1hXlgW7gvrwgYeM40n08KL15gtfC5pIF7pFlyPhcffinNZuC7cFuaFZeG+sC5s4DHTePLiNWYLn2soSBmzhScbeMwWPpdGkDJmC08uC9eF28K8sCzcF9aFDSyL15gJfI7ZSBkzgSfLwq55DtuIF6wlG9i3wA6mhcvCdeG2MC8sCy++IwbPQQwpIwbJ2+2Iwcl14bYwLywL94W9381P15+hA/0ZOpGABViBDcjAcb08fkZ8OtcRn5PH+TTnsnBduC3MC8vCfWFd2MAjticvviOGzzWMpI4YPkdSpI4YntwX1oUNPGJ4Mi3sfcx+uqPvemADMlCAHahAS6wxzii1VmADxlic1CyMl5qF8VKzMF5qFsZLzcJ4qVkYLzUL46VmYbzULIyX2uDW4Nbg1uDW4MZwY7gx3BhuDDeGG8ON4cZwY7gJ3ARuAjeBm8Q4o1RhoAA7UIGWOMarBhIwxhnFS9gCG5CBAuzAGIsTL2GbqAeQgAVYgQ3IQAF2INw0iiJllLBNJKC7qWMFNiADBdiBCoyRP2lHjMVJOwhYgBXYgAwUYAcq0BIJbgQ3ghvBjeBGcCO4EdzGKFZxzEzQSoyOSSsMFGAHKtAS6wEkYAFWINwq3CrcKtwq3CrcGtwa3BrcGtwa3Brc/Au6+I31L+iJmuhv0xNjLE681CxQgB2oQEuUA0jAAqzAGIuTNsarBgqwAxVoif0AErAA/bnpd36MVw1kYBTUyqhFm6hAdzvjzWvRAglYgBXYgAwUYIzFSVMFWqIdQAIWYAU2IAMFCDeDm6Wb16IFErAAK7ABXfe8UF5fNl5GvL7MB7/E68sCK7ABGSjADlSgJZYDCLcCtwK3ArcCtwK3ArcCtwK3CrcKtwq3MQ7WHBuQgZrYYixOuBVgBTYgAwXYgQq0RD6A7uY3i2MsTrxmLFCBligHkIAFWIEN6MfrjcDjeGIHKtAS+wEkYAHG6JiMmrGJDBRgByrQEvUAErAA4aZwU7gp3BRuCjeFm8HN4GZwM7gZ3MbYljeYMbY1MEb+RMYo1sAYixM5GpCBAuxABVoiHUACFqC7dccGZKAAYyxOvBYt0BLLASRgAVZgAzLQ3cyxAxVoifUAErAAKzBGx2TUok0UYAcq0BLbASRgAVYg3BrcGtwa3BrcGtwYbgw3hhvDjeHGcBujY96ixujYQE0c42ADYyxORn3ZRAF2oAItsR9AAhZgBbqutyiNsTgZ1WETK7ABGSjADlSgJXrEijcCj9iJBViBDchAAXZgjI7JqCRzHJVkEwlYgBXYgAwUYAcqEG4EN4IbwY3gRnAjuBHcCG4EN4LbGNtqjgQsQAbmWNyoJBtYDyABC7ACG5CBAuxAd+uOltgOIAFzLG5Ukk1sQAYKsAMVmCN/XkkW6G7mWIAV2IAMFGAHKjBHx0Yl2UQCFmAFNiADBdiBCoRbh1uHW4dbh1uHW4dbh1uHW4dbh5vCbYx4eYsaI14DK1CAORY3KskmErAAK7ABGSjADsyRv1Ez5gNlo2ZsYgU2IAMF2IEKzLG4UUk2EW4EN4IbwY3gRnAjuBHcKMfiRn3ZRAIWYAU2IAMF2IE+IkOOORY3atEmErAAK7ABGSjADtQYzRuL8g3MiaEyatF8WG7Uok2swAZkoAA7UIE5OjZq0SYSsAArsAEZKMAOVCDcBG4CN4GbwE3gJnATuAncBG4Ctw63MZLWHQuwAgWYY3GjFm0iAQuwAhuQgQLswBz5G9VhPpo3qsMmEhBjcHbUhdvCvLAs3BfWhTH2Z3QsTAsvXnM8i5wNXI6FMQZnpSxcF24L88KycF9YF8bYn9Vj4cVrjmdVZ10YY3/WMAZnjRYuC9eF28K8sCzcF9aFMfZnvHjN8Sx27gvrwhiDMzkWpoXLwnXhtjAvLAv3hTH2Z33xmmPK3VkW7gtjDM46xuBMj4Vp4bJwXbgtzAvLwn3hxWuONXu8zLHmwW1hjMGZycJ9YV04x/76cRwL08Jl4bpwW5gX1hjj68ccsyonzzGrwbRwWbgu3Bbmhb3fzRw7UIGWWA4gAQuwAiXG8vox4nOyLpxjcP2ox8K0cFm4LtwW5oVl4b6wLrz4jhg+x/j6MWL4HJvrx4jhybywLNwX1oUN7E/L4qc7+q4HFmAFNiADBdgTx/wqbyL+XJxYgDFe1bEoXMeicB2LwnUsCtexKFzHonAdi8J1LArXsShcx6JwHYvCdSwK17EoXMeicB2LwnUsCtexKFzHonAdi8J1LArXsShcx6JwHYvCdSwK17EoXMeicB2LwnUsCtdHTdgIuzFeNbABGSjADlRgjPw9Pmn9vlVHAhZgBTYgAwXYgQq0RIIbxQzD7jVhgRXYgAwUYAfCjeDm+cGb/agJO4cG+6gJm1iBDchAAXagAi2xHkC45eIrnXLxlU65+EofNWHn2GEfNWETO1CBljjmag4kYAHGyF8fNWETGSjADlSgJfIBJGABwo3hxnBjuDHcGG4MN4HbGPEqjpl3fKE3H6HrvtBboCX2A0jAAqzABmSgAOHW4dbhpnBTuCncFG4KN4Wbwk3hpnAb8y/9xvrX9kQCNmCMM3YyBcY4Yy/HASRgAVZgAzJQgDHO2H3xtkBLpANIwAKswAZkoL8TVMcOVKDNIcc+F28bSMAYZ+ylVGADMlCAHahAS6wx8te9oC2wACuwARkowA5UoCU2uDW4Nbg1uDW4Nbg1uDW4eXRXv1Ccb0xeyeYjdN0L2QIF2IEKtEQ5gAQswAqEm8BN4CZwE7gJ3DrcOtw63DrcOtw63HrMMOxe1haoiR7dE2OcsRdloAA7UIGWaAeQgAVYge7mN8tinLHX4wASsAArsAEZKMAOjHHG7mVpE+kAErAAK7ABGRgjf71SByrQEssBJGABVmADMhBuBW4FbgVuFW4VbhVuFW4VbhVuFW4Vbh7H5zhj97q1ie0AVmCMM/baOlCBlsgHkIAFWIENyMAYZ+x1zL8cqEBLlBhn7FUIWIAV2IAMFGAHKjDGGfuoRZtIwAKswAZkoABj5K+PWrSJlqgHkIAFWIENyEABwk3hpnAzuBncDG4GN4Obwc3gZnAzuFnMMOyjFm0iARswxhn7qC+baIl0AAlYgBXYgAwUoOueLWpUkvmjeVSSTRRgByrQEsfsyYEELMAYZ+yjkmwiAwXYgQq0xHYAY+Svj0qyiRXYgAwUYAcq0BL5AMKN4cZwY7gx3BhuDDeGG8NN4CZwE7h5dHdvMB7dExmoiT3GGfuoJJtYgQ3IQAF2oAItUQ9gjDP2UUk2sQIbMMYZ+6gkm9iBCrREO4AELMAKjHHGPirJJgqwAxVogaOSbCIBY+Svj0qyiQ3IQAF2oAItkQ4gAeFGcCO4EdwIbgQ3ghvBrcCtwK3ArcBtjHg1RwYK0BJrjDP2UUk2sQEZKMAOVKAltgNIwBj566O+bKIAO1CBlsgHkIAFWIFwY7gx3BhuDDeGm8BN4CYxzthHLdrEBmSgADtQgZbYD6CP/5BjjDP2UYs2sQEZKMAOVKAl6gGkOeTYvRYtsAJjnLGPWrSJAuxABVqiZ4KJBIyRvz5q0SY2IAMF2IEKjJG/PirUJhKwACuwARkowA5UINwIbgQ3ghvBbczV7I4MFKAllhhn7KMWbWIDMlCAHahAS6wHkBLHCLM5VmAD5iBjlyYL94V1YQPzsTAtXBauC7eFF685+EXOZeG6cA4ydhFeWBbuC+vCBu7HwrRwWbguvHjNwa/qTAuXhXOQ8cFtYV5YFu4L68IGtmNhWrgsvHhZTjDs/TgWpoVzkLH3oy7cFuaFZeG+sC5sYDoWpoUXL8oJhn1u3Tp4DkAPzkHGPrdunVwXbgvzwrJwX1gXNnA9Fl68ak4w7HMb18l94Rxk7HNL18HtWJgWLgvXhdvCvLAs3BdefEcM+iDG3LrVBxDn1q2T28K8sCzcF9aFc5xxriM2kIAFWIENyEABWg449jkhczAtjEHG3uvCbWFeWBbuC+vCGGTseixMCy++c0Kmx49ikLFrX1gXxiBjt2NhWrgsnOOMoyZsIgMF2IEKtMCxuthEH9M5HBuQgTkWp7m2aNdcW7Rrri3aNdcW7Zpri3bNtUW75tqiXXNt0a65tmhXghvBjeBGcCtwK3ArcCtwK3ArcCtwK3ArcCtwq3CrcKtwq3CrcKs5zjhqwiZ2oAJznHGsTzaRgAWY44yjJmwiAwXYgQocLfDMpDqe1pNpYT89/+djuubABmSgADtQgZY4pmsOJGAOcoyysIkNyEABdqACc0hFc+pWH3u1eqfK2Kt1YgU2IAMF2IEKtMQx/D0wJsT0UULmj7ZRQjaxAc9z8+fFKCGb2BMtO6rHEmUTG5CBAuxABWa3uKFbfOy/6q+tY//ViRWYHdVjibKJAuxABWa3uKFb3NAtPpYo8z7gsUTZxAZkoAA7UIHZUW3oFjd0ixu6xQ3d4oZucUO3uKFb3NAtbugWN3SLG7rFDd3ihm5xQ7e4jW7x5shAAWYH+FiizPuhxxJlExuQgQLsQAVmt7ihW9zQLW6jW7w7VmADMjA7qsciZxMVaInoFjd0ixu6xQ3d4oZucculwbvl0uDdcmnwPhY58+5rQ7e4oVvc0C1u6BY3dIsbusUN3eJjkTNPTIZucUO3uKFb3NAtbugWN3SLG7rFDd3ihm5xQ7e4oVvc0C1u6BY3dIsbusUN3eKGbnFDt7ihW9zQLW7oFjeL6Tfdsltcj+wW17H02cToqNYju8X1yG5xPbJbXI/sFtcju8X1yG5xPbJbXI/sFtcju8V1FLSdOVVHkdrZZ61Hdovrkd3iemS3uB7ZLa5Hdovrkd3iemS3uB7ZLa5jibKz+1qP7BbXI7vF9chucT2yW1yP7BbXI7vF9chucR1LlJ2dxHpkt7ge2S2uR3aL65Hd4npkt7ge2S2uR3aL65Hd4npkt7geDDeGG8ON4cZwY7gx3BhuDDeGm8BN4CYx/UaP7BbXI7vFdSxcNrBHR7Ue2S2uR3aL65Hd4npkt7ge2S2uR3aL65Hd4npkt7ge2S2uY+Gy7i0qu8X1yG5xPbJbXMfCZd2bRnaL65Hd4npkt7ge2S2uR3aL65Hd4npkt7ge2S2uo0iteyvJbnE9sltcj+wW1yO7xfXIbnE9sltcKbvFdS5cVh0LsAIbkIEC7EAFWmJ2iysR3AhuBDeCG8GN4EZwI7gR3ArcCtwK3EpMv1HKbnGl7BbXUY42sEZHtVJ2iytlt7hSdosrZbe4UnaLK2W3uFJ2iytlt7hSdosrzU95dW4L88KycF9YFzbwfHEfTAuXhRdfXnx58eXFlxdfXnx58ZXFd3TRlcO5LFwXbgvzwrJwX1gXNvDoAih+p0cXwFn4pjS6ACbXhdvCvLAs3BfWhQ08ugCK38fRBTC5LDx8xbktzAvLwn1hXdjAo2tgsvtWvw6ja2ByXbgtzAvLwn1hXdiS51prk2nhsnBduC3MC8vCfWFdePGlxZcWX1p8RzdhJee2MC+s4NFNeH7/aRndhJPrwm1hXlgW7gvrwgYe3YSTh05zloX7wrqwgUfX4GRauCxcF24LL75t8W2Lb1t82+LLiy8vvrz48uLLiy8vviOfVHbuC+vCBh75ZDItXBauC7eFh684y8J9YV3YwCOfTKaFy8Lu27ztjXwymReWhfvCurCBRz6ZTAuXhRdfXXx18dXFVxdfXXx18bXF1xZfW3xt8bXFd+ST5jE18snknjzXgJs8dIpzW5gXloX7wrqwgUd+mEwLl4WHb3VuC/PCsnBfWBc28Bh2mEwLD9/mXBduC/PCsnBfWBc28MgnZ++M1jGvZnJZuC7cFuaFZeG+sC5s4Lb4tsW3Lb5t8W2Lb1t82+LbFt+2+LbFlxdfXnxH/jk7i7SO/DO5LdzBI5/w4UwLl4Xrwm1hXlgW7gvrwgYe+YS9/Y+8wd5ORt6YPPT9/o68MbkvPPTZ2cAjb0ymhcvCdeG2MC8sC/eFF19dfG3xtcXXFl9bfG3xtcXXFl9bfG3xNfi241iYFh6+4lwXbgvzwrJwX/jstz37e7SNVHH2a2kbqWKyLDz+VJ11YQOPVDGZFi4L14XbwrywLLx4jXAfxzzCfTIv7H97bnisbYT7ZF3YwCPcJ9PCZeG6cFuYF168Rsiemw1rGyE7uS08/rY4y8J9YV3YwCPEJ9PCZeG6cFt48epZYaCtl4XrwllhoA2j/tq6LNwX1oUNrMfCtHBZuC68eFlWGGgzWrgsnBUG2jDqr814YVm4L6wLZ4WB8nEsTAuXhdvCWWGgTMfCtHBWGChj1F+Z2sK8sCzcF9aFDVyOhWnhxatkhYFyMXA9Fs4KA2WM+ivXunBbmBeWhfvCurCB27Hw4jVjqjrrwgYej03vmeXx2JxcFq4Lt4V5YVm4L6wLG1gWr9Fmzu1FVUabmUwL+/EYO9eF28K8sCzcF9aFDTza22RaePGlxZcW39F+znEulZGrz6IslZGf538fx6bO49jMuS+sCxt4tKvJtHBZ+Dw2Oiuf1BcFS+aFxZmcu3NxVme/zt6uyONRRrsa5zJy++TlHMdrmncZzuquybqwgUd7m0wLl4Xrwm1hXth91c9rtDf18xrtbbKBR86f7L7q5z5y/uS6cFuYF5aF+8IKHs8F71SUkf+901BGzvcuPRk5X71tjJw/2cAj50+uCw8dv/7jFWzy0PE2NvK8+rUaedv8Wo28PVkXHu3tvD6zumsyLVwWHrFQnNvCvPwbWbgvrAtbXp9Z3TWZFi4Lc16HTrgOnfrCCj7bM/sXlxdNBRKwACuwARkowA5UINwYbgw3hhvDjeHGcGN387Nm1z0bjtdIBRKwAF3XL5D4kfl1EEvsB5CA/m/V0RL1ABLQ3cyxAhuQgedZ+CeOVy6xf+F44VIgAQuwAk8x9tZ1ttiBvlAV+2eRlx+xf/14+VGgAM+b5a//Xn4UaIl0AAnouuLoCt1RgZZYDiABSx5kqcAGZKAAO1CBllgPoOuqYwMyUICue94WLwhif932gqDABmSgADtQgeeR+Xu51wMFEtB1/b55A/fnvtf9sA/Tet3PvGaM68u4voLrK7i+3uwHdj8hv1m9AhuQgQLsQD+hIWaJHgETCehuflG9rfswrZffcPdLcublQAVaokfARAIW4HkW3S/f+UIeyEB384tqHahAdzuvr5fqBBKwACuwARkoQHcTR3c7r4OX37A/nL38JpCBAjyPzB/eXmgTSMACrMAGZKAAzyPzh7wX2gRaogfORAK6RXFsQBc7g8wXgmJ/APk6UIEFWIENyEABdqAfpF9UjyF/dnt1TSABC7ACG5CBAnRdv+oeLf649zIZ9iewl8mwP7y9TCawAxV4ivkLuZfJBBLQLfzcPAonNiADBdiBCnQ3vzoehRMJ6G7eEP05NLEBGSjADlSgu53R7WUygQR0N7+oHpsTG5CBAuxABbrb47aYl8kEEvDhJue7unnxjJyv5+arRcn5dm6+WJScH8XmJTWBHahAO7GfeD7q5Pw+NC+pkcPdqAArsAFPN/LDOeNYztpt85WjhPzIzsdioCWe0R3obodjAVZgA/JsqeZFOYEdqEBL9OieSMACrEA/C7+StQMVaInNz8Kv5Bn+gQVYgQ3IQAF2oCaO75Y+2MDju2Xy+F7y2zi+WybXhcf3kt/f8d0yWcBeclpc0ktOJ54lnOd4sY0VlyZWYAOeBa7FDX3FpYkdqEBL9BWXJhKwACuwAeHmnyl0Lr9iXqySTAuXhevCbWFeWBbuC+vCiy8NX3OmhcvCdeG2MC8sC/eFdWEDl8W3LL5l8fVuA/I49XWSHlicaeGycF3Yj9ODlUa3wWRZuC+sCxu4HQvTwmXhuvDi2xbftvi2xbctvm3x5eHbnGnhh34nv3XnIzJQgB2oJ/qlPKNw4hmEgQR8nE8/i0vMC1YCG5CBAuxABVri+WQNJCDcOtw63Drcuut6I1BX8Pur/md+qbQBGSjADlSgJZofpF9fI2ABVmDLYzAGCrADFWiBXlQSSMACHF1b7NwXHl1b4mzgEcOTW+RALwQJPPPauVaP+VpIgQq0RJ9P4plxrIU0MfOaF4wENiADBdiBCsws6pUigQSEW4Vbhdvs5XMeoTW5L7z+GwOP0JpMC5eF68JtYV548eXFlxdfXnxl8ZXFVxZfWXxl8ZXFVxZfWXxl8ZXFty++ffHti29ffPvi2xffvvj2xbcvvn3x1cVXF19dfHXx1cVXF19dfHXx1cVXF19bfG3xtcXXFl9bfG3xtcXXFl9bfA2+o+gjmBYuC9eF28K8sCzcF9aFF19afGnxpcWXFl9afGnxpcWXFl9afGnxLYtvWXzL4lsW37L4lsW3LL5l8S2Lb1l86+JbF9+6+NbFty6+dfGti29dfJfcUuvi2xbftvi2xbctvm3xbYvvkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/qkq/akq/akq/akq/azFfm3BbmhWXhvrAubOCZrwbTwmXhxZcWX1p8afGlxZcWX1p8y+JbFt+y+M5PjvPF0ytAOvt/PkM8sAIbkIECPF8FZYgp8HwVPLuSzddsCjzdzl5l85KRwNPtHNw2LxgJZODpdvZAm1eLBLobO1qiv/mf3cPmlSKB7uZ329/8Jzagu6mjAN3NT9Pf/Ceebt1P09/8J55u3U/T3/wnVuDp1v2M/c1/4unW/TTP+A083bqfZrdEdTc/Tf9KmFiA7uZn7B8ME0839YP0D4aJHahAS/QPhokELMAKbEC4GdwMbgY3SzcvPQkkYAFWYAMyUIAdqEC4EdwIbgQ3ghu5W3VkoAA7UIGWWA4gAQuwAuFW4FbgVuBW4FbgVuFW4VZdtzm6Aju6gjlaYjuABCzACmxABgqwA+HW4MZwY7gx3BhuDDeGG8ON4cZwY7gJ3Dw/eN+ir/oUWIECPBXO7nfzlZwCCViAFdiADBRgByrQ3c784Cs5BRKwACuwARkowA50N28PHvMDPeYnErAAK7ABGehu3rg85icq0AK9dCiQgAVYge5mjgwUYAcq0BI95icSsAArEG4EN4IbwY3gRnArcCtwK3ArcCtwK3DzHgbvXfeao0BN9L6EiWevgY89eP1QoAA7UIGW6DsTTSRgAVagu/lt8R3DJ7qbOLpbd1Sgu/m5+Y7hEwlYgBXYgAwUYAcqEG4CN4GbwE3gJnATuAncBG4CN4Gb78DgHbpeVxRYgBXYgAwUYAcq0BJ9PMC7g30tqsACrMAG5ETv4ye/b97HP7EAK7ABGejH6/fYeqAXE6l30notUaAmesea98z6ck2BAvSOtcNRgZY4OtYGErAAK7ABGShAWHgEeHesVxsFVqCLFUcGCrADFWiJHgETCViAFQg3b+veoetLMqn313q10URv6xMJWIAV2IAc7wS+IlNgByrQEv1ZOJGABeiXxO+mN+WJCrTEMbQ1kIAFWIENyEC4Kdx8aKv6NfOhrYHe7CcSsAArsAEZKMAOhJulmy/DFEjAAqzABmSgADtQgXDzxZnO2Xk2FmeaWIAMdAV2tETvIJ9IwAKswAZkoAB7osfmOdfOxiJKExvQFbqjADtQgZboj6+JBCzACmxAWMzBKD/KORjlBzR6oCbXhdvCvPAYBBua40v7zHY6epom08Jl4bpwW5gXHvrm3BfWhQ08epom08Jl4TH4eTi3hXlhWbgvrAsbePQ0TR4DnuRcF24L88KycF9YFzbw6F2aTAsvvrb4jt4lz6g6epcmy8J9YV3Ykm0OaA/GPR3b+gXXhdvCPm7WHS3RX1InErAAK7ABGSjADoSbv6R6ZvRSrkACFmAFNiADT7dz7rV5KVegAi3RP0wnErAAK7ABGQi3CrcKtwq3BrcGN/9crX7D/MPU86VXdXVPA17VNdE/TCcSsAArsAEZKMAOhBvDTeAmcBO4CdwEbgI3gZvATeAmcOtw8we3D4t6MVhgBQrQFfzO+4fpRAIWYAU2IAMF2IEKPN2a3yz/MG1+C/3DdGIBVmADMlCAHahAd3s8E8/1aI+FaWE35MF14bYwLywL94V1YQN7+J9l2CfTwmXhunBbmBeWhfvCurCBy+JbFt+y+JbFtyy+ZfEti29ZfMviWxbfuvjWxdeTwlmDfnJduC3cwR7sZ/H5ybRwWbgu3BbmhWXhvrAubGAP+7O8/WReWBZ2nTpYFzawB38wLVwWrgu3hXlhWXjx8hjn0YY9yIPrwq452qF3VgXLwn1hXdjAnhiCaeGycF148fU8cBbwn+z6fbCBPRUE08Jl4bpwW9izz7gmnhCC+8K6sCV79VoyLVzAY2i3jF/GGG5p4xdafynrL3X9pcVb6PkLr7/I+ktff9H1F1t+acf6C62/lPWXuv6yHkFbj6CtR9DWI2jrEYwX6XkNxpt0mf9PW3/h5bTHS3P80tdfdP1lvHt5+xjrEuUvtP4yLm8fv9T1l7b+sh6BrEcg6xHIegTjzXr+0tcb3Ncb3Ncb3NcbPF+v5y/rEcyX6va/Hr/97R//829euHpOC/KyVYca0AI4QAJ6gAbYhPPGDAhlDmUOZQ5lduXHQ58loAdogE2QI4ACSkANaAGhLKEsoSyhLKHcQ7mHcg/lHso9lHso91A+r6mcz4gzWQ2wCWeaGkABJaAGtAAOkIBQ1lDWULZQtlC2ULZQNj9mH4YIkIAeoAE2watjZTx7/ED8CdOTNMmCvHp8ECWVpJrUkjgpPSg9KD0oPUp6lPQo6VHSo6RHSY+SHiU9inucCaRYUD2SKKkkcZL/7RlRXg7uzxWvBh9ESSWpJrUkTpKknqRJ6cHpwenB6cHpwenB6cHpwenB6cHpIekh6SHpIekh6SHpIekh6SHpIenR06OnR0+Pnh49PXp69PTo6dHTo6eHpoemh6aHpoemh6aHpoemh6aHpoelh6WHpYelh6WHpYelh6WHpYeFhxe5TqIk9+gn1aSWxEmS1JM0yYJG/DpRUnpQelB6UHpQelB6UHpQepT0yMgrGXklI69k5JWMPC9dlXOyoq97NqknaZIFeTSeVSK+2tmkknTqndUivs7ZJE6SpJ6kSRbk0TiIkkpSenB6eDSe9ShlRGM7qSdpkgWNaHSipJJUk1oSJ6WHpIekh6RHT4+eHj09enr09Ojp0dOjp0dPj54emh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh4WHvU4kiipJNWklsRJoeyFpiJOlOQtR06qSS3JW04/SZJ6kiZZkMfbWUvkJaWTTo+zksjLSSedHmfxkJeSTjo9ztIhLyOdpEmnx1lC5AWkkyipJNWklsRJkuQefJImWZBH8iBKKkk1qSVxkiSlh0fyWbPkpaGDPJIHUVJJqkktKT04PTySz/lWXgg6yYI8kgdRUkmqSS2Jk9zjvIMeyYNOj7N4yEs+B3kkDzo9zmmsXuw5qSa1JE6SpJ6kSRbkkTwoPTQ9ND00PTQ9ND00PTQ9ND0sPSw9LD0sPSw9LD0sPSw9LD0sPLxocxIllaSa1JI4SZJ6kialB6UHpQelh8f5OanYCzMHef/L2Xc/6gYHcZIk+eQkO0mTYmrSqBgc5D3ux0klqSa1JE6SpJ6kSTEhadQJDkoPTQ9ND02PMXvoPHOLiTuj0u/8jB+FfoNaEidJUk/SJD+qdn59HkmUVJLq9B3VfYM4SZJ6kibFvKNR1zeIkkY5LZ8owFFM61/DCswZR4yqfkYBPqP+nuvyDxqQgQLsQAVmoTKj7p5Rds+oumcU3TNq7hkl94yKe0bBPaPenlFuz6i2ZxTbM2rtGaX2jEp7RqE9o86eUWbPqLJnFNkzauwZJfaMCntGgT2jvp5RXs+ormcU1zNq6xml9YzKekZhPaOunlFWz6iqZxTVM2rqGSX1jIp6RkE9o56eUU7PqKZnFNMzaukZpfSMSnpGIT2jjp5RRs+oomcU0TNq6Bkl9IwKekYBPaN+nlE+z6ieZxTPC2rnBaXzgsp5wUQfwTwfwTQfwSwfwSQfwRwfwRQfwQwfwQQfwfwewfQeweweweQewdwewdQewcwewcQewbwewbQewaweQfgL5vQIpvQIZvQIJvQI5vMIpvMIZvMIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcolYzkwRy4kp/TiABCzACmxABgqwAxUIN8y+6Zh80zH3pmPqTcfMm46JNx3zbjqm3YwdJh/86KIvZxe9f0adawz4V5QDB0hAD9CA8yX0LJ/w7yeH8xX0XPHev54cTuWzZMG/nRxO5VpmV79DDziVa51d/Sf4V9NZ3+UfTQ4lwJV5dvU7uLLMrn6HHuDKfXb11z67+h1cObr6a3T11+jqP4fw/TPJQQK8c/uIrv4juvqP6Oqn6Oqn6Oqn6Oov0dVfoqu/RFd/nV39Dhrgym129TtQgCvz7Opv/Lih9byh/gV/vgf7B7yD37WzV9rv2tnl5XetPv6k5Z+c5V5jERV7/Hf2/+7/vj9+Ff/VBeXxa8/BnXMkzO94OQ9Az//un/Jn6aR/yZ+r5vmHvAMFlIAa0AI4wD+DbDY/Bw04lc9ZDd78HCigBNSAFsABEtADNCCUvfmdUxm8+TmUgBrQAjhAAnqAK5fZ/E7w5udAASWgBrQAV66z+Tn0AA2wCd78HCjAldtsfg6uzLP5OUiAK/fZ/HzXZZvgzc8X/aSAEnB+9RxzpKn7Qp/nN89Y5TOgB5wfPL7o5/m9M9YUCji/dsYCCgE1wJVljDT1M0X7B5svKNQDNMCVRw3G+Z3q1RWnNvmYU0mqSS2Jk2R6k3+tOXllCNU5zjNJkyzIK0KozXGeSSWpJrUk9z09vDxsUE/SJPeQOR40iZLco8/xoEktiZMkqSdp0HwDisGfwPG0kTn8EzieNmdKsAj9fpbkj4tRRugPoIAS4AdZzrHiA1no1KK/Bo//Gjz+a/D4H/4aPP5r8PivweOkvwaP/xo8/mvw+K/B478Gj/8aPP5r8PivweO/Bo//Gjz+a/B44F+DxwP/Gjwe+Nfg8cC/Bo8H/jV4PPCvweObBo/JR49905Xmffhj8NHHjn3+V4v//3Hbzt99RHHs0VRHP/LccipAA2yC74jhQAEloAa0gFC2ULZQtlC2UPahoUmUVJJcvc1eZm4xDDRJkyzI93I6hw2899h3t/Le40k9SYN8t4mzi957gCf1JE1yD5s9wJMoqSSdx+xTicfeS2cf+dh6iWav8CQL8v1lBp0q3vPsG8I4+c4v3qPsW7x4j7Lv8DKoJ7ly9NNy9tNy9tNy9tNy9sn6Dlfe/+o7KXn/6yDf4mUQJZWkGkfl27sM4iRJ6kmaZEG+scsgSnI9nX2tkySpJ7mezT5U34vK+1AncZIk9SRNskneh+obVnkf6qSS5Hpl9pf6FlbeX+o7WJUjrl854voVOpIoqST59TtH9MmH9P1qn704frEdSkANaAEc4MfSx/DSAA2wCWMLKx3DSwP8r2yGfJ9DRwNsQm5QldtT5eZUY2uqOXTku1HltlRjUyqaIe+LkmqATaDcjYpyMyrKvagot6Ki3ImKciMqyn2oRhromQa6RBo4dzkZaWCQ/61FGhjUkzTJgnL3KcrNpyj3nqLceopy56mRLgZpkgXlrlOUm06NdDGoJrUkVy6ROJzGJlRngORuU5SbTVHuNUW51RTlTlM0NppqkVacxjZTTpTkRxXDRL6FFOUWU5Q7TFFuMDXSzyBNsiBPP4Nc77y6Y5epI5LOWZkxks5ZZDGSziBKKkmnimXSsUw6lknnrKyg3FCKcj+pkXScxm5SLZLOoJLkHjHoM4mT3EMiEQ3SJAsae0g5UVJJco8eCWsQJ7mHRsIapEk2aSSsQZRUktzD5qDPJE46O6cOmknMt5cagz5Hm0nM944agz6DKKkknZ1TR49Bn7PoYwz6nO8oY9BnUE/SJK9wohj08VoF74QmH/QpSTWpJbnHmbS9E3pQT9Ikm22t5N5QJbeGKrkzVMmNoXzHjEmcJEk9aOwJ1WLoaFBJqkl+zBxDR4MkqSdpkgV5h/MgSnKPs8KLvPTLc1XxYa2AFsABEtADNMAm+PVxoIBQrqFcQ7mGcg3lGso1lGsoe96KusQBJaAGnMp1FoYNkIAeoAE2wTOYAwWUgBoQyhzKHMocyhzKHMoSyp6i6iwj5LM80lOQ/xdXnrWCfJY+eq6ps1jLwTNNjUevQwmoAS2AA/wIZT6ez0JHzyu+jNERQAEloAa0AH+xPeJF/IgX8SNexI94Ead4Kg+ipJJUk1oSJ0lSn9dpPJVrlIA86Gyz+leb/avN/v+szY56ulPrrO3zpkrRVCmaKkVTpWiqFE2VoqlSNFWKpkrRVCmaKkVTpWyqJZpqiaZaoqmWaKolmmqJplqiqZbZVB04IJRbKLdQbqHMocyhzKHMocyhzKHMocyhzKHsTfUcivGm6kABLcD/qs1W7GAT/NXQgQJKQA1oARwgE7w5n0XS3pwdaoD/lczm7CABPUADbIK3awcKKAE1IASXLQeXHQcJGw4u+w0u2w3S3G3QkYAFWIENCDfsM7hsM7jsMrhsMrjsMbhsMbjsMEijL3pgAzIQbgVuBW5zGar4yhm7D8YSVI4KtETsKrhsKrjsKbhsKbjsKLhsKLjsJ7hsJ7jsJrhsJhh7CdZ/iCLcgXBjuDHcGG5z4dbooZk4l22N/pixyutcYWpgBTYgA4du9NSM9T/n2lEDCViAFdiADBy6Nj+eAhVoiaN3eCABC3C0kmN+QwUyUIAdqEBLnMuxHvMDaqy6SliAleb6qzS/oQIF2IEKtMAyV16Nrp/AAqzA4Vbm11SgADtQgZY4Q7rMb6pxAwoVYAXmzSozNuOTaKz0VWYUtvlRFCjAHk2ujCgcaIn1ABKwACuwARkoQLhhIbmCZeQKFpErWEKujOD1cxvBW+LrKFDzhEaYOs7F4dr8Qgoc9+18Vo8wHdiA40Kdn61zqTjHDoQbw03gJnCby8NFoV0gbgsWhitYFq5gUbiCJeFKrAF3Tgk7oheffd5PGZX4/mrA8wHu0AM0wF86zk/EUmLuEFP7X4//8K///n/903/8y7//23/5j//+z/98/n/xH/7H3/7x//jPv/23f/rv//xv//G3f/y3//mv//oPf/t//+lf/6f/o//x3/7p3/znf/zTf3/8v49I/Od/+78fPx+C/8+//Os/n/S//gF/fTz/02Jnl4P/dT1EUsD6VYV6nP3VU8F6KjxeBS9L0NnHMSQegfBUoj6XIO8odIlHyi6LRPsi0Z5LtLObzRXYZ4xNgdYvH4PvVDqOQas+PQZ5LsFekjYOYowNDQmmywq9xe149MW2Zwq6aRJ8Pi9d4RGC9EzBnisox0loR5N6vGh8EaBds6RzDuI4hscDPzUew2lfJGgjoWjYTwX2F5JwIfXZZaBtg+hxLx7PxPq0QdCmVT5egrJhPzrrnx5G28W4Wl6Kejw/DNkdRm95GLScin67I/25hvdGusSYKRkK18/kkWuiWdTHM/j5mWwa5+NVreRdebzLrLfla6iX4/PrUejj67E7l8cbTzTSx8vQ0Z6fS90F2zkININNl/SrX69q2bUxn8I4NHpBM5UXzqWq5rm0trkvm3b6eLjHzX083Jc0/jivLxp99zgqmq2MV41vx7FJorX2bKnV6nON3XGUxvlY1OfHUTfttFkeBx+HPdXY3xk50Mr6l7j7diRlF7uWCbmsd+a7xq6lepX0bGVkzzV2LbUckQ0fYxr9PY1W8xHZ9HlLrZuW6tPbR/QLjqLK14ipm/ZhiJdjuRg/JDbNVEomVCm6OYxd81DJq3Fye66yu7W+Bv+8te1589g21EfUxUV9jN1yearSyu4BoZzn84iT40kya/WPpsN25Kvgo4OlPW+oZ5L4g4+Y5rNL53HIprG3TVN9fIbGgTy+PddU9vWdsOmn13R7FI0yfbR2PD2K7StIlSWxy9NXEN48+KvghazXta3LZY1W82q0yvJco37+EsPtj77UtSM/INuXyG8vaOAjtO3uyqZ1EJro8lJY+tcXB960UM3PWK32XMF2KT1Ow+y5wvZK8JHtU4Wef4TS7oGv2S5qXV8qv8aJ7B73PjYzjoP1eEujlfyof7Tx8lyjfd7G5eMsur2iNT8mH13O9fmZ9O2LC7JXfX41tq1D8Vpqpb0Xa1bztdT0+VdtPz6NtU6fxlovfzTWzOIg2uO2Pr8S2w+ngqfalzj52j77pn0q1bwY5ZC3NOyQiDU7zJ5r9M9jreuffJ40yl6XVkjeauMNL/itb7pMtv1HB/qPlpvyreNm1y1aaqbQx/vT025RrdtXjSNfNex509hqqORxqNHHGnaUNzWOmhr0PFS0f5o2VD9NG1sFySg5lkvxQ2J3KYyQx798G3y9FEYf9zVvJa618b1EgcTyOf6SxKUub+PtB73gy+BNiew1ekjIWxKcvXmPcbDnd2SbPvMl4dFp096RYMu3rq0EfzyEQMf2AR93RJttBhHo83GI+vlAxNE+HInYH8Vh6KFd4uyHxuZ5pBq3xKhsLkbfjmdkHx6pLidTrL3ZOJ4PrByb76QuIdH708vxS864NLqzG2G6moS3Iu0o+Y1zqG1Etk95DKDK+rrybfByfySUOfDRudA2R8KfPl9pN9R08b18fyroHCHaXVT5+DG9PxDB3e3rMMD3A9mNNV28pruhpovXdCtxx+XQjJhHt/nucrQPY397GI8ElG8+xJuWvhtpqsVylKguj0l5QaLmN1etS+/7dwndtfQ8isfHzlOJq1ejbF7N9yI9u524903E1d2Qfc/eiQfqs5PZSVwep96NRVz8Bt1K5GiGLG8Nr0kIBoh0I7G7Gl5+NK/G2pGn5ZVLir4rXnurf4hs2inZ0qdoxd5rqVri5ZaN9Xkja/sR0Yz95Yo8mttXCfp4dGd3FIyvnqabo9hJ5NAd6+ZEthfULJ4LUpneC31pnbKtv5s/pGb/wGMEf5OS28cf99Q+/rrfS9zwoBSUs4ns3sV4G/2WHSYPXrLhCzH3eMZSPm5376e8HQ4VRmJ/+mH7iwa+gfT5Z+lWo2Lsv5bnnQ2/aRwfazTKT8JWjvc0Kt4/Gm007NKn/iMV9Lc0LvY4XD2Ovcb2mta8t42f9zlI/fx6XNT44Fz6MpypH2usafm1NlbyC5dpcz12T370QFNvm56H7YF09KGs31HfD2Q35nT15u40rjb2i8fxfgNB90XdJcPdyNOjgwVlLmunwUs3RkvD2MDzltpl1wWSH4Vl0z62I09Iho83NwT/Y9zkheOoR36r6+Zy7B+5Fd8fxk/fDfXYi5RFRN4Rufhh+NvJXDuO3VeM9riqj4G054M2pLse1AM1e7R2o3zv39p+T+Vwh3wppnzlkwxvuropBPh4tEM/HqnQjwcq9ONxCjL6PJNuO3EvjlR8Psjwedf8rkf8Yte8yR1d85dnfjxP5rvRo2u9czfMotnOeNB8tBX70v/7raJ9N3p0rYNvL3Gpg6/shn4u5vHtxciXuGKbWoZyfNyvX46P+/X3Ehc/rfvHHXP94345uaFbTj7vlStUbuiV23279Yq36uUwLgs8BmGyJ+vBfe2G+jZZYjfydDFctxLXwnXXOK6F626051on+HZe0aUmvlW41MS386MuNvH9HKuLTXw3uelqE99OkCo5IFBKWevG23UNXyhlPlv5ucZ+Ik6hrMUvZVX5Hin7eUWXImUrcS1Sin38YLt+OWSTOLYzxvA6LOuY5PcZY5c1+ucaaz/JKzPXDsm+yUOez/Yqlbevksub5Gbq2m52E945tNGbEhxJSLm/KdHyKNbhojclpL53QYuv9BShX94VwWNhLDf3zq01BIxt7stuRmGV/Fo557G8pfH4hsXklU0Tuziz8dFFurm7V2dp7jSuzjjtm7htn341bY+io6Jej00W480ltZqPSnt0yj17mSvbuU0Vc5vquhzEtyvKm9fSx/MJFXPriOJ3jd1zn5b5c4+uTn16NrL9dMp+J/3y0H4hr2t+tDxQnmrsn3ScNRr0paLyx5NuN8PJMDvyWDsavn3fb2e++tI3s7tjMymx7IZ7NEedv5Rx/2iqu4lS6Ls+Dt3cmN1bLtY+EaPnzX03RenR/Y2pF1Keh8zu7h5Z1vD4Jt+1sl1vvkn2gJvtXmP48wQg8nkC2E51upgAtuNOlxPA9t7UfNo9xhjKe431q4g9FdlPW8/FAB5v5s/f/PcaeVlL3U3j32nULKouXxY2+K6xq9PI733V9+atP8Z6c35OW87kFY1HZ2eOB5K29zRaDkzwOgj/kobv+DzHBJbP3Nc0sHjR2vn7mkZ+PLCW59fDG9HzJxX65OlL7L4qg3T2gUxd1kd5fBG9L4MlYx4ydSOze/suGLV9sNBGZtt7yIolgdZOt5dl8rHDchxvnxRWf3ic1O5otssMKNYYaUrlbRnGQLB2ffuGLzOgqWyOxnbdq40OrJ1Ajd+WkUVG6W0ZBEM7O9Gey/Atd+oXmVxI4bxT/W2Ze2441vx5ML+byddJJf09DUNZp+l7TwM58mkgRO8dh1B2fAhtMt5eQ1FIvbumu/KyW1ao6eiN1s70pooimlXpeFPFlmOxujmWbTFkx0JIm8/BvYZhxZ0vU4Nf0NCGbgd+/ja4/7i1gm5cs+cflXU3lnWtaH8vcWngZC9xaeTkl+WH8FwmW17mvjWP7dwlzIE3eto/v5coWeRujw+Hd/rnKxOWY+LNR8teRSyvR+20+fQpx6eDHnuJS4MetZQ/Oujx9XKUty8q3iEfKvKmSq94ve68yUOfz6Sqn8+kqjfMpLp+OTbjUb/dGl1UNouY8aepbKtwrcxh+zJes6LywdtHTPt0QHwr8ciG6D/t0t4U6VgX7sH2pkh21D9Y5Z121ho0Gpfnq3627WIttyzsVgxdSl96DPk9jbVf+hUNRvcYr5H3gsbj+Ev2On4ZlfqqwZ/Pkt2u7HZkFd7jm3G9uS+sDkdYOevxDvFUo7aP6wT2Etfycvu4TmB7MQoW8ylf1tH5dhhbETUMN65l6j9Eyu4D8UKt1P4w8HnYbB3hf+lcMHrCR2lvi2S35dH0bZH8Yj7eXMXw8kqI7dPH5Vbh0uNyO2J5sWRqv6LjtZKpKndUBe4W0MKzsml5XnRad2Na14pO63ZE61LR6V7iYtHp7mqUgiku8l5Nc6s5s719mSfz44ruelOyV12WtebKt3G1bU/ZUfGxvraw9rVxbFfeu3ZF+74eOdqXHpv5wlsN30B0aPRe3tOwrP54PCDoLY3HN368JttR+LnGbmj/6vJ9+mkS3CpcSoLbiVwXk+B+GcKLSXDbzi8mwd0Mu8dLU07BLP354nt1N4GKeraw89MlRb4XbWw1MM+/rOUSPzS2i6BemrCz1bg4YeeXc8k3oHLU8lxj961/acZh3Y40dSPcF1secd8n3OyP5NKcw+0FKXTkp88jJb91UQthQXta0sd3DasfX1TbfR1fnMa5P45Ll3Sbxi7NFNwrXJkouC1wuvaM3C7B3HImVV0n+r20jLPl+nftSw3NS8s4Q6O8uYzz5aWgP+4Tk4/7xLZlWhefb/slra8939p2Lb+LzzfZzrq+YVVrrITztTj6FQ0s/fDo/Hm+1nijjxeUbvTxitJ7iYthv72iObBe2MrmauzG1a+uHbN/UqeEyfPFxttuQtXFpWN+0bi0dMxW4+LSMb9pHB9rXFs6Zq9xbemYVj5fKmWrcfGV8upxbDX21/TS0jFtN/Xm8vXof/pcLi0dc1ljs3TML23s0tIxbbdl1NWlY/YHcm3pmLYbtbl6c2v7vLFfPI73G8i1pWPadjW/i0vH7A/k2tIxbbuY36Vvjtbo82+O/XFc+ub47Yl7aemY1tpe5MqSLVuRayMuv57MtePYPbYV+x+QPP9+adtdoy4uHbN97b/0PbhXuPQ92D49hr3ClWPYD7JmZcID7X+9NVDb67LP2/GehmDAWKy+p6FZAFPs4Lc0HgNP+Yw7yvPrUVv7fNR5K/JoE/ltq/1pydhWwrIbSaz09yTwhW38NHFcbh3tzRZWoFE3rWP3jX1t7HsvcWnsu4n8UYmLyXz/BfZ3629euyeYedTt3cyxHMe7GtgS4oHvarRySePjJ0r7+InyS4Vn9kVZKW8WiWbF2wOfVkRtK2YvXYpfJC5di20dc07BLF8XnXqlFjpfRh+9DP1NDWzFrP3d48CEdO2bTXL3te4NVeprZfeLFfOrymb61W8qDSr9+ZyItpvvdHG2b9vuHnVttu8v9f8Fy2vYUnn74jXBtvBqx9tzEdZjqW+r4MNFrW1mUm7nlaIfuO42/96u05NFAaWssxG+rbHT7PMnv33+5Df5oxIXl6LaXc+Kosraj831/HR9sO1RNLw7tC/TuL/t7Xp8Ptefjxvm+m9XgSpYYXEt9XhpJal19c3n16NsV6W4uBzVVuTaV8de4tJXxy8SV746tsudXXoF2StceQPZrip4bXXa/ukx7Dqx8t1D1qLQKlcFsM4Rf9lvTa8KdM0B1v5le9pmb0lUeSrB21X8MnOuXdfle2fLViK3deWlZ+CnxG6Ts54F+n2doPd40fwqsp20xNgJa5E4vkvstjshdLc8RsHeFMGXwuMxXd4U6VlzU9ZtWV8TqTmy+Tgmevd00H1Uj+ens1tt6dCcYEfryPf1xo4qf1q3DrbLx1By0PvLvsEvCKC/Zq1EeEGA0aVo7wg0zq73dY23F44gX1DKMif+BYGa5ZtfFlX5JsB1Wy6dtb3Ly945D/31Y6jH5hg+/0Di+vkH0qV8Vdc3+BfaQxY9tfZWTDRqf29M6QWBT2+mSA4nPfD5DPGdBPbEld6PdyT6kReiH1XeOgrLr9R3JfqR6xD0o791LR5PijyRWt47iprzB3vdrOxwVWLTFbKVUEiYviXRsnO8t1rfktD8/ugq70m0nIfwQHtLQrLzskt5745wVsD1tVDqFYmeA+Fd34vULyfyrgSWj5T+XrvATt69U3vvKHKG3EOC3zsKxjqY3D6+I/S8dbJsp1FdXVVmGyf5svpu2ziLK7AWRKW3joOEMWVH+L3Uc67RjlpP1jdFBDWn0o/+nkjHciHnY+5NkazVfLC9eWEVd0eU6M0jWS7sbjkl70h7KnN5bTHe7gl1eW2xX2WurS3220ldXFuM9/OBrq5Y9ZvM50nhcbt5aXjybsPLivoH85txZEv19lqf+5oIVvF65P+3HuXUCQugdnrvPfHxh1gxsK+fwy+KdIjY5vFxw1AT6x/9kqJe8gX+ZH7vipRl0Yvy7mUtFfemtPqmiCxH8m5TqwdmbdVS3hRpiwi/eWFrXUXebPR1qZCt+u416YuIvXmL29LYWnnzFrdjFWlvthOstvv4xnl+d+TYbj5ScxmOB29aym8yWHmm1c3Sc3KUO549vx1Njtg8ePPx9spJfSCTdebn+kC7Syz/O66N4aTa0e44qQ9kvHY6ZDZf6kLH/4Zrg10HH9z4lpNqbybO48BaTsfx5vu/YRW1vltfePt1dnGF8Y0GNqrTdXS8Xx5EyPuyDn1++3sh/cNnkSuw6LqU3Lej2A1TrXMz63sKiuFPfVPhQGflG/eit4q+tXU85vqAzmN4LYflaVkT9xWJtcRA3xpWqpkzGq0V8+1yD3hFD/i6RAhfHknOjySW9wTylYbXErgXBHJx1C8zW98SWHoGXhBYx/OPtwSwCrC1dwR6Tp3o68DWWwJrXnhBACu0HG+dApbs1fdOQbMHQtcZaG8J8Fu30fKZae9dREONbnurJWKNGxP5UKC/dRvpyFFeOuSty6hGeNQuPdxUrktg4wo71nWKy/eFDHaFIdgvir+sXPQtP29F+NBcJZzKsRGx3cB3PrZLL8/mm+2PgyoqZUTeO5kvY5VyvCuST05Zd8B4TQT1yvKltP/6s9MoP2GNloqbF5rZF4nlS/pHM+PthtBLUe6yPF8rr1wOwuWo794YXSrbbNPed6uhXL0xW5FrBbG/nAxWAFnnrL4WvCW7O7m0TdDshqiulSnvJS7VGIvwH5W44a4wJPjLrqg/LujuO4ix7zh/2Qz+eEUEndBf1t54SQTlH4+htnaDiLx9JNqXrrQ3RbCvEPX1c+C7yHZEyQyHYusGZ9+X29rKtJ4LobV1ns8Pke0JqWRnyFqz/OOE9kkAuy192c/re5vdLTNVlm3S6GmK3y5UdamEey9xqYT7F4krJdy7j170QBRt7xUOL2UYS2J/9EZ8OQ3dtS7FhmLHmxJZx8frPsLfJLafXDgN2xzD9g0VFXCyZMJK394/9OOmqfsMVpAG3zyMLxlsrZ94SaSzIYO1d0UML2TLK/trIoqsvi5T9b7IWj/xQ2TbSPLJ3zptRHZTlErBbqJlHUd7USTnXRaxN0XqsaxBT++KFMyX4rePBNPX67Lg1WsiDflw7cN7USSXNyhrbfWrIlmy3/q7FxYTMh7vd+8eCeeUjHMK1dsiy+Srd1ssZ6//4y2gvSkitOwXr2+LYFdxefeaIMc+4q8/Fdn29+bzf625bpcfe4QXAFp7+iq/J7HM2XlFAh1dtHaVvSZRINHfk2hYd6+9dSKcfWX8ZV0TekPgyyIvlwWubed1cUSJ3hK4tNjntgP/ypS+iyMAb12DYpjfY8uTvn1fFbxslyfPqaJ2LJtP/hTZ5AjGqDh/qVP51ia3R/IYIs3+V1qWfv55JLobUshpV3oslYnfZ9X9IpLf+bpupf5DpO5ipHTMEVx39fx+TbYiNVcMfSC/K3L17uhuqIVwTZaXuZ/XZPP9c3XOY6+7XqlLcx77bjLU1TmPe5GLcx73IhfnPO7Gc48cRqu0LDr8I252S9w9/rBgT9y2dJ78lNlNnOSK1WnXPUHrS8dSUQtYm21SQas3pIK9yMVUsBO5HDtNboid7Zpm12Jnu+Te1djZilyNna3IxdjZi1ycL/zL6VybL7xPBVePZJ+Urh7J9oGRNZYP1HefOthBqh301qtuRSF8XR6h+u0weLsFw5Vila3EtXKVvcSlgpW9xKWSlasSm6KVrcS1spW9xKXCla3EtdKVqxKbuou9xKXyla3EtQKWvcSlEparEvzmTb1WxrKXuFTIspe4VMpyVaK/eVNvKGchzHOntqy28j3z7WY0VcqKx0rrC4N832xJdy+XuUB/PdZZGd8W7up9MzRfe36onutTb0S2R5IdfI8RcX0ustv36fLrnJYbvuy2Ile/7PYiF7/slG54O9U73k7187dTvePtVO94O9U73k63MYwZwo9PqLaJ4e3GFFjIeH2d+yFid3xN2R1fU3bH15Td0V7t8/Zqd7RXu6O92h9vry3f2GtbUuP3pqa76VCVcqnVSss0EpJvGtt99TD9ta9v7d/2wjwubhtb31O4MmvhF4ULsxZ+uSWE7U+WGQM/b8nuy+EglLW2/vyW7L7EDHVcx1rl901jN+Op4ROmyTr08LZGfabxwkV9/m6l2x2UsL8FrT1uP05mu+9Iw54htrkgu+0cDsOyALSu5POJytMbvH3tPfTKa6/d0aFjd3To6B1HorccSbmhQ2cv8nGHztU35z/brXT1rXmXQ7Dj8/I9U+xbvOwGVCrhSVmeSuyOgfLtY6mJ+3EMuz66q29BWunTtyDdbQV19S1oL3LxLWgvcvEtaC9yMfB/OZ2P16DkiiVb6/K0fKULtmcZyvL+8X3DQt2tIH5t60XdjQhd23pxL3Ft68Xtw8mWxXOe7pum+5Gg3E/8SxE6vyDB2NZcNhKbR/UjxLJWipYp1t/qN3U3HKX5RDEqm8PYbbVRsW91Wzbp+b4319V70p/ek20DX1ZAWSu1j2+3lXeVGJfmWm2LelCd9KX383jhRPpSQl82J1I/jtXdRlQXY3Ur8XGsFsKq8uvaOD8vxm5JqHMRsziQx8DHs8r130TquiRUfSqym8unFb2w66Tt76cj2ynLWZcoR8FLoPbrGoJ4k3WF+1c02Bhz+WSjsZvchJUV6ronhb1wHL3ks+1cH/H5cew+evqyWsVakV+/35hd9dTxd6vpfkj0P3s9lvvS1+XuflyP3XYQkuu5si7lzd+Pox+f9zTuXo3R8dI6lXfSaROCRNk8F/rn6bR/nk775+n0tzS2rCfX+dlmUNrvyIU7kWszCvfplLNXvXyZDPj93uq+DhfVwEvp+49vp60IXqPKUXYi5fOA+UXkWtf8VuRq17wq3/BRuhuPuvhRuhuNuvxRuhW5+lG6Fbn6Ubpr9JXqMhy8SWi23V0h59GVVjft1e5or7uHph74DKrPH5rW7jgZvuFktvem5Ko+9cs2BT/uzba9YvfDdcO/n6ejf/reYIm+dQWv7zfHjuPzs7GD7jib3TueoDK2993p7F5YjwMzJnUnckOD9Sm7n16T/emgX6iWL5Okv59Ov+MW39Jgr736Poaw3vusES+fH581fdnp991Po3Uq6jcN222XeX0u/Vbm6lx63W2SS3WZ5VvXeTI/j2UXgYRhISrrJu7yyrHUvEFUu9HmlLZfnrk/7KP7ip5/ae00LHf2abSsk27fb7N9/r5m5YbxmL3IxUqmX0Sujclsr8nV108rN8xRsfLxHBUrN8xR2YtcfP3ci1x9/dz2tnBdtuN42vtku+GqmsmkrmUh5ZsC7fonUMvd133hi347Fb0nk/QbMkn/PJNUviGT7OYdXM4kW5GrmaTeMBdxe00uZ5J2w+iqtY9HV63dMLq6F7maSdodo6vb7lI0knWNru9vnrvBq4Zl71vR9jwN7D8f8fpapb/7+Xix28XuaK18R2vlz1sr39Fa+Y7Wyn+6tWIPbmN+3lp5Oz6QW84xrVWA31rr9nuaiSDCshG5oXx+K3K5tcodrVU+b61yR2uVO1qr3NBat9/1X5YU4Of9arZr8u3IAa12rN3rP5raDdn1l76Oq+31juza72iv/fP22u9or/2O9tr/dHut6Bl49I1t+qG6XOzqWEdgf7TXfkd+1Tva6w0rNZje0V718/aqd7RXvaO96i1vA7vx8ZIVJVyWVmKvjLG3HOtnbs+/+XYjSo8etZyiSOveUccrB8LZCcyyLCT040B2Ix9/dzOCb/XevpvHawrftzP4peLg4kt4P24Iu+0Eqatht/swuRh2uy+Ky2G3FbkadluRq4+JrcjFgtxfTudaQe4+i1w9Er2hNHj//L16JP2OI5E7jkTuOBK+40j4jiNpdxxJu+NI9v1p1+aO/CJybdbGvh/66jUpNyyQ8stoxcVrUm6YyWK7+V+EJR5JlsWffg6N7R7Cmh0M1Y7na8DtRSwXkqvGz1ejo2M3hHPLi0k1lP8dy1rNPw+l0IevJuSrEnz4brI7l8cxH6nB23Npn4+S/6Zy7T1pr3L1Remh0j9/U3qo6KevSg8N+/xd6ReViy9Lv6jcUSn2pdq8Pq82f/RF7ma3Xtui5Jdys6td7HdUNlq5o9HWWxptvaHR1lsabb2l0dY7Gq3d0P/yS/Xb1aaidzSVxnc0lSafN5XW72gqrd/RVNofr4Qt2d9X62ay1VakHRXvGFw2SXL3rXCPyrVtPn7RuLTPx28aVzb6+OUOX3zJ/621XXvL/yUxXT6WfZK8eizllmMpNxzLvhz96vRmveEObZeVx1yjZQy/X97Ylo6eq4Cf/GxSy14C+0ofuiTZFySw/t6Dl3f8FyR8VH5KrMVEr0hgs/kvZduvSGTP9CnBb0g8/mxZRKTI0xyy65W6ei57lWsTjY7tc+bCJm7bercr+6+dLffPanx8Jahgi511ExfS6zO9C6qayzq9+V0JeUuiYp52PfQ9CcGituvUlRckOOcmErf3rkXFxPl17v3bEu/d1HWZy0rvSWD/uSbypgROZF0C4BUJ7OvR9L2b2rCDFB/Hm+0CqyGUt25q6xgKf+tiomlyeX4dHhl6V/uhuehoUV2bxeWjyBfRdYT0ldPIHtEvy4y9IMAYG21vCWSPHVt9TyDXnLb2mcCXFadfuYhYm+ytXCm5xJFU+/AI3ruNRHi9K8fz/vWrEkTvSBTLoYJ6rJeyXI6IemS2rl9WxPgmMebaPO2VKNkngQ69y4sJlZ7dK6Vvym6PzzsAdvdD8MSQrm9J9I5FY+ytjxcyvOhaeU8CKyLTsZTLvyKBScG0Lqr8kgS+oUjfO4pqeCWy946Cc5iE1pT/kgReA1jtvRPBTa3lvROpDfuw8Fsn0nNeSW/yjoDldtzGb52EHX9vNfhXBLJNWecPT+E9AS652+t7aYazTQu9dQSFGzbeWzqjjb8l7N2UqUdfay51UZaNokW+i9D22YEdhpbd0n6K7D7KuWP7PF6X2vrRpU27caVC2HJyXR24fCs7e6i07beg4FvQ3lVZNipqy0Dz31HZnVHJ1l5Kf35Gu9vcsN6VLEPNP9vKboFeIkwmWwYu2F5I5Mt3EC0vO3Z964PHcygz4ONLCCmQvzeT3bwpwlyyx79b3jX4+yVp20abbW3po6z0/Z2p3VDT91D5uKjvoXFDBdtDRT5/4P9yLBdf5M7m8PmL2EPFPn3e7TWuvoz9cj4X3wp/afvYqvzxMiSbtr9bC1B6LlnRy7JWk31v/NyuvhGth3I9qRC+pR+89Af8SAjbWVTLcMGXiYPfjuShshu2wCLXj1GQpWui8AsqFW+rj3c8fVdFsrOm9i/zFr6rbNecuLT63ENj94Jwbfm5kTl2D9Nri0U8dOp2DOHSahG/Hc3VSd6/XJprM7QfInJDSQHJHdUnJJ9Xn5DcMSRK/YYvz19ULn6zPVTK54+Q/bDV1UfIxSPp/O79ufxw3g0bXX8479b7u3xl++fXZLt44fW7I3c84Lc5+9IU+EdQ7IY3L86B3x/JtWXYHkdyw7JWZ5DfkSPv2MfqodI/z5F37B/1ULE7YtCOz2PQjjviZ3s+t8TPtUn5j/Npu/ema7Pyf4mfa0vlPQ5lu1TQtYXUHir9jgDallBeDiCzjwOoHDcMFTxU6IYAKsfnrwdbjcsBtD+fywG0/fToDZ8euvkMKsdubYyOTQR0GfL+/kVWfllFMFvcg5evqZ8fdttVZbLXiftSQEU/D8a2/UX50SDrHlfl+z2i7XDftVUYzuHEzQP+4jIM+2O5unDlQ6Xe8IgvdMfMkUJ3VFYX+ryyutAN1cwPlTv6wAp93ge21bieoeiOPrB9u724MgT50rtPY+ji0hC/Hcu11VIfx8I3POVLuaMrodwy+6rcMPuq3DHjiUo97oih3TjZ1RjaaVyPoXrcEUPbpxm2UaAvG63/eJrt1tJrNd8V2mN86GkPWNlNIH50x6FEYHnh+D4dcy9ybVfth8h237Zr22o/VHYvuBf31abStgXC+Q1f67Km+4sqraM3+tB3VVgzycnS0/+iysWtwn+7utf2Cn8cyx09CqXd0aNQ2uc9CqXdsJXkQ8Vu6HXdq1ztdS18Q8LlWxLuxSPp/O79wWa/RdZ1u38eCd9yZeWGKyt/+JpcfrzzHb1gRT7vBdtqvNDa7ugF2z/JLu4L/zijWz7K5JaPMrnho0zumDpYtmtEX86ScssHYr/l5bbfkGv7Lbm2H3+89V/cqv5xLLz9zLyyV/1DZDsolLOAH13OTzeK34s8zj6fHkepG5HdPu/ZUtjWgvuXjqOhZmqd6/X9OPT4s8dBOc/q0d3Q3ryoPrb/sUjWr3wgsqalsmkjun03QCaoS0nDayLYePrxQXWLCL8rUjBxq7W3RbDnPNsNp/O+SMfpqH4usn7MvSayTiRbJxh+F9kOkF2L4f1xCCY67iJnNzp28Tj2z4q8Ho9nRdk8K3ZDY3zk05yPdVqavCDSLOfi8rG2tG8idTc09mii8ZXdvkyMel+kPj+d61d205tSd8sAU8NGvW3ZrOjn+Wzaq/QDmy+V400Rzer0x4CSvCli2ez7umPnSyK9ZJFI/zJh+jWRfKN+iNT3RPRgLD5mz9t9pV/WJ1hWBqhyj4y9eUo1R8W0ts3F3Q2KvXJK9Y5T+qVzFGWT+87RXV8vSjib6NP1jR8ndMPixA+V7WyGPJLl1eCc9/9Nw274Kq3l+PirtO4WI7z8VVp36xFe/irdH8vVr9K6Wwbw8ldp3Q2KXfwq3Wpc/irdn8/1r9JdAPVcz7OtNd0/Aqhsx2EJU1wPWoYXvhcz1O0g0oEu/ceFWaag/ZShzwNxN3nseiDuJlpdDcTdlK9SBBPq+q7xv3Bpl9Hc1+4QYVe1c2pEeVdGlpJ5KbyR2WXc7E5sjXY32rZD5fk6WHYaN2T+3RSa6w2ulc8b3G762PVs227Jtu2GbNtuybbtjmz7SsOv+m78YOG7s67xefz8kvuxc9362v8j9/MNuytR5VvyLd+Qb3cTyK43/+2g2OXmf8Og2FbjevPfns8t9R2PEdq8tlzL8/qOut34GNOXHw+yzbvGbprU9SrOX44l1yqVusxZ/Cmy7U3A2xOv5VrtpYJSOzKarW8KSutuXExyoqC07Q3ajYpdnIJW5Y7q8Cp3VIdX+bw6vPbjjve47bBlltjq9vb0/dLSkVVk09i2x6F5Wdf1X//Ocez6azXjmHUXx51viONf5vWhA0CWXjT+cT67boSrKwDU3YjYxRUAar+lG0Fv6EbQW7oRdDs39mKJiW+T8fRpemmRmF/O5/Lbgd7ydqA3vB3oLW8HesfbwT5+rq4iUHfTvq6uIlBtO2klS5/J+trdKm8mFd0kle0GXRVLoDV6fiQPlbZt+tn26ctQw0sqWFjOypr2f6psd9XJeWyl8aJi9RWVkqOoZe09/jsqm2RrOQfH1iULf2psN7OpOTVJl/qDSvySSq4P9GiZH6hkla9VflsFZ2TLKMGLKoZaYVN+XyWfQse6adG7Z9SOL4/VV1TagfWKDjneV8nFjY8ud5zRsjjiq8eCIVUq/L5KTvyiVm44I1qGd188FvREt3K8fY8o14/+sgD1+2dUlukMLx5LJUxnqJvr0mi7iNLFRUp+OZascXoMe/PuWPSWY9mpHOiKPnjzBGi7sbLLr8qtfLzx7EPjhs3zHir1hhG3/bFcfc1t5Y7X3FY+f83dalx+zd2fz+XX3O2bC1d0gsnb7z8ty3Iegrxp/dsJZNjM71gWa/y2o8VD446dqlq9Y9G6Vj9ftK7VOxata/WORev2x3I5DusdE3Zb/XzC7lbjehzWOybsbts+FSz7uJaV/mz82w9FTBO05Wvzh0jbbnOYnWnrHmC9f9fYtlrKPXK+TNZ9UaViZdD2vgotKvq2Ci+rlNIdx9Lfv7o5UlbWnTw+OBbbXt3dVziWKlZ5U0OXco3l4fFTZDdSdj1l70aWrqZsvmGP3YdKv6GXsbF+niZZ70iT26tydXpfE7rjqsjn69Fc1ej87j2+/FjeXtnLj2W5Y7m6Jv2GK3vHUnP787nnsWy5r+aXyoYfT9TdvK+eK5n3ZfnwYt8PZLvV/LVNYfYHgj1p9Utp0PGKRh6H6vGmhmEPqLUX7e+I7EaYKfeNY5LNdsyt37GUR+ufL+XR+h2rgja9Y1XQ/bFcTinbgbLLKWU7UHYxpWi9I6Vsz+eelLK87mxTyk6kcA5+FOH2XGS3xiKVksmtLHe5cvuusvsSqxi2aEd/nplsu5QHFpau6ySJ76+Att2oATO6v+zc/ZIIpivWtXb4RRHsfVhodyS72i8p2NVgezrbXqJrk2u3Ilcn17btFtWXJqL9chzXJte2Xa/xHcdxcXLtbyJ0g8i1ybV7kYuTa/nYLnV/bXLtXuTi5NoXRPhdkWuTa38TuTS59vrpvC9ybXLtZZHd5Nq9yMXJtbyb9HUthn85jmuTa3m3mOLVXLLN8ox9jjY5jbdzxi5m+a3I1SzP9HF2/eU4rmV53o2B3XEcF7P8byJ0g8i1LL8XuZrlt0NXV7P8VuRqlr8uwu+KXMzyv4hcy/KXT+d9kYtZ/qrINstvRa5m+fpxdv3lOC5m+dr/bJbvNb/X1k6gn8dhNwTfVuRq8F0X4XdFLgbfLyLXgu/y6bwvcjH4ropsg28rcjX42sdrIf1yHBeDj4/Pg2/3NV6yxvPx4Nvc3t2csKtf47ybEnb5PW0ncvk9jT/PrfvjuPiexv3PHsfV97RfROgGkYvvaVuRq+9p+/27Lj4qtiJXHxXXRfhdkYuPil9Erj0qLp/O+yIXHxVXRbaPiq3I1UdF//xba38cFx8V/fNegX2Wv/g13m/oc92KXM7y/fPs2m/oc+Vuf/Y4rmb5fkOf6y8iF7N8v6PPVe/oc9U7+lz1jj5XvaPPVe/oc9U7+lz1jj5XvaPPVe/oc7XPs6ve0edq/Gez/NWvces3BN9W5GrwXRfhd0UuBt8vIteC7/LpvC9yMfiuimyDbytyMfjk+HgVz1+O41rw+ZowH36Nb0sXJBepKJ2f1z/IdiHDq6ULstsj7GrpglD5vHRBdgNaV0sX9iIXSxd+EblWuiAkn3eWyB2DWnLHoJZ8PqgldwxqyeeDWnLHoJbcMagldwxqyR2DWnLHoJbcMagldwxqyR2DWnLHoJbcMagldwxqyR2DWnLHoJZ8PqgldwxqyeeDWr9k+WudJbIdJLia5Xcil7N8+zy77o/jYpZv9c8ex9Us/4sI3SByMctXuyHL7wa0Lmf5rcjVLH9dhN8VuZjlfxG5luUvn877Ihez/FWRbZbfilzN8p8Pa/1yHBezPNufzfIXO0tkP2/rYvBtRa4G33URflfkYvD9InIt+C6fzvsiF4Pvqsg2+LYiV4Ovf1wy8MtxXAy+3Zytq8FXPy9dkH7DRAK5Y1BL7hjUks8HteSOQS35fFBL7hjUkjsGteSOQS25Y1BL7hjUkjsGteSOQS25Y1BL7hjUkjsGteSOQS25Y1BL7hjUks8HteSOQS35fFDrlyx/8Wvc7uhztTv6XD+fpvXLcVzL8r5G5588jqtZ3u7oc7U7+lzthj7XftzQ57oXuZjlXxDhd0WuZfnfRC5l+eun877ItSx/WWSX5fciF7N8/3ya1i/HcS3Ld+p/Nstf/BrvdMNEgr3I1eC7LsLvilwMPrphIsH103lf5GLwXRXZBh/dMJGgl49LBn45jovBVz+fSLAtXeh5UYvWzfpqWxHVXBvNqLwrkst8PETePJJ6lFwTeV37t/9YnHy7gGQu8lx4v2z1digpW1r5siXrayqGZedstwx332/KGif0iOZlofTvEpsGq1hbTcuXVXLpm0rbtdiSa1lyaWizrbwkkuv5cV1O56fIrjx7Xd12WYnvtWvCR16Tvr0m7Y5r0u64JvLxNdmup6/lyNWU1rUJf6xh3/dTtfKtnvXg3ZXdbU6jWQzVjehtlVzdpq/Z7UUVwyKU6yqur6pkUZUe/diobOdsHd2wWeF6fb+3/t3yhNxyBSJutb2pkXeIm8l7La5StrhHotu0uN3wVmu5rcXjhWtdS7y+oMItM8Lj1OxNla5ZT/hocfyuiuVqYn3dY+PVY+lo/do3KtvJMJdb3G4fr6stbq9xpcVtlyPDSmIPrkuaPL4fx7a34OJmRl32FbDollruzfdX0Vu28Oo3bOHV91t4XVwvrvc7FtTsu5Gui5sZ7c/n6ppzvd+x02fvn+/0udW4vObc/nyurjm3j5+rmxn13YDX1c2M+naBwi8Nbj2UF3ZI64qk8iU/fr8ou+X8mLPDnNn06ZE8VHbTdbH9fD3quvscv6DySAjx4KjrtnEvqkguDF3X7bP/jspurkHu6serRv3+0qSbVFvVsN3O0iXzfdPFvl2fsEouAH5urLjEkLXvOrvug6s7fPxyNBU9RLUb7Y5md2ku7kf5yF6b17ir2xx0u2Obg26fb3PQLy9Bt32Y2R3bHOxVLj8S7fOVt7vdsfL21SPp/O79ufpw1uOOBWH1+HxB2Ksau2uy1bh8d/bX5PIDfpuz8/34y5Pse87WY7uBfW6R9ugLX16yi75wJIoejaWT5+eR7GZ3FXyklrY8U3/kJaU79gJXumMvcKXP9wJXumMvcKU7tkFS+nwbpK3G9fgh/tPxY1khZ0tL+dlqd5t38ZG1evzoHHw3fnJ0gI5DdodStuP8GUBf9l/50Wh3u3ddD6Byx8YcWj7fmEPLHRslaOl3BFD5/PVgq3E9gLbncz2AdgmuN3x66OYzSHe7d1nP1m+67Jf4/YtM634VpmubcP/yeSjo++qy2cFed9O9Hn1O+dEg64jw983JtW4Hto7cpdZ491jdTflqR37ZtaPZ8wS1PZZ6ZC9APXSXobZTei4/4neDW9cz1G7i1/UMtRsju5qhdlO/rmeodkcfmLbP+8C2GtczVLujD2zfbtEL8Gh7fdNu26bdNv90HLdZv3SxvBRD1DHJvuyOhemOpzzf0ZWgfEdXgvLnXQnKt3yq8h3bISl/vh3SVuN6DLHcEkO7eBbNQpxOunma7SbXPEajsIfwsgPK9x4w3a9wiL0O6/LCofUVEd9hdY4rLQUjP0V2jZZyZ7NKa9OX8l1l94J75MZK9VgW73j88l1ll1gqtjmvdryr0jp6o5fisRdVWDPJydLT/6JKz1efxzsm7VS2VzeDqFLbnVG/pUeh39Kj0G/oUdgWk17tddXtQNfVXte9ytVeV+03JNx+S8K9eCTbHsb9lI6Leyaq3jHEq/r5nolXNd6/Jpcf73pLL5je0Aumt/SC6R29YPsnWcEqVHWpPP75JLNbPsrslo8yu+GjzOodWXI3SnY9S9otH4h2y8ut3ZBr7ZZca/LHW3/LN8raljfKH63fju3Wb1kL83jTWAvsvotsB4WuTcPbilydhme7bZKuVc3/chzXpuHZ5wsg7o/j4jS830ToBpFr0/D2Ihen4RndsC7HXuTiTKAXRPhdkWszgX4TuTQT6PrpvC9ybSbQZZHdTKC9yMWZQFY+noHzy3Fcmwlk5eN1OX55VuT1eDwryuZZsRsa4yOf5rxOIfjxrPj/aPu3HMl1LYoW65LI9W6MYRj36wKGL2D71313BBUhjl15isnMUJ2vGbXzrElS4hAfS9QqiNaVLGwH77QvQRZ4fdyi71m2/uf9m98Hkb8G+UHL+qpll6+/XU/hppJ/r8/qjTGP6wHq0Y9fBhlbkmeQZOrlj4LUdds/ytR/FyT6lSQSvX4d5BpRP4LI74I8pgXX61FHLe57WU6cZuZle+y3+z1h6pdVkmtXLEVXjVv3VKnuqNI3i6MzbXK9OLpa650pnOrozn+u9dZqW+xRieuT2Y2veBxfoqxAeT2R9T9fv/+zaVcbWtuz0lL/eFZaunsKw2pWWstD5nZnpeuy7M5Ka/Wlr+1Zaa02xTZnpcsY27PSdX32Z6WrDjROFDhvFuZ0f+lAttyHbfOj8wfPBv8zmaGWm0jHXNJ/NAxe7/saZpWHcK0yqbZFR7Rc7qBeo4S+ihGfA8GPO4Cwusi7QPB+BxBc7gDCsizbQPA7FmnLP1+kXcbYB4LfsUj7k06Iff+f9eVm8/3lx1yq/zaM4+UKx8T9S5jVntguEpY7YptIWJZjEwlxyxghbhgjxC3P5cg7uuHq5bHdbhh1Rzdc1ueebvjfG1/y1/2nrplqC130n9UhdD7Sal6zzJg9yH8So67UfS9g5Wcx9CpH2d9jrJtkBnnost8OVtSu63xYW2STrsdfMddo8Fj9Mv66ZUusbtkSqxu2xOqWLbG6ZUusbtkSq1u2xOqGLbG6ZUus7tkSW+V7db2yHbsJVjX+yPfqx2pLzPt1nR/Dlb/OPR5B1nsme1nd35XlOi3CBe8wfw2yPL90zqaM6Zv6owTzseH1WoeOvyeYP8riqwpda5S6vECfv5L6CJKfM+4RpT5nXD9WL5DtMe4RY5Vd26+L3HsciyiryxNXyn0uL09bv4fzpor//WZblyOvZuXw4H+UY3WM4jx0zHLVj5efE9jtx8sDAAqnihQujn2pz2oNwfJKCrT6a5DlZ+iOa8zUnvvcfy9IXx59IVeThMbvClIXkjpfcv9akP5vC9Lb/DJfV/tdjPkS3GNvu30ew353dTWu3cZueKXva6OujjlqcZ0z0f9zeM2f/Wb1slfPmTNQ6asodQek5bgD0tI+h7TcsND0iCKfD/76OPLts8HfOsbu4O+b+mwO/r67b6855eO+jdUdt4rSr7x2e94ff4+y2tKSXld2vHAg+iXK6nWx/T6k7Y4+pP2OPqTyeR9SvWOgs7xCck3aRZaj2dXOmNU8yrBqMTxfbUedb/udt38yqUl/UhSfT1TnoPhrUeqWWcu6cedxOsrMii9RrH0+VVi9LbZ5sM8jyIpP2wf7POIsFxD2Dvb5pkq7sx/zO6CwPD9wGwrLvbFNKNjuJ/eO1SPEtw/7Wj0UvX3+YPUbtnS3SxL22zbZXPX65vpsD3z8hlWvR5S44frEDS0bt1zjG1bOvmHt9aKkM8HpC2tj/Yrj5olj67LsrkGsXrvZXYNYlWN3DWK1Lba9BhFxz1riarMw5rImpnVfHj6qd/TjPO64Z5dDdZnpqP/JKP/SKqtlTYnrppVguv/XKDccq7iOsnus4jdRNo9VfET5+FjFR4zPj1V8BLnlWMVHnBuOVfymSrujr7plSla3TMnqhilZ3fBi7iPKDa/UPqJ8nD+zjrH/ZN4syXKMUDe8rPzN9dmldlvtRW2Pvtrx8Yu52zFWLbuMsX2N122y/ST7/DjE3o5lluLecYjrkuwdh/goyQ1nJfXWbshBeES5IQfhEeXjHIRHDLmjDza9ow82+7wPNruj/zT91/1n7zjER0lWH3DcPA7xm/6zdxzic8trOd7fOijpEaXf0YG63NGBun7egbrd0YH6HUsIrX++hLCMsd+B+i3T/zuOQ+xttUO2eRziI8gtiTPrsuS1r1upsQjycXrgN/PLWZDHHGixFt5k/T3HrXMZH1FWCwmb5zI+oqwOXt48l3Fdlt1zGR9b0DccvfyIcsd8rN2yRdZu2CJrt6zSNL3hfYZHlM/nY03vmI+t67OLyvV9u3ku44Ndx2otbu9cxu/Ksncu46MsN5y+/Pg7uaMPmd7Rh8w+70Pmd/Qhizv6kOXnfcjyjj5kcUsfWvXnzXMZe1u9tbV5LuMjyHJvd+tcxm+C7J3L+Aiyumk3z2V8RFked7x3LuN5uszfN/D3zmX8JsrmuYzfRNk8l/GbKJvnMn7XunvnMvYWt8zM4paZWdwwM4sbvobziHLDd2x6ixtmZnHLzOzzExW/aZPd5d/19dk8l7G37Hdcn5TPr89mjPh1m2w/3vOW1YS84Z7NW+7ZvGM1Yf0k2zyXsbdbNsnaLZtk7YZNsnbPJkzdMim7YZOs3bJJtq7PPXfc5lmIvR/Hcmq3cxbiI8hyR2jrLMR1kL53FuIjyOpruDvnhn1Xjq2zEPv4Lvi/LMfeWYjfBmk3BNk6C/GbIHtnIfbelsmKW2chfhNk7yzEnwSx3wbZOgvx2yA7ZyH+oDq/D7J1FuJ+kMVZiN8E2TsL8RGkPu7D63JsnYX4WIJqn5bjm2fF3lmIj4Ks4Lp3FuI6yOZZiI8gi/psnoX4kyB/PSfvJy3rq5ZdLVTtnYX4CLL+9vPOWYjfBNk7C/GbIHtnIa6DbJ6F+F2QrbMQ10E2z0J83PbL3IHNgwN/FqZ+WaW9sxAfZcl7qpR3VOmbBcmtsxC/WV/dOwux99Wm2O5ZiI8oK1BunXP0iHHH1kLXz7cWut6xtdD1jq2Frp9vLSxjbM8E1/XZnwkuk9y3zh/s3Za5gZvnD/a+fG9s90if78JsHmP4CLN6xG+dWfaIsf4Q3PWA76sY9nlfXm1m7ffl1UtJu33Zjzv6st+RWtv989TaZYz9vux3pMX+5Mb/+9GB34TZPTrwuzCbRwc+miY/74Zen3fDZTk2u2HckV3b4/Ps2h53ZNf2uCO7tsfn2bXLGPvdMPSfd8PdowO/DbN3dOBjdrg8oH7n6MBvYmwdHfhdjK3cwG+aZPPowO/GPFtn/j3qYzdst/TVBtI+EZYvWW0SYfXa2D4Rli+NbRNhdZ7iLhFWMfaJsKzPLfk72+fs9dWG2O45e321f7SfLvxNWfbO2evLoxA3z9n7JmG48hohHLo4maTXarFn7yVqOdav4Lxv29VL1MtybL5ELatXtXZfopbVbthPbpTV7GXvJeplm2webCKrA/J230OV1Ttj28yX447JmByfT8ak3TEZk3bD5GX/KDbcKfalJKtNhisLz5xv9PU/YywTvK7aiBmWJZv+GWU1Orh2Pf9zQtHXGMs3yttVnQO7nvJnjFWqzHUGaYn/uhzzINNlOVZjfDsuNC7bY3llLtDLf0DwJcpqR6yNhdPXNrCv2mR5kqLKta2tQOz/iLJcpr36nzbW6M/FXlm9LPaflFyMl54JcH9EseUYfx5pwuPg8s8gq9f5+jU+z+cu1t+DrA7YH4unr30X9sBfByEMfhakLlJL+22Qdp1tF8xT/lmQmTH9kKurszzXeO4t6H8usf3kppWaKyFMgfhy065eFQt937OBB2n2H4So67YvHDz4NcRyfXYvg0lkuRC/l8G0DLKbwSTycdbBN+XYy2ASbf+2HJsZTN8FaTcE2ctgWgfZzGCS5WtdmxlM6yCbGUw/CGK/DbKXwfRdkK0Mpv3q/D7IXgbTdpBVBtM6yGYGk9jHWYjflGMvg0lWb1DtsmT1oKi5q4i+9+VJYcvjDvbyl5ZBdvOXZPnFks38pR8E+Xtuy3okMLdrVXl9v4wEfLnoPl/V5pmwLf9crljlUpXk9f66HosB0vJ1JZmnkgmTdb7UZ/mi9szmP0R+GWQ+dIT76T8MUvN117YoSazWCPw6LKT7qjpxQ362RP+YBHFDfrasdonuKMfucCDuwHx8jte4A/Px+dB1fafaNWT01cXNG15HWAbZvt3z49cRvinH5u2e9m/LsTuYzxteR/gmyOZgPu/ovXXD6wjrILuD+brhdYRvgmwO5uuG1xH2q/P7IJuD+brhdYR1kF3K1+d0rRteR9Cj/VvKh1ynb4TnohzyeedbB9nsfD8IYr8Nstf5vguy1fn2q/P7IHudbzvIqvOtg2x2Pm0fj1u/Kcdm52ufj1uXM4p+Hfr3ePAtLu/yE2GbMwptNyy6LoPsjtP081e9vinH3jhNP3/Va12OzXHad0HaDUH2xmnrIJvjNO03LLqug+w+KvoNi67fBNl8VPQbFl33q/P7IJuPin7Dous6yO6jQj6ea31Tjs1HhcTnLPHPZ+O62tDaBvTqzMPNyqzLsQlo7f+2HLtEW73YtX2n6ud36rocm3eq/uM7dXdGsfoS2PZjYhlk9zGxH8R+G2TzMfFNkL3HxHZ1fh9k8zGxG2T5mFgG2e18q9e5djtf3dD5/GOyrveQ/MrAUI9FNoku38KS+XlcRfZgtj+DrDJe9XrtqfMrfF9ex9fldlbk9e1iZsCL6U+i5HHd9Qkm/Y8o2zXKVY1WUWw+yS36Ksrq/YK/fIbyf9SobmnduqV1lzW63rbrPB/gkyjx2yhy5a8/04Z/G0WvAxwet07/dZQ5AVT/dY30Subt3Fz+YRS7nh7dVH7bj9Kudkk/Fj1gtcW1u0Wtq9eodreodbWBsbtFvQ6yuUX9TZC9LWpNvWFBKe2GBaVVkO35Sn4+pF2XY3O+kvVvy7G7oPRNkHZDkM0Fpdw9uHU1/Sq9YaawDLI7U9gPYr8NsjlT+CbI3kxhuzq/D7I5U9gNspwp1A3TdPv8TMNvyrE3U7DPzzT8hvJ7C0p23LDib8fH069vyrEHaGvHvy3HJtFstcG1fae2j+/Ub8qxeae2f3ynbi4o2XKDa/MxsQ6y+Zj4QRD7bZC9x8R3QbYeE/vV+X2QvcfEdpDVY2IdZLfzrTYNdjtf3ND5+ucLW8sZxeYWtckNSa8mN2QBmny8afBNOTafNaL/thy7zxq5YZvNPt/e+qYcm7f75+9rfXOnbo6K9Iak12WQ7dtdPx8F6B23++fbW+tybM59vwvSbgiyN/ddB9ntvXZD0us6yO6gxm5Iev0myOagxm5Iet2vzu+DbA5q7Iak13WQXcrb53S1G5Jezdu/pfzujMJvSHpdB9ntfPtB7LdBNjuf35D0ul+d3wfZ7Hy7QZadz29IerXPX9b6phybne/zl7W+2f259m0ecrGLarE86e1dkMDZ0PbLXajCHt8Pd3NLrmEav/79P6IsN9yvQVZTTJD+3HC35V7WPI/iIf9+WsgySM4TR1IX5VidB7j5Ru0PgvzyjdrH/Ol6QVjF/p4NYattiscG8PWp4O7LKMsEvvkVtGi1irJM5G1z7Mn3pr9GWawL5HV+XuFU6C9vCC9jVF1Pv4No/BKk1idhbp2SY8svdW2ekrMsye4pOftBFqfkfBNk75ScdZDNU3LWQTZPyVneJ+3o8yxzXd1ttYqy+1a71Q0pA37ckDLgxw0pA+sgmykD3wTZSxnw44aUAT9u2O334+Ol12/Ksbfi4Z9vaq3LsblE4Hd8fsnbx1Muv+PzS/75ptY3d+reAp+3G5JblkG2b/cWn1+ZO273z9/aWpdjc4HvuyDthiB7C3zrILu9t9+Q3LIOsrnG8IMg9tsge2sM3wXZWmPYr87vg+ytMWwHWa0xrIPsUl4+p2u/IbnFP39ra035zQU+lxtSBtZBdjuf3JAy8E2Qzc4nN6QM7Ffn90E2O5/ckDKwDrLb+fTzcavckDLgesO49YaUAbcbUgbcbtiIXQbZHqfZ52y1GzZi/fNjCNfl2B2n2Q0bsd8E2Ryn2Q0bse43bMSug+w+KvyGjdhvgmw+KvyGjdj96vw+yOajwm/YiF0H2X1U+OdzLb9jNh6frwrYDek2vvz41i6gP9/Y+qYcm4AO/7fl2CVa5A136uenEH5Tjs07Nf/xnbo7o8gbUgbWQXYfE/tB7LdBNh8TeUPKwH51fh9k8zGxG2T5mMgbUga8Pk4Z+KYcm52vPk91Xe4hjZM93/2mfrlj+d8ofRVltQM7jvl+0ZU7UT/bx1XB67iLKL78kpNeX4Pii8H+xx55HMsPu81WOfhi8I+i9HmVH8ui+dsoMQf0ya91f42yuGvL/N17ip9b/WEUuXZQS9dlWe0U2GHzo2wHPpDz0zpdLfNJnfqVrFJdb4kC2P7wWle/0oAqZBFlta1Uda01tOOQVSdYfnOrCb4TL63fFCd/Hafb/Obpo1v8spHFbH596/dR0t9d4bH3/VvQ6HE9TB5Pa/ltlPFlyDNKP9qqfVePgsiLEY+dc3yr7X/EWZ18cbhMerrab+M80HuV5/G/flOcuidO/329ftCv6p7+8JPy5K/vn/npiZaHr+7mvlqy7f36cNNDW/w6js6Plj1CHr+OYzHjWH0Qx+WeOPOzs93k19cr5fps80MvH8M/iLN+bC3jzDXyR5xDf18euac8ijhq/ls69/lZ9/UAQ5aliWZXacLar+Okzjhpck8c7x/Ema2cS4qtTj7czZqM1athu1mT39SocN+ULu7jdXJsXseWPQb+y7TWZRSd0wdbTKrWScN6DQ3M2m+j+Pwi32O9z38ZJeS6SKG+OM4tVmtX2wnMsdwo2U1gDlt96XM3gTlW22m7ycdhq28mbn/TcnWFos+vD4f+8jqnz+9l+/IjkKsodVyD0frP97B+FqVfp7lV/31ZZE7C9Th+GeVxdedy2tGO1b27emfsscg41we5EZz6oyjHXKpkD/h9lFVZ1i3TZpr4YyTbf8upx//3Ws966NJVC69e4D7GZyZeV0ry7ynnPwlT9uswc353/Of++2EY2wvzzdeNr/ctuq2+tBx7223Op1KzH8SYSRXO5dyvMVasSn/X5vH0B8H1zw/MLb8+nfnukVJMxf/aJqvlNfE5HhceeGp/PglWm279scp+bZk1i/xbmOU31/26yo8ZKo57/POb67Ha77J2TcCs8+2PrxVaHWw9P5jei33xS5Tlu2DH9azOg++25Z81Wm2+PZ6K8wmJV1H+R5S+Wsm6JhYNMY4vMXY3RvGC3P+IsspxbH49S56fev5lWeL6AObjZjlWUVaAmq9B/uf81v8RZfVV+2t2U/je+c9itGM+YQ+339anjou3j8HHIsq6D11QePShWPWhVZR+rXpaxxexv0ZZ7cJJv7YRRACF/xFF7ujPq524/f5cdkd/Lv+8P9fytLX/fQby/4iyukJzjiXCI7O/tu0q1aGuK2R8Qe3PILnci0ttczbd/v5oXRbFj+v0bm94tH4tSr/hkfhd414zNeEh4O1rYXQ1bLkqxOFTP/6MsXqLt66ZhLJVKv4M4jf0oFydErjdg3L1htlmD8qjbngi5vLdLpnUZsLR/4jSbniCLKNsPst2Y4T9tk12Rwnr67M7Ssh2xyghW9zQsnFDy8Yt98kdI401mHIuxMYCTH159oPMDCgJYL+X/qAsMZeQlpDs6xHC+/r4Yma3LEdecEs+Tb+WY5UFmVfvscSbzV+eGj1ueYStJocaV5INPoXxmG3+ZKSy3Y9XxxbdNDqWqyz2n/TQL427OkhR4rppJZjs+jXK8vSU+S79Ibxb7AdRHk/CY2Y55G+jjLzcV414UMHXKKs79+qFxhjS/oyx+ixkzkET91S+DFWWWzPi0ufSCB9BX7Ai36QCzJ13bMX92QHWVdodfa3OzNsffa12z/ZHXyqfj75WX+zaH32p3TH6Wr1/tvt0V7/jybxZkuUYYdkm26Ov5fXZpvbyJbTt0ddq32z3+mzGWLbsKsb+NV6/mLc7+lqy1q9lnsoFay1WGQvXd3G0c0285w9KMmaerzGPrEqyGuvLlfTQFc/Cr1zyO9Zs0+9Ys03/fM02/Y510lx/RWy3D7p93gdXMfb7z7I+t/SfunaDeHLd17t2+TLacSUy2WO77Lf9Bznohy+KEuvXQa8O1HFc1debdnXS4n4HCrmjA61eStvtQKstsv0OFLcsIcQNSwhxy/Q/bpn+L6cMoXPKkKvpy2qDrOK6+yuxx/xlJpW3rNeuy5LtOiEtdbF2nMtVkWv/xbkG4D+JUdcj1Qud+WcxrpV9L/t7jOU8dzbIYy62WsDO9VuM1yTKmZnzZVVk9QWxXsd8ZcJW44xa5uFfU1Q9tBbEXpVFjmupSI5cIXu1PbA/5lntju0je7U7to/s1e7YLrLL70D2as1pH9mrgxd3kV15B7KX9dlG9vK+ncsZj3sv/n7f1mp3TOPK9dD8z1rRj/pQi3n0Yl+WRW8Y9tRqe2y7D9XhN/ShWu2PbfahWu2ObfehOuqGPlTLl9T2+tAyxnYfWtdnvw+t+vPc9mjR8u9Ps1plgOk881qZ6PfnkmAtT2KU+d6LYASW8pMg85zbpuGLIKubtl3p0cITd78cBF6rFzHkmK/aHdj4kONLq6zAIteixmMD/vhtFI25rI4s6x9GseuDzOLdfxslrqHPY9DdVlGWrXt1Imm6qlG/I42m+h1pNNU/T6OpvvvRwtUydPW8YRm6en2Oyl53oHKzJGG/bZPdZej19cGLF47Uoq9RRO+4PvL5EthujPh1m2w/3pd7ZNuPd7nhnpVb7tllfXYf7+snWZ9nk8vqAx2ld0zKSu+YlJV+PikrvWNSVnrHpKz080nZMsb+Hafxz++4+fayKEZxX++41dbUY2oX8+mOBW3/M8jqfZjNIyOXQXZPJKvPj2r8phx7J5KVxb8tx+aRkd8FaTcE2Tsych1k84C1Wn/yZ+8ssHWQzbPAfhDEfhtk7yyw74JsnQW2X53fB9k7C2w7yOossHWQzbPA6vOjGr8px95ZYBUfH4P7zbPiao/Hs6IvnhWrXTE7ZhLcwdeQ/QdBdB4CYv953/ZLkFUCwubXsn4Q5O9fy/pBy65WMHJ5Tur1FG6KAzu+FGW1DeVxPUA9+vHLICPF9LUNpf7LIHXd9o8y9d8Feb5e/g7S69dBrlHsI4j8LshjKN6vUXkt7vv1u16F04EO8XvC1C+rJNdOVIouGreOW6r0kzCLKq0XJPGK+HJBcrW+OvM/1dGdv6yv1vJlR5yXxFPwvqyYrTbF5hOZQ4PH8+bPGLdsLdQNWwt1y9ZC3bC1IMfx8dbCOsb+TLDu2FpY37TR3k8PZRL2Hzfto0Krm/bxcJ+HCLS/vz/wCLNM1VK8/W/t+G2YuQL+aF+cgfY1zDJR8WoYbX/tQ48YudxwvB7wfRUjPu3LDyYfn/flR5T2aV9+xOif9+VHFLmjL6/u/d2+3PTzvvxNfTb78o9u/B6/7D/N5hlTjYef/jCM40UGxzz3S5h+fN4Ne/u8Gy7LsdkNu9zRDbt+3g273dENu9/RDXt83g173NENu//zbvjfG1/y1/2nroldC130n1U+3V5u4DcxtnIDv4uxkxv4XZPMIA9df22S78Y8MdciMMX8MuZZvWC1u93yiJJ3EEHqcyLocQcRtN1BBO2fE0H7HUTQW96bWeXv/Oc8Kvn7u8JyrDbEvPt8MXY1xtY73tH9rizXCYcuLosgqxmMzlmD9dXrz8uE4bHmcd79h/79OBE5Vi9I7b3MLYet32R437aLl7nX5dh7mfsRY/UBiL2XuR9B7J4bZTV72XqZe90me6eRPGKsZmJ778M+gtQdzPdbJmN+w2TMb5mM+Q2Tl/2z3DA8sC8lWW0yXFl4xuNFe/8zxjLB65gn+ONc5j/PyXtEWY0Orl3P/xwr9DVGLrdMruoc2PWUP2OsUmWOd7OW+K/LcfhWOVZj/OujHOXL9lhemQv04otTHR9Lpau7tevcBvZVm6xeFHsEuba1FYj9H1GWy7RX/9PGGh1/Umn5ahVTco3nm9qfUWI5xt854/oRZHGrbJ5xvS7Jf44JNr8hyN/PGv4uyHXka0j7bZB2HUgXzFP+WZCZMf2Qq6vjy12Oa7yl/7nE9pObVmquhCyOK36+pbSq0PueDTxIs/8gRF23feG0wK8hluuzWxlMcuRyIX4rg2kdZDOD6TxZ/KPd/u/KsZXB9CiH/Nty7GUwfRuk3RBkK4PpmyB7GUyPZl1mfG9lMH0TZC+D6SdB7LdBtjKYvg2yk8H0g+r8PshWBtN+kEUG0zdB9jKYTvh92Ifr80+JPspRn7Nk9aCYB7dz/Prnk6Kt9r4285fWQTbzlx5BFnDdzF/6SRD5+4NvORKY27Wq+feD7KWtDwacr2rzINc/vy3xiLKaYEhe79Hr8fcBUlu+riTzdDRhss6X+ixf1J7Z/IfIL4PMh45wP/2HQWq+7toWJVmepT+PsO++qk7/PD/7EeTT75p+V4690U3r/m/LsTkcaP0OzPf6vDJ3YF7a5+VY3qlb3zZ/lOPz1xHWQbZvd7GPW0TuuN0l/m05Ngfz3wVpNwTZG8yvg+z2Xv38dYRvgmwO5n8QxH4bZG8w/12QrcH8fnV+H2RvML8dZDWYXwfZpbx9Tlf9/HWERznk31I+5Dp9I3zRqGY3dL5lkN3Otx/Efhtks/N9E2Sv821X5/dBNjvfbpBl51sG2e18/vm4dV2Ozc7nn49blzOK+RXVx4NvcXlX+0nbMwq/YdF1GWR7nBafs9VvWHRtIf+2HLvjNL9h0fWbIJvjNL9h0bXFDYuu6yC7j4q4YdH1myCbj4q4YdF1vzq/D7L5qIgbFl3XQXYfFfn5XCvumI3n56sCa8pvzsZXG1rbgF6debhZmXU5NgFd+m/LsUu01Ytd23dqfX6nrsuxeafWP75TN2cU/WifPybWQTYfEz8IYr8NsveY+C7I1mNivzq/D7L3mNgOsnpMrINsdr6+ep1r76b/phx7na+3j8m63kPyKwND+TnZL3tIffkWltTMbEGeabY/g6wyXtMuyKcjG/KP1/EfUfzzjai+PBlgcyOqf3P43tZG1Dctez35miLIl5ZdvTuVMyssFxdn9QrX7q7nD4L8ctfT5EoCNhVb3LHLl7iOK4Feui+jrG5ZnFQXrVZRll9jbnOyxb3tr1FWKa9XBm+14++7uMsYVfgsQa6CLIYEu5mMffXpr91MxmVJdjMZ94MsMhm/CbKXybgOspnJuA6ymcnYv3ndb75vrqu7TeKGzIO+eoVrG/jLN7h2gb96hWsb+Msgm5kH3wTZyzzoqwMNd9cJ+/KTUpszyK4fb8V+U469GWTX+Lfl2JxB9uWLW7uDWPt8ELsux+Yg1vrn5ZDP1zq66ecr2ssg27e7fbxR8E05Nm/31Ttbd5Rjc0X7uyDthiB7K9rrILu9d/m+1u5SxTLI7lLFfhD7bZDNpYpvguwtVWxX5/dBNpcqdoMslyqWQXYpH5/TdV2OTcqH/lvK764Trl/W2ux86xd5NjvffhD7bZDNzvdNkL3Ot12d3wfZ7Hy7QZadL25YpH8sWn1808cNi/Q9bxi3Hp9nHvTlWzi7M4rlkYO747RVkO1x2ucbW9+UY3Oc9vnG1rocu+O0b4K0G4JsjtOWQXbHacsD/nYfFcsgu4+K/SD22yCbj4pvguw9Krar8/sgm4+K3SDLR0XdMBuX4/O5Vt0wG5cbtrbWlN+bjcvynMJNQEv7OCXrm3LsAVqa/dtybBJNVtta23dqy88rEzfcqf0f36mbMwrpN7xIsA6y+Zj4QRD7bZC9x8R3QbYeE/vV+X2QvcfEdpDVY2IdZLfzff6a1jfl2Ox88jFZ13tIkug39csdy/9G6asoqx1YmZ8UFe5E/WwfV+Vdlsee4SKKrPazXK8Tu3CK2fOonD9irMA2r093fLDyh1FiDsWTZ6F/ibI6wq/M3/d98TDbH0aRa++zdF2W5VLWYfPIuwPHD/20TlfLfFKnsQN+Rul6SxRg8ofXenwB8rzWFbIqy2ovtq5VgnYcsrp9l/tKTXAKv7R+U5z8dZxu80TZHvbLRn5QZp5t9vsoOT+ZmvVbROhxPQYez1n5bZQm1wla/WiLKLY8xzgvRjz2vHES3v+Is0xLcJkJLK722zjtwFct2vL++0mcuidO/3299vvVOs5+f/hJefLX98882KPl4au7eXV+Yev9OhbroS1+HWd+3++h4/h1HIsZx+qDOC73xJmH+naTX1+vlOtQ7IdePoZ/EGf52FrHmavbjziH/r48ck95FHHU/Ld07vPQ/PUAY7kFkdGuz4VnWPt1nNQZJ03uieP9gzizlXNJsdUHwHbzHWX5UafNfMdvalS4b0oX9/E6rTWvpPDHwH+ZkLqMonP6YIvp0DrdV6+hgVn7bZSQq3lDfZHmLqt9tO2kYVmeRr6bNCzrY/E2k4ZltVGym/ArtfxQ2+5Zn8vPw/d5KnPoL69z+jxH3JeHY66i1HENI+s/54T9LMpj4fqamP2+LDKnz3ocv4zyuLpzCetox+re/ea4v7kmx83X1B9Fwefe2AN+H2VVlnXLtJma/RiD9t8S5vH/vdaQHroWd7AeqyWKx7R55lZL/j3N+ydh8KmOn4aZM7PjP/ffD8PYXphvTn3GdxxWJ1Dr3lab83nS7AcxZiKDcwn1S4zVVttj6PKuzeO5vfpgwfJU7sx3j3yQPhZt0pabGD5H0sIXwf782oC29fFOex8tWJ5FX5isFDrAn2fR6/KTknJ9gvTBGFwj+3KN1uk3cxdyjqa+3Pyr3a7t7w3o8m2ya4bL5c8vXwpYx9j7ZoH2O75To/2O79Ro//w7NcsY29+pWddn98tV63tWE1tEvrhnV9sQHtd85DEcm4SrP2/a9b7KrNBjrIui7Hfk89uMrxgHP6D1pWlXb5i3aw3E+n868p9kWr1P1ucXIf7DlP8RZfk14c0PkOjqizn7QFhtwe12ZtnNZz9Wt62sv5R2daHnWfa/LMs2WJbvlG2DZflO2SZYVjH2wbJ+R24XLOs+dD3dH30oFnf/Mkq/Nh6s48j/r1FWe3DSr528x+pVX0XRO/rz6sWy/f6sN3yp+RElPu/Pq/23x/b0tbTQY9WHlldoLpY81psWX/TS5ftldV0h49udX4O05Upomwta7e9j5GVR/LiOJ3B+fOprUe4Y237XuNeSy/MPV41rq/nH1ie51JYzh1kSrhX++UkuXW7hyPzq+kOT/vXnBGT1rtlzi2vuKGGJ+c8vla2rtPmVMV19H2wfCqvvg+1DYfWFsF0ouNzxkHfdHRCuHoqrHaTdB+tyF2r7wbpZkrDftsn2wGd5fbYHPnHcMfBZHaa4e302YyxbdhVj/xov22R78LRkbc7tnViw9ptvhM2MSIlqK0yuVsn3PpOpy4+E7X0mc1mOzc9k6mrfbPczmbraN/vJUznv6IMpd9xvy2G2zE+d/CfV+2vDLK6QxHXDPfYMaxVlldJY81yMQ3il7QdRHk+x93BFeIl+GMWvz0ZL8NCRr1FWrXv1IGMM+eMwJF3tmm2PnKrdM3JavYW2P3JaVml35LR6EW1/5FR2x8ip/POR0+qQxf2R0/qzYbsjp9XbPbtP5uUbQttP1c2SLJ/vyzbZHjktr88ute3QG0ZOdnw+st2NsWrZZYzta7xuk+0n2ZK11xaMVf6dtbbaJdN+fVRYO/faev6gJHnYNV6RVUlWr2DJlQbVFc/CL1yy1RbZNiNtdSzgNiNttd+wyUhb7ZDt98F2x7Kttc+XbZcx9vtPi3/df+raZS7cKV/v2tX+lh1XauOjn8lv+08iT8hXRVkfwXN1oI6j577etP2ONVvrd6zZWv98zdb6HVMPW00a9jvQapdstwOtYux3oGV99jvQahAYOqcMuZi+2GpnquK6+yuRu/LnTMpWm2T7E9V1WbJdpx2mxiLI6lvjeW0HOefv/pMYdT1SvdCZfxbj2mjwsr/GWM9zZ4M85mKL9XTT9XHM1yTKmfH354qGrb7R1OuYL1HZapyx2iHQ45qi6qH1d2Ivy/LYfL9yVY9cIXu1QbY/5lltkO0jW+/IozH9PAfGtO5Att2xYmv2+YrtMsY+su2O1db1fTuXMx73Xizu29X6pMaVKaj5n7WiH/Wh8aWPsywcsPyPssQdwx7LO/qQ1R19aLVDttuHVvtj+31otT+234dWOzC7fWh5St52H1rWZ78Prfrz3LJo0XLxNPPFfavz6HllAvGfS4Lmy8Wv+SacYASW8pMg88zq9thm+XuQWJ6JfL12ITw9+8vnBWy1MSXHfPn2wKaF/JnkbatTGUWuRY3n+xm/jaIxl9Xx9sYPo1hekHNk+v0wSlxDn8egu62iLFv36kTSdFmjuAOVq22yfVRGfY7K3D3NbLUMbdluWIa2/DzldhljH5WbJVkuli7bZHcZen198EKXI9Ppf0SJW67PDUtgmzHi122y/XivO9LErW64Z+uWe7buSBNfP8n6/M6A4Eyjr0+yumVSVrdMyuqGSVndMSnz445JmR+fT8qWMbbvuHV97rnj5nkGz3SMv99xvtqaekztYj7dsaDtfwZZZdJsHv+6DLJ7uqB/fmTjN+XYO13QPz+ycV2OzeNfvwvSbgiyd/zrOsjmYYnebvhG+TrI5rl+Pwhivw2yd67fd0G2zvXbr87vg+yd67cdZHWu3zrI5rl+3j8+wvmbcuyd6+f940+PfPOsuNrj8azoi2fFalfMjpkEd/B4A/9BEJ3HAtl/3uP/M8hqP2v3y3c/CPL3L9/9oGUXKxguy29TXE/hpjjC52t9Fverx/UA9ejHL4Nk92sbiq87/ihIXbf9o0z9d0Gex1a8g/T6dZBrFPsIIr8L8hiK92tUXov7XpdbsIXzwg7xe8LUL6sk105Uii4ad3ly4w+qJHdU6ZsFSRw9sVqQXK6vzvxPdXTnP9dXXddHw80T1Hgu5vElygqU85woDA16fWnaO7YW3D7fWnC7Y2vB7Y6tBbfPtxaWMfZngnbL1sLypo12fS+YSdhfbtr1OY3N5+EkbZH778t3xg7FqSLWjt+GmSvgj/bFqYhfwvgyUfFqGG2LPrTaFJM2p9l9FeP4vC+vNrP2+/Lq9ajdvrx6TWu/L7vf0ZdX9/5uX/a4oy8v67Pbl39y4/f4Zf9pNk+dazwO+YdhHC8yOOa5X8KEfN4NV+cM7XbDZTk2u2HckaTo8XmSoscdSYoedyQpen6epLiMsd8No/55N/zvjS/56/5T18SuhS76Ty7fdtzKDVzH2MsN/CbGVm7gN00ygzx0/b1JvhnzxFyLwBTzy5in7nir3OuOt8q9Pn+r3OuOt5a97nj3xuvzd2+WMfaJUHe8N7PM3/nPOXeyeM/XVxtij4W+60sSfTHGjmP9ObbNtOVvynKdnOrisijL8jMsc9ZgffXq8jJhuPIaIRy6ON0kVi9Ibb6IHcf6TYb3bbt6EXtZjs0XseNYfR5y80XsWO2G7d8oy/psHmwS7YZ3WaPdcdRXtDuO+or2+VFf0e44XiuWmwybfNs/Fi7+fixcrN6wsiuDznjkcO9/xlimHRzzexw4Zf3L2ZnRVu9GXTuW/zmh6EuM5cfMjnZV58COpfwZY5V0cLwvcIn/uhyH75Rj1R51fWKnfNUe6ytzQVp8ddJr9G++w3Ddab5sk/Vnna4taQUe/0eU1SCyXf1PG2v050Jt9N10WuOZx/ZnlFqOz7dOrI/VltbuifXLkvzn6HDzG4Iszh//Jsh1DHRI+22Qdp1tF8wx/lmQme38kIur09c7FNdYSf9zie0nN63UXMVYHWEeq5MQ4/qoSuBBmv0HIeq67QsHD34JsfyC9Wb2USwz6zezj5ZBdrOPQj/+At835djLPgq1f1uOzeyj74K0G4LsZR+tg2xmH8XyZarN7KN1kM3sox8Esd8G2cs++i7IVvbRfnV+H2Qv+2g7yCr7aB1kM/soVm+FbfbhdTn2so/CP/666fpBMT/mwPHrlyfFavdrN/doGWQ39yhWu1+7uUc/CPL3vJT1SGButarm4uMWscybqPmaNc+E/fK9mfDVBEPyegdej8UAaZlMJfNkM2GizZ/1+eZ9pWtMcYj8Msh86Aj3wn8YpOarqm1VktUawfysRfdldeyG0U18nIf4TTk2RzeR/7Ycu8OBvAPz+Tle8w7M5+dD1/WdateQ0VcXN+2GwXzecbuv3v3avTJ33O5Z/7Ycu4P5b4K0G4JsDubzjt673BXaHcwvg+wO5veD2G+DbA7mvwmyN5jfrs7vg2wO5neDLAfzyyCblM/jc7quy7FH+Tzs31I+5Do54zGuXJQjPu986yCbne8HQey3QfY633dBtjrffnV+H2Sv820HWXW+dZDdztc+Hrd+U47NztduGLeuZhTzm8iPB9/i8i6/FrY5o8h+w6LrMsjuOC37x2z9phx747Ts9m/LsTlO+y5IuyHI3jhtHWRznJZyw6LrOsjuo0JuWHT9Jsjmo0JuWHTdr87vg2w+KuSGRdd1kN1HhXw81/qmHJuPCm2fs+T4fDaeqw2tbUDrx+/RflOOTUCr/9ty7BJt9WLX9p2qn9+p63Js3qn2j+/U3RnF8n2s3cfEMsjuY2I/iP02yOZj4psge4+J7er8PsjmY2I3yPIxsQyy2/lWJwJu3vTrcmx2Pv+YrOs9JL8yMJSfmP6yh5TLd5+kZmZLn7XJ9meQ1Zmcer2y1PkVvi+v0udyOyvy/aj4T/a6mP4kSh7XXZ9g0v+Isl2jXNVoFcXmk9xicXhDrg4D/NtnKL/WaPUG1X7rLqNst+66Rtebcp3v9n8SJX4bRa7c84es30bR6/CFx63Tfx1lTgDVf10jvZJ5OzeXfxjFrqdHN5Xf9qOcn3xPPxY9YLXFtbtFnamfb1Hn8nWHzS3qdZDNLepvguxtUefqbMLtBaWsGxaUVkG25yv1+ZB2XY7N+UrJvy3H7oLSN0HaDUE2F5SWQXanX+tPf23OFJZBdmcK+0Hst0E2ZwrfBNmbKWxX5/dBNmcKu0GWM4W6YZpex8dJBN+UY2+mMN4C+pQl+fmCUrUbVvyrfTz9+qYce4Cupv+2HJtEq9UG1/ad2uLzyvgNd2r7x3fq5oJSLTe4Nh8T6yCbj4kfBLHfBtl7THwXZOsxsV+d3wfZe0xsB1k9JtZBdjuffHxc7Dfl2Ox88vnC1nJGsblFXXJD0mvJDVmAJR9vGnxTjs1njeS/Lcfus0Zv2Garz7e3vinH5u3++fta39ypm6MivSHpdRlk+3bXz0cBesft/vn21rocm3Pf74K0G4LszX3XQXZ7r92Q9LoOsjuosRuSXr8JsjmosRuSXver8/sgm4MauyHpdR1kl/L+OV3thqTXcvu3lN+dUfgNSa/rILudz29Iev0myGbn8xuSXver8/sgm53Pb0h6XQfZ7Xyfv6z1TTk2O9/nL2t9s/tz7ds85GIXtVZvSc1DzQLnOtsvd6EKe3w/3M0dE8FXFJ5h9DXKcsP9GmQ1xQTpzw33Wu5lzfMoHvLvp4Usg+Q8cSR1UY5FZXbfqP1BkF++UWtyHTD12K20v2dD1Gqb4rEBfH3mt/sqSm1+wSxaraIsE3nbHHvyvemvURbrAnmdfVc40fnLG8LLGFX4XH2ugiy/LLB3Sk6tjhXcPSVnWZLdU3L2gyxOyfkmyN4pOesgm6fkrINsnpJT33zVbZ5Drn+/2x7wWp6svvdW+/lh7w9TBh5BPk8ZeAT5PGXgmyB7KQPfBdlKGdDj+Dxl4BHk891+PT7+Utd35dha8XiUo//bcuwtETzK8fnU7xHEPq5M+3zq9wgSnzfq59uej3J8ntyyDrJ9u/f2+ZW543b/+K2tb8qxt8D3bZB2Q5CtBb5vguz23v55css3QfbWGH4SxH4bZGuN4dsgO2sMP6jO74NsrTHsB1msMXwTZJfy8jld++fJLY9y1L+l/N4C3/Nw6hs6n7YbOp+2Gzqfths6n7YbOp+2Gzqfths6n7YbOp+2GzqffT5u1XZD57Mbxq2fpww8yvF5ysAjyOcbsesg2+M0+5yt9vlG7CNI/dty7I7T7PON2O+CbI7T7PONWD38843Yb4LsPir8843Y74JsPir8843YH1Tn90E2HxX++UbsN0F2HxXx+VzL75iNx+erAvZ5us2jHHEDoD/e2PquHJuAzuPflmOXaNlvuFPz8zt1XY7NOzX/8Z26O6PIz1MGvgmy+5jIz1MGvguy+ZjIz1MGflCd3wfZfEzk5ykD3wTZ7Xzln3e+uKHz1eeprss9JEn0m/rljuV/o/RVlNUOrNgFAuFO1M/2cVXwOu7fo2hb7We5Xl8f44vB7n/GWIFtXp/uLX8bJeZQPPmN7K9RFrdsmb/v++JHTn8YRa69z9J1WZZLWYfNT6Ed+LTNT+t0tcwndepXmkl1vSUKMPnDa/0owftaV8giyuqDW1XXKkF7bNqubt/lvtLzW1fvOE1avylO/jpOt/ml0R72y0Z+UGZ+N+v3UdLfXeGxa/1bRDzmEu/HwOM5K7+N0uT6OlM/2iLK8r2YyIsRjz1vfGXtf8RZpiW4zAQWV/ttnAdErvI8/tdvilP3xOm/r9d+v1rH2e8PPylP/vr+mR+NaHn46m5engvX+/XJpYe2+HUcnZ8be4Q8fh3HYsax+iCOyz1x5sdeu8mvr1fK9bHkh14+hn8QZ/nYWseZq9uPOIf+vjxyT3kUcdT8t3Tu82Pq6wHGcgsix6ctX6UJa7+OkzrjpMk9cbx/EGe2ci4ppuuvdu/kOz6CLEZxm/mO39WocN+U/v0+/iatNa8Dxx4D/2VC6jKKzumDLSZV63RfvYYGZu23UUKu5g31vx+h9pharL7/vZk0/IiyOqByM2n4EWU1YN9MGn5EWX0BfC/h9xFkce/uf0dydYWizy/+hv7yOqfP70v78sOLqyh1XMPI+s83qH4WpV8nqFX/fVlkTp8fW7S/jPK4unMJ62jH6t719XGVc02Om6+pP4oyv2Ss7AG/j7Ioyzct02Zq9mMM2n9LmMf/91pDeujSVQuvlige0+aZWy3pf38U/CBM2a/DzJnZ8Z/774dhbCvMd18Uvt5x6Lb4urG2va025/Ok2Q9izEQG5xLq1xirVxzG20Mnq0pWH7JffvE5890jn8ccrdpkuYnhcyQtPGTU/nwSxB0fs18eJt/ne1OP8fS8zH9851zb8otbLebK8OMv55W2/qMwOe/cxyixL8KsRg4u11WKNlv3y0Azl+fRxvV220NjWvkYsP0ZZzl0mEdY8ou+z6M1/4iy/Ej4PGa0Y/3+h1FkzkwV7y39jyirGnW/jrDkcsT/iLK+1tdnmx+LNVKLa716tSzejyUVPPUlf1SU0nnbFV72+VKUWn4BxGsmS8WRf+/Wq02W7W79XWmyXRf7USdfhNHl4vtce8JjX3wXMY89q/et6wduusdT8v/3f3v8+n/8H//n//v//v/8v/6P/8f/9//8v/5f/5/n/7HJeKo//l9NL2WX8kvF+fR/qLxUDRo/ytOP8Yx4NFFvl+pDParU5VLD47nE1u1Sfqnh8aRSHx7PpYtebyXHpdpJvofql5JLDY8nbsQu5ZcaHs97QvJS9VY6PJ4bMvr06M81CO2XkqEeJVW91NNjrEaoXyou9fToz0eq1lvZMdQjng2P54jchsdzac3kUnopu5Rfang8Z2OWl6q38uNS7VL9UnIpvZRdyi91efjl4ZdHXB5xecTweCIr5FLD4znmCLvU8Hg+t2N4PIfwMTyen6uM4fHEYh5vHGe71PB4XqOUSw2PesRLu9TTQ54rGBlDPf8uL1VvVcel2lAPj+qXkkvppZ4e8jxZr/xSw+O511LD47mwVPVWj1nK+8I9JilTnjb9KWXKYfQ86+4xnRnDhvG3w2p0xSOmzCmH24jbjilHnXTI4fbkXRu9Xp59ro1u/5I2pU853J5Xso2u/5LD7Zm11UbnH7kibfR+eR4N0Eb3f8nh9jw0rw0AvORwe/a6NhDwksPteU3bgMBL1iUHBl6yTdmnlCl1SpvSp5xucro9G0rqknpM2absU8qUOqVN6VM+3UYCSRtgeMmnmz5Xv9pAw0u2KfuQz/YddHhJHXLg2qb0KYfbuPIDES9Zl/TT7Xk/eJuyTzncnvvKbYBCn1hvgxQv6VMOt+caUxuwUB//t7rkwMVY8mqDFy853J6PhjaIoeM2Gsh4SZvSp4wpc8q65ADHS7Yp+5TTLadbTrecbjndcrrldKvpVtOtpltNt5puNd1qutV0q+lWl1s/jinblH1KmVKntCl9ypgyp5xubbq16damW5tubbq10+35zG8+5XDLIXPKuuRgyUu2KfuUMqVOaVP6lNOtT7c+3WS6yXST6SbTTaabTDeZbjLdZLrJdNPpptNNp5tON51uOt10uul00+mm082mm003m2423Wy62XSz6WbTzaabTTefbj7dfLr5dPPp5tPNp5tPN59uPt1iusV0i+kW0y2mW0y3mG4x3WK6xXTL6ZbTLadbTrecbjndcrrldMvpltOtpltNt5puNd1qutV0q+lW062mW11uchxTtin7lDKlTmlT+pQxZU453dp0a9OtTbc23dp0a9OtTbfJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKZLJHJEpkskckSmSyRyRKdLNHJEp0s0ckSnSzRyRKdLNHJEp0s0ckSnSzRyRKdLNHJEp0s0RdL4imH25j2nyw5ZU5ZlzxZ8txT1JMlpxxuzyUXPVnyTNbRkyWntCmfbvbMCtLBkpfMIUewuuRgyUu2IZ9FHyx5yaebtbEmoVPalMPtOYfUwZKXHG7PRXcdLLHnYTc6WPKSw+25E6aDJS853J6n6+hgyUvalMPtOU3VwZKXHG7PuakOlpxysOQlh5uMVZQ+5XB7rirpYMlLDrfntEQHS14yphxuz7mIDpaccrDEnjsAOlhiz3VmHSx5SZlyuD3nvDpY8pLDzUewmDKnHG7PxV4dLHnJ4RZjNahPKVMOt+dylg6WvORwe86adbDEnkuuOljyksPtuc6lgyUvOdye61s6WPKSMuVwGz1gsOQlh9tzSVIHS14ypxxu4wYfLHnJ4Tbu6sGSl3y6jQ+66WDJS9qUPuTzYg2WvOTTzcdNO1gypA2WvGSbsg9pTylTDrfnXW2DJf68lW2w5CVjyuH2vKttsOSUgyX+vJVtsOQl+5TD7XlX22DJSw63561sgyUvGVMOt+ddbYMlpxws8eddbYMlIy/eBktecrg98zpssOQlh9tz5m6DJS8ZUw63Z2ewwZJTDpb481a2wZKX7FMOt+cc3QZLXnK4PZd6bLDkJYfb8yPhNljyknXJwRJ/zgBtsOQlh9vzrrbBEn/eyjZY8pI25XB73tU2WPKSwy1HsLrkYMlLDrfnXW2DJS853J63sg2WvKRNOdyed7UNlrzkcHve1TZYEk9W22DJS7Yhn00yWPKSMuTTeLDkJW1KH3Is5MaUT7d4AtoGS045WPKSw23c4IMlLzncxl09WPKSw+2ZcWKDJS8ZUw6355vmNlhyysGSGEvRgyXxTLeywZLxKpkNlrzkcBs3+GDJS/qUMeXp9qxm1iXrmPJaVbPBktCxkC1T6pQ2pU8ZM8JwG51hsGRIHyx5yTZln/KsWz6lTmlT+pQxZU5Zl2zHlKdbPWWfUqbUKa8VQx8sieeymw+WvORwez7UfLDklP1an/Tephxuz8U4Hyx5SZ3Spjzd7CljypyyLjlY8pJtyj7l6eZPqVPalD5lTJmX1NNCn7JN2aeUKWeFdFZIfcrr1nDNKc8KPa+QHVO2KfuUp9vzCplOaVP6lDHlqNATpH4CZMgTIM9Bg58AOWWfUqYcbs/1dT8BckqfMqY83Z4X4ATIkCdATtmm7FPKlKfF2PPxKWPKnLKuQuasUM4KndQY7XBS47nP4yc1TjnccvytTzncnrs+flLjlHXJkxpPrvugRj5R7IMa+dyW8UGNl9QpbchncQY1XjKmfLrlk6k+qJHPXboY1BgfW49BjXwSMQY1XnK4PTt6DGq8pE053J6EiUGNlxxuNuIOt2dDxaBG+thMa1P2KWVKnXK4jd2zQY2XjClzyrrkoMZLtin7lDKlTjnd+nTr021QY3wdKQY1Tjmokc9ctBjUqOfEJgY16vlYjEGN8SWzGNSo55GJMagxPsUVgxov+XQb36KJQY2XrCGfcQdAXnK4PYdqMQAyzleJAZCX1CltyuEmY+sypswp65IDIPV8ksUAyEsOt+cILwZAxvdIYgDkJe26hAMgL3nW7dlmllMOt+fAMAZAamy0DoCMY0ZjAOQlZUqdctTtmTUXAyAvGVPmlMPtOZaLAZCXHG5jb3YApJ5jrhgAqWeHjDECeUmb0qeMKXPK4fbc1Y3BkpdsU/YpZUqd0qb0KWPKnHK61XSr6VbTraZbTbeabjXdarrVdKvLLY9jyjZln1Km1ClPt3xKnzKmzCnrku2Ysk3Zp5Qpdcrp1qZbm25turXp1qdbn259uvXp1qdbn259uvXp1qdbn24y3WS6yXST6SbTTaabTDeZbjLdZLrpdNPpptNNp5tON51uOt10uul00+lm082mm003m2423Wy62XSz6WbTzaabTzefbj7dfLr5dPPp5tPNp5tPN59uMd1iusV0i+kW0y2mW0y3mG4x3WK65XTL6ZbTLadbTrecbjndcrrldMvpVtOtpltNt5puNd1qutV0q+lW060utzqOKduUfUqZUqe0KX3KmDKnnG6TJTVZUpMlNVlSkyU1WVKTJTVZUpMlNVlSkyU1WVKTJTVZUpMlNVlSkyU1WVKTJTVZUpMlNVlSkyU1WVKTJTVZUpMlNVlSkyU1WVKTJTVZUpMlNVlSkyU1WVKTJTVZUpMlNVlSkyU1WVKTJXWy5Dkoq5Mlp7QpfcoYxxbJU+aUNaQ9s6COpxzJT0+W9HEscj1Z8pYy5DPYkyV9nBJcT5b0cVBvPVnykCNCTJlTDrfnYlzFMWWbsk8pU+qUp9szfyt8ypgyp7wygCqH23Mxo3K4Pcf2lX3K4aZDDrfn2L7SphxuzxFeZUw53GL8QV2yjimH2zNtomq4PZfHqmTK4fYceFfZlMPtOWGqiilzyuH2HH614xh2z4Wuh376teP89w4t0Dr0+fcG7dAx3uEaOWtPqPT2XJh66Jr6iZWHrqGHbx+Zb234PpehHlqgr6o+tEE7/r/DV85/T+iaug9fHeXsw3ckLx29Qw/fkbN09FFfG2Xoo74j4+3oDh3QCV1Ty/A9yywNukMLtEIbtEMHdELX1Apfha/CV4dvnlqhh+95bzzR0/srOzGGHvV6wufSNfSZtnhAt6FHzCeALi3QT9/eRvs/GXTp4XveM4NCb53Qw/e8BwaI3nr49lGGgaJxnMjzJAVohTbo4SujDINHb53QNfVAUn8lZzbo03fUMQT69B3lHFzqOnwHmN46oHFfBe6rAae3Pus7+t3A01sL9PAdWYVHGvTwHZl+x2BUtzNmQtfUA1Nv3aA7tEArtEEP37P8g1ZvndB16ZFG+9A+dIPu0AI9fP3MiTXo4RunHr6jL4x02ksP3+ect42E2ks36A4t0MM3R6Ls4NVbO3RAJ3RN3Q/oBt2hBRq+Hb4dvh2+Hb4dvgJfga/AV+Ar8BX4CnwFvgJfga/CV+Gr8FX4KnwVvgpfha/CV+Fr8DX4GnwNvgZfg6/B1+Br8DX4Onwdvg5fh6/D1+Hr8HX4OnwdvgHfgG/AN+Ab8A34BnwDvgHfgG/CN+Gb8E34JnwTvgnfhG/CN+Fb8C34FnwLvgXfgm/Bt+Bb8K3p248DukF3aIFWaIN26IBOaPg2+Db4Nvg2+IJXHbzq4FUHrzp41V+8Gun/L16deow35NQdWqDHeGM8r0cO7zldaP3Fq/F2wYtXp07omvrFq1M36A4t0Apt0PAV+Ap8Bb4KX4Wvwlfhq/BV+Cp8Fb4KX4Wvwdfga/A1+Bp8Db4GX4Ovwdfg6/B1+Dp8Hb4OX4evw9fh6/B1+AZ8A74B34BvwDfgG/AN+AZ8A74J34Rvwjfhm/BN+CZ8E74J34RvwbfgW/At+BZ8C74F34JvwbemrxwHdIPu0AKt0AbtFwdGVvADWm3oMQ0d48yRF/wA2Pj3dlx9X9ocT0rr0MN3vCQkJ69e2qCH7zOHo8nJq5ce9R1zmZEh3Md7YW2kCD/0iD949dYdWqAnrwS8GonC19/E0Db06Tva4ZwPDu7JOR+0Uw/fNmKevDrLPHg1PgnZRsLwpQ3aoQM6oWvqwau3btAdGr4KXz19a2j4KnwVvgpfO+b/1xp0hxZohYavOXRAJ3RN7fB1+Dp8B69kzCVHOnE/37cb+cSXduiATuiaevDqrRt0hxZo+AZ8A74B34BvwDfhm/BN+CZ8E74J34Rvwjfhm/At+BZ8C74F34JvwbfgW/Ct03dcr6pLj5TjSw/fMX8fSceXFmiFNmhHnIBO6Jp/P3j11vBt8G3wbfBt8G3wbfBt8G2ob0d9O3w7fDt8O3w7fE9evXRAJzTqK/A9efXSHVqgFRq+Al+Br8BX4KtoZ0V9FfVV1Ffhe/LqpdHOinZWtLPC1+Br8DX4GnwN7Wyor6G+hvoafA3X19HOjnZ2tLPD1+Hr8HX4Onwd7eyob6C+gfoGfAPXN9DOgXYOtHPAN+Ab8E34JnwT7Zyob6K+ifomfBPXN9HOiXYutHPBt+Bb8C34FnwL7Vyob6G+Netr4JUdDbpDC7RCG+I4dEAnNHzBKwOvDLwy8MoafJtBO3RAJzR8O3zBKwOvDLwy8MrAKwOvDLyyDt8+r6+BVwZeGXhlAl+BL3hl4JWBVwZeGXhl4JWBV6bwVVxf8MrAKwOvTOGr8AWvDLwy8MrAKwOvDLwy8MoMvobrC14ZeGXglTl8Hb7glYFXBl4ZeGXglYFXBl5ZwDdwfcErA68MvLKAb8AXvDLwysArA68MvDLwysArS/gmri94ZeCVgVeW8C34glcGXhl4ZeCVgVcGXhl4ZRhfGcZXDl45eOXglWN85RhfOXjl4JWDVw5eOXjl4JWDV97g2wRaoQ3aoeHb4AteOXjl4JWDVw5eOXjl4JV3+PaATmi0M3jlAl+BL3jl4JWDVw5eOXjl4JWDV67wVVxf8MrBKwevXOGr8AWvHLxy8MrBKwevHLxy8MoNvobrC145eOXglRt8Hb7glYNXDl45eOXglYNXDl65w9dxfcErB68cvPKAb8AXvHLwysErB68cvHLwysErT/gmri945eCVg1ee8E34glcOXjl45eCVg1cOXjl45QXfwvUFrxy8CvAqMB8MzAcDvArwKsCrAK8CvArwKsCraPBtDbpDC7RCw7fBF7wK8CrAqwCvArwK8CrAq+jw7Qbt0AGd0PAV+IJXAV4FeBXgVYBXAV4FeBUCX8H1Ba8CvArwKjAfDIUveBXgVYBXAV4FeBXgVYBXYfA1XF/wKsCrAK8C88Ew+IJXAV4FeBXgVYBXAV4FeBUOX8f1Ba8CvArwKjAfjIAveBXgVYBXAV4FeBXgVYBXkfB9rV+dGu0MXgV4FZgPRsIXvArwKsCrAK8CvArwKsCrKPgWri94FeBVgFeB+WCCV4nxVWJ8leBVYj6Yh0E7dODvExq+GF/la3zVh57rddkEWqEN2qEDOqHnOmH2A7pBw7fDt8O3w7fDt8O3w7fDV+Ar8BX4CnwFvgJfga/AV+Ar8FX4KnwVvgpfha/CF/PBxPpVYv0qwasErxK8SoyvEuOrBK8SvErwKsGrBK8SvErwKsGrBK8SvEqHr8MXvErwKsGrxHwwsX6V4FWCVwleJXiV4FWCVwleZcA3JicTvErwKsGrxHwwsX6V4FWCVwleJXiV4FWCVwleZcG3BBrtDF4leJWYDybWrxK8quOAbtAdWqAV2qCnb2G9vbDeXsds58L4qjAfLKxfFdavCuvthfFVYXxVGF8VxleF8VVhvb16g+7QAq3Q8MX6VWH9qrDeXhhfFcZXhfFVYXxVGF8V1ttLDBrtLGhnjK8K88HC+lVh/aqw3l4YXxXGV4XxVWF8VRhfFXhViutraGdDO2N8VeBVYf2qsH5VWG8v8KrAqwKvCrwq8Kqw3l6O6wteFXhV4FVhPlhYvyrwqsCrAq8KvCrwqsCrAq8K6+0VuL7gVYFXBV4V5oOF9asCrwq8KvCqwKsCrwq8KvCqsN5ehesLXhV4VeBVYT5YWL8q8KrAq5q86sfkVT8mr/oxedWPyat+zPFVP+b4qh+TV/2YvOrH5FU/Dvg2+Db4Nvg2+E5e9WPyqh+TV/2YvOpHg+/cH+zH5FU/Jq/6MXnVjw7fDt8O3w7fDt/Jq3501FdQX0F9Bb5zf7AfgnYWtLOgnQW+Al+Br8JX4atoZ0V9FfVV1Ffhq7i+inZWtLOhnQ2+Bl+Dr8HX4GtoZ0N9DfU11Nfh67i+jnZ2tLOjnR2+Dl+Hr8PX4Rto50B9A/UN1DfgG7i+gXYOtHOgnQO+Cd+Eb8I34Zto50R9E/VN1Dfhm7i+hXYutHOhnQu+Bd+Cb8G34FtoZ/CqgVcNvGpzPtjb3B/sDbxq4FUDr9qcD/Y254O9gVcNvGrgVQOvGnjVwKsGXrUG37k/2Bt41cCrBl61Dt8OX/CqgVcNvGrgVQOvGnjVwKsm8J37g72BVw28auBVE/gKfMGrBl418KqBVw28auBVA6+awldxfcGrBl418KopfA2+4FUDrxp41cCrBl418KqBV83ga7i+4FUDrxp41Ry+Dl/wqoFXDbxq4FUDrxp41cCrFvANXF/wqoFXDbxqAd+AL3jVwKsGXjXwqoFXDbxq4FVL+CauL3jVwKsGXrWCb8EXvGrgVQOvGnjVwKsGXjXwqs/1q97n+lXv4FUHrzp41ed8sPe53t47eNXBqw5edfCqg1cdvOrgVW/wnfuDvYNXHbzq4FVv8O3wBa86eNXBqw5edfCqg1cdvOodvnN/sHfwqoNXHbzqAl+BL3jVwasOXnXwqoNXHbzq4FVX+CquL3jVwasOXnWFL3jVMb7qGF918KobfA2+Bl/wqoNXHbzqGF/11/iqP7Vf63W9e4Pu0AKt0Abt0AGd0DV1wDfgG/AN+AZ8A74B34BvwDfgm/BN+CZ8E74J34Rvwjfhm/BN+BZ8C74F34Jv4foW7qvCfQVedfCqg1eC8ZVgfCXglYBXAl4JeCXglYBXAl4JeCXglYBX0uDb4AteCXgl4JVgPigNvuCVgFcCXgl4JeCVgFcCXkmH79wf7AJeCXgl4JVgPigCX/BKwCsBrwS8EvBKwCsBr0ThO/cHu4BXAl4JeCWYD4rCF7wShS/GV4LxlYBXgvGVYHwl4JUYrq+hnQ3tjPGVYD4oDl+Hr8MX4yvB+EowvhKMrwTjK3H4Oq5voJ0D7YzxlWA+KAHfgG/AF+MrwfhKML4SjK8E4ytJ+Caub6KdE+2M8ZVgPigJ34RvwRfjK8H4SjC+EoyvBOMrAa+kcH0L7TzzGTry2zvy2zvy2zvy2zvy2zvy27uCVwpeKXiF/PauDb4zn6EreKXglYJXyG/vivUrBa8UvFLwSsEr5Ld35Ld35Ld37fCd+QxdwSsFrxS8Qn57V6xfKXil4JWCVwpeIb+9I7+9I7+9q8BXcH3BKwWvFLxCfntXrF8peKXglYJXCl4hv70jv70jv70rxleK8ZWCVwpeKXiF/PauGF8peKXglYJXCl4hv70jv70jv72rw9dxfcErBa8UvEJ+e1esXyl4peCVglcKXiG/vSO/vSO/vWvCN3F9wSsFrxS8Qn57V6xfKXil4JWCVwpeIb+9I7+9I7+9K8ZXivGVglcKXil4hfz2bhhfGXhl4JWBVwZeIb+9I7+9I7+9G9bbbe4PdgOvDLwy8Ar57d2wfmXglYFXBl4ZeIX89o789o789m5Yb7e5P9gNvDLwysAr5Ld3w/qVgVcGXhl4ZeAV8ts78ts78tu7Yb3d5v5gN/DKwCsDr5Df3g3rVwZeGXhl4JWBV8hv78hv78hv74b5oBmuL3hl4JWBV8hv74b5oIFXBl4ZeGXgFfLbO/LbO/Lbu2G93RzXF7wy8MrAK+S3d8P6lYFXBl4ZeGXgFfLbO/LbO/Lbu2G93QLXF7wy8MrAK+S3d8P6lYFXBl4ZeGXgFfLbO/LbO/Lbu2G93QrXF7wy8MrAK+S3d8N80MArB68cvHLwCvntHfntHfnt3bHe7tgfdPDKwSsHr5Df3h3rVw5eOXjl4JWDV8hv78hv78hv7471dsf+oINXDl45eIX89u5Yv3LwysErB68cvEJ+e0d+e0d+e3estzv2Bx28cvDKwSvkt3fH+pWDVw5eOXjl4BXy2zvy2zvy27tj/cqxfuXglYNXDl4hv7071tsdvHLwysErB6+Q396R396R394d6+2O/UEHrxy8cvAK+e3dsd7u4JWDVw5eOXiF/PaO/PaO/PbuWG937A86eOXglYNXyG/vjvV2B68cvHLwysEr5Ld35Ld35Ld3x3q7Y3/QwSsHrxy8Qn57R357R357R357d/AK+e09sN4eWL9CfntHfntHfntHfnt/57f3oed63Su//dTtgG7QHVqgFdqgHTqg4dvg2+Hb4dvh2+Hb4dvh2+Hb4dvh2+Er8BX4CnwFvgJfga/AV+Ar8BX4KnwVvpgPBtavAutXyG/vyG/vyG/vyG/vyG/vAV4FeIX89h7gVYBXAV4FeIX89o789o789h7YHwzsDwZ4FeBVgFfIb++B9asArwK8CvAqwCvkt3fkt3fkt/fA/mBgfzDAqwCvArxCfnsPrF8FeBXgVYBXAV4hv70jv70jv70H9gcD+4MBXgV4FeAV8tt7YP0qwKvA/mBgfBUYXyG/vSfGV4nxFfLbe2K9HfntHfntHfntHfntHfntHfntHfntPTG+SoyvEuOrxPgqMb5KrLcn9gcT+4OJfIbE+CoxH0ysXyXWrxLr7YnxVWJ8lRhfJcZXifFVYr09sT+Y2B9M5DMkxleJ+WBi/SqxfpVYb0+MrxLjq8T4KjG+SoyvErxK7A8iv70jv70jv70jv70jv70jv70jv70jv70neJXgVYJXyG/vifX2RD5DglcJXiV4hfz2nli/SvAqwasErxK8Qn57R357R357T6y3J/IZErxK8CrBK+S398T6VYJXCV4leJXgFfLbO/LbO/Lbe2K9PZHPkOBVglcJXiG/vSfWrxK8SvAqwasEr5Df3pHf3pHf3gvjq8L4qsCrAq8KvEJ+ey+Mrwq8KvCqwKsCr5Df3pHf3pHf3gvr7YX9wQKvCrwq8Ar57b2wflXgVYFXBV4VeIX89o789o789l5Yby/sDxZ4VeBVgVfIb++F9asCrwq8KvCqwCvkt3fkt3fkt/fC+KowvirwqsCrAq+Q394L46sCrwq8KvCqwCvkt3fkt3fkt/fCenthf7DAqwKvCrxCfnsvrF8VeFXgVYFXBV4hv70jv70jv70X1tsL+4MFXhV4VeAV8tt7Yf2qwKsCrwq8KvAK+e0d+e0d+e29sN5e2B8s8KrAqwKvkN/eC+tXBV4VeFXgVYFXyG/vyG/vyG/vhflgzf1BOSav5Ji8kmPySpDfLsecD8oxeSXH5JUck1dyTF4J8tsF+e2C/HY5Gnzn/qAck1dyTF7JMXklyG+Xo8G3wbfDt8N38kqQ3y7Ibxfkt8vR4Tv3B+WYvJKjo50F7SzwFfgKfAW+Al9BOwvqK6ivoL4KX8X1VbSzop0V7azwVfgqfBW+Cl9DOxvqa6ivob4GX8P1NbSzoZ0N7Wzwdfg6fB2+Dl9HOzvq66ivo74OX8f1DbRzoJ0D7RzwDfgGfAO+Ad9AOwfqm6hvor4J38T1TbRzop0T7ZzwTfgmfAu+Bd9COxfqW6hvob4F38L1LbQzeNXAK+S3S5vr7dLAqwZeNfCqgVfIbxfktwvy26U1+M79QWngVQOvGniF/HZpDb7gVQOvGnjVwCvktwvy2wX57dI6fOf+oDTwqoFXDbxCfrs0gS941cCrBl418Ar57YL8dkF+uzSBr+D6glcNvGrgFfLbBfntgvx2QX67NPAK+e3SFL4GX/AK+e2C/HZBfru889v70Gd9bejTN4cevnr+/fDV8fcnr3T8/cmr5zce5ZXf/tLD9/lxU3nlt7/08LUR/+TVSw9fP+MPXz//vaY+efXSw9dH3U9evfTwfX5/WV757S89fGOU+eTVSw/fHL4nr55n+corv/3UJ69eevjmqMvJq5cevjnKcPLqpQ16+FYbOqCfvnqMdh68eunBq7duQ49yDl69tQw9yjZ49dZPX22j7oNXbx3Qw7eNdhi8OvWZ367PM2zlzG/X5zmxcua3v7VAD9/n+cBy5re/9fDtZ8yATujh+1zvlTO//a2H7/N7InLmt7+1QA/fca+e+e1vPXyf3/iQM7/9rYfv8/PJcua3v/Tgldqoy+DVWw/f55dK5cxvf2uFHr4+4g9evfXw9VHOwSuNM+bwjfE3g1evfx+8eusOLdAKbdCOmIF/T/x7zX9X+Cp8tc+/V/gqfBW+6tCB/y/qq/A1+Fqbf2+orwn+Hb5m+Hf4Gupr8DW0s8PX4evwdfg6fB31dfg66uvwddQ3jvk3gXYOtHOgnUPx7/AN+AbqG/AN+CZ8E76J+iZ8E74J38R9lfBN+CZ8C+1caOeCb6GdC+1c8C34FnwLvjV9z/z2t27QHVqgFXreV2d++/vfAzrxN/Bt8G3wbfP6nvnt739X/Lvh3+HbAn+T+Pd5P5/57a9/7w3/jvp2+HbUt8O3w7fDF7ySjvrKvK8EvBLwSsArAa8EvBKBr8BX4AteCXgl4JWAVwJeCXgliusLXgl4JeCVgFdiqK/B1+Br8AWvBLwS8EoMvuCVGHwdvg5f8EocvuCVgFcCXonjfnbcz+CVgFcCXknAF7ySgC94JeCVgFcS8AWvJHF9E/czeCXglYBXAl4JeCXglYBXAl4JeCWF+haub8EXvJLC9S3Ut3B9wSup2X8VvFLwSo+OvxH8u0IbtOPvA/+e0PAFrxS80tah4dvgC15pg2+Db0v8+2xnBa+0w7ejvuCVdsW/w7fDt8O3wxe8UvBKwSsFr1QEf4P6glcKXinGVwpeqaCdwSsFr1Thq/AFrxTjKwWvVOELXqnCF+MrxfhKMb5SjK8UvFLwSsErxfhKwSvF+EoxvlKMrxS8UvBKHdcXvFLH9QWvFLxS8EoDvuCVYnyl4JWCVxqoL3ilEfh31DdQX/BKMb5S8ErBK034JnwTvuCVglea8AWvFLxSjK8UvNJCO2N8peCVglcKXinGVwZeGXhlGF/ZMe8rA68M4yvD+MqOwL8n/n3W18Araw3/Dl/wysArA68M4yvD+MowvjKMrwy8MoyvDOMr66gvxlfWUV+Mrwy8MvDKwCvDfNAEvuCVgVcGXhl4ZeCVYXxl4JVhfGXglSl8wSsDrwy8MoyvDLwyjK8MvDLwyl686kOfvjL06WtDC7RCG7RDB3RC19QvXp26QcPX4evwdfg6fB2+Dl+Hb8A34BvwDfgGfAO+Ad+A74tXPnRN/eLVqRv06RtDCzR8E74J34Rvor6J+hbqW6hvob6F+hZ8C74F34Jvwbemrx8HdIPu0AKt0Abt0AGd0LOdvR3QDbpDz3b2F69ODd8G3wbfBt+G+nbUt6O+HfXtqG9HfTt8O3w7fDt8O3wFvgJfga/AV+Ar8BX4CnwFvoJ2VrSzop0V7axoZ0U7K3wVvgpfha+ivob6GuoLXjl45eCVg1cOXjl45eCVg1cOXjl45eCVg1cOXjl45eCVg1fukxvuaOdAOwfaOSY3PNDO4JWDVw5eOXjlgfoG6puob6K+ifom6gteOXjl4JWDVw5eOXjl4JWDVw5eOXjl4JWDV/7i1WirF69OjXau2c7x4lUM3aCnb4BXAV4FeBXgVYBXAV7FMesb7YBu0PBt8G3wBa8CvArwKsCrAK8CvArwKsCrePFqtM+LV6c2aIeO2W4vXp0avuBVgFcBXgV4FeBVgFcBXgV4FeBVCHwVvgpfha/CV+ELXgV4FeBVgFehuK/sgG7QHXr23zCFhi94FeBVgFcBXgV4FeBVgFcBXgV4FeBVgFcBXgXGV4HxVWB8FRhfBcZXgfFVBO6rwH0VuK8ioHFfvXg1NHgV4FWAVwFeBXgV4FWAVwFeBXgV4FWAVwFeBXgV4FWAVwFeBcZXgfFVgFcBXuVxQDfo+VzIQ6Cnb4JXCV4leJXgVYJXCV4leJXgVYJXCV4leJXgVYJXCV4leJXgVXbUt3dogVZom+3w4tWp4YvxVYJXCV4leJXgVYJXCV4leJXgVYJXCV4leJXgVYJXCV6lor6K+qpBO/Tkc2pCwxfjq8T4KjG+SoyvEuOrBK8SvErwKsGrBK8SvErwKsGrBK/SUV9HfR319YBGfX1yI8GrBK8SvErwKjG+SoyvEuOrxPgqMb5KjK8SvErwKsGrBK8yUd9EfRP1TdQ3Ud9EfcGrBK8SvErwKsGrBK8SvErwKjEfTMwHC/PBwnywML6qY97PdSi0QTv0vJ/rSGj4glcFXhV4VeBVgVcFXhV4VeBVgVcFXhV4VeBVgVcFXhV4VeBVgVcFXhV4VeBVgVcFXhV4VeBVgVcFXhV4VeBVyXweFeaDhflgYT5YOp9HhflgYXxVGF8VxleF8VVhfFXgVYFXBV4VeFXgVRna2XBfGe4rC2jcVzb7UYFXBV4VeFXgVWF8VRhfFcZXhfFVYXxVmA8W5oOF+WAF7ivMBysUGr7gVYFXBV4VeFXgVYFXBV5V4n4Grwq8KvCqEv0XvCqMrwq8KvCqwKsCrwq8KvCqMB8szAcL46ua4ys95nxQjzkf1GPySo85H9Rjjq/0mOMrPeb4So85vtLjSHjBd65f6THXr/RofZZhrl/p0eDb4Nvg2+A7eaVHg2+Hb4fv5JUeHb5doeHb4dvh2+Hb4SvwFfgKfAW+Al+Br8BX4CtoZ4Gvwlfhq2hnha+inRW+c3ylhwY0fBW+hvvKcF8Z7isT/L1CGzR8LRAnoeHrqK+jvo52dtTX0c4nr575mXrmt791QCf08E156pNXLz18c3idvMocWqAVevjWMbRDD986YyZ0TX3y6qWHb422PXn10k9fe+Zq6pnf/tYG7UOPMg9evXUOXUPX1INXj52yoRt0H3rUa/DqrYdvH+08ePXWDj18+xk/oYevPOt45re/9fB95hLrmd/+1sP3mT+sZ377YxdpaIN26OGrPnRCD199luHMb3/rBj18rQ0t0MPXj6EN2qGHr49yDl699fD1UbbBq7cevjHqPnj11gI9fEf/OvPb33r4jvv8zG9/64QevjHqNXj11g16+I77/Mxvf+vhm+ffDN8adRm8euuATuiaevDqrRt0hxZohYavwlfhq/BV+Bp8Db4GX4Ovwdfga/A1+Bp8Db4OX4evw9fh6/B1+Dp8Hb4OX4dvnL7jvooG3aFP33H/hEIbtEMHdCJOTZ3wzTb/Pjs0fBO+Cd+Eb8I34ZvwLfgW6luob8G34FvwLfgWfE9evXRd+sxvf+sGPX3P/Pa3VmiDduhAnISGb4Nvg2/r0AKt0AYN35NXL53Qs53P/Pa3hm+Hb4dvh2+Hb3do1Lejvh31FfhKg0Y7C9pZ0M4CX4GvwFfgK/BVtLOivor6Kuqr8FVcX0U7K9pZ0c4KX4Ovwdfga/A1tLOhvob6Gupr8DVcX0c7O9rZ0c4OX4evw9fh6/B1tLOjvoH6BuoLXvXA9Q20c6CdA+0MXvWAb8A34QtedfCqg1cdvOrgVU/4Jq4veNXBqw5e9YJvwRe86uBVB686eNXBqw5edfBKjukrR4Pu0AKt0IY4Dh3QCQ1f8ErAKwGvBLySBt9m0A4d0AkN3w5f8ErAKwGvBLwS8ErAKwGvpMO3z+sr4JWAVwJeicBX4AteCXgl4JWAVwJeCXgl4JUofBXXF7wS8ErAK1H4KnzBKwGvBLwS8ErAKwGvBLwSg6/h+oJXAl4JeCUOX4cveCXglYBXAl4JeCXglYBXgvGVYHwl4JWAVwJeCcZXgvGVgFcCXgl4JeCVgFcCXgl4JQnfxPUFrwS8EvBKEr4FX/BKwCsBrwS8EvBKwCsBr6TgW/P6Knil4JWCV3pMXz0U2qAdOqATetZXwSsFr7TBtwm0Qhu0Q8O3wRe8UvBKwSsFrxS8UvBKwSvt8O0BndBoZ/BKBb4CX/BKwSsFrxS8UvBKwSsFr1Thq7i+4JWCVwpeqcJX4QteKXil4JWCVwpeKXil4JUafA3XF7xS8ErBKzX4OnzBKwWvFLxS8ErBKwWvFLxSh6/j+oJXCl4peKWYDyrmgwpeKXil4JWCVwpeKXil4JUmfBPXF7xS8ErBK8V8UBO+4JWCVwpeKXil4JWCVwpeacG3cH3BKwWvDLwyzAft6NACrdAG7dABndCzvtbg2xp0hxZohYZvgy94ZeCVgVcGXhl4ZeCVgVfW4dsN2qEDOqHhK/AFrwy8MvDKwCsDrwy8MvDKBL6C6wteGXhl4JVhPmgKX/DKwCsDrwy8MvDKwCsDr8zga7i+4JWBVwZeGeaDZvAFrwy8MvDKwCsDrwy8MvDKHL6O6wteGXhl4JVhPmjglWF8ZRhfGXhlmA9awBfrVwZeGXhl4JVhfGUvXsXQT19/np+gZ377Wzt0DC1DJ3QNPeIMXr11G7qG7tBPX28+9PAda+82ePXWDj18n+cq6Jnf/tbDtz/LcOa3v3WDHr7PcxX0zG9/6+ErOrRBO/TwfZ6roGd++1sP3+e5Cnrmt7/18H2e9aFnfvtbC/TwHWvyZ377Ww9f60MPXxtlGLx665p68MptlGfw6q2Hr42Yg1dvrdDD93kmg5757W89fJ/vpOiZ3/7WNfXglcco5+DVWw/fsYZ/5re/9fAd6/ZnfvtbD98cdRm8euvhO/aJzvz2lx68euvhO+7hM7/9rYdvjXYYvHrr4Tvu8zO//a0DOqFrajugG3SHFmiFhq/B1+Br8DX4Onwdvg5fh6/D1+Hr8HX4OnwdvgHfgG/AN+Ab8A34BnwDvgHfwasYbDnz29+6QXdogVZog3bogE7o03eUoQ7o03fcM9WhBX+j0Ia/cejA3yT06fvsg2d++/nvZ377W0/fM7/9rRV/Y9COvwnoxN/M+p757a8yNPi2Dg3fptDwbQ4N35bQ8O2ob2+zDB2+XaDh2w0avj2g4dtraoGvoL7SZxkEvoJ2FvgK2lngK2hnga8e0PBV1FdllkHhq2hnha+inRW+inY2+FqDhq+hvqazDAZfQzsbfA3tbPB1tLPD13E/O3wd9XWbZXD4OtrZ4eto54BvoJ0DvoH7OeAbqG/4LEME9PB9ng2lZ377S5+8eukG3aEFWqGHbxu+J69eOqATuqY+efXSDbpDC7RCw/fk1fNMKj3z2986oYfvGEed+e2P3jd0g+7QAq3Qw3fkSJz57Y+eOHRAJ3RNffLqpRt0hxbo4TvyK8789rc+fWPo03eU5+TVS9fUJ69eukF3aIFWaIN26OE7cjnO/Pa3rqlPXr10g+7QAq3QBu3Q8BX4CnwVvgpfha/CV+Gr8FX4KnwVvgpfg6/B1+Br8DX4GnwNvgZfg6/B1+Hr8HX4Onwdvg5fh6/D1+Hr8A34BnwDvgHfgO/JK82hh+8Y85/57Q9KD53QNfXJq5du0B1aoBXaoB0avgnfhG/Bt+Bb8C34FnwLvgXfgm/Bt6bvmd/+1g16+LoNLdAKbdAOHdAJXVOfvHrpBg3fBt8G3wbfBt8G3wbfBt8O3w7fDt8O3w7fDt8O3w7fDt8OX4GvwFfgK/AV+Ap8Bb4CX4GvwFfhq/BV+Cp8Fb4KX4Wvwlfhq/A1+Bp8Db4GX4Ovwdfga/A1+Bp8Hb4OX4evw9fh6/B1+Dp8Hb4O34BvwDfgG/AN+AZ8A74B34BvwDfhm/BN+CZ8E74J34Rvwjfhm/At+BZ8C74F34JvwbfgW/At+Nbla2d++1s36A4t0Apt0A4d0AkN3wbfBt8G3wbfBt8G3wbfBt8G3wbfDt8O3w7fDt8O3w7fDt8O3w7fDl+Br8BX4CvwFfgKfAW+Al+Br8BX4avwVfgqfBW+Cl+Fr8JX4avwNfgafA2+Bl+Dr8HX4GvwNfgafB2+Dl+Hr8PX4evwdfg6fB2+Dt+Ab8A34BvwDfgGfAO+Ad+Ab8A34ZvwTfgmfBO+Cd+Eb8I34ZvwLfgWfAu+Bd+Cb8G34FvwLfiCVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4NWZ3x7PPSM789sfK3JDD9/n3pCd+e1vrdDD9/nuhp357fE8K97O/Pa3fvo+VqiGrqEf61d25re/9dP3sYI09NM3n/uJdua3v7VC29A2tA+dQwf08H2ucdmZ3/7Sg1dvPXyfe4t25re/tUAPXxleg1epI/7g1WPFY+iATujha+PvB6/eukEPX4+hh2+MOg5evfXwjVHmwasc1+vMb88cbTh49daor6C+g1eP1YOhO7RAK7RBD9/nu2l25re/dULX1INXb92gO7RAK7RBw1fhq/DV03e0oR3QDbpDC7RCG7RDB3RCw9fh6/B1+Dp8Hb4OX4evw9fh6/AN+AZ8A74B34BvwDfgG/AN+AZ8E74J34RvwjfhO3iVgw9nfvtbB/TTt45x/w9e1cmKwau3fvrWyY3Bq8dK0dAy/n3cG4NXb23QDh3Qw1dGGQavTn3mt791g+7QAq3QBu3QAZ3Q8G3wHbwqPXWHHr7P70HYmd9ez5wEO/Pb67kmaWd++1sP38GfM7/9rYevj5iDV2/doIevy9ACPXwHl8789rd26OE7ni9nfvtbD98YZRi8qhx/P3j11h1aoIfv4N6Z3/7WDh3QwzdPr5p68KrGvXfmt7/16TvKOXhVNXwHr97aoOd9dea3v3VCn/V9MvnMb3/rBj18a5TZBPrh+/yK3NA29Ij55NWlAzqha+onry7dnvos25NXlxZohR6+bbSbO3RAJ/TwbaNecUAP337q4Xve5yHQw1dG3cOgHTqgE3r4juf4yG+/dIPu0AKt0Abt0AGd0PAt+BZ8C74F34JvwbfgW/At+Nb0Hfntl27QHVqgFdqgHTqgExq+Db4Nvg2+Db4Nvg2+Db4Nvg2+Db4dvh2+Hb4dvh2+Hb4dvh2+Hb4dvgJfga/AV+Ar8BX4CnwFvgJfga/CV+Gr8FX4KnwVvgpfha/CV+Fr8DX4GnwNvgZfg6/B1+Br8DX4Onwdvg5fh6/D1+Hr8HX4OnwdvgHfgG/AN+Ab8A34BnwDvgFf8ErBKwWvFLxS8EpfvLKhDfoc18nQAX36+tA19YtXp27QHVqgFdqgHTqg4VvT144DukF3aIFWaIN26IBOaPg2+Db4Nvg2+Db4Nvg2+Db4Nvg2+Hb4dvh2+Hb4dvh2+PY5brcO3w7fDl+Br8BX4CvwFfgKfAX1FfgKfAW+Cl+Fr8JX4avwVfgqfBW+Cl+Fr8HX4GvwNfgafA2+Bl+Dr8HX4Ovwdfg6fB2+Dl+Hr8PX4evwdfgGfAO+Ad+Ab8A34BvwDfgGfAO+Cd+Eb8I34ZvwTfgmfBO+4JWBVwZeGXhl4JWBVwZeGXhl4JWBVwZeGXjl4JWDVw5eOXjl4JWDVw5e+YtXNvS5ftWGnutmZ357jrHxmd9+rsX5yasxnveTVy89fJ/5KuYnr17aoYfvWNfyk1cvPeo75pV+8spGGU5ejbmkn7x6aYFWaIN26IBO6Jr65NVLw1fgK/AV+Ap8Bb4CX4GvwFfhq/BV+Cp8Fb4KX4Wvwlfhq/A1+Bp8Db4GX4OvwRfrV37yyk59Xt9xj73Wr8Y19eNaP/GTVz7ujZNX5/1w8mqsSfrJq5c2aIcO6ISuqU9evXSD7tDwDfgGfE9exegXAd+Ab8A34Xvy6vz/JnwTvgnfhG/C9+TVSyd0TX3y6qXhe/LqpQVaoQ0avgXfk1djvcVPXo31hDh59dINukMLtEIbtEMHdELDt8G3wbfBt8G3wbfBt8G3wbfBt8G3w7fDt8O3w7fDt8O3w7fDt8O3w1fgK/AV+J68yja0Qhv08B1rXHHy6qUTuqY+efXSbcY5efXS8D159fp7g4avwlfhq/A1+Bp8Db4GX0N9DfU1+Bp8Db4GX4fvyauX7tACjfo6fE9evXRAJ3RNHfAN+AZ8A74B30A7B+obqG+gvgHfk1cvjXZOtHOinRO+Cd+Eb8I34Zto50J9C/Ut1LfgW7i+hXYutHOhnQu+NX3zOKAbdIcWaIU2aIeevnkk9GznbAd0g4Zvg2+Db4Nvg28L6IRGfTvq2+HbO7RAK7RBw7fDt8O3w1fgK2hnQX0F9RXUF7xKcWi0s6CdBe0MXqXCV+Gr8AWvErxK8CrBqwSvUuFruL7gVYJXCV6lwdfgC14leJXgVYJXCV4leJXgVTp8HdcXvErwKsGrdPg6fMGrBK8SvErwKsGrBK8SvMqAb+D6glcJXiV4lQnfhC94leBVglcJXiV4leBVgldZ8C1cX/AqwasEr7LgW/AFrxK8KvCqwKsCrwq8KvCqjulbh0MHdELPdq4G3wZf8KrAqwKvCrwq8KrAqwKvqsG3H9ANukMLNHw7fMGrAq8KvCrwqsCrAq8KvCqMrwrjqwKvCrwq8KowviqMrwq8KvCqwKsCrwq8KvCqwKtS+CquL3hV4FWBV2XwNfiCVwVeFXhV4FWBVwVeFXhVDl/H9QWvCrwq8Kocvg5f8KrAqwKvCrwq8KrAqwKvKuAbuL7gVYFXBV5VwjfhC14VeFXgVYFXBV4VeFXgVSV8C9cXvCrwqsCrKvgWfMGrAq8KvKrJKz8mr/yYvPJj8sqP4/L141Bog3bogE7EgW+Db4Nvg+/klR+TV35MXvkxeeVHg29L6Jp68sqPySs/Onw7fDt8O3w7fCev/Oiob0d9BfUV+EqHRjsL2lnQzgJfga/AV+Cr8FW0s6K+ivoq6qvwVVxfRTsr2lnRzgZfg6/B1+Br8DW0s6G+hvoa6mvwdVxfRzs72tnRzg5fh6/D1+Hr8HW0c6C+gfoG6hvwDVzfQDsH2jnQzgHfgG/CN+Gb8E20c6K+ifom6pvwTVzfRDsX2rnQzgXfgm/Bt+Bb8C20c6G+4FUDr9oxfdvRoQVaoQ3aESegExq+4FUDrxp41cCrBl61Bt/m0AGd0LOdW4dvhy941cCrBl418KqBVw28auBV6/CVAxrtDF418KoJfMGrJqivoL7gVRP4KnwVvuBVA68aeNUU9X3xSoe+1uu8aULX1HZAN+gOLdAKbdAODV+Dr8HX4evwdfg6fB2+Dl+Hr8PX4evwDfgGfAO+Ad+Ab8A34BvwDfgGfBO+ieubuK8S9xV41cCrBl61xP2cuK/AqwZeNfCqgVcNvGrgVQOvGnjVwKsGXrWavv04oBt0hxbo6dvn+pV38KqDVx286uBVB686eNXBq97g2xTaoB06oOHb4AtedfCqg1cdvOrgVQevOnjVO3x7QqOdwasOXnWBr8AXvOoCX4yvOsZXHbzqGF91jK86eNUV11fRzop2xviqK3wVvgpfhS/GVx3jq47xVcf4qmN81Q2+hutraGdDO2N81R2+Dl+Hr8MX46uO8VXH+KpjfNUxvuoO38D1DbRzoJ0xvuoB34BvwDfgi/FVx/iqY3zVMb7qGF918Konrm+inRPtjPFVB696wrfgW/AFrzp41cGrDl518KoXfAvXF7wS8ErAK8F8UOb6lQt4JeCVgFcCXgl4JeCVgFfS4Ns6tEArtEHDt8EXvBLwSsArAa8EvBLwSsAr6fDtDh3QCY12xnxQBL7glYBXAl4JeCXglYBXAl4JxleC8ZWAVwJeCXglGF8JxlcCXgl4JeCVgFcCXgl4JeCVGHwN1xe8EvBKwCvBfFAMvuCVgFcCXgl4JeCVgFcCXonD13F9wSsBrwS8EswHJeALXgl4JeCVgFcCXgl4JeCVYHwlGF8JeCXglYBXgvGVYHwl4JWAVwJeCXgl4JWAVwJeScG3cH3BKwGvBLxSzAcV61cKXil4peCVglcKXil4peCVHvCd+4Ou4JWCVwpeKeaDivUrBa8UvFLwSsErBa8UvFLwSjt85/6gK3il4JWCV4r5oGL9SsErBa8UvFLwSsErBa8UvFLMB3XuD7qCVwpeKXilmA8q5oMKXil4peCVglcKXil4peCVGnwN1xe8UvBKwSvF+pVi/UrBKwWvFLxS8ErBKwWvFLxSh6/j+oJXCl4peKVYv1KsXyl4peCVglcKXil4peCVglca8E1cX/BKwSsFrxTzQcV8UMErBa8UvFLwSsErBa8UvNKCb+H6glcKXil4pZgPKtavDLwy8MrAKwOvDLwy8MrAK8N6u839QTfwysArA68M80HD+pWBVwZeGXhl4JWBVwZeGXhlWG+3uT/oBl4ZeGXglWE+aFi/MvDKwCsDrwy8MvDKwCsDrwzrV4b1KwOvDLwy8MowHzSstxt4ZeCVgVcGXhl4ZeCVgVeG9XYzXF/wysArA68M80HDeruBVwZeGXhl4JWBVwZeGXhlWG83x/UFrwy8MvDKMB80rLcbeGXglYFXBl4ZeGXglYFXhvV2C1xf8MrAKwOvDPNBA68M4yvD+MrAK8N80LDebli/MvDKwCsDrwzjq1d++1j/fOW3P3OA/ZXf/vw+rL/y2+v8++Fb598P3+dZ0P7Kb68aukE/fR+r5UML9NP3sVo+tEH70Dr007f1898TuqYevGrPvHcf+e2XHr7PMx/8zG9/6+HbR5kHr956+MrwHbxqzxx7P/Pb37qmHrxqMuoyePXWw1dHGQav3lqhh6/K0A49fJ9nyPuZ3/7WNfXgVbNRzsGrtx6+Nso2ePXWw9dH3Qev3tqhh6+Pdhi8euvhG6OdB69ajDIMXr11hx6+McozePXWwzdGzMGrtw7o4TvWe8/89pcevGo52nbw6q079PAd9+qZ3/7Ww7dG2w5evfXwrVH3wau3fvr2Y9Rl8Oqtn769jWs3ePXWAq1Dj/iDV2/99O39jBNDjzIPXnU5/7819eDVWzfoDi3QCm3QDh3Q8A34JnwTvgnfhG/CN+Gb8E34JnwTvgXfgm/Bt+Bb8C34FnwLvgXfmr5nfvtbN+gOffrK0Apt0KevDh3QCV1TtwO6zTitQ8O3Kf7eoOHb4Nvg2+Db4dvh2+Hb4dtR3476dvh2+Hb4dvgKfKVBd2iBRn0FvuLQAZ3QNbXCV+Gr8FX4KnwV7ayor6K+ivoqfO2ARjsb2tnQzgZfg6/B1+Br8DW0s6O+jvo66uvwdVxfRzs72tnRzg5fh2/AN+Ab8A20c6C+gfoG6hvwDVzfQDsn2jnRzgnfhG/CN+Gb8E20c6K+ifoW6lvwLVzfQjsX2rnQzgXfgm/Bt6ZvHgd0g+7QAq3Q0zcPhw7ohJ7tnOBVNvg2+Db4glcJXiV4leBVglfZ4NsP6AbdoQUavh2+4FWCVwleJXiV4FWCVwlepcBXFBrtDF4leJUCX4EveJXgVYJXCV4leJXgVYJXqfBVXF/wKsGrBK/S4GvwBa8SvErwKsGrBK8SvErwKh2+jusLXiV4leBVOnwdvuBVglcJXiV4leBVglcJXmXAN3B9wasErxK8yoRvwhe8SvAqwasErxK8SvAqwatM+BauL3iV4FWCV1nwLfiCVwleJXiV4FWBVwVeFXhVGF8VxlcFXhV4VeBVYXxVGF8VeFXgVYFXBV4VeFXgVYFX1eDbEnq2c4FXBV5Vh2+HL3hV4FWBVwVeFXhV4FWBVyXwlQ6NdgavCrwqga/AF7wq8KrAqwKvCrwq8KrAq1L4Kq4veFXgVYFXZfA1+IJXBV4VeFXgVYFXBV4VeFUGX8f1Ba8KvCrwqhy+Dl/wqsCrAq8KvCrwqsCrAq8q4Bu4vuBVgVcFXlXAN+ALXhV4VeBVgVcFXhV4VeBVJXwT1xe8KvCqwKsq+BZ8wasCrwq8KvCqwKuavIpj8iqO4/KN4+jQAq3QBu2IE9AJDd8G38mrOCav4pi8imPyKo4G3+bQAZ3QNXWHb4dvh2+Hb4fv5FUcHfXtqG9HfTt85YBGOwvaWdDOAl+Br8BX4CvwFbSzor6K+irqq/BVXF9FOyvaWdHOCl+Fr8HX4GvwNbSzob6G+hrqa/A1XF9DOzva2dHODl+Hr8PX4evwdbSzo76O+gbqG/ANXN9AOwfaOdDOAd+Ab8A34JvwTbRzor6J+ibqm/BNXN9EOyfaOdHOBd+Cb8G34FvwLbRzob6F+hbqW9O3HQd0g+7QAj19G3jV5vgq2hxfRQOv2gHfBt8GX/CqgVcNvGpzfBXtxSsfevg+18bjzG9/65r65JX2oRv08NUR5+TVSw/f5zkkcea3v/XwfZ63HGd+e3+ecxJnfvtb19Qnr57fXY0zv/2th6+PMpy8emmFHr4+6nvy6qWHb4x2O3n10jX1yasY5Tx59dLDN0bZTl699PDNUfeTVy/t0MM3RzucvHrp4VujnU9e1SjDyauX7tDDt0Z5Tl699PCtEfPk1UsH9NNXnuf0xpnf/tKDV3KMth28eusO/fSVNso5ePXWNvRo28Grt46hR90Hr956+PZRl8Grtx6+Mq7d4NVbC/TwPe/hwau3Hr4y2mHw6q2H73mfD1699ODVWzfoDi3QCm3QDh3Q8E34FnwLvgXfgm/Bt+Bb8C34Fnxr+p757W/doDu0QCu0QTt0QCc0fBt8G3wHr0SPoQVaoQ3aoQM6oWvqwau3btCnrw0t0KevDm3Qjr8J6MTf1NRyzL+RBn36xtDwFYWGrzg0fCWh4asHNHwV9VWZZVD4qkHDVwMavlpTG3ytQcPXUF/TWQaDr6GdDb6Gdjb4OtrZ4Xvy6qXh66jvyauzDA5fRzs7fB3tHPANtHPA9+TVS8M3UN+TV2cZAr6Bdg74Jto54Zto54Rv4n5O+Cbqe/LqLEPCN9HOBd9COxd8C+1c8C3czwXfQn1PXp1lqOl75re/9fQ989vfWvA3Cm34G4cO/E1C11WGM7/9rYevtaE7tEArtEE7dEAP3zH+OfPbX/rk1Us36A4t0Apt0A4d0PA9eeVPHp757W/doIevjzKfvBpjpzO//a0N2qEDevj6aM+TV/4cS5z57W/doDu0QCu0QTv08B3jtzO//a2H7xi/nfntMsZsZ367PPNw4sxvf2uBVmiDduiATuia+uTVS8PX4evwdfg6fB2+Dl+Hr8M34BvwDfgGfAO+Ad+Ab8A34BvwTfgmfBO+Cd+Eb8I34ZvwTfgmfAu+Bd+Cb8G34FvwLfgWfAu+J6/G2P7Mb5cxPj/z2+WZoxVnfvtbC7RCG7RDB3RC19Qnr14avg2+Db4Nvg2+Db4Nvg2+Db4dvh2+Hb4dvh2+Hb6DV/rM84kzv/2tE7qmHrx66wbdoQVaoQ0avgJfga/AV+Gr8FX4KnwVvgpfha/CV+Gr8DX4GnwNvgZfg6/B1+Br8DX4Gnwdvg5fh6/D1+Hr8HX4Onwdvg7fgG/AN+Ab8A34BnwDvgHfgG/AN+Gb8E34JnwTvgnfhG/CN+Gb8C34FnwLvgXfgm/Bt+Bb8C341vQ989vfukF3aIFWaIN26IBOaPg2+Db4Nvg2+Db4Nvg2+Db4Nvg2+Hb4dvh2+Hb4dvh2+IJXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl4ZeGXglYFXBl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl45eOXglYNXDl4FeBXgVYBXAV4FeBXgVYBXAV4FeBXgVYBXAV4FeBXgVbx4VUMP37Gnc+a369jHOfPb3zqhh28f+uTV892KOPPb33r4jrX3M79dx77hmd/+1sPXTj187YwZ0MN3rCOd+e0vffIqxt+cvHrpDj18Y9Tx5NWYv5/57W89fPOMGdAJPXzHnt2Z327HaKvBKzvOf+/QAv30tbNtB6/e2qGfvtZHWw1e2dgXO/PbX3rwysZe2Jnfbs/3quLMb7ext3Lmt7/18JVRhsGrt3bogE7omtpP39GGg1dv3aEFWqEN2qEDOqFr6oBvwDfgG/AN+AZ8A74B34BvwDfhm/BN+CZ8E74J34Rvwjfhm/At+BZ8C74F34JvwbfgW/At+Nb0PfPb37pBd2iBVujhO/r4md/+1gGd0DX14NVbN+gOLdAKDd8G3wbfBt8G3w7fDt8O3w7fDt8O3w7fDt8O3w5fga/AV+Ar8BX4CnwFvgJfga/A9+TV2Ac589vfukMP3+c3g+LMb7fnO4xx5re/9fB9vrcYZ367Pb9FG2d+u411+DO//aVPXr10g+7QwzdHGU5evbRBO3RAJ3RNffLqpRt0h4avw9fhe/KqTh3QT18/RlsNXj1mE089eOXjeXrmt7/109cH58/89rfWoUfMwau3dugYerT/4NVbD9/B/zO//a0b9PDto2yDV289fGWUYfDqrYevnP/fgE7omnrwysez5sxvf+sOLdDDd+QUnfntbz18z/tw8OqtT99R5sErH3t2Z377WzfoeV+d+e1vrdBnffvQDh3Qw3fkMp357S89eOVjH+3Mb/eRj3Tmt7+1QCu0QTv08D3LNnj11jX14NVbD9/n94PizG9/a4FW6OEbo16DV289fPPUw3fc82d++0sPXvnY4zjz29+6Qwu0Qhu0Q5++MXRC19R6QDfoDi3QCm3QDg1fha/C1+Br8DX4GnwNvgZfg6/B1+Br8HX4Onwdvg5fh6/D1+Hr8HX4OnwDvgHfgG/AN+Ab8A34BnwDvgHfhG/CN+Gb8E34JnwTvgnfhG/Ct+Bb8C34FnwLvgXfgm/Bt+Bbl2+e+e1v3aA7tEArtEE7dEAnNHwbfBt8G3wbfBt8G3wbfBt8G3wbfDt8O3w7fDt8O3w7fDt8O3w7fDt8Bb4CX4GvwFfgK/AV+Ap8Bb4CX4Wvwlfhq/B98SqHNmiHPsftPnRCn7711C9enbpBd2iBVmiDduiATmj4Onwdvg5fh6/D1+Hr8HX4OnwdvgHfgG/AN+Ab8A34BnwDvgHfgG/CN+Gb8E34JnwTvgnfhG/CN+Fb8C34FnwLvgXfgm/Bt+Bb8K3p244DukF3aIFWaIN26IBOaPg2+Db4Nvg2+Db4Nvg2+Db4Nvg2+Hb4dvh2+Hb4dvh2+Hb4dvh2+Hb4CnwFvgJfga/AV+Ar8BX4CnwFvgpfha/CV+Gr8FX4KnwVvgpf8KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4NWZ367PfLw889vHGm+e+e2ap77Wn/PMbx9zpTzz2996+D7Pv8ozv/2tG/TTN57rtHnmt7+1Di1D29A+tA9dQwd0QtfUg1dv3aA7tEArtEHDt8G3wbfBt8O3w7fDt8O3w7fDt8O3w7fDt8NX4CvwFfgKfAW+Al+Br8BX4CvwVfievHq+z5Jnfvs5Luqv9avz34dvO//d5nUfvIrneVB55re/dULX1INXb92gO7RAK7RBw9fga6fvuA8Nvg5fh6/D1+HrOuM4fB2+Dl9Hfb3m/zfgG/AN+AZ8A75h0A4d0KhvwDcP6AbdoQUavnn66tDDV8a1Hrx664SuqQev3rpBd2iBVmiDhm/Bt+Bb0/fMb3/rBt2hBVqhDdqhAzqh4dvg2+Db4Nvg2+Db4Nvg2+Db4Nvge/Lq+a5invntb92hT18dWqEN2qEDOhGnphb4nrw6//7k1UvDV+Ar8BX4CnwFvgJfha+ivor6KnwVvgpfha/C9+TVS9fUJ69eGvU1+J68emmFNmiHhq/B1+Dr8HX4OtrZUV9HfR31dfievHpptLOjnQPtHPAN+AZ8A74B30A7B+obqG+gvgnfxPVNtHOinRPtnPBN+CZ8E74J30I7F+pbqG+hvgXfwvUttHOhnQvtXNNXjwO6QXdogVZog3bogJ6+eszrq+2AbtAdGr4Nvg2+Db4Nvi2hUd+O+nbUF7zSLtAKbdAODd8O3w5fgS94peCVglcKXil4pQJfCWi0M3il4JUqfBW+4JWCVwpeKXil4JWCVwpeqcHXcH3BKwWvFLxSg6/BF7xS8ErBKwWvFLxS8ErBK3X4Oq4veKXglYJX6vAN+IJXCl4peKXglYJXCl4peKUB38D1Ba8UvFLwShO+CV/wSsErBa8UvFLwSsErBa+04Fu4vuCVglcKXmnBt+ALXhl4ZeCVgVcGXhl4ZeCVHdPXjoBO6NnOBl5Zg2+DL3hl4JWBVwZeGXhl4JWBV4bxlWF8ZeCVgVcGXhnGV4bxlYFXBl4ZeGXglYFXBl4ZeGUCXzFotDN4ZeCVCXwVvuCVgVcGXhl4ZeCVgVcGXpnCV3F9wSsDrwy8MoOvwRe8MvDKwCsDrwy8MvDKwCtz+DquL3hl4JWBV+bwdfiCVwZeGXhl4JWBVwZeGXhlAd/A9QWvDLwy8MoSvglf8MrAKwOvDLwy8MrAKwOvrOBbuL7glYFXBl5ZwbfgC14ZeGXglYNXDl45eOXglR/T1w+DduiATmj4NviCVw5eOXjl4JWDVw5eOXjlDb5tXl8Hrxy8cvDKMR90zAcdvHLwysErB68cvHLwysErF/iKQKOdwSsHrxzzQRf4glcOXjl45eCVg1cOXjl45QpfxfUFrxy8cvDKMR90gy945eCVg1cOXjl45eCVg1fu8HVcX/DKwSsHrxzzQXf4glcOXjl45eCVg1cOXjl45QHfwPUFrxy8cvDKMR/0hC945eCVg1cOXjl45eCVg1ee8E1cX/DKwSsHrxzzQS/4glcOXjl45eCVg1cBXgV4Fcf0jUOgFdqgHToQJ6HhC14FeBXgVYBXAV4FeBUNvi2gE3q2c4BXgflggFeB8VVgfBXgVWA+GB2+WL8K8CrAqwCvAuOrePHKh57rdSEG7dABndBzvS70gG7QHVqg4avwVfgqfBW+Cl+Dr8HX4GvwNfgafA2+Bl+Dr8HX4evwdfg6fB2+Dl+Hr8MX88HA+lVg/SrAqwCvArwKjK8C46sArwK8CvAqwKsArwK8CvAqwKsArwK8ioRvwhe8CvAqwKvAfDCwfhXgVYBXAV4FeBXgVYBXAV7lMX3zaNAdWqAV2hDHoQM6oeELXiV4leBVglfZ4NsM2qEDOqHhi/WrBK+ywxfjq8T4KsGrxPgqMb5K8Cqx3p5Yb09BO2N8lZgPJtavEutXifX2xPgqMb5KjK8S46vE+Cqx3p6K66toZ0U7Y3yVmA8m1q8S61eJ9fbE+CoxvkqMrxLjq8T4KrHenobra2hnQztjfJWYDybWrxLrV4n19sT4KjG+SoyvEuOrxPgqwasMXN9AOwfaGeOrBK8S61eJ9avEenuCVwleJXiV4FWCV4n19kxcX/AqwasErxLzwcT6VYJXCV4leJXgVYJXCV4leJVYb8+a17fAqwKvCrwqzAcL61cFXhV4VeBVgVcFXhV4VeBVYb29mkArtEE7NHyxflXgVYFXBV4VeFXgVYFXBV4VxleF8VWBVwVeFXhVGF8VxlcFXhV4VeBVgVcFXhV4VeBVYb29sD9Y4FWBVwVeFeaDhfWrAq8KvCrwqsCrAq8KvCrwqrDeXtgfLPCqwKsCrwrzwcL6VYFXBV4VeFXgVYFXBV4VeFUYXxXGVwVeFXhV4FVhfFUYXxV4VeBVgVcFXhV4VeBVgVeF9fbC/mCBVwVeFXhVmA8W1q8KvCrwqsCrAq8KvCrwqsCrwnp7YX+wwKuavKpj8qqOOR+sY65f1TF5VcfkVR2TV3VMXtUxeVXH5FUdk1d1NPjO/cE6Jq/qmLyqY/KqjgbfBt8G3wbfBt/Jqzo66ttR3476dvjO/cE6Jq/qmLyqY/Kqjg5fga/AV+Ar8BW0s6C+gvoK6ivwFVxfRTsr2lnRzgpfha/CV+Gr8FW0s6K+hvoa6mvwNVxfQzsb2tnQzgZfg6/B1+Hr8HW0s6O+jvo66uvwdVxfRzs72jnQzgHfgG/AN+Ab8A20c6C+gfoG6pvwTVzfRDsn2jnRzgnfhG/CN+Gb8C20c6G+hfoW6lvwLVzfQjsX2rnQznM+WG2uX1UDrxp41cCrBl418KqBVw28anO9vdrcH6wGXjXwqoFXrcG3wRe8auBVA68aeNXAqwZeNfCqdfjO9atq4FUDrxp41Tp8O3zBqwZeNfCqgVcNvGrgVQOvmsB37g9WA68aeNXAq6bwVfiCVw28auBVA68aeNXAqwZeNYOv4fqCVw28auBVM/gafMGrBl418KqBVw28auBVA6+aw9dxfcGrBl418Ko5fMGrFqhvoL7gVQv4BnwDvuBVA68aeNUS9X3xyoe+1uuqpUArtEE7dEAndE0980WrzXzRagXfgm/Bt+Bb8C34Fnxnvmj1mS9afeaLVp/5otVnvmj1mS9afeaLVp/5otVnvmj1mS9a/YBvg2+Db4Nvg2+Db4PvnA9Wn+tX1ef6VXXwqoNXHbzqGF91jK86eNXBqw5edfCqg1cdvOrgVQevOnjVwasu8BX4glcdvOrgVRf4KnzBqw5edfCqg1cdvOrgVQevusJ37g9WB686eNXBq27wNfiCVx286uBVB686eNXBqw5edYfv3B+sDl518KqDV93h6/AFr3rAF+OrjvFVB686xlcd46sOXvXA9Q20c6CdMb7qCd+Eb8I34YvxVcf4qmN81TG+6hhf9YJv4foW2rnQzhhf9YJvwbfgW/DF+EowvhKMrwTjK8H4SuZ6e8ncHyyZ+4MlM5+hBOMrwXxQGnwbfBt8Mb4SjK8E4yvB+EowvhLwSub+YCG/vZDfXshvL+S3F/LbC/nthfz2Qn57CXgl4JWAV8hvLxH4znyGEvBKwCsBr5DfXiLwBa8EvBLwSsAr5LcX8tsL+e0lCl/F9QWvBLwS8Ar57SUGX/BKwCsBrwS8Qn57Ib+9kN9e4vB1XF/wSsArAa+Q317i8AWvBLwS8ErAK+S3F/LbHxr1xfhKML4S8ErAKwGvkN9egvGVgFcCXgl4JeAV8tsL+e2F/PaShG/i+oJXAl4JeIX89pKCL3gl4JWAVwJeIb+9kN9eyG8vnevtpXN/sBS8UvBKwSvkt5di/UrBKwWvFLxS8Ar57YX89kJ+eynGV4rxlYJXCl4peIX89lKMrxS8UvBKwSsFr5DfXshvL+S3lwp85/5gKXil4JWCV8hvL8X6lYJXCl4peKXgFfLbC/nthfz2UoWv4vqCVwpeKXiF/PZSrF8peKXglYJXCl4hv72Q317Iby81+BquL3il4JWCV8hvL8X6lYJXCl4peKXgFfLbC/nthfz2UswHNXB9wSsFrxS8Qn57KeaDCl4peKXglYJXyG8v5LcX8ttLE76J6wteKXil4BXy20uxfqXglYJXCl4peIX89kJ+eyG/vQzr7Tb3B8vAKwOvDLxCfnsZ1q8MvDLwysArA6+Q317Iby/kt5dhvd3m/mAZeGXglYFXyG8vw3zQwCsDrwy8MvAK+e2F/PZCfnsZ1ttt7g+WgVcGXhl4hfz2MqxfGXhl4JWBVwZeIb+9kN9eyG8vw3q7Ka4veGXglYFXyG8vw/qVgVcGXhl4ZeAV8tsL+e2F/PYyrLeb4fqCVwZeGXiF/PYyrF8ZeGXglYFXBl4hv72Q317Iby/D+pVh/crAKwOvDLxCfnsZ1tsNvDLwysArA6+Q317Iby/kt5dhvd0S1xe8MvDKwCvkt5dhvd3AKwOvDLwy8Ar57YX89kJ+exnW2w37gw5eOXjl4BXy28ux3u7glYNXDl45eIX89kJ+eyG/vRzr7Y79QQevHLxy8Ar57YX89kJ+eyG/vRy8Qn57OdbbHetXyG8v5LcX8tsL+e31zm9/rn++89vb0A26Qwu0Qhu0Qwd0Qs91Qlf4KnwVvgpfha/CV+Gr8FX4KnwNvgZfg6/B1+Br8DX4GnwNvgZfh6/D1+Hr8MV80LF+5Vi/Qn57Ib+9kN9eyG8v5LeXg1cOXiG/vRy8cvDKwSsHr5DfXshvL+S3l2N/0LE/6OCVg1cOXiG/vRzrVw5eOXjl4JWDV8hvL+S3F/Lby7E/6NgfdPDKwasAr5DfXoH1qwCvArwK8CrAK+S3F/LbC/ntFdgfDOwPBngV4FWAV8hvr8D6VYBXgf3BwPgqML5CfnsFxleB8RXy2yuw3o789kJ+eyG/vZDfXshvL+S3F/LbHxq+GF8FxleB8VVgfBVYbw/sDwb2BwP5DIHxVWA+GFi/CqxfBdbbA+OrwPgqML4KjK8C46vAentgfzCwPxjIZwiMrwLzwcD6VWD9KrDeHhhfBcZXgfFVYHwVGF8FeBXYH0R+eyG/vZDfXshvL+S3F/LbC/nthfz2CvAqwKsAr5DfXoH19kA+Q4BXAV4FeIX89gqsXwV4FeBVgFcBXiG/vZDfXshvr8B6eyCfIcCrAK8CvEJ+eyXWrxK8SvAqwasEr5DfXshvL+S3V2K9PZHPkOBVglcJXiG/vRLrVwleJXiV4FWCV8hvL+S3F/LbKzG+SoyvErxK8CrBK+S3V2J8leBVglcJXiV4hfz2Qn57Ib+9Euvtif3BBK8SvErwCvntlVi/SvAqwasErxK8Qn57Ib+9kN9eifX2xP5gglcJXiV4hfz2SqxfJXiV4FWCVwleIb+9kN9eyG+vxPgqMb5K8CrBqwSvkN9eifFVglcJXiV4leAV8tsL+e2F/PZKrLcn9gcTvErwKsEr5LdXYv0qwasErxK8SvAK+e2F/PZCfnsl1tsT+4MJXiV4leAV8tsrsX6V4FWBVwVeFXiF/PZCfnshv70K6+2F/cECrwq8KvAK+e1VWL8q8KrAqwKvCrxCfnshv72Q316F+WBhf7DAqwKvCrxCfnsV5oMFXhV4VeBVgVfIby/ktxfy26uw3l7YHyzwqsCrAq+Q316F9asCrwq8KvCqwCvktxfy2wv57VVYby/sDxZ4VeBVgVfIb6/C+lWBVwVeFXhV4BXy2wv57YX89iqstxf2Bwu8KvCqwCvkt1dhPljgVYFXBV4VeIX89kJ+eyG/vQrr7YX9wQKvCrwq8Ar57VVYvyrwqsCrAq8KvEJ+eyG/vZDfXoX19sL+YIFXBV4VeIX89iqsXxV4VeBVTV6145jAev5o/NH5Q/jjMn/+MP5w/gj+SP5gCRpL0FiCxhI0lmDi6/nD+MP5I/iDJZhrWo8fE2LPH40/On+wBJ0l6CxBZwk6SzBh9vzBNhC2gbANhCWYO4jPH7wKwqsgvArCEghLICyBsgTKEiivgrINlG2gbANlCZT3gfIqKK+C8SoYS2AsgbEExhIYS2C8CsY2MLaBsQ2cJXDeB86r4LwKzqvgLIGzDZxt4GwDZwmCJQiWIFiCYBsE2yBYgmAbvOjn54+zBHX+GCV4frPu8eMEoJ7/n5OAev5/TgTq+f85GWjt/KH8MUrgx/nD+WOUwF8+yR+jBH76nCiM87+cLHz/6PwxShBng5w4fP8YJYg4fzh/jBLEWYUTie8fowQ5SvBKon9+rOD5o/FH549RgjrOH8ofowQl5w/nj+CPUYKy80fhx2DiYzJ7/mj80flDxo+z1IOJ1w8bP86CDiZeP54leMxFzx/JH4Ufg4mPqen5o/HHKEHv549Rgn4WZzDx+mH8MUrQz7INJl4/Rgn6K3Thx2Di9WOUQNr5o/PHKIGeDT+YeP0w/hglOG/yM9P++jFKoGfDDya+fwwmPqaT54/GH6MEdlZuMPH6MUrg5wUeTLx+OH+MEvjLJ/ljlCDOUg8mZpyhBxMzzj8bTLz+i/CH8ofxh/NH8EcydOG/+IH/4o3/hSVwlsCV/x+WwFkCZwk8+aMQINgGwRIESxDC/w/bIIz/hSWI4H9hCYJtkCxB8iokS5AsQbIEyRIkS5Bsg2QJkm1QLEGxDarzz3gVileheBXK+V9YgmIJCm1wJupfPxp/oARnrv71X5Q/jD+c/5/gf0n+F5agsQSNJWidP3AVzrT9678Y/4vzv7AEjSVoLEFnCTpL0FmCzjboLEFnG3SWoONOPJP4r//CEgh645nHf/0XlkBYAlH+f1gC4VUQtoGwBII78Uzof/8XbfwvLIHyKijbQFkCZRsoS6AsgbIEZGI3toHxTiQTO5nYycROJnYysRtLYCyBswRkYicTO5nYycROJnYysTvvAzKxk4mdTOxkYg+2QbAEwRIES0AmdjKxk4k9WAIysSdLkCxBsgRkYk+WgEzsZGInE3uyLxT7ApnYycROJvZiCcjEXiwBmdjJxE4myoESCJkoR+cP4Z8p/4vxh/PPgv8l+V9YAjJRyEQhE6UJf+A+kMYSkInSgn+W/C+4D4RMlN74X1gCMlE6S0AmCpkonW3Q2QZkoghLICwBmShkogivApkowhKQiSIsgbAEyvtAeRXIRFGWQNkGZKIo7wMyUZQlUJbAWAIyUchEIROFTBQz/hnbgEwUMlE4ThQyUZxXgUwUMlGcJXCWgEwUjhOFTBRnCchECZaA40ThOFE4ThSOE4VMFDJRyEThOFHIROE4UThOFI4ThUwUMlGS98H/v7Q72HFtNw4o+i8e90AkiyxWfiUwDNtxAgOGbTh2gCB4/x6JbKkXkMw8ecBWS+qt4tG+PNI999nEsT0ObOKwicMmjtLAJg73icMmDps4yhnYxFH0INwnxqP5k+5PhhDCFJaQPtv2J8wgbGI0DWxi2MRwnxg2MdryCdKfaGATwyaG+8SwiWETw31i9OmzOQP3ieE+MboGNjFsYtjEGMOfaGATwyaGTQz3ieE+MdwnhvvEsInhPjHcJ0Y4A/eJEc7AfWLYxLCJYRPDc+eYGtjEsIlhE8Mmhk0M94lhE8N9YtjEWBrYxLCJYRPDfWLYxHCfGDYxbGJ8N3FduAZ54RrUhSksIYUtFPDdxG9oQheGoMHWYGuwNdgabA1Kg9KgNCgNSoPSoDQoDUqDwuBe1PD8KvxCE7owhGOw24UpLJ86hS1o0B5CE7owhBCmoEHToGnQNOgadA26Bl2DrkHXoGvQNegadA2GBsNVGK7CcBVuE9/gKtwmvkGDocHQIDQIZxDOIJxBOINwBuEMQoPQIDSYGkwNpgZTg6nB1GBqMDWYGkwNlgbLVViuwnIVlquwXIXlKiwNlgZLg9QgnUE6g3QGNnHaxGkTp02cNnHaxGkTp02cNnHaxGkTp02cNnHaxGkTp028l0u8J1quQrkK5SqURSpXwSZOmzht4rSJ6/EQmtCFIYQwhSWksAUNbOKyicsmLpu4bOKyicsmLpt4L6X4HuK9luIN/SE0of+M915P8QENbOKyicsmLpu4bOKyiWs4g+EMhjMYGgwNhgY2cdnEZROXTVw2cdnEZROXTbxXWbzndpv4hhRchdvE74neJr5BA5u4bOKyicsmLpu4bOKyicsmLpu4lgZLg6XB0mBpsDSwicsmLpu4bOK9/uI9quzCEEKgB/cijA9oYBOXTVw2cdnEZROXTVw2cdnEZROXTVw2cdnE5T5xuU9c7hOX+8TlPnG5T7wXZrynUx6J5ZFY9CAfHIn5vU/8BgzSJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sS0iek+Md0npk1Mm5i9C0PgT6Z71cYHNLCJaRPTJqZNTJuYNjFtYtrEtIlpE9Mmpk1Mm5g2MW1i2sR7Hcd7BhHCFJaQTOe7id+ggfvEtIlpE9Mmpk1Mm5g2MW1i2sS0iWkT0yamTUybmDYxlzNYzmClsAX+XLiXeHxAA/eJ6T4x3Sem+8R0n5g2MW1i2sS0iWkT0yamTUybmDbxXvLxfqXbGWxnsC1SOYOySDYxbWLaxLSJ6T4x3Sem+8R0n7jdJ273idsmbpu4beK2ifcykO8Xd68D+cAWmMG9FOT7Zd9rQT6ggU3cNnHbxG0Tt03cNnHbxO258/bceXvuvD133u4Td+e9cC8N+YAz6M6g8164l4d8QAObuG3itonbJm6buG3itonbJm6buG3itonbJm6buG3itonbJm6buG3itonbJm6buG3itonbJm6buG3itonbJt6LR97Wnjtvz52358578Wfj9tx5u0/c7hO3+8TtPnG7T9w2cdvEbRO3Tdw2caerkB6J6ZGYvhu3R+L23WgTt03cNnHbxO0+cbtP3O4Tt/vE7T5xe+68PXfenjvv8kj03HnXEjSwidsmlk0sm1g2sWxi2cR68F4om1g2sWxiPehB2cRyn1g2sWxi2cSyiWUTyyaW587luXO5Tyz3ieW5c3nuXDaxPHcu94nlPrHcJ5b7xBoa+Hli+Xli+XliDd6N5eeJZRPLJpZNLJtYNvFejfL+PaGBTSybWKFBLEEDP08sm1g28V6X8n7qqcHUYGowNZga2MSyiWUTyyaWTSybWDaxbGLZxLKJZRPLfWItj8TUwHPnSo/E9Ei0iZW+G21i2cSyiZW+G21ibQ22M9jOYLsK2xlsV+F7n7gubKGA733iN1yDvNCFY3D/kvS9hOXZzAtTWMIxqLiwhWNQr6du9zqWDzShC9egLoTwMqjzl6TbvY7lAym8DJ79u1DAaeIzeRea0A/MC0N4GdT5u9TtXsfygWNw/o5zu9exfGALx2Dc33Oa+IFjMO7LPk38wDEY92WfJn7gGJy/79/udSzP9/6FFLZwDOadwWniB47BvDqniR8YwjGYdyCniR84BisupLCFY7Cu9WniB47BuqKniR84BnkHcpr4gSkcg7zTOU38wDHYdxVOE99wmviBY7DvKz1N/MAQjsG+v/Q08QPHoL7vdgzqvrjTxA8UcJr4gSZ0YQghTGEJGiwNlgapQWqQGqQGqUFqkBqkBqlBarA12BpsDbYGW4OtwdZga7A12BqUBqVBXYN7JNYQQrgG93irJaSwhfqBex3L97Pd61g+0IXhY0KYwhJS2IIGTYOmQdOgDSEEDZoGTYOmQdPgNvENTeiCM+ga3Ca+YQkpbEGDocHQYGgwNBiuwnAGwxkMZzA0uE38hnAVwlUIVyE0CA1Cg9AgNAhXIZzBdAbTGUwNpsfBdBWmqzBdhanB1GBqsDRYGixXYTmD5QyWM1gaLI+D5SosVyFdhdQgNUgNUoPUIF2FdAbpDNIZbA22x8F2FbarsF2FrcHWYGuwNdgalKtQzqCcQTkDm9jK46BchXIVylWwif3xEJrQhSGEMIUlpIBBf3AcdJvYbWK3ib1p0DSwid0mdpvYbWK3id0mdpvYuwZ9CCFMYQkadA1sYreJ3SZ2m9htYreJ3Sb2ocFIwVWwid0m9tAgNLCJ3SZ2m9htYreJ3SZ2m9inBtPjwCZ2m9htYp8aTA1sYreJ3SZ2m9htYreJ3Sb2pcHyOLCJ3SZ2m9iXBqmBTew2sdvEbhO7Tew2sdvEnhqkx4FN7Dax28S+Ndga2MRuE7tN7Dax28RuE7tN7O4Tu/vEbhO7Tew2sbtP7O4Tu00cNnHYxGETh00cNnHYxPHAYDxS2AKrMGziaBo0DWzisInDJg6bOGzisInDJo6uQW9CF4YQggZdA5s4bOKwicMmDps4bOKwiWNoMKbgKtjEYRPH0CA0sInDJg6bOGzisInDJg6bOEKD8DiwicMmDps4pgZTA5s4bOKwicMmDps4bOKwiWNpsDwObOKwicMmjqXB0sAmDps4bOKwicMmDps4bOJIDdLjwCYOmzhs4tgabA1s4rCJwyYOmzhs4rCJwyaO0qA8DmzisInDJg7PnYfnzsMmDps4bGLYxLCJYRPDJsYDg3hMYQkpbEGDpoFNDJsYNjFsYtjEsIlhE6Np0DgOwiaGTQybGJ47R9fAJoZNDJsYNjFsYtjEsIkxNBhDcBVsYtjE8Nw5hgY2MWxi2MSwiWETwyaGTYzQIDwObGLYxLCJ4blzTA1sYtjEsIlhE8Mmhk0MmxhLg+VxYBPDJoZNDM+dY2lgE8Mmhk0Mmxg2MWxi2MRIDdLjwCaGTQybGJ47x9bAJoZNDJsYNjFsYtjEsImxNdgeBzYxbGLYxPDcOWxiuE8M94lhE8Nz5ygMpp8nTps4beK0idN94rmO5VnWdmEdWBdS2EIdOJ+Gn+tYfqC9oN1nezXxB8aBcSGEY9AfF47B/cLlXMfyA1s4BudfsmnnOpYfOAb96vQuDOEY9DuDPoVjMO5EewpbOAZxrcdDOAZxRUcXjsG8AxkhTOEY3K9iznUsP3AM5l2FcQzm1YmH0IRjsK5bDOEYrPvUMYUlHIPzT+G0cx3LDxyDvIOfD6EJxyCv9RzCMbhf35zrWH7gGNxvbM51LD9wDPZ9cbOAdQzut4rnOpYf6MIx+D78Vwgvg+dH9BeWkAeuwauJP1DAq4k/0IQuDCGEKSxBg9QgNdgabA22BluDrcHWYGuwNdgabA1Kg9KgNCgNSoPSoDQoDUqDwuBcx/ID12Be6MIQQpjCElLYQgHtIRyD+430uY7lB65BXQhherclpHfbQnG308QPXIN+QYPTxA9o0KegwWniBzToBQwNhjMYHZ2hwWniBzQYS9DgNPEDGsRD0CCcQQx0QoNwFUKDcBVCg3AVpgazCRpMZzADnanBdBWmBtNVmBosV2FpsLqgwXIGt4nfOkuD5SosDZarkBqkq5AapO+F1CCdwW3it05qkK5CarBdha3BdhW2Btv3wtZgO4PbxG+drcF2FUqDchVKg3IVSoPyvVAalDO4TfzWuU28kLeJbV1oQheGEMIUlnAM7v4tbxPfUMBt4hua0IUhhDCFJWhwm9jnhQJuE99wDe5LuE28G8C8TXxDCFNYwjEYd9a3ieff+Gx5m/gNt4lvaEIXhhDCFI7B3Y/mbeIbjsHdj+Zt4t2C5m3i+ScTW94mvqELQwhhCktIYQsFTA2mBlODqcHUYGowNZgaTA2mBkuDpcHSYGmwNFgaLA2WBkuDpUFqkBqkBqlBapAapAapQWqQGmwNtgZbg63B1mBrsDXYGtwm3hObvE285yV5mzjv++c28Q1dGEIIU1hCCluoH9iPh9CELgwhhCksIYUtaNA0aBo0DZoGTYPbxJUXlpDCFgq4TXxDE7owhBA06Bp0DboGXYOhwdBgaDA0GBoMDYYGQ4OhwdAgNAgNQoPQIDQIDUKD0CA0CA2mBlODqcHUYGowNZgaTA2mBlODpcHSYGmwNFgaLA2WBkuDpcHSIDVIDVKD1CA1SA1Sg9QgNUgNtgZbg63B1mBrsDXYGmwNtgZbg9KgNCgNSoPSoDQoDUqD0qAwqMdDaEIXhhDCFJaQwhY0aBo0DZoGTYOmgU0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLRxP6gif1BE/uDJvYHTewPmtgfNLE/aGJ/0MT+oIn98dCgadA0aBo0DZoGTYOmQdOgadA06Bp0DboGXYOuQdega9A16Bp0DYYGQ4OhwdBgaDA0GBoMDYYGQ4PQIDQIDUKD0CA0CA1Cg9AgNJgaTA2mBlODqcHUYGowNZgaTA2WBkuDpcHSYGmwNFgaLA2WBkuD1CA1SA1Sg9QgNUgNUoPUIDXYGmwNtgZbg63B1mBrsDXYGmwNSoPSoDQoDUqD0qA0KA1KA5vYbGKzic0mttvE8z1gb7eJ56u/3m4Tz7d9vd0mviGFY7C/n62A28Rz4WJvt4nnkqzebhPfcAxq/vL1q//67d/++Nvf/ekP//mrf/mfJ/77P/78+7//8S9//sa///df3z/53d/++Kc//fE/fvPXv/3l93/4t3/87Q+/+dNffv/62a8e3//51+d51fp6nkLlr5+/5cmvaw3n1/m/rzxvGa97PD87/HqersTrHq+HxPMrhK94fg3wuuH1mOeOuH89/xO//uU8yX3mGPkVc38/S/TxFWN8nqM9f9j7+xmenwd+PT/5ez2+vx5/7lPr5fG6bXxue6r0et0UPzfl1+ivm+bPTfNrPF43rc9Nrb768cvXTS+jvr/G/vjEV5zn3T+PeD6k9XgrPr+X+np+L/O6T72fItrXncLr/rN/zfMK2uP//tb2z46l/czl+XF1P2NpP3Np+6sftxb/z/3m+5f35yeufc7vX772V34m0F9375817c8Z9n5/9fo8PMdz/PH98Pn4Wo/Pw+fz/hfPw5/T6ndaLd8Pf32u/Py6//vhr0/0232t54fPSbS+P+N+fiDdxtXf/+wT1M8LeL7Ie6yfI2w/j7DxcX7ieJzjprOE+ZzDua29l/1pEZ9f+/xIcK7z858V6q8X/+tffvnl17/8Lw==",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7P3djjW9bqWJ3ss6roOgKFKkb6WxUXBXuxsGDLvhcu0Tw/e+Z1BBDmW+ayoj55xfAxtoHzif/NabY8SPyIiQKOk///Z//NP//r/+r//+z//6f/7b//zbP/xv//m3//3f//lf/uWf/6///i//9j/+8T/++d/+9fFf//Nvx/n/qOnf/oH+2+PnuH7a9dPnTz6un3T9bNdPvn7266dcPy89vvT40uNLr196/dLrl16/9Pql1y+9fun1S69fev3Sk0tPLj259OTSk0tPLj259OTSk0tPLj299PTS00tPLz299PTS00tPLz299PTSG5feuPTGpTcuvXHpjUtvXHrj0huX3rj07NKzS88uPbv07NKzS88uPbv07KHXzp8+f/px/aTrZ7t+8vXzoSfnz4feOH/q9XNcP+366fGzHcf1k66f7frJ189+/ZTr53l87YSRYAl+AR0JlNASOKEnSEIqUypTKlMqt1RuqdxSuaVyS+WWyi2VWyq3VG6pzKnMqcypzKkcsSMnSIImjARL8AsiggIooSVwQir3VO6p3FO5p3JPZUllSWVJZUllSWVJZUllSWVJZUllTWVNZU1lTWVNZU1lTWVNZU1lTeWRyiOVRyqPVB6pPFJ5pPJI5ZHKI5UtlS2VLZUtlS2VLZUtlS2VLZUtlT2VPZU9lT2Vz7gjO0ESNGEkWIJP4DP6JlBCS+CEniAJmjASzizRTvALzhicQAktgRN6giRowkhIZUrllsotlc8YbHICJ/QESdCEkWAJfsEZgxMoIZU5lTmVOZXPGGx+wkiwBL/gjMEJlNASOKEnSEIq91TuqdxTWVJZUllSWVJZUllSWVJZUllSWVJZU1lTWVNZU1lTWVNZU1lTWVNZU3mk8kjlkcojlUcqj1QeqTxSeaTySGVLZUtlS2VLZUtlS2VLZUtlS2VLZU9lT2VPZU9lT2VPZU9lT2VPZb+U+3EkUEJL4ISeIAmaMBIsIZUplSmVKZUplSmVKZUplSmVKZUplVsqt1RuqdxSuaVyS+WWyi2VWyq3VOZU5lTmVOZU5lTmVM4Y7BmDPWOwnzHIjzeZfsbgBEpoCZzQEyRBE0aCJaSypLKksqSypLKksqSypLKksqSypLKmsqayprKmsqayprKmsqayprKm8kjlkcojlUcqj1QeqTxSeaTySOWRypbKlsqWypbKlsqWypbKlsqWypbKnsqeyp7Knsqeyp7Knsqeyp7KfinLcSRQQkvghJ4gCZowEiwhlSmVKZUplSmVKZUplSmVKZUplSmVWyq3VG6p3FK5pXJL5ZbKLZVbKrdU5lTmVOZU5lTmVOZU5lTmVOZUzhiUjEHJGJSMQckYlIxByRiUjEHJGJSMQckYlIxByRiUjEHJGJSMQckYlIxByRiUjEHJGJSMQckYlIxByRiUjEHJGJSIQTlhJFiCXxAxGEAJLYETeoIkpPJI5ZHKI5XPGOzHCZTQEjihJ0iCJowES/ALPJU9lT2VPZXPGOznRThjcIImjARL8Al6xuAESmgJnNATJEETRsKp3E/wC84YnHAq6wktgRN6giRowkiwBL/gjMEJqdxSuaVyS+UzBrufoAkjwRL8gjMGJ1BCS+CEnpDKnMqcypzKZwzK4+7oGYMTKKElcEJPkARNGAmWkMqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKI5VHKo9UHqk8Unmk8kjlkcojlUcqWypbKlsqWypbKlsqWypbKlsqWyp7Knsqeyp7Knsqeyp7Knsqeyr7pTyOI4ESWgIn9ARJ0ISRYAmpTKlMqUypTKlMqUypTKlMqUypTKncUrmlckvllsotlVsqt1RuqdxSuaUypzKnMqfyGYPSTugJkqAJI8ES/IKIwQBKaAmp3FO5p3JP5Z7KPZV7KksqSypLKksqSypLKksqSypLKksqayprKmsqayprKmsqayprKmsqayqPVB6pPFJ5pPJI5ZHKI5VHKo9UHqlsqWypbKlsqWypbKlsqWypbKlsqeyp7Knsqeyp7Knsqeyp7KnsqeyXsh1HAiW0BE7oCZKgCSPBElKZUplSmVKZUplSmVKZUplSmVKZUrmlckvllsotlVsqt1RuqdxSuaVyS2VOZU5lTuWMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEHLGLSMQcsYtIxByxi0jEGLGJQTfIJHDAZQQkvghJ4gCZowEiwhlSmVKZUjBvUETugJkqAJI8ES/IKIwQBKSOWWyi2VWyq3VG6p3FK5pTKnMqcypzKnMqcypzKnMqcypzKnck/lnso9lXsq91TuqdxTuadyT+WeypLKksqSypLKksqSypLKksqSypLKmsqayprKmsqayprKmsqayprKmsojlc8Y1OOElsAJPUESNGEkWIJfcMbghFS2VD5jUPmEniAJmjASLMEvOGNwAiW0hFT2VPZU9lT2VPZU9kuZjuMooqJWxEW9SIq0aBRZUXlQeVB5UHlQeVB5UHlQeVB5UHlQebTyaOXRyqOVRyuPVh6tPFp5tPJo5cHlweXB5cHlweXB5cHlweXB5cHl0cujl0cvj14evTx6efTy6OXRy6OXh5SHlIeUh5SHlIeUh5SHlIeUh5SHloeWh5aHloeWh5aHloeWh5aHlscoj1EeozxGeYzyGOUxymOUxyiPUR5WHlYeVh5WHlYeVh5WHlYeVh5WHl4eXh5eHl4eXh5eHl4eXh5eHhXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V51RxThXnVHFOFedUcU4V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOI/6INUgK/KkiPNJVNSKuKgXSZEWlYeUh5SHlkfEuQW1Ii7qRVKkRaPIijwp4nxSeYzyGOUxymOUxyiPUR6jPEZ5WHlYeVh5WHlYeVh5WHlYeVh5WHl4eXh5eHl4eXh5eHl4eXh5eHl4ekRR0UVU1Iq4qBdJkRaNIisqDyoPKg8qDyoPKg8qDyoPKg8qDyqPVh6tPFp5tPJo5dHKo5VHK49WHq08uDy4PLg8uDy4PLg8uDy4PLg8uDx6efTy6OXRy6OXRy+PXh69PHp59PKQ8pDyiDj3IC7qRVKkRaPIijwp4nwSFZWHloeWh5aHloeWh5aHlscoj1EeozxGeYzyGOUxymOUxyiPUR5WHlYeVh5WHlYeVh5WHlYeVh5WHl4eXh5eHl4eXh5eHl4eXh5eHp4eUbh0ERW1Ii7qRVKkRaPIisqDyoPKg8qDyoPKg8qDyoPKg8qDyqOVRyuPVh6tPFp5tPJo5XHG+eAgK/KkM86HBlFRK+KiXiRFWjSKrMiTenn08ujl0cujl0cvj14evTx6efTykPKQ8pDykPKQ8pDykPKQ8pDykPLQ8tDy0PLQ8tDy0PLQ8tDy0PLQ8hjlMcpjlMcoj1EeozxGeYzyGOUxysPKw8rDysPKw8rDysPKw8rDysPKw8vDy8PLw8vDy8PLw8vDy8PLw9MjiqMuoqJWxEW9SIq0aBRZUXlQeVB5UHlQeVB5UHlQeVB5UHlQebTyaOXRyqOVRyuPVh6tPFp5tPJo5VFxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4j9qv4UG9SIq0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rxZ8teCrBV8t+GrBVwu+WvDVgq8WfLXgqwVfLfhqwVcLvlrw1YKvFny14KsFXy34asFXC75aH1/tkw/X7OTDfT9Ti9vf/s2H6/d7G3mQD/f92a64/e3z/t37cfvbv/lw4/n912//+Q9/+/M//ONf/vRvv/2//359+U//8S9//Pc///VfPl/++3/96/f//OPf/vyXv/z5n//+X//21z/+6f//x9/+9Pd/+esf3//vt+fzn7+b9drambX7D79+e9H+7v2Hcdev95/BjdeReL+iPX+9Hu3n+xXvb8n30+OXK+x94P09r+fL/uv1n/zD7+ck/31fZ/XL7X3Iv7D3nxp4yfNz4vcfOXj9s/Nz2uf1P+3npPU6Z91Txs8pd7/emr+P5c+x17vz/T60dKh/xXlV6dD6Fc/7UOv97V9+zj/vQ+939BrpmJ/3k7/ynHf/7++wn/F77QP8eq2HPyW9tvD65wT+HgD/Kei1O/H6ss+328+3vx5kv5Zen29/7a7W8/Ptr2fufr883172+jLOt/8M6Gs39ddrV/Hz7a+95F+mAX1dwteX8z3Ba3f212sn9pwg/q8nSBXwKvLePecCzesCxc97fn35WhCe79DVsX6NwzlW34GP953wPceyX6vO/9e18nfxf/j999//8Pv/AA==",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AGU1uALsr94r6A4DW\n8ArcQjKdqe5DkeEjxDEctqj5Ht8GNkkPAZQL4Tox/G3Q5K+a4bxdpSF3cClqGj7NX/scBxYcpQml\n9g6LAJpIZLAIJsKF2RWPmI8Kc+/COQ6ua68lB0tQHlaq1sFVmYd8WDr+Sm+xXdyjR45Y3ZKz6g5A\nO5kkdI+f5+vZmGwMSJRZOdfHrK8vy72Hdemoht8gL/ePOAqrv9H6Xn/HCuB8//23HLXcRgoX7aNI\n06n/0t/Ccw5eHtyX2W32Eh6A7zii1nTEqgL6gJY7GrGC4Pb4elSwJRcOpNZ2o+db8PXquNYzedPW\noUNY6qtXR8Bit0JxKE2Xqin3sR/dw0KTYq+5gf9Sc3NGMsXkjWQtWBz95ZkalZIzAUYHIGdKueOr\nBDTiK64eqkdFbrh9VKZgwHJt9fos0NgTCrfJC4/yPAxB/mjiVbG4PjATBKlmUwTQi1wHguXlDBD+\nOvaxZe5gkU/3oeUm+jdb0Q0X3RU0FGr9/7DmB3BVJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7\nBxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTB1yUyfbxAb9sHPVMJnYs4BKZbb7\nw0CAGKvJyEBzYF7PLgZs2Prg2oc0f8vuYQ9c9mZLwVNrcZBC5td5v75qv9QX5Y2YA7UfmWJmDJtR\n+5LEUhemGc8m4gc3s+wi0MLOQig/ZfKof+rlix9nO4QH0aLDH80H1ADuaA7aPejdaLLuJHD94ZsH\nhPj4MYPnoTvFOPmU3iYBtXNEgaMXI/ZmQXsfKqw+FL5gKOccR9rsd54/vFnfLB5LN/1vV0TZFUn6\n8icSlHd1beEDJDus9YxT7tjvXq4tuMJiBbq/r46gUctRIAmBVDQn5Mgeb2n39uhD+HaR50/cM8Hc\nYVUFDS1BhB4hWPF6Rhh5ICaPg/CKph34GHMz7qV4cB52ssJ+pCwD9wGAQY8rxPQLQK/IaSnDrVti\nonWjF589Kym3ooPJW++lE50vBp6O5VPWbA1PG4A3O0Bfdiege7kX4xD65hUjRSoKSOvi5haLmkpB\n7RCSOkOGC4R+aFUXL/M65u3GKr2orAntWo4i3mAswn8we09vX7o06xDPePlZbAU2kKvIkomUFgsS\nO/LOBbxT8IBeyteLAL1v8LGHHw7Z94qWrveA3cQS6mxK8qYDyhSaVsfuH230sXYvjMNaIiqD1vn1\njQDdmAIjcOtconz/A697znXVdrge2jkh+jiV7E5nyz1/V5bDDZ2UINUBVLO5qyr3UCUz7PSIPloo\nPhFEYhj5O2Urh28EIXnQlAcPzs+A/U9Ra3dCVSJgZCBBK8GHotuPo61EVCPkC8rWnuD7t2X9t+O6\nO+HweEERBAjqf/JAcKU7kbGKIZ7vEa3rjAjyXilbyCVyKXIbfic2LvAVn3L6JxYu5RcYK9juj2Fa\nq30HXey5ixRsuerNg3PboW01hVKV0dIeYA37m53p77PJXT7IXlYMoCvqoQDoyG6x+vSNJFENfFkY\nGnSJ3ETdZIH+Fr/GJ2XzF5DE9C2m09Fp5By+5yaMXXolxIPpPSWsONnqmNLKUOf18yQEboPq5nrH\nyOwGyE6Lox1msX0SdcaIQo1UPhIkPwrkrxZs17igMC3UcsEpVgaZAPXWWSLI/BoIVrvuV0dOE/oW\nPfdi865hyHCFjITYte0EOP0FZZLlKoGvniJ8zNsKAAjjnyFbj8h5TqJ5ZxdlXC71GJBAMliKoool\nnQYEemTEdjDVhEsqLfI3Uk7JMqPVJpaWK2NzmGUX7VJGfk4c3sxCl4pHDvu/s9fD+djkgmMPZT46\nwx35Xy6Xi61GlblC2fvPyTX5MO3hRPP3Nm6lMgtaDT7C5fKzBDrVkn917iJOe4uwdsAdnRXmldtJ\nYoR5L0k+SqJepx+Q/5V+KqqeomSYTxXLfqssT2ml2Ailb00MDfwyFqfkTkJc7/GGGfQrfw/rg2SO\nEbH+DYvGtgxvIQt+Bww1reRIgasMq+ppQb4/zeTE4IFhvnl5SCKu+7P2F0xNqsxv6+gtiDGpBETv\nEX32GkvxinRGtU2OzdDlJyENPQ9wXJw7Qm4veGR5CujPFMTyBusHozGX/1z2u6wLrwcDm+cLVXtv\nDU1Z+xKAoZlYPQqQ5tVT5L1kSbWO9QehChGFSw0wrqddreiukl/tbL8F77PitlsEvecaM00v6zMA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACHKzqHSGS+T79i8lKcj2beAxK+h4CooCcZIQY+rpnt6EryI/BMpAozl8nO1XMgNUZn3JG\nAmtobr6754DIxg/5AgDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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SapJLUmPp/sH9aSRZEkzqG9JklSSalJLSkdPR09HT0dPx3DHfjs2JMkd+1k8apI79jdrhzv2ejncsdeA4Y59bHO4Y78LHDPINr8WPn4jk6Ti9IhnNak5PeLZ7iiy/72eNJIsaTo9HHNLkqSS5I79ijRb0uF4bPN0x36nN0eSxe82Z9DjNPMNHDsK6Jr9LZPHsP2O1f+ui5r/VwU76K4jroG+R/sN1uMMdtxTWdzW/b8WsIINdNu+mIF44p/otv21JvHUL/vL5+K5X/bOGPHkP9Ft07GAbvPZo//nL//461/++9/+da89e3X6j7//S5Six//89//3f8X/57//469/+9tf/+c//69//Nu//Ov/+I9//Otetrxibef/+W82Hncbj/ud/n89HI///ZgYtT8/jvS2/4e6/4X5mB+wWev+F/Z/0exR1Jrptv8H8b/xqECP/9P34igRuD1St7VxRtlHk1opGeNxljWRiPCYKfxzH23/98Xr6f53HuXl8dvu/63mf3tMM5S5/6fGfxp/rv63lP+kf67b/p96/qfHeVY8/tj/075Fxf5cLben/bl5XIv/d923N/7fKn/Wx97t5f//Aw==",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAULQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjdbuJMDIbvJcccjD32/HArq6qiLV0hIVqx8EmfKu597WQ8gZVmRMPuCfPEZN7Yju0Evoa37cv55/Pu8P7xa1j/+Bpejrv9fvfzef/xujntPg5i/RqcfqQ8rGE1ZD8taVzA+bLGYU2yAg5r1jVOK5ZjlGPQEz0aqIIXIG9gFlaLqkUQSApBIAskMDBLFgvqrswToHMGZgGzQLXkAugNUgH1cIJYgMDAtrMJRt0urmImAVYQHe9Wg3ehgF59Ai6AZkEqoBedQHdJfjw5Ay7AZmGzBLMEMkgF1LEJYoGEBnoJcd5nZ8AGkhYv4ZAjg1RA7+wEZtHUTWAWb+eMUSiMUYzABnoJSRQxGaQCAQ1CAS2ACcySnIFul9qgjAZyDkmArM5PIMqEAuANzKLOEymkAr7osN73EcgsZBY2C2s9ixusro4QJUBSUA8pKKhFT9YSpajAU5EEBwapgHo4QS6AZGAWb+eMlSkQtdQpK6QCY6QKCAbiIUtpRU8GuQCZReOaQPtWUhcDF4jOIBVIcglGhVQgmyXrdimkpAFOEAqAWcAsaBbUa/nLZTXY2Hk+HbdbnTpXc0im0+fmuD2chvXhvN+vhv82+/N40q/PzWFcT5ujfCtxbA9vsorg+26/Vbqs5t2uvTWy1ta4OzJzFeBvKKSqEFxTAdsKcpuhKARp/qoQbhV8WyHFZAopOWwp3BsF0JI8BPJVgXNLIbQVfEDzQcZaqgoQ/I1EbEvIYycXCcA8OwH5ViJ14kje6ikmhlYucy8TmGsmQmopQCeZAJQtmwCMoSXSDQTnQEJTAbDnRuaaTphzIQ+t+8sC45wMWFRYc2lGiC0FncntygJfK8tfV9ZtHBAe7lKID7fp3ZFQbEfS1eBYNWJuamDnplAAq3EKRG0NeLjTsFOgkXJtNXZukYR0V5XAuEgiAMzDsy0BDzcr9sYnZpOQUqVms2JvfrpYx45Lc2l4/kOjM3dSrYzkqa3QGaABXO200FboxhGgxhFdW6Nb4jUXJK9bzRL3+G815PGHFsv1g1V+XXxDI1nLy2+stEwjcn22xkRtjU6NogPzAx3NExAD3mr07m2oDSup4bZGN5ZMpiGd144lPx4LuX8cyzxGIVFoxnL3IyGHZp1S5yUUsquxZLp6WQD/jUnKV28LC4cx4cMSd73AUfwLL3C94pB3hHpjr5uW/SIJzIskMs+3NYSFEjhLxGUS9deF4B+BPMnh5nV3vPkT66Jix93mZb8th+/nw+vVt6f/P+0b+xPs8/jxun07H7eqNP8TJh8/pD1X0l5P+teXHkpHgo96CHqY0krq/+mizvwG",
      "brillig_names": [
        "winner"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000003"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claim",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "spend_limit",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "pot",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        },
        {
          "fields": [
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "tally",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::TallyEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "claim",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "spend_limit",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "219": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "402": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        },\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n    use token::Token;\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        claim: PublicImmutable<u32, Context>,\n        spend_limit: PublicImmutable<u128, Context>,\n        challenge_fee: PublicImmutable<u128, Context>,\n        deposit_size: PublicImmutable<u128, Context>,\n        token: PublicImmutable<AztecAddress, Context>,\n\n        pot: PublicMutable<u128, Context>,\n        deposits: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct TallyEvent {\n        address: AztecAddress,\n        tally: u32,\n    }\n\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        claim: u32,\n        spend_limit: u128,\n        challenge_fee: u128,\n        deposit_size: u128,\n        token: AztecAddress,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.claim.initialize(claim);\n        storage.spend_limit.initialize(spend_limit);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.token.initialize(token);\n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        let token = storage.token.read();\n        let deposit_size = storage.deposit_size.read();\n        // Token::at(token)\n            // .transfer_in_private(\n                // context.msg_sender(),\n                // context.this_address(),\n                // deposit_size,\n                // 0\n            // )\n            // .call(&mut context);  \n\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n        CTF::at(context.this_address())\n            ._join(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _join(sender: AztecAddress) {\n        // assert(context.block_number() as u32 < storage.start.read(), \"Game has already started\");\n        storage.deposits.at(sender).write(storage.deposit_size.read());\n    }\n\n    #[public]\n    fn claim() {\n        assert(context.block_number() as u32 > storage.claim.read(), \"Claim period has not started yet\");\n        let mut refund = storage.deposits.at(context.msg_sender()).read();\n        if context.msg_sender() == storage.winner.get_current_value() {\n            refund += storage.pot.read();\n        }\n        Token::at(storage.token.read())\n            .transfer_in_public(\n                context.this_address(),\n                context.msg_sender(),\n                refund,\n                0\n            )\n            .call(&mut context);\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[private]\n    fn submit_score() {\n        let capture_note = storage.capture_note.at(context.msg_sender()).get_note();\n        let mut score  = storage.tally_note.at(context.msg_sender()).get_note().note.tally;\n        if capture_note.note.capture_block != 0 {\n            score += storage.end.read() - capture_note.note.capture_block;\n        }\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        assert(context.block_number() as u32 > storage.end.read(), \"Game is not over yet\");\n\n        storage.final_score.at(sender).schedule_value_change(score);\n        let (winner_score, _) = storage.winner_score.get_scheduled_value();\n        if(winner_score < score) {\n            storage.winner_score.schedule_value_change(score);\n            storage.winner.schedule_value_change(sender);\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n\n        let event0 = TallyEvent { address: context.msg_sender(), tally: note.note.tally };\n\n        // context.emit_event_in_private_log(\n        //     event0,\n        //     &mut context,\n        //     context.msg_sender(),\n        //     context.msg_sender(),\n        //     PrivateLogContent.CONSTRAINED_ENCRYPTION,\n        // );\n\n\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        assert(context.block_number() as u32 < storage.end.read(), \"Game has ended\");\n        assert(context.block_number() as u32 > storage.start.read(), \"Game has not started\");\n\n        let challenge_fee = storage.challenge_fee.read();\n        // Token::at(storage.token.read())\n            // .transfer_in_public(\n                // context.this_address(),\n                // context.msg_sender(),\n                // challenge_fee,\n                // 0\n            // )\n            // .call(&mut context);\n        storage.pot.write(storage.pot.read() + challenge_fee);\n\n        // Ensure the game is initialized\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[private]\n    fn slash(address: AztecAddress) {\n        // Set their tally back to 0.\n        let slot = storage.tally_note.at(address);\n        let note = TallyNote::new(address, 0);\n        slot.replace(note).emit(encode_and_encrypt_note(\n            &mut context,\n            address,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._slash(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn _slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger != AztecAddress::zero() , \"Challenge is no longer open\");\n\n        storage.deposits.at(address).write(0);\n        storage.pot.write(storage.pot.read() + storage.deposit_size.read());\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n\n        // New values assuming the reponder does not have the flag \n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let new_responder_note = CaptureNote::new(context.msg_sender(), 0);\n        let mut challenger_capture_note = CaptureNote::new(challenger, 0);\n\n        // The responder has the flag\n        // Update the values accordingly\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            challenger_capture_note.capture_block = challenge_block;\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_responder_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "91": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "99": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_tuple().is_some() {\n        let tuple_len = typ.as_tuple().unwrap().len();\n        let mut tuple_quotes: [Quoted] = [];\n        for i in 0..tuple_len {\n            let element_quote = quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name.$i)); };\n            tuple_quotes = tuple_quotes.push_back(element_quote);\n        }\n        tuple_quotes.join(quote {})\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    }
  }
}
