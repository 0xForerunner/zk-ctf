{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_join",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACJx4CAAIBHgIAAwAKKgIDBCQCAAQAAACDJQAAAlAnAgIAAC0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUtDgIFACIFAgUtDgIFACIFAgUtDgIFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OAgcAIgcCBy0OAgcAIgcCBy0OAgcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwAQJwIIBAktCAAJLQoECi0KAwstCgUMLQoGDS0KBw4ACAAIACUAAAJiLQIAACcCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAACYi0CAAAtCwYBCyIAAYBEAAckAgAHAAABuicCCAQAPAYIAScCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAABACUAAAOQLQIAAC0LAwEBIgABgEYABC0LBAMKKgMCAQsiAAGARAACJAIAAgAAAgslAAAEoycCAQALLwoAAQACHAoCBAYcCgQBADAKAAEAAyYoAIAEBHgADQAAAIAEgAMkAIADAAACTyoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEF2rtV/+xXZjk8BAIBJiUAAAInLQsEBgsiAAaARAAHJAIABwAAAoQnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAADHCMAAAKdLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJwILAQEkAgAKAAACxyUAAAS1LgIAB4ADKACABAQABCUAAATHLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEYABQ4qBgUHJAIABwAAAwclAAAFVS0OCgEtDggCLQ4FAy0OCQQjAAADjycCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAOQLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAExy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBGAAMtDggEIwAAA48mJQAAAicuCIBFAAUjAAADoA0iAAWAQwAGJAIABgAABBAjAAADtS0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEJiMAAASSLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAExy4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAASSASIABYBGAAYtCgYFIwAAA6AqAQABBQLcbieAdhKdPAQCASYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAATiIwAABO0uAIADgAUjAAAFVC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVALgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAUPKAGABQQAAQMAgAYAAoAGIwAABVQmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZjRbuMqEIbfxde5YAYYoK+yqqq0TVeRorTKtkc6qvruZwbz46SS0Vmv9ib+MobfDPwwTj6n58Pjx8+H4/nl9dd09+NzerwcT6fjz4fT69P+/fh61ujn5OyDnJ/u/E6veboTvZJ+T3bN85Vlvnqa7igYSIPgALFBRCQiIohIAOQGyQNSg8wAe0TcTexSAyIAbjEijIhHxEdAaRACIDeIHoBHCANMUKeEkwNEQGmQPSA3KAxo3b0jQGpAiBDasPUSg9TAI1Ln2aDOc4UAyA0iGkc0FgIgktC9ZlGhNKhZVMDTC7oXNC6tcXABgIhZhbKBdS8KHBt4D8gNgg6VnUFqEAkQAaWBeAAaJ3RPiGR0z9adFIoHWBs1UnTcgBwgN2DzvTPIDbwm6NmgNLAJ92p+IX2EzwZ2S9MRW68KZrYKtkwzBIAqB1UW0V5BBybm+RlSA8tihtigoE3JMyQnDcw/gQ1SAw6A0sDGU8HGM0OPWBt1XTLPVzDPVzCTzBABaGwmmQG9zOFB5zCbw2eIgNLAvDFDasBozOjuEfHo7tE9oLu5JeiuzLZhK9iRMkNskAggDXIAtDnMtj1naJNZXIsUM0BQP5c6P7rcpT6rQmpQJ6qCzE4o9tAZmjdKdgBECiKlRcg516nHiDotsQKqRp0pgXzv4XuPut5SybKvsTrsmWROgFydrZl6zIbeyPqWSgVUeswsGZ1VBysbjRKIoEyUQNWgMxVQXe5KwXVaYr0dlkGp60l/RrVs+vraTahqD++Xw8GK2lWZ0+L3tr8czu/T3fnjdNpN/+xPH7XRr7f9uV7f9xe9qxkczs96VcGX4+lg9LVberv1rsRkS1C7K0fpEiXeaNC6RtQ1aBKKuSvI7Sh4XSFHq15VQTeLW1MY5yG85JF5LY+wrhGKS00iFJK1UcRBHiFgMnOQsC2P6/XIYS2PgYbEVJqExLKsR7wdRR6MwkvAIAItY9CXoxuJMpCI0hTYLYvhKd+6apBGSgFp6Im+LAfn2zxoYE19y8CKXi0ou28KA2syFUIi7Mq6hh9sEEYi1+b+LYUCZ2o935YHZwyC/dWK/JZGor6oaZRJ+rsaJIIDhyTlbRopeWikwts0isOcUuF1jdFOC31ZKAZZ3Wk8WBZJDhZNLH45MW73Gg/8laQrXM2n/vL532eOEKZTxK+eOTw4PL0wioCXfD0Kf6sho+OzH31atJfdSuWbxmBV9a0R7kpamFbLWR5NZ9/xSWS9Io7OT32Z6AalyKvlaJwKL6nIqoSn0V6j1PeaX0qB/sbbUo+EeM0b3o+2Sbc4BU6rDvWD8p45oxjoCq8WZz+q7y739xStkasSI4fq/wr9RUWH77e8JDjuEk7W68FIgrrJ1Wl5m8TyxkV52yh8r2uK20YRu8X1AE3bJGQ5g3PZlshSCTxvS8SH/s7l46ZEUsCCpCBbBEqAvUvclMTyBl142wi6p/TH6R+m8F3gXr/un46Xm78Sv0zqctw/ng7t68vH+enq7vu/b7iDvyLfLq9Ph+ePy8GUlv8j9eMH658mLHRvvzj1q/7s3On+sq9kdzU7lnD/ZYP5Dw==",
      "brillig_names": [
        "_join"
      ]
    },
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEguCIBIAAElAAAARSUAAABpKAIAAQSASScCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcEAAEmJQAAAXgnAgIAEScCBAQFLQgABS0KAgYtCgEHAAgABAAlAAABoS0CAAAtCgYDCyIAA4BGAAILIgACgEQABCQCAAQAAACzJQAAAxsvCgADAAILIgACgEYAAwsiAAOARAACJAIAAgAAANYlAAADLScCAgAQJwIEBAUtCAAFLQoCBi0KAQcACAAEACUAAAGhLQIAAC0KBgMLIgADgEYAAQsiAAGARAACJAIAAgAAARslAAADGzAIgEYAAycCAQAPLwoAAQACHAoCBAYcCgQDABwKAwIGJwIDAAsvCgADAAQcCgQFBhwKBQMAHAoDBAYAKgIEAw4qAgMFJAIABQAAAWwlAAADPxwKAwIAMAoAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAAGgKgEAAQX3ofOvpa3UyjwEAgEmJQAAAXgtCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQFLgyARgAFACIFAgUuDIBGAAUAIgUCBS4MgEYABSsCAAQAAAAAAAAAAAIAAAAAAAAAAC0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHACIHAgctDgQHLQgBBAAAAQIBLQ4DBC0IAQMAAAECAS0OBQMtCAEFAAABAgEuDIBFAAUtCAEGAAABAgEuDIBEAAYnAgcECC0IAAgtCgQJLQoDCi0KBQstCgYMLQoBDQAIAAcAJQAAA1EtAgAAJwIBBActCAAHLQoECC0KAwktCgUKLQoGCy0KAgwACAABACUAAANRLQIAAC0LBgELIgABgEQAAiQCAAIAAALfJwIHBAA8BgcBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAABH8tAgAALQsDAQEiAAGARwADLQsDAi0KAgEmKgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVHcc4LT428GzwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmJQAAAXgtCwQGCyIABoBEAAckAgAHAAADcycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAQLIwAAA4wtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAO2JQAABZIuAgAHgAMoAIAEBAAEJQAABaQuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARwAFDioGBQckAgAHAAAD9iUAAAM/LQ4KAS0OCAItDgUDLQ4JBCMAAAR+JwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAABH8tAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAAWkLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEcAAy0OCAQjAAAEfiYlAAABeC4IgEUABSMAAASPDSIABYBDAAYkAgAGAAAE/yMAAASkLQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAUVIwAABYEtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAAWkLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABYEBIgAFgEcABi0KBgUjAAAEjyoBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABb8jAAAFyi4AgAOABSMAAAYxLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABh0uAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABewoAYAFBAABAwCABgACgAYjAAAGMSY=",
      "debug_symbols": "tZnRbts6DIbfJde9kEiJEvcqwzBkXTYECNIiaw9wMPTdR0qknBawsDrrTfSZsX5LJEUpzu/d98O3559fj+cfD792nz7/3n27HE+n48+vp4f7/dPx4SzW37ugHzFKA3fS5t6CXUOytvYWwdrS22TXiXqbpV/WtvaWqLclWcu7TzEIVHlQ1B6MAvFuByE6sEGUTjEpsAG4RcfTQAfUgQxSdHCLDqqDdi8CBAYlOFSDKuMBUJCHglo4dcCgTmGFbBDdon5DmSCq4zrI01F7YXRwi44QqwIZZLdkNiB5aAIFsSQRTCBjzkGBDFS5g1uSW5JbWkAauIX8HioGxZXVCVk8n5g75IAO9lWOboluAbdAMUC3oN+TkoMr52xAwUGnzArVoKBDMajRgQw4OHh3HbwCaZg6uCXaPaRhyqCQHdigDb5BMWhebeA3J79ZM6qDW8i76ywaNPc2IIPqT6/evfrN7DezPb0EcNDuksZFsy5nhWrQUkKhpUQDHSoJpOCQHKpBBgcyIL+ZvHtxS/HuLUkkjYuGQKE2J1QF/UrcW9uyV2i9GrCBrq8OMkGSrGNNLZIE4AgOZKBh6pAM0O/R6DTQoDTQVCdQIAONRYdqoOPpwAbVLRoCQgGmDjFoSTJiJ00ho+qkS9No9NUAUFLSCBilQdVJg2BETjR60FApw1aGShkqdahoVEhLbdBUMmIjebCTJpFRdtKVbGTejVEzyig7pWHTGkKk1NxXlNpzO5FRK+5GuSdLhJbGndIgdoJhg2HDYcNhS8OWh15ebNVJS74ROZXRo4weLTGobXnqDbVhG32nbPNopd9osbFT8yQ3qk44bJq7RXdB1P3TiJzyUM7uP2yZ3Mn9jC0POo3n1mEb8cARDxzxSCEMan1fXu52fiz4+nQ5HPRUcHVOkNPD4/5yOD/tPp2fT6e73X/703O76dfj/tzap/1FvpUZHM7fpRXBH8fTQenlbukd1rtKXlWw7pKUAYdEfq0RJxqoq6BLpJiGQsz5ryVSZZfIiVYlcF2CSogmIaV5mQfXVwppXaHQECh1GQKljc6MZc2ZNNXIQ6KE1WGUyTwqekaUmuOQoNeDqDNPgIejyJ66psDTaTAurgBa05i6k0ZIhTGv5uYks1j3zybBvLhCKtM7RlF4GQXX1VHgP1giePsaifnmRRLpQ1fJtUNLXC85deaMJTUSlNVxxEmOVhirVVZMWstQmMylhuqrtUqMVyXiPMuXokEJN60UOWkuLqWw5lLA2ysPpJtLD+Sbaw/QPyg+86nAMhVal5glKemv2z4MwiXB5FfpOyJLV1Hh1cjiRAQJXEOOMteLFl9rzNIUlkULzIsGv9GAm7MD8ebswPQPsmM+lb/KDqSPzo7rdc+wlh1zDaBFI62WY+Tby3Ga1VKMPMox8JpL0yxJM1xtkbDq0ukw/m5XSHjzrpDSB+8K4+gD4coX8c2BeLbXlzRWW+FlIlDfzGRyGsXs80jxSiG8UZiUUfmB6skF8qJyXWOSoEtiZAzbFNhXK8W8bR4wDnCAVxF5l0aJI6hlMpOMH6shL5nDKF5X58B3aZQy6vB17XqXBoex4hnWNWbLJMBYafLuZ5NEHBub/gbcJkHLeq/bRoEjRQW3jSKPbU0KaNkmQUsNrrxtIktQ5V3ONollY8S8aSIleUBKoi0CPM7TnDdNgoPHk2HbCEZOcck3TuGtwBe53N8fL6/+2XpRqctx/+10sMsfz+f7q2+f/n/0b/yfscfLw/3h+/PloErL32Py8VnPnPIP0Bd9nyqX8jqwoF7Iq8HPUV6Dx8xfXnQofwA=",
      "brillig_names": [
        "_slash"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgIEAScCAwQAHwoAAgADgE4uCIBOAAElAAAARSUAAACxKAIAAQSATycCAgQAOw4AAgABLACAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgEQEAAMoAIBFAQAAKACARgQAACgAgEcAAAAoAIBIAQABKACASQQAASgAgEoAAAEoAIBLBAAEKACATAAAcCgAgE0AAHImJQAADKwtCAECAAABAgEuDIBFAAItCAEDAAABAgEuDIBHAAMtCAEEAAABAgEnAgUAAi0OBQQeAgAGBRwKBggEHAoIBwAcCgcGBCcCBwADLwoABwAILQgBBycCCQQCAAgBCQEnAwcEAQAiBwIJLQoJCi0OCAonAgkECi0IAAotCgcLAAgACQAlAAAM1S0CAAAtCgsIDCoGCAckAgAHAAABViUAAAz6HgIABgUcCgYIBBwKCAcAHAoHBgQvCIBKAActCAEIJwIJBAIACAEJAScDCAQBACIIAgktCgkKLQ4HCicCCQQKLQgACi0KCAsACAAJACUAAAzVLQIAAC0KCwcMKgcGCCQCAAgAAAHBJQAADQwnAgYACS8KAAYABxwKBwgGHAoIBgAcCgYHBicCCAANLwoACAAJHgIACAAeAgAKAScCDAQAJwIOBAMAKgwODS0IAQsACAENAScDCwQBACILAg0tDgwNACINAg0tDgwNJwINBAMAKgsNDC0LCwwAIgwCDC0ODAsnAg0EAScCDwQDACoNDw4tCAEMAAgBDgEnAwwEAQAiDAIOLQ4NDgAiDgIOLQ4NDicCDgQDACoMDg0tCg0OLQ4IDicCDgQPLQgADy4IgEYAEC0KCxEuCIBJABItCgwTAAgADgAlAAANHi0CAAAtChAILQoRDS0LDQsAIgsCCy0OCw0nAgwEAScCDwQDACoMDw4tCAELAAgBDgEnAwsEAQAiCwIOLQ4MDgAiDgIOLQ4MDicCDgQDACoLDgwtCgwOLQ4KDicCDgQPLQgADy0KCBAtCg0RLgiASQASLQoLEwAIAA4AJQAADR4tAgAALQoQCi0KEQwtCwwIACIIAggtDggMACIKAgguAgAMgAMoAIAEBAABJQAADe0uCIAFAAsuCIAGAA0tDgYNLQsLBgAiBgIGLQ4GCwAiCAIGLgIAC4ADKACABAQAASUAAA3tLgiABQAKLgiABgAMLgyARwAMLQsKCAAiCAIILQ4ICikCAAgAjJ5UcgAiBgILLgIACoADKACABAQAASUAAA9tLgiABQAMLgiABgANLQ4IDQAiDAIKLQsKCCcCDQQCACoKDQY5A6CAQ4BDAAkACAAGIAIABiECAAgtCAEKACIKAg0tCw0MJwIOBAIAKg0OCyIyAAiARgALLQoIDCcCDgQDACoMDg0ACAENAScDCgQBACIKAg4tDgwOACIOAg4tDgwOLQoMCQYiCQIJJAIABgAABIAjAAAEVy0LCgYAIgYCBi0OBgoAIgoCCy0LCwgnAgwEAgAqCwwGPA4IBiMAAASACyIACYBGAAgkAgAIAAAEmScCCgQAPAYKAScCCAAPLwoACAAJHAoJCwYcCgsKABwKCgkGACoJBwoOKgkKCyQCAAsAAATKJQAAEOccCgoHADAKAAcACCcCBwARJwIMBA0tCAANLQoCDi0KAw8tCgQQLQoHES4IgE0AEi0KARMACAAMACUAABD5LQIAAC0KDggtCg8JLQoQCi0KEQsvCgALAAwLIgAMgEcACyQCAAsAAAU2JQAAEsAeAgALAR4CAAwFJwIOBAMnAhAEAwAqDhAPLQgBDQAIAQ8BJwMNBAEAIg0CDy0ODg8AIg8CDy0ODg8nAg8EAwAqDQ8OLQoODy0OCw8AIg8CDy0OAQ8AIg8CDy0ODA8AIg0CDi0LDgwnAg8EAgAqDg8LNwsACwAMJwIPBBAtCAAQLQoCES0KAxItCgQTLQoHFC4IgE0AFS0KARYACAAPACUAABD5LQIAAC0KEQstChIMLQoTDS0KFA4eAgACATAKAAIADicCAgASJwIEBA4tCAAOLQoCDy0KARAACAAEACUAABLSLQIAAC0KDwMLIgADgEcAAQsiAAGARQACJAIAAgAABj0lAAAUHx4CAAEFHAoBBAQcCgQCAC0IAQEnAgQEBAAIAQQBJwMBBAEAIgECBC0KBAcuDIBHAAcAIgcCBy4MgEcABwAiBwIHLgyARwAHLQgBBAAAAQIBLQ4BBC4IgEYABiMAAAacDSIABoBEAAEkAgABAAAMXSMAAAaxLQsEBi0IAQQnAgcEBAAIAQcBJwMEBAEAIgQCBy0KBwguDIBHAAgAIggCCC4MgEcACAAiCAIILgyARwAIASIABoBJAAgtCwgHJwIIBAIAKgYICi0LCgkBIgAGgEQACy0LCwotCAEGJwILBAQACAELAScDBgQBACIGAgstCgsMLQ4HDAAiDAIMLQ4JDAAiDAIMLQ4KDC0LBgkAIgkCCS0OCQYnAgoECy0IAAstCgYMLgiASQANAAgACgAlAAAUMS0CAAAtCgwJLQsGCgAiCgIKLQ4KBicCCwQMLQgADC0KBg0tCggOAAgACwAlAAAUMS0CAAAtCg0KJwIIBAstCAALLQoJDAAIAAgAJQAADNUtAgAALQoMBicCCQQLLQgACy0KCgwACAAJACUAAAzVLQIAAC0KDAgcCgcKBBwKCgkAHAoJBwQvCgADAAkcCgkLBBwKCwoAAioJCgssAgAJAC1eCYuCuje0O5mhMWEY/SDUL1FmyenxP7XqZaltHgptBCoLCQocCgoMBBwKDAsAHAoLDAQCKgoLDQQqDQkKHAoKDgEcCg4NABwKDQ4BAioKDQ8sAgAKADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCoPChAcChARBBwKEQ8AHAoPEQQCKhAPEgQqEgkPHAoPEAEcChAJABwKCRABAioPCRIEKhIKDxwKDxIEHAoSCgAcCgoPBBYKEAocCgkQBBwKChIEBCoQDwoWCg4PHAoNDgQcCg8QBAQqDhEPHgIADgUcCg4TBBwKExEAHAoRDgQMKg4MESQCABEAAAkvIwAACRccCg0MBAQqDA8RACoREAwtCgwBIwAACUccCgkMBAQqDAoQACoQEgwtCgwBIwAACUcAKg4BEA4qDhARJAIAEQAACV4lAAAQ5wwqDgcBFgoBBxwKAQ4EHAoHAQQEKg4GBwQqAQgGACoHBgEcChAGACcCBwAgJwIOBBAtCAAQLQoFES0KBxIACAAOACUAABSxLQIAAC0KEQgEKgsIBwAqBgcIJwIGAEAnAgsEEC0IABAtCgURLQoGEgAIAAsAJQAAFLEtAgAALQoRBwQqDQcGACoIBgccCg8GACcCCABIJwINBA4tCAAOLQoFDy0KCBAACAANACUAABSxLQIAAC0KDwsEKgYLCAAqBwgGJwIHAGgnAgsEDS0IAA0tCgUOLQoHDwAIAAsAJQAAFLEtAgAALQoOCAQqCQgHACoGBwgcCgoGACcCCQQNLQgADS0KBQ4uCIBMAA8ACAAJACUAABSxLQIAAC0KDgcEKgYHBQAqCAUGHAoBBQAtCwQBACIBAgEtDgEEKwIAAQAAAAAAAAAAAwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS4MgEcACQAiCQIJLgyARwAJACIJAgkuDIBHAAkAIgkCCS0OAQktCAEBAAABAgEtDgQBLQgBBAAAAQIBLQ4HBC0IAQcAAAECAS4MgEYABy0IAQgAAAECAS4MgEUACCcCCQQNLQgADS0KAQ4tCgQPLQoHEC0KCBEtCgYSAAgACQAlAAAVsS0CAAAnAgkEDS0IAA0tCgEOLQoEDy0KBxAtCggRLQoFEgAIAAkAJQAAFbEtAgAAJwIJBA0tCAANLQoBDi0KBA8tCgcQLQoIES0KAhIACAAJACUAABWxLQIAACcCCgQNLQgADS0KAQ4tCgQPLQoHEC0KCBEACAAKACUAABbaLQIAAC0KDgktCAEBJwIEBAUACAEEAScDAQQBACIBAgQtCgQHLQ4GBwAiBwIHLQ4FBwAiBwIHLQ4CBwAiBwIHLQ4JBy4IgEYADCMAAAwYDSIADIBLAAIkAgACAAAMLiMAAAwtJhwKDAIAACoDAgQAIgECBQAqBQwGLQsGAjAKAAIABAEiAAyASQACLQoCDCMAAAwYHAoGAQAAKgMBBy8KAAcAAS0LBAcuAgAHgAMoAIAEBAAEJQAAF04uCIAFAAgAIggCCQAqCQYKLQ4BCi0OCAQBIgAGgEkAAS0KAQYjAAAGnCgAgAQEeAANAAAAgASAAyQAgAMAAAzUKgEAAQX3ofOvpa3UyjwEAgEmJQAADKwBIgABgEkAAy0LAwIcCgIDBBwKAwEAHAoBAgQtCgIBJioBAAEFOKrUXVEOYIE8BAIBJioBAAEFxYWxByP1C5U8BAIBJiUAAAysLQgBBgAAAQIBLQ4BBi0IAQEAAAECAS0OAgEtCwQCACICAgItDgIELgiARgAFIwAADVUMKgUDAiQCAAIAAA14IwAADWctCwYCLQsBAy0KAgEtCgMCJiQCAAIAAA2FJQAAF9wnAggEAwAqBAgHACoHBQgtCwgCLQsGBy0LAQgtCwgJACIJAgktDgkIACIHAgkuAgAIgAMoAIAEBAABJQAADe0uCIAFAAouCIAGAAstDgILLQ4JBi0OCgEBIgAFgEkAAi0KAgUjAAANVS4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAAA48IwAADqwkAIANAAAOSSMAAA5iLgCAA4AFAQCABQACgA4uBIALgA4jAAAOpygAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgSAC4AOAQCADgACgA4uBIAJgA4jAAAOpyMAAA8AKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uBIALgA8BAIAPAAKADy4EgA6ADyMAAA8AKACADQQAAwEAgAWADYAMCwCAA4AFgA0kAIANAAAPZAEAgAqACIAPLgCACoAQLgCADIARCwCAEIAPgBIkAIASAAAPZC4BgBCADi4EgA6AEQEAgBAAAoAQAQCAEQACgBEjAAAPMwEAgAyACIAGJi4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAAA+8IwAAECwkAIANAAAPySMAAA/iLgCAA4AFAQCABQACgA4uBIALgA4jAAAQJygAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgSAC4AOAQCADgACgA4uBIAJgA4jAAAQJyMAABCAKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uBIALgA8BAIAPAAKADy4EgA6ADyMAABCAKACADQQAAwEAgAWADYAMAQCADIAEgA0DAIAIAAKADgEAgA2ADoAPAQCACoAOgBANAIAQgAqADiQAgA4AABDgLgGAEIARLgSAEYAPAwCAEAACgBADAIAPAAKADyMAABCvLgCADIAGJioBAAEFRafKcRlB5BU8BAIBJiUAAAysJwIMBA0tCAANLQoEDi0KBg8ACAAMACUAABLSLQIAAC0KDgsLIgAFgEwABAsiAAuARwAGJAIABAAAEoUjAAARPgsiAAWATQAEJAIABAAAElsjAAARUycCBAB0CioFBAwkAgAMAAASMSMAABFqJwIEAHUKKgUEDCQCAAwAABIHIwAAEYEnAgQAeQoqBQQMJAIADAAAEd0jAAARmCcCBAB7CioFBAwkAgAMAAARsycCDQQAPAYNAQsiAAaARQAEJAIABAAAEcglAAAUHy0KAQctCgIILQoDCS0KCwojAAASrwsiAAaARQAEJAIABAAAEfIlAAAUHy0KAQctCgIILQoDCS0KCwojAAASrwsiAAaARQAEJAIABAAAEhwlAAAUHy0KAQctCgIILQoDCS0KCwojAAASrwsiAAaARQAEJAIABAAAEkYlAAAUHy0KAQctCgIILQoDCS0KCwojAAASrwsiAAaARQAEJAIABAAAEnAlAAAUHy0KAQctCgIILQoDCS0KCwojAAASrwsiAAaARQAEJAIABAAAEpolAAAUHy0KAQctCgIILQoDCS0KCwojAAASry0KCgQtCgcBLQoIAi0KCQMmKgEAAQWHoozzdrSOyzwEAgEmJQAADKwtCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQFLgyARwAFACIFAgUuDIBHAAUAIgUCBS4MgEcABSsCAAQAAAAAAAAAAAIAAAAAAAAAAC0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgcuDIBHAAcAIgcCBy4MgEcABwAiBwIHLgyARwAHACIHAgctDgQHLQgBBAAAAQIBLQ4DBC0IAQMAAAECAS0OBQMtCAEFAAABAgEuDIBGAAUtCAEGAAABAgEuDIBFAAYnAgcECC0IAAgtCgQJLQoDCi0KBQstCgYMLQoBDQAIAAcAJQAAFbEtAgAAJwIBBActCAAHLQoECC0KAwktCgUKLQoGCy0KAgwACAABACUAABWxLQIAACcCAgQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAACACUAABbaLQIAAC0KCAEmKgEAAQUC3G4ngHYSnTwEAgEmJQAADKwBIgACgEkAAw4qAgMEJAIABAAAFFAlAAAQ5w0ogEQAAwAECyIABIBFAAMkAgADAAAUbSUAABfuDSIAAoBEAAMkAgADAAAUgiUAABfcACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYlAAAMrC0IAQQAAAECAS4MgEoABCcCBgQCJwIHAQEtCAEFJwIIBCEACAEIAScDBQQBACIFAggnAgkEIEMDqgACAAYACQAHAAgnAgoEIC4CAAiAAy4CAAqABCUAABgAJwICBCEnAgYEIC4IgEkAAyMAABUkDCoDAgckAgAHAAAVOyMAABU2LQsEASYtCwQHBCoHBwgCKgYDBw4qAwYJJAIACQAAFVslAAAYgAwqBwYJJAIACQAAFW0lAAAX3AAiBQIKACoKBwstCwsJHAoJBwAEKggBCQQqBwkKAyiASgAHAAkEKgkIBwAqCgcILQ4IBAEiAAOASQAHLQoHAyMAABUkJQAADKwtCwQGCyIABoBFAAckAgAHAAAV0ycCCAQAPAYIAS0LAwYLIgAGgEQAByQCAAcAABZmIwAAFewtCwMGLQsBBy0LAggtCwQJDSIABoBEAAokAgAKAAAWESUAABfcLgIAB4ADKACABAQABCUAABdOLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEkABQ4qBgUHJAIABwAAFlElAAAQ5y0OCgEtDggCLQ4FAy0OCQQjAAAW2ScCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABiSLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAXTi4IgAUACQAiCQIKASIACoBGAAstDgULLQ4JAS0OBwIuDIBJAAMtDggEIwAAFtkmJQAADKwtCwQFCyIABYBFAAYkAgAGAAAW/CcCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABiSLQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEgABAEiAAaASQACLQsCASYuAYADgAYLAIAGAAKAByQAgAcAABdpIwAAF3QuAIADgAUjAAAX2y4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAABfHLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAABeWKAGABQQAAQMAgAYAAoAGIwAAF9smKgEAAQXFa8RaDhAAAjwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAGH8DAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4EgAeACwEAgAOACIALLgSABoALAQCACQACgAkjAAAYHCYqAQABBSiGkrBH3P1DPAQCASYlAAAMrC4IgEYABSMAABiiDSIABYBEAAYkAgAGAAAZDSMAABi3LQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAZIyMAABmPLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAXTi4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAABmPASIABYBJAAYtCgYFIwAAGKI=",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "claim",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "spend_limit",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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+yuP3l939P6q4xLPdePaW37tvdm+wHO91HO9zHO93HP9red6hef6O8/1957rle71Knr9geRHktUka0h+IvmZ5Jfm627yF+Wtvz+9ofgLf0uuMv8mv1oRtr3lujkthW3q2x6/Ei6/kfxO8kfmmwnqHxtk6H7T6H7X6P5wdd5VFwtWWlD9NohfUYNgUsjfgG+Q/A7Zax1ef4A/chVU8f6QK15t8f5JuPxFspbk78zi/VNTlH9pdGs1ur8DKN4fgMX7J7B4/wIW71pg8f5tafH+mCtebfGqEXIrkloktVPjZKoA1T9mFuVWGl0tja52C/7i/RFYvMpXv3ulinerFrjirdUCV7y1W9hZvKtzxast3joUz7ok9UjqZxZvHU1R1tXo6ml09QMo3tXA4q0DLN66wOKtByze+pYW75pc8WqLtwHFsyHJ1iTbZBZvA01RNtTottbotgmgeNcAi7cBsHgbAot3a2DxbmNp8f6UK15t8W5L8WxE0pikSWbxbqspykYaXWONrkkAxfsTsHi3BRZvI2DxNgYWbxNLi/fnXPFqi7cpxbMZSXOSFpnF21RTlM00uuYaXYsAivdnYPE2BRZvM2DxNgcWbwtLi/eXXPFqi7clxTOfpBVJQWbxttQUZb5G10qjKwigeH8BFm9LYPHmA4u3FbB4C4DFm0qmR/LAiUqrQW6/3H65/XL75fbL7ZfbL7dfbj+T9wunZv9XGqznAS97rod7rl/yXL/ouX7Bc/285/o5z/Uwz/WznutnPNdPe66f8lw/6bl+wnP9uOf6Mc/1o57rRzzXD3uuH/JcP+i5fsBzfb/n+j7P9VDP9b2e63s813d7ru/yXN/pub7Dc/1Tw/XXazzXqz3XP3quf/Bcr/Jcr/Rcf++5/s5zvcJz/a3nernnepnneqnneonnerHnepHneqHn+hvP9QLP9dee6/me66881/M813M913M817M917M81zM91zM819M919M819Ft1l9Xeq4rPNflnuuI5zrsuQ55rqXnWniue3que3iuu3uut/dcd/Ncd/Vcb+e57uK57uy57uS57ui57uC5bu+5LvNcl3quHc91O891W891iee6jee6tee62HNd5Lm+YNv11+d7rs/zXA/xXJ/ruR7suT7Hc3225/osz/WZnuszPNene65P81wP8lyf6rke6Lk+xXM9wHN9sue6v+f6JM91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CqC2uxKo7a4CarurgdruGqC2uxao7a4DarvrgdruBqC2uxGo7W4CarubgdruFqC2uxWo7W4DarvbgdruDqC2uxOo7e4Caru7gdruHqC2uxeo7e4Darv7gdruAaC2exCo7R4CaruHgdruEUu03U1AbfcoUNs9BtR2jwO13RNAbfckUNs9BdR2TwO13TNAbfcsUNs9B9R2zwO13QtAbfciUNu9BNR2LwO13StAbfcqUNu9BtR2rwO13RtAbfcmUNu9BdR2bwO13TtAbfcuUNu9B9R27wO13QdAbfchUNt9BNR2H1ui7W4GartPgNruU6C2+wyo7T4HarsvgNruS6C2+wqo7b4GartvgNruW6C2+w6o7b4HarsfgNruR6C2+wmo7X4GartfgNruV6C2+w2o7X4Hars/gNruT6C2+wuo7f4Gart/gNou0B2n7Rp0R2io/3w17I7RY+yrUXectmsM8FXQdk2626HtbgFqu6bdcdpune44bdesO07bNe+O03Zl3XHarkV3nLZr2R2n7Vp1x2m7dbvjtN163XHarnV3nLZbvztO27XpjtN2bbvjtF277jht1747Ttt16I7Tdh2747Rdp+44bde5O07bdemO03Zdu+O0XbfuOG3XvTtO2/XojtN2PYHarhdQ2/UGarsNgNquHKjtKizRdrcCtd2GQG3XB6jt+gK1XSVQ21UBtV0/oLbrD9R2A4DabiOgttsYqO02AWo7B6jtXKC2CwK1XQio7cJAbRcBarsoUNvFgNouDtR2CaC22xSo7TYDarvNgdpuC6C22xKo7bYCaruBQG23NVDbbQPUdttaou1uA2q77YDabnugttsBqO12BGq7nYDabmegttsFqO12BWq73YDabnegttsDqO32BGq7vYDabm+gttsHqO32BWq7QUBttx9Q2w0GarshQG23P1DbDQVqu2FAbXcAUNsNB2q7EUBtNxKo7Q4EartRQG2XBGq7lCXa7nagtksDtV0GqO2yQG2XA2q70UBtNwao7cYCtd1BQG03DqjtxgO13cFAbTcBqO0mArXdJKC2OwSo7SYDtd2hQG13GFDbHQ7UdkcAtd2RQG13FFDbHQ3UdscAtd2xQG13HFDbTQFqu+OB2u4EoLabCtR2J1qi7e4AaruTgNruZKC2OwWo7U4FarvTgNpuGlDbnQ7UdtOB2m4GUNvNBGq7WUBt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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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K49WHq08uDy4PLg8uDy4PLg8uDy4PLg8uDx6efTy6OXRy6OXRy+PXh69PHp59PKQ8pDyiDj3IC7qRVKkRaPIijwp4nwSFZWHloeWh5aHloeWh5aHlscoj1EeozxGeYzyGOUxymOUxyiPUR5WHlYeVh5WHlYeVh5WHlYeVh5WHl4eXh5eHl4eXh5eHl4eXh5eHp4eUbh0ERW1Ii7qRVKkRaPIisqDyoPKg8qDyoPKg8qDyoPKg8qDyqOVRyuPVh6tPFp5tPJo5XHG+eAgK/KkM86HBlFRK+KiXiRFWjSKrMiTenn08ujl0cujl0cvj14evTx6efTykPKQ8pDykPKQ8pDykPKQ8pDykPLQ8tDy0PLQ8tDy0PLQ8tDy0PLQ8hjlMcpjlMcoj1EeozxGeYzyGOUxysPKw8rDysPKw8rDysPKw8rDysPKw8vDy8PLw8vDy8PLw8vDy8PLw9MjiqMuoqJWxEW9SIq0aBRZUXlQeVB5UHlQeVB5UHlQeVB5UHlQebTyaOXRyqOVRyuPVh6tPFp5tPJo5VFxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4j9qv4UG9SIq0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8NWCrxZ8teCrBV8t+GrBVwu+WvDVgq8WfLXgqwVfLfhqwVcLvlrw1YKvFny14KsFXy34an18tU8+XLOTD/f9TC1uf/s3H67f723kQT7c92e74va3z/t378ftb//mw43n91+//ec//O3P//CPf/nTv/32//779eU//ce//PHf//zXf/l8+e//9a/f//OPf/vzX/7y53/++3/921//+Kf//x9/+9Pf/+Wvf3z/v9+ez3/+btZra2fW7j/8+u1F+7v3H8Zdv95/BjdeR+L9ivb89Xq0n+9XvL8l30+PX66w94H397yeL/uv13/yD7+fk/z3fZ3VL7f3If/C3n9q4CXPz4nff+Tg9c/Oz2mf1/+0n5PW65x1Txk/p9z9emv+PpY/x17vzvf70NKh/hXnVaVD61c870Ot97d/+Tn/vA+939FrpGN+3k/+ynPe/b+/w37G77UP8Ou1Hv6U9NrC658T+HsA/Keg1+7E68s+324/3/56kP1aen2+/bW7Ws/Pt7+eufv98nx72evLON/+M6Cv3dRfr13Fz7e/9pJ/mQb0dQlfX873BK/d2V+vndhzgvi/niBVwKvIe/ecCzSvCxQ/7/n15WtBeL5DV8f6NQ7nWH0HPt53wvccy36tOv9f18rfxf/h999//8Pv/wM=",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "user_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZndbhs5DIXfxde5GP2RUl+lKIo0dQsDhhO4yQKLIu++PBLJsReYQauiN+E3zOiYkiiKcX4evh6/vH3/fLp8e/5x+PDx5+HL9XQ+n75/Pj8/Pb6eni/i/XlY8CMEOnzgh0OIQW0ZNi1q9Tnrc7bnNmxJauuwFNXysCy6VWyLaqnbuAS1+hz0OehzXNRmtW3YlNTWYXNUy8MW0SHYMiwtarPaOiwntTxs1XGVhkW83Y7ntAS18n4TG6Jafcb6dVvUtmERb7f6Xtb3Mg1b9LnoOMTbbVZbh2X9PNZxVd+r+l7Vz2v63GRcCA+HvMjAEAXCYlAVYjKQ4EISSNGAFLDvA7JBVSj2crHhZB6y4WzD2YazDa/2crWXm72MRQ/54VCWbIBRkk8lJAUs+ICmkOTlGADiiTKvgpgHmKfAQ4CqQMnAPGweNg9CHUAKLRiUAbQsBtlAh1NQQYrwSKjU45F0JRyfJFMmCgZFAUs3wD1NobICwkgZUAYwwhhgnmCe4J6mgAQYUBWQAANYAQmbCFAUymIgM00MaApYzAGswObBYnao5qn2Tp9FhzKg9ll0wEdUQFPAYg5gBWTCAFJI5kH1GoDhci4qUmJAVUAaD2AFMg/SuAP2Ii+AYtAUMJ0BVaGZp/GAhuKRA4AUgnlQ77JsZcMsBpTxoQ0leIB5snmyeVA2smxTQ93IBQCPLF1D5c0EKCPZGmrcgKqAUAdoQoalp+8g94XkxEYoQHmQjMgNhKLZKWADlYpTM4JeWUA4syV0qkYo6UpkhJxT8vfIf4upltiJjRCVUjNCfnWKiE9p9eG91O9CNorRCLuhVJx8RE5OPrYgvgzC4VYqTs0IR0SJjaqPqK7S3NdcpZlKWpITVAqor3MnXKdKxQinRImMcDyUbJ1TiU624onch1wq1DsExNJ7g/65g9ior+Qg0szJiECpGOXFyX3FfcV95D5yH7ser75m1E/qIDZqPqLZiNJzgzphNbqvRz+IdB6lr98g9yF6JYxtnZpRcR+ymHAC+v2jxEbsymzrV3o+D7J17pdPp377KK0+e498P8j3g6J9BiUfizJHoVM1wqoNwlopoSnCmWGs0CA0RIOQa0pownAWGG3QINwnSlBBxnJv2ga5rzdupVN2akbsPnZfdR9ychDaIMJeVpTeQbgQiTsVox4zv78/HKxH/vx6PR7RIt80zdJKvzxej5fXw4fL2/n8cPjn8fzWX/rx8njp9vXxKr+VXTxevooVwW+n8xH0/rCOXraHVimUOlruuugC5V4hbCvI6cyqIAcwu4Jk3Z1E3JFA/neFuKwhpFDvBNK2gGxQUwXZIXKJWO+nkbclEqpyV8jhRmC5FyjbAjG0YLOQ4r4pQdsS0lyqQknLlEBjFaBQpiYRq4UgV1CckuDgu8k70wjL39WQC9syGwVmTkMaStPgFuc02mJLKn+W7mjsSGTfFanvtHnEws62SLW19ORIyTXa/SELtDcT3NU6E15nIis9VW5K2yw3deegUrA9SZTqZhSh7SyGdCN2UFJeTwrdhxH3ZsLVJGq9OSk0OZPM2zPZ1SjsGtw2NeJO9cwULL0y5bytsVM+5e8s21iuJWyu6E6GSg33Ii5d0ZREieQSkackKPg5kf5lU2J3LeK6FkSbEjsJKl/omISk6rol0jvf34l7hWdZi9dS19SQvvpeI+ydV9uSmvK2ws7dTn7gKdG2wu48KPg8eNnU2E9xXwv5kmi7aKTydzWk/Y1+Kd3UvxTKb2hU9ksp1DkNLn6jSCc7qdG88ZOMn9NYy4b8CU2bGr9cAm+av//vS467lzT51ZbDTRzpNyqHx8FEk8Unxz+W8CZSJOqWRN675+XPU68c+BN0S2T30EZP9IW2e9E9ibDmhnRAcxLkUYQ6F0XynlpwLori94G0bzwnQWsHWNvcRNY+NMW5iaTsJz6VqYnwmuCZZgRath60lalJtMX2s8W5CDyn5LvOP5zCnIB8veBpXW9vgJKmJGKbkmhlrZlEkxJxleA5iZzWyj03EQnDJOKy3Wz9qkQI9xKf5PHx6XS9+4foO8Sup8cv56M+fnu7PN389vXfF/uN/UP15fr8dPz6dj1Caf2vqvz4mOTLplT5E74Xl0eJ4UH+uYnHgN/KTZ0afXpHMP8B",
      "brillig_names": [
        "user_score"
      ]
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAULQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZhRbuM4DIbv4uc8iBQlUbnKoCjSNh0ECNIikyywKHL3JW1RTmYhIXVmXqrPjPWblEha9dfwtn05/3zeHd4/fg3rH1/Dy3G33+9+Pu8/Xjen3cdBrF+D0z+chzWshuyngccBnC9jGtYkI+CwDjqmacRyjXINeqNHA1XwAuQNzBLUomoJBFghCmQBBgOzZLGgzsphAnTOwCxgFqiWXAC9ARdQDydIBQgMbHowwaTTxVXMJBAURMe71eBdLKBPnyAUQLMgFdCHTqCzZH08OYNQIJglmCWaJZIBF1DHJkgFGA30EeK8z84gGMiyeAmHHBlwAd3ZCcyiSzeBWbzdM0ahMEYxQjDQR8hCUSADLhDRIBbQBJjALOwMdLrkBmU0kHtIAgzq/ASiTCgA3sAs6jyRAhfwRSfovo9AZiGzBLMEzWdxI6irIyQJkBTUQ4oKatGbNUUpKYQpSaIDAy6gHk6QCyAZmMXbPWNmCiRNdcoKXGCMVAHBQDwMklrJk0EuQGbRuCbQupWlSzEUSM6AC7A8IqACF8hmyTpdEok1wAliATALmAXNgvosf7msBms7z6fjdqtd56oPSXf63By3h9OwPpz3+9Xwz2Z/Hm/69bk5jONpc5RfJY7t4U1GEXzf7bdKl9U827WnpqC9aZydgocqEL6hEGcFbipgW0G22RSiFH9ViLcKvq3AiU2B2WFL4d4osluyDlG786QQfWgpxLaCj5rio4K0Na4KEP2NRGpLyGvHnADMeZbItxLciYO95VPiAK21zL2VwHklIrcUoLOYAJS9BQIBY0ukGwjOgcSmAmDPjRzqcsK8FvLSuj8tnJ/TIi1KrDk1o+xjQ0F7cjuzwNfM8teZdRsHxIerFNLDZXp3JJTakXQ1QqoaKTc1sLMpNFc7RaK2BjxcadhJ0ES5llpwbpGEVFeVwLRIIs4vkQhtCXi4WLHXPjGbhKQqNYsVe/3Tpdp2HM+p4cNvGp2+wzUz2FNbodNAI7haabGt0I2j9gwJybU1uile14LkuNVMcY9/V0Nef2ixxHC1JxC+ocFW8vI/Fi/TkINB1WBqa3RyFB2YH+ho7oAY8Vajt7exFixcHzT+p9GNJZNpSOW1Y8mPx0LuL8cyt1Fgis1Y7n4l5NjMU+ocQiG7Gkumq8MC+G900uqHvPYXNmPChyXuOsBR+gMHuF5yyBmhbux10Qa/SALzIokc5m2NcaEEzhJpmQT5Obl+C+RJLjevu+PNR6yLih13m5f9tly+nw+vV7+e/v20X+wj2Ofx43X7dj5uVWn+EiZ/fkh5rqS8nvTTl15KRYJPegl6ybyS/H+6qDP/AQ==",
      "brillig_names": [
        "winner"
      ]
    },
    {
      "name": "winner_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAuQtCAEBAAABAgEnAgIEAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFLQgBBCcCBgQCAAgBBgEnAwQEAQAiBAIGLQoGBy0OBQcnAgYEBy0IAActCgQIAAgABgAlAAADDS0CAAAtCggFDCoFAwQkAgAEAAAA2yMAAAKMHgIABAUcCgQGBBwKBgUAHAoFBAQnAgUAAC0IAQYnAgcEBAAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIIAggtDgUIACIIAggtDgUILQgBBQAAAQIBLQ4GBScCBgAYLQoCAyMAAAFBDSIAA4BDAAIkAgACAAAClSMAAAFWLQsFAgEiAAKARAAFLQsFAycCBQQCACoCBQctCwcGASIAAoBDAAgtCwgHLQgBAicCCAQEAAgBCAEnAwIEAQAiAgIILQoICS0OAwkAIgkCCS0OBgkAIgkCCS0OBwktCwIGACIGAgYtDgYCJwIHBAgtCAAILQoCCS4IgEQACgAIAAcAJQAAAzItAgAALQoJBi0LAgcAIgcCBy0OBwInAggECS0IAAktCgIKLQoFCwAIAAgAJQAAAzItAgAALQoKBycCBQQILQgACC0KBgkACAAFACUAAAMNLQIAAC0KCQInAgYECC0IAAgtCgcJAAgABgAlAAADDS0CAAAtCgkFHAoDBwQcCgcGABwKBgMEDCoEAwYWCgYDHAoGBAQcCgMGBAQqBAIDBCoGBQIAKgMCBC0OBAEjAAACjC0LAQItCgIBJhwKAwIAACoGAgcvCgAHAAItCwUHLgIAB4ADKACABAQABCUAAAO5LgiABQAIACIIAgkAKgkDCi0OAgotDggFASIAA4BEAAItCgIDIwAAAUEoAIAEBHgADQAAAIAEgAMkAIADAAADDCoBAAEF96Hzr6Wt1Mo8BAIBJiUAAALkASIAAYBEAAMtCwMCHAoCAwQcCgMBABwKAQIELQoCASYlAAAC5AEiAAKARAADDioCAwQkAgAEAAADUSUAAARHDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAA3AlAAAEWQ0iAAKAQwADJwIEAQEkAgADAAADiiUAAARrACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAAPUIwAAA98uAIADgAUjAAAERi4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAQyLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAQBKAGABQQAAQMAgAYAAoAGIwAABEYmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZhRbtswDIbv4uc8iKJESblKURRpmw4BgrTIkgFDkbuPlEg7GSAjdbeX6jNj/aZIilb9Obxun88/nnaHt/efw/rhc3g+7vb73Y+n/fvL5rR7P7D1c3DyJ5dhDauhYBtyHcChjmlYBx7BD+soY2qj12vP1yA3ojcQBc8QvEFSiGaJZiGzECkkdgpQIBoUhYwGWaGYpaQG3gEDO+xBZmUGHxiKQFFAsyBbvMwKwSArRDQwC5mFzJK8ASlkMIgKxRnYI4pOR6eC6GUW+4wSMR8FWBAdQwwGWUHcaGAWcaNCdgYyCwSyggSqgVqCQwOzSIobkII41iAqoDOQR6BAVghowLlAXk6QdDcgBXIGZklgYJZs99RVVMgKdRUV5BEcqOi8ASmAMwgGRcGbxWcFKVokgaQQwCAqRGcwWopCzUUSyAo1FxVIQUqigVmkJBqIP1mgNCAXDNgSOJUkq2iQ20PJo4FZ0CxoFskF8AKp7jgBYjcCCLAbgTcaSeRDEJAtzomjWr1yc04KtWgrlAbJRQWJc4PRYveIhxVkyZGdT6LTgD2M7EaW8mtgFpkVeFZGMCAF2Z4NJCy8wCwNpII0kAZmkb5RQQopJIGsIPUjUKRLNJBHcMALgIFZvEwvAsGgKKBZ0CzBLNJAQrlcVoN12qfTcbuVRnvVerkhf2yO28NpWB/O+/1q+LXZn+tNPz82hzqeNkf+lWO2PbzyyIJvu/1W6LKaZrv+1JRd0tmMeRSIX1CQWlSF2FXwfQUuTVAFwhBHBbpVwL5CTtkUOKG+p3DvKigtikMhUyjgewrUV0CS/VAVuG9PkQTCG4nUl+A3bVEJ8KVMEuVWIs9Gwk35hF4sy4wCeXMiEeWeAswEE4DbuC2ETwS0yA2A0Q1IPYXZUPgpFESLyiq7qSjCkrIq0n5VIXfLStp3v64Ax7rC67qiWw369h6F9O1NevdKQuqvZFYjplEjla6Gn0lKILAKDxRCXwO+vc/8TONMoYwbLTq3SIL31ijh0yKJ+/bZfCzu2mh+rnnyIdrSilc7DfGvlMx1T5fGpuPyVBoY/9KY6Rl5rIyMoa8w07cI3LjTqK8wuw6CcR3J9TVmS3yMRUiu3zTQ/18Nfvl5WwvFq5xA/IJGti0PCfIyjRTHN2vKYaFGsV4OXPHLNKa2ATlQV+PuFlion5eZKgU+FZsfJcCVH/iFzjH6wQeFhc0n+G9L3HVcCfgPjitzRx5+J46JvS7SiIskfFkkUeKUVqKFEn6SSMskAk7FtWwh7MZ4Enb998G9EgC3Eo98uXnZHW++lV1E7LjbPO+3evl2Prxc/Xr6/WG/2Le2j+P7y/b1fNyK0vTBjf88QPErD/goX9jkMuIKYpZL/j/0wfNhiz9gPV7EmT8=",
      "brillig_names": [
        "winner_score"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000003"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claim",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "spend_limit",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "pot",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        },
        {
          "fields": [
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "tally",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::TallyEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "claim",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "spend_limit",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::user_score_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::user_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_score_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_score_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "134": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "219": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "402": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        },\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n    use token::Token;\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        claim: PublicImmutable<u32, Context>,\n        spend_limit: PublicImmutable<u128, Context>,\n        challenge_fee: PublicImmutable<u128, Context>,\n        deposit_size: PublicImmutable<u128, Context>,\n        token: PublicImmutable<AztecAddress, Context>,\n\n        pot: PublicMutable<u128, Context>,\n        deposits: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct TallyEvent {\n        address: AztecAddress,\n        tally: u32,\n    }\n\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        claim: u32,\n        spend_limit: u128,\n        challenge_fee: u128,\n        deposit_size: u128,\n        token: AztecAddress,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.claim.initialize(claim);\n        storage.spend_limit.initialize(spend_limit);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.token.initialize(token);\n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        let token = storage.token.read();\n        let deposit_size = storage.deposit_size.read();\n        Token::at(token)\n            .transfer_in_private(\n                context.msg_sender(),\n                context.this_address(),\n                deposit_size,\n                0\n            )\n            .call(&mut context);  \n\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n        CTF::at(context.this_address())\n            ._join(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _join(sender: AztecAddress) {\n        // assert(context.block_number() as u32 < storage.start.read(), \"Game has already started\");\n        storage.deposits.at(sender).write(storage.deposit_size.read());\n    }\n\n    #[public]\n    fn claim() {\n        assert(context.block_number() as u32 > storage.claim.read(), \"Claim period has not started yet\");\n        let mut refund = storage.deposits.at(context.msg_sender()).read();\n        if context.msg_sender() == storage.winner.get_current_value() {\n            refund += storage.pot.read();\n        }\n        Token::at(storage.token.read())\n            .transfer_in_public(\n                context.this_address(),\n                context.msg_sender(),\n                refund,\n                0\n            )\n            .call(&mut context);\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[public]\n    fn winner_score() -> u32 {\n        let mut winner_score = 0;\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner_score = storage.winner_score.get_current_value();\n        }\n\n        winner_score \n    }\n\n    #[public]\n    fn user_score(address: AztecAddress) -> u32 {\n        let score = storage.final_score.at(address).get_current_value();\n        score\n    }\n\n    #[private]\n    fn submit_score() {\n        let capture_note = storage.capture_note.at(context.msg_sender()).get_note();\n        let mut score  = storage.tally_note.at(context.msg_sender()).get_note().note.tally;\n        if capture_note.note.capture_block != 0 {\n            score += storage.end.read() - capture_note.note.capture_block;\n        }\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        assert(context.block_number() as u32 > storage.end.read(), \"Game is not over yet\");\n\n        storage.final_score.at(sender).schedule_value_change(score);\n        let (winner_score, _) = storage.winner_score.get_scheduled_value();\n        if(winner_score < score) {\n            storage.winner_score.schedule_value_change(score);\n            storage.winner.schedule_value_change(sender);\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n\n        let event0 = TallyEvent { address: context.msg_sender(), tally: note.note.tally };\n\n        // context.emit_event_in_private_log(\n        //     event0,\n        //     &mut context,\n        //     context.msg_sender(),\n        //     context.msg_sender(),\n        //     PrivateLogContent.CONSTRAINED_ENCRYPTION,\n        // );\n\n\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        assert(context.block_number() as u32 < storage.end.read(), \"Game has ended\");\n        assert(context.block_number() as u32 > storage.start.read(), \"Game has not started\");\n\n        let challenge_fee = storage.challenge_fee.read();\n        Token::at(storage.token.read())\n            .transfer_in_public(\n                context.this_address(),\n                context.msg_sender(),\n                challenge_fee,\n                0\n            )\n            .call(&mut context);\n        storage.pot.write(storage.pot.read() + challenge_fee);\n\n        // Ensure the game is initialized\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[private]\n    fn slash(address: AztecAddress) {\n        // Set their tally back to 0.\n        let slot = storage.tally_note.at(address);\n        let note = TallyNote::new(address, 0);\n        slot.replace(note).emit(encode_and_encrypt_note(\n            &mut context,\n            address,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._slash(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn _slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger != AztecAddress::zero() , \"Challenge is no longer open\");\n\n        storage.deposits.at(address).write(0);\n        storage.pot.write(storage.pot.read() + storage.deposit_size.read());\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n\n        // New values assuming the reponder does not have the flag \n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let new_responder_note = CaptureNote::new(context.msg_sender(), 0);\n        let mut challenger_capture_note = CaptureNote::new(challenger, 0);\n\n        // The responder has the flag\n        // Update the values accordingly\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            challenger_capture_note.capture_block = challenge_block;\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_responder_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "61": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "91": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "99": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_tuple().is_some() {\n        let tuple_len = typ.as_tuple().unwrap().len();\n        let mut tuple_quotes: [Quoted] = [];\n        for i in 0..tuple_len {\n            let element_quote = quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name.$i)); };\n            tuple_quotes = tuple_quotes.push_back(element_quote);\n        }\n        tuple_quotes.join(quote {})\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    }
  }
}
