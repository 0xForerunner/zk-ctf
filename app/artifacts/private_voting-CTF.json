{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgADAAAKmCUAABT7ACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYlAAAI+AEiAAGASAADLQsDAhwKAgMBHAoDAQAcCgECAS0KAgEmJQAACPgtCwQGCyIABoBEAAckAgAHAAALDicCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAuhIwAACyctCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAALTCUAABT7LgIAB4ADKACABAQABCUAABRbLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAC4wlAAAS9C0OCgEtDggCLQ4FAy0OCQQjAAAMFCcCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABUNLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAUWy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBIAAMtDggEIwAADBQmJQAACPgtCwQFCyIABYBEAAYkAgAGAAAMNycCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABUNLQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEcABAEiAAaASAACLQsCASYqAQABBQLcbieAdhKdPAQCASYlAAAI+CcCCgQLLQgACy0KAQwtCgINLQoDDi0KBA8ACAAKACUAABDrLQIAAC0KDActCg0ILQoOCS8KAAQACicCEAQRLQgAES0KChIACAAQACUAABHxLQIAAC0KEgstChMMLQoUDS0KFQ4tChYPHgIACgUcCgoRBBwKERAAHAoQCgQMKgoPECQCABAAAA1PIwAADS4WCg0QHAoNEQQcChASBAQqEQ4QACoQEhEtChEGIwAADXAWCgsQHAoLEQQcChASBAQqEQwQACoQEhEtChEGIwAADXAAKgoGEQ4qChESJAIAEgAADYclAAAS9AwqCgkGFgoGCRwKBgoEHAoJBgQEKgoHCQQqBggHACoJBwYcChEHABwKDwgAJwIKBBItCAASLgiASgATLgiATAAUAAgACgAlAAATBi0CAAAtChMJBCoICQoAKgcKCBwKDQcAJwIKBBItCAASLgiASgATLgiATQAUAAgACgAlAAATBi0CAAAtChMJ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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "join_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "slash_fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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nvOvxTznXzv7OWvKnH8dhjkwnPOvyzznX495zr8+Ax6c828Q5l+bvdqCtdk1mO3UIcx26obMdupGzHbqUGY7dRizneoy26lhZjs1wmynRpnt1DJmO7Wc2U6tYLZTK5nt1CpmO7Wa2U7dmNlO3YTZTt2U2U7djNlO3ZzZTt2C2U4dzmynbslsp27FbKduzWynbsNsp27LbKeOYLZTt2O2U7dntlN3MGCnXmOBnVrEbKf+j9lO3ZHZTt2J2U7dmdlO3YXZTt2V2U7djdlO3Z3ZTt2D2U7dk9lO3YvZTt2b2U7dh9lO3ZfZTt2P2U7dn9lOPYDZTj2Q2U49iNlOPZjZTj2E2U49lNlOPYzZTq1htlNrme3UOmY7tZ7ZTm1gtlMbme3Ukcx26uEG7NRrLbBTi5nt1COY7dRRzHbqkcx26mhmO/UoZjt1DLOdOpbZTh3HbKcezWynjme2U49htlMnMNupxzLbqROZ7dTjmO3UScx26mRmO3UKs506ldlOncZspx7PbKeewGynTme2U2PMduqJzHbqScx26snMdmoTs516CrOdOoPZTp1pwE69zgI7tQuznTqL2U6dzWynzmG2U+cy26nzmO3UU5nt1PnMduoCZjt1IbOduojZTl3MbKcuYbZTlzLbqcuY7dTTmO3U5cx26unMduoZzHbqCmY7dSWznXoms516FrOdejaznXoOs516LrOdeh6znXo+s516AbOdeiGznXoRs516sQE79XoL7NSuzHbqJcx26qXMduplzHbq5cx26hXMduqVzHbqVcx26v3MduoDzHbqg8x26kPMdurDzHbqI8x26qPMdupjzHbq48x26hPMdur/MdupTzLbqU8x26lPM9upzzDbqc8y26nPMdupzzPbqS8w26kvMtupLzHbqS8z26mvMNuprxqwU2+wwE7txmynvsZsp77ObKe+wWynvslsp77FbKe+zWynvsNsp77LbKe+x2ynvs9sp37AbKd+yGynfsRsp37MbKd+wmynfspsp37GbKd+zmynfsFsp37JbKd+xWynfs1sp37DbKd+y2ynfsdsp37PbKf+wGyn/shsp/7EbKf+zGyn/mLATr3RAju1O7Od+iuznfobs536O7Od+geznfons536F7Od+jeznepEeO3UUITXTm0XSdveMrJTcyI+2m8GdmquH7wM7NQ8f3i+7dT2fvF8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",
      "debug_symbols": "7L3Bji29jp35Lndcg6AoUqRfpQdGtV02CihUGXa5JwW/e+9gBLmUmTeVyr33aaCB3wOf7/51zloRsUWGQqKk//jbf/2n//t///f//M//+t/+7X/97T/9X//xt//7f/7zv/zLP//3//wv//Zf/vHf//nf/vXxX//jb8f5/1GTv/0n+ofHn3r/Oe4/7f7Trz/5uP+k+892/8n3n/3+89bjW49vPb71+Nbrt16/9fqt12+9fuv1W6/fev3W67dev/Xk1pNbT249ufXk1pNbT249ufXk1pNbT289vfX01tNbT289vfX01tNbT289vfXGrTduvXHrjVtv3Hrj1hu33rj1xq03bj279ezWs1vPbj279ezWs1vPHnrt/NPuP/3604/7T7r/bPefDz05/3zojfNPuf/U+89x/2n3nx5/tuO4/6T7z3b/yfef/f7zvL52giaMBEvwG+hIoISWwAk9IZUplSmVKZUplVsqt1RuqdxSuaVyS+WWyi2VWyq3VOZU5lTmVI7YkRN6giRowkiwBL8hQiiAElpCKvdU7qncU7mnck/lnsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKI5VHKo9UHqk8Unmk8kjlkcojlUcqWypbKlsqWypbKlsqWypbKlsqWyp7KnsqeyqfcUd2Qk+QBE0YCZbgF/AZfhdQQkvghJ4gCZpwZol2giX4DWcMXkAJLYETeoIkaEIqUypTKrdUPmOwyQktgRN6giRowkiwBL/hjMELUplTmVOZU/mMweYnaMJIsAS/4YzBCyihJXBCT0jlnso9lXsq91SWVJZUllSWVJZUllSWVJZUllSWVNZU1lTWVNZU1lTWVNZU1lTWVNZUHqk8Unmk8kjlkcojlUcqj1QeqTxS2VLZUtlS2VLZUtlS2VLZUtlS2VLZU9lT2VPZU9lT2VPZU9lT2VPZb+V+HAmU0BI4oSdIgiaMBEtIZUplSmVKZUplSmVKZUplSmVKZUrllsotlVsqt1RuqdxSuaVyS+WWyi2VOZU5lTmVOZU5lTMGe8ZgzxjsZwwyneA3nDF4ASW0BE7oCZKgCSMhlXsqSypLKksqSypLKksqSypLKksqSyprKmsqayprKmsqayprKmsqayprKo9UHqk8Unmk8kjlkcojlUcqj1QeqWypbKlsqWypbKlsqWypbKls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AqzAA9iAHTiAwdvA28DbwNvA28DbwNvA28DbwNvA28HbwdvB28HbwdvB28HbwdvB28Er4BXwCngFvAJeAa+AV8Ar4BXwKngVvApeBa+CV8Gr4FXwKngVvAO8A7wDvAO8A7wDvAO8A7wDvAO8Bl4Dr4HXwGvgNfAaeA28Bl4Dr4PXwevgdfA6eB28Dl4Hr4PXwRvgDfAGeAO8Ad4Ab4A3wBvgDfAmeBO8Cd4Eb4I3wZvgTfAmeKFXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVw161aBXDXrVoFcNetWgVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXHXrVoVcdetWhVx161aFXq7893ntzuvrbXyu3E0/e9/tNuvrbLxzAWXjp1Ykn7/s7F7r62y/85j3e73/p6m9/rcROPIAnb19/48ABnIWXXsnCk1fbxB14zlfn+Euv3t+q0NXffmEDduDJO6b/S6/ee8G6+tsv3IAn7/u9PF397fH+foqu/vYLD2AD9jtWq7/9wnlfo9XfLrnwur7z/z31amEBVuABbMAOvO6rmDgLn3q1cAPuwAKswAPYgP2+H1Z/u7zf09TV3x4x/Vl6deIGPHnf6za6+tsvPHlzxm3qVR7r3w3YgWPi9fdZeOrVhd+8Oe/t1d+ebfo/9erCb958f59FV3979nmNpl7lmtfUqwsHcBZeerWu+9Irm7xLr+Y9ufrbX6vHE+v9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wzjhh2DF+aG3E9+wDJtwO/ENzRCGbkhDGSToEnQJugQpQUqQEqQEKUFKkBKkBClBSlAS1CE49akwdEMayjAM07AMmzAugwRDgiHBkGBIMCQYEgwJhgRTginBlGBKMCWYEkwJpgRTginBkmBJsCRYEiwJlgRLgiXBkmBJsCXYEmwJtgRbgi3BlmBLsCXYvwny3GN5QzOEoRvSUIZhmIZlkKBJ0CRoEjQJmgRNgiZBk6BJ0CQICUKCkCAkCAlCgpAgJAgJQoIuQZegS9Al6BJ0CboEXYIuQZcgJUgJUoKUICVICVKClCAlSAlKgpKgJCgJSoKSoCQoCUqCkmBIMCQYEgwJhgRDgiHBkGBIMCSYEkwJpgRTginBlGBKMCWYEkwJlgRLgiXBkmBJsCRYEiwJlgRLgi3BlmBLsCXYEmwJtgRbgi2BTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTmw6senEphObTgydGDoxdGLoxNCJoRNDJ4ZODJ0YOjF0YujE0ImhE0Mnhk4MnRg6MXRi6MTQiaETQyeGTgydGDoxdGLoxNCJoRNDJ4ZODJ0YOjF0YujE0ImhE0Mnnnss674+mucey7qPC/PcY/nsKp4Qhm5IQxl+CM77EOZ9j+V5H8KM531Jn7AJz/uSPqEZwtANaag/fN8fMM89ljdMwzJswrgMzRCGbqj3fQjzvrryvA9hnqsr3+Ud53rvWZBHg+cFHg0+oRnC0A1pKMNd+p4nTMMybMLR4Dc0Qxi6IQ13te+roHluq7zhvtk94++//vC///lvf/7nf/nLn/7XH/7bf37i//iPf/3jv//5r//6xH//P//2/cy//O3Pf/nLn//nP/3b3/76xz/99//425/+6S9//ePP5/5wPf/zD58Tjfj1Obzo//j5KZ/82SDqvz57Qe2T+8/nP2L99TkmuH4+//MN+XMNMUf9fMGPYv7hsy29fn22o69//Pv9Ev95vu6z/RXt50Px+0PrV/SfD/X/96vy50M/P/Cz+n29Pyx/5f75dH15s89fWeuh+/zm/cre3y//rNVHB1+yz3Hpr8/B6M/3j/cn7vHr07D+fGy+H4v8FfePWb8/NH/1+PnQ/v2h+tXPQ16/+fevyPtj7f/zsfhSfwzz6/NL9VCP9Wu+jxg/SxDvan4E+Ik3c+vvt39qEjufb6/r13jL8XnVX3Hi/e2jfeK9yC2/3/7pBn99GqDn23/enbqdRbo/+VnCT4v5fYFPg/nr00reL1D/1RcYvx/g85B7fr/l8wv/GQ1e5k/s11nZ3zX5lDLuArT1X6r93//+j3//vw==",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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OTfO59wEn3MzfM7N8jk33+fcQp9zf/ic+8vn3Eb185/b2OdcY59zm/uca+pzbjufczv7nNvV51wrn3NtfM5V+Zxr73PO8Tnn+pzb3efcnj7n9vM5d4DPuUOy50Z/cOUfT/3yzrnec0dnz70e/eDwn5/dajvvuVOy5744/rHvO2172dbec6f6nDvN59zpPufiPucSPufOzp7T9eRzs+cO+GvsIcPvu6nWJfFCn/fd63Pufp85H/Z537DsOd314aXsf+muqW/5zDnWZ91/9zk3yefcFJ9zy7PndNdU1lJ86K6pm2bP/Trp++O7X3DFMd5zjbPn6pdsvWWXMed+4D33VoP83N/zOfeFz7lvsud06/eLz/sm+pybnj2nW7+lPu/bISsqdbneyedca59zpT7n9sqe061fx+w53fp1zp7Trd+Yhvn5lW2U/1w7n3MnZM8dcGenznd3fLWV91ynzfPzO8nn3Kk+57r6nMv4nDvL59x5Pue6+Zy71OdcT59zV/ucu8bn3PU+5270OXenz7m7fc7d63Pufp9zj/ice9Tn3Kyt8p+b43Nuqc+55T7nVvqc+8PnXMnW+c/V9znX0OdcI59zjX3Obe5zrqnPue18zu3sc25Xn3Pl2XM3tVm07fDBj5R5z83bJv/7FvicW+JzbpnPudU+52oMtVZ7+5zb2OfcZj7ntvA518zn3PY+53b0Obezz7mWPuda+5wrzZ7TXQOO9znXMXvuswe++nDQLfGU91wnn/ed7PO+Lj7vO83n3Ok+c8Z93pf0eV/a531n+Zw7x2fO83ze183nfd193nexz7lLfOa8zOd9l/u870qf9/XyOdfbZ87rfN53g8/7bvJ5360+5273mfNOn/fd7fO+e33e94DPuYd85nzE532P+ryvr8/7nvQ595TPnP193jfQ533P+rzvK5/3Hd40//uO9Tl3is+5RPacziN093nfZdlzOu19k8/7Ps6e0/XdT33Ofetz7nufc3Oz53Teol6zf/7UeYtGzfLzu7BZfn7LfM6t8jl3cPYuh85bHLZrfn6H+5w7xufccT7nOvucO8Xn3Ok+5+I+5872OXeuz7nuPucu8jl3qc+5nj7nevucu87n3A0+527yOXe7z7k7fc7dnT2n06Yntcj/vs4+507zOXe6z7kzfc6d7XOum8+57j7nevicu9TnXC+fc719zl3nc+4G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",
      "debug_symbols": "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j5oeNT1qetT0qOlR06OmR02Pmh41PVp6tPRo6dHSo6VHS4+WHi09Wnq09OD04PTg9OD08Dg3J06SpJ6kSRbkcX4TJZWkmpQekh6SHpIekh6SHj09enr09Ojp0dOjp0dPj54ePT16emh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh6WHh44dIgSipJNaklcZIk9SRNSg9KD0oPSg9KD0oPSg9KD0oPSg9Kj5IeJT1KepT0KOlR0qOkR0mPkh5XnPfrjehlTYMo6Sp0Fqea1JI4SZJ6kiZZ0BXngygpPVp6tPRo6dHSo6VHS4+WHpwenB6cHpwenB6cHpwenB6cHpwekh6SHpIekh6SHpIekh6SHpIekh49PXp69PTo6dHTo6dHT4+eHj09enpoemh6aHpoemh6aHpoemh6aHpoelh6WHpYelh6WHpYelh6WHpYelh4eHHUIEoqSTWpJXGSJPUkTUoPSg9KD0oPSg9KD0oPSg9KD0oPSo+SHiU9SnqU9CjpUdKjpEdJj5IeJT1qetT0yDjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4zznnHeM857xnnPOO8Z5z3jvGec94zznnHeM857xnnPOO8Z5z3jvGec94zznnHeM857xnnPOO8Z5z3jvGec94zznnHu1V/dnCSpJ2mSBXmc30RJJakmtaT0qOlR06OmxxXnelx0xfkgSipJNaklcZIk9SRNSg9OD04PTg9OD04PTg9OD04PTg9OD0kPSQ9JD0kPSQ9JD0kPSQ9JD0mPnh49PXp69PTo6dHTo6dHT4+eHj09ND00PTQ9ND00PTQ9ND00PTQ9ND0sPSw9LD0sPSw9LD0sPSw9LD0sPLyQTMmJkkpSTWpJnCRJPUmTLIjSg9KD0oPSg9KD0oPSg9KD0oPSo6RHSY+SHiU9SnqU9CjpUdKjpEdJj5oeNT1qetT0qOlR06OmR02Pmh41PVp6tPRo6dHSo6VHS4+WHi09Wnq09OD04PDw6h9fcO0PqDhdIs1JkyzIH8ZNlFSSalJL4iRJSo+aHjU9Wnq09Gjp0dKjpUdLj5YeLT1aerT04PTg9OD04PTg9OD04PTg9OD04PSQ9JD0kPSQ9JD0kPSQ9JD0kPSQ9Ojp0dOjp0dPj54ePT16evT06OnR08OTni/T96R3U0mqSS2JkySpJ10e4nR5XK88rxUaREklqSa1JE6SpJ6kScOjeNHQIEoqSaeHHU4tiZMkqSdp0ulhxTcqOJIoqSTVpJbESZLUkzQpPUoqX6nOqpMkXf+2OWmSBV3xO4iSLhVxqkktiZMkqSdpkgVd8Wv39gyUVJIuD3/ivrPA4Q/Q9xY4/J58d4GBHahAS/RdBgbWC9mxATnR9wQ41JGBAuxABVqi7w8wkIAFWIFw63DrcOtw63DrcFO4KdwUbgo3hZvCTeGmcFO4KdwMbgY3g5vBzeBmcDO4GdwMbpZuXtYTSMACrMAGZKAAO1CBcCO4EdwIbgQ3ghvBjeBGcCO4EdwK3ArcCtwK3ArcCtx8Lw86HBkowOsaxp4lCrRE39djIAELsAIbkIEChFuDm0chXfnj3jVnIAELsAIbkIEC7EAFws33/6DqSMACrMAGZKC7dccOVKAleswPJGABVmADMhBuHW4dbh1uHt2+Dce9Bc/ABmSgADtQgZbo0T2QgHAzuBncDG4GN4Obwc3SzYt5AglYgBXYgAwUYAcqEG4EN4IbwY3gRnAjuBHcCG4EN4JbgVuBW4FbgVuBW4FbgVuBW4FbgVuFW4VbhVuFW4VbhVuFW4VbhVuFW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Mbw43hxnBjuDHcGG4MN4Ybw43hJnATuAncBG4CN4GbwE3gJnATuHW4dbh1uHW4dbh1uHW4dbh1uHW4KdwUbsglBbmkIJcU5JKCXFKQSwpySUEuKcglBbmkIJfc+w6ROTYgAwXYgRp4bz1071R1J5AbC7ACG5CBAuxABVoiwY3gRnAjuBHcCG4EN4IbwY3gVuBW4FbgVuBW4FbgVuBW4FbgVuBW4VbhVuFW4VbhVuFW4VbhVuFW4dbg1uDW4Nbg1uDW4Nbg1uDW4NbgxnBjuDHcGG4MN4Ybw43hxnBjuAncBG4CN4GbwE3gJnATuAncBG4dbh1uHW4dbh1uHW4dbh1uHW4dbgo3hZvCTeGmcFO4KdwUbgo3hZvBzeBmcDO4GdwMbgY3g5vBzdKtIZc05JKGXOLFSHTtDFa8GimQgZdbqY4dqEBLvLcXvJGAl1txt3uTwRsb0N2aowA70N26oyXeWw7e6G7mWICXWz0cG5CBl1v12/RcMlCBl1v1a/BcMpCABViBDei6fpueH6o4uoJfuueHgRXYgH69fkOeHwZ2oAIt0fPDtb1K8YKkwAK83JrfpueHgQy83Nr9dztQgZbo+WEgAS+35o3A88PABmSgADtQgZbo+WGgu/mj9vwwsAIbkIEC7EAFWqLnh4Fw8/zQvBl5fhjYgAwUYAcq0BI9PzRvMJ4fBhZgBTYgAwXYgQq0QK9gCiRgAVZgAzJQgB2oQLgR3AhuBDeCG8GN4EZwI7gR3AhuBW4FbgVuBW4FbgVuBW4FbgVuBW4VbhVuFW4VbhVuFW4VbhVuFW4Vbg1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDDeGG8ON4cZwY7gx3BhuDDeGm8BN4CZwE7gJ3ARuAjeBm8BN4Nbh1uHW4dbh1uHW4dbh1uHW4dbhpnBTuCncFG4KN4Wbwk3hpnBTuCGXMHIJI5cwcgkjlzByCSOXMHIJI5cwcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJfInUvE0d3MsQIbkIEC7EAFWuKdS24kINwK3ArcCtwK3ArcPJdcu+QUL6Ea6LlkIAELsAIv3WtrhiL3xsbXm1furY1vdIXmWIAV2IAMFGAHKtDd/Ae4tzu+kYDu5j/LvenxjQ3IQHfrjq579aXl3uz4RgIW4KUr/hw8E4jfsWcC8UfimUD8ej0TiF+ZZwJxY88EN3omGEjAy038yjwTDGxABrqb/7Ae/t0vx8O/++V4+F817sUrpc6BUsfLovsNefgPbEAGCrADFehufg0e/gNLtpJ7Y+QbG5CBaFEe8wMVaIFeMRVIwAKswMvtmngv/d4w+UYBXm56/10FWqLH/EACFmAFNiADBQg3gpvH/DVRW7yKKtDdmmMBult1dF1x7EAFWqJHt3ZHAhZgBXo/4P5nDBRgByrQEtHr6Hev48YC5Lv2oXjJ1DmE7tiBCrRED/mBfhPmWIAV2IAMFGAHKvBy8xlmL6AKJODl5lPBXkNFPgPsRVTkU7teRRUowA5UoCV6yLusR/xNLYmTJKkHefj5VK9XMgUSsAArsAEZKMAOVGC6eU1TIAELsAIbkIEC7EAFwo3gRnAjuBHcCG4EN4IbwY3gRnArcCtwK3ArcCtwK3ArcCtwK3ArcKtwq3CrcKtwq3CrcKtwq3CrcKtwa3BrcGtwa3BrcGtwa3BrcGtwa3BjuDHcGG4MN4Ybw43hxnBjuDHcBG4CN4GbwE3gJnATuAncBG4Ctw63DrcOtw63DrcOtw63DrcOtw43hZvCTeGmcFO4KdwUbgo3hRtyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXWOaSemQuqUfmknpkLqlH5pJ6ZC6pR+aSemQuqUfmknpkLqnHATeCG8GN4EZwI7gR3AhuBDeCG8GtwK3ArcCtwK3ArcCtwK3ArcCtwK3CrcKtwq3CrcKtwq3CrcKtwq3CrcGtwa3BrcGtwa3BrcGtwa3BrcGN4cZwY7gx3BhuDDeGG8ON4cZwE7gJ3ARuAjeBm8BN4CZwE7gJ3DrcOtw63DrcOtw63DrcOtw63DrcFG4KN4Wbwk3hpnBTuCncFG4KN4Obwc3gZnAzuBncDG4GN4MbcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZfcdZFXCXW96yJvvEP6xtOiXIXV1esiAyuwARkoQB/2ctIkC/JDmq6y6+pFkYEF6FbNsQHdym/BD2wa2IEKtEQ/uGkgAQuwAhsQbgo3hZvCzY9yuopv632E4UACFmAFNqAP6zhJUk/SJBtU8nw1L4cshzleV3oV+VYvfCxEjgq0RD/CaeB1pVdxa/XCx8AKbEAGultz7EAFuptc6Mc6DSSgu/ld+OFOA93Nb8gPeBoowMutOGmSBfk5TzdRUkm6FIs/Ij/IqfgT8KOcxvluB5CABXhdafEb9IPVBjJQgB14ubGTBfkRazddVv73/JC1m2pSS+IkSXKTW0aBluhRPNAv0x++x+vAS8F/Uz9S7SYL8ngt/tN4vA4swOtCqz9Tj9eBl1X1x+vxOrAD3cufqcdrdTeP1+o35vF6FXFUL0cMrMAGZKAAO1CB7uaX7vFavVV5vDa/dI/M5hfpB641v0g/cm1gByrQAr0GMZCALlYdBdiBCrRED9WBBPR/1hwVaIkecwP9n7Gjty9xrPcBQrXGaU61xnFOtcZ5TrXGgU61xolOtcaRTrXGmU61xqFOtcapTrXW9KjpUdOjpkdNj5oeNT1aerT0aOnR0qOlR0uPlh4ebq07Xg/EnEpSTWpJnCRJPUmTLCgPN8TphjjeEOcb4oBDnHCIIw5xxiEOOcQphzjmEOcc4qBDnHSIow7vAw3bjZbosTbwEmJvLB5r1+RovY82ZG83HlXs7cYj5ZpArPdRheJ/199sAxvwujnxBuvxM7ADFWiB99GFAwlYgO5Gjg3IQHczx0u3X5dzH1w48NLt/nf9rTewAhuQ8c8E2IEKhFuBm0fgwAJsQL7P06peVTeoJ2mSBXng3eTixbEAK1CAfnn+DP1V15sjAQuwAhuQgQLsQH8YfmX+rrvRo2+gu4ljAVagu3VHBgqwAxVoiR6GAwlYgBXoburIQAG6m7clD8eBlugBOfByU/9JPSQHVuDlpv5b+CtyoAA78HJT/7E8bG/0sB1IQHfzH8DDdmADupvfsQfzwA5UoCX6K3IgAQvQ3fxB3eeU+m3ep5Be0cP3OaQ3ErAAPQNWRwF2oAJd97ohvk8hvZGAriuOrtAdFWiJ92mjNxKwACuwAf161VGAHaiJ92mj5liAFdiAVw7wLtR95uHADlSgJfrbcSABr/fj4c/XX4YDBdiBrlscLdFPPhxIwAKswAZkoIv57+aHHQ4kYAEKsAMVCLEOsQ4xP+PQO4v3KYcDG5CBAuxABVqin3k40N3YsQDrfRphzaMPa559WPPww5qnH9Y8/rDm+Yc1D0CseQJi9Vqz81vRsQIbkIEC7EAFWqDXmgW6bnd0BXXs9xGHNU89rHnsYb3PPbyJkkqSK5pjAzJQgB2oiffBo4ejf9K57v1teuOlUJx6kiZZkL8jb6Ik/3CsjhXYgAwUYE+8P0eboyuwY7uPfqxeBjZIkq4Hev9rTbKgK9QGUVJJchP/ie6TRm9koCbeZ4n6b3ifJnpjBV6X6Q/ietkNkqSepEkWdJ/t6z/RfbrvjQVYgQ3IQAF2oAItUeGmcPO48267V3sFNuDl5l1Xr/YK9HbiP4Wf/+v9Ya/2qsUfnJ8BPJCA7ubGHoADLzfv5nrhV/X+hRd+ec/K674GaZIN8qKvQZTkisXxulLvDHsZV/VvPC/jGugn/w68rrS6gp/+O7ACG5CBrnvdoJdmVe8Me2lW9c6wl2YFNiADBdiBCrRED8KBl5unNi/YCqzAy83TiBdsBQqwAy83b5hesDXQg3Mg3QeSVq/XGlSTrkDwG/d4vUmSepImWZC/Gj04vXwrsAArUIB+mVcj9JKsQFfw39NDdmAFtvv0sJqnH9Y8/rDm+Yc1D0CseQJizSMQa56BWPMQxJqnINY8BrHmOYg1D0KseRJizaMQa56FWPMwxJqnIdY8DrHmeYg1D0SseSJizSMRq+9rVe9o8AgdaIkeoffz9wgdWIDXI/OeqxeEBXrPyp+/vyIHdqACLdALwqr3iL0gLPBy8x6xF4RV7xF7QVi9ym+rF4QFCtDd1FGBlhint1WN49uqxvltVeMAt3qfongTJ7ni1aa9vKt6z9vLu6r3hb28K7ABGXhdqXesvbwrUIGW6NE8kO5DxKrXcXln+96pyi8gdqWquStVzV2pqpdlVfF/7KM2AxkowA5UoCV6OA4kYAHCjeHGcGO4+Ynd4j+bv1cHWqKH7kACFmCLZxD70FWNfeiqF2JV8V/dv24HWqK/ZQcSsACvu/FhAy/ECmTgdTc+dOGFWIEWP1JsFF81NoqvXnrl4wJeeTWoJbl4cRRgByrQEj1kB163cot5yA6swHbvplg1dp6sGjtPVo2dJ6vGzpNVY+fJarHzZLXYebJa7DxZLXaerBY7T1aLnSerxc6T1WLnyWqx82S1Iz0oPSg9KD0oPSg9KD38i9dHR7zCKlCB/syucPYKq0ACFmAFNiADBdiBCoRbhZu/nO/r9ZfzwApsQAYKsAMVaIn+cvZRF6+wCizAem9jWb3AahAnSVJP0iAPfR+x8XqpOv7rdaUeeV4vFdiBCryu1IdevF4qkIAFWIGXmw+yeL1UoAA7UIGW6CE/kIDu5g/OQ97HW7xeqvogi9dLBQqwAxVoif5hPZCABViBcFO4KdwUbgo3hZvBzeBmcDO4GdwMbgY3g5vBzcKteb1UIAELsAIbkIEC7EAFwo3gRnAjuBHcCG4EN4IbwY3gRnArcCtwK3ArcCtwK3ArcCtwK3ArcKtwq3CrcKtw88xwDeY1r5cKdLfi2IEKtETPDMaOBCzACmxABgqwA91NHC3RU8U1mNe8SCqwAhvQLdRRgB2oQBt5p3mRVCABC7ACG5CBAuyJcZZrO+Iw13bEaa7tiONc2xHnubYjDnRtx50kbpkOVKAl3kniRgJeTv5Y/LP+ppbkg15udY963diBp9X17djyJMiWJ0G2PAmy5UmQLU+CbHkSZMuTIFueBNnyJMiWJ0G2PAmy5UmQLU+CbHkSZMuTIFueBNnyJMiWJ0G2PAmy5UmQLU+CbF7v1K7x1Ob1ToEF6MOExbEBGSjADlSgJZYDSEB388spFdiA122JkyT1JE2yID9I6iZXbI5+pezoV3r/BQVaYjuAfqXqWIAV2IAMdDdz7EAF2n0MVKM4LqpRHBfVKI6LahTHRbX7+MebOEmSepImpYekh6SHpIekh6SHpIekh6SHj7Rdo53Nq6Qa+S/VDyABC7ACG5CBAuxABcJN4aZwU7j5GDf5j++D3AMZKMAO1EQf1SZvB/cKaSdJ8n/kD8QHzQZaoJc8BRKwACuwAf0SzVGAHegDnYejJXo0DyTg5XYNMzavhGpXSVDzSqjADlSg61636ZVQ7Rp8bF4J1a4KnOaVUK349XrcFr8yj9vqxlfcBgqwA31U2a+sWGI9gAT0keXq6BZ+OdUt/HI8vK/xweb7vrXql+Ph3fyGPLxv9PAeSMACrMAG9DFyv4Z7kPxGjTbiZVIDfXR8oFv49fr4+MAKdIv77zJQgB2oQEuUA0jAAqxAuAncfDi9+TPz8fSB7ua/sYf5jR7mzR+1BzT7r+kBPZCBArx02X9ND+iBlugBPZAiWXsdVWAFNiADBdiBmugBzf5rXu/rwApsQL8L/419mHxgByrQh0Ku2/Q6qkACFmAFNiADBehP54pCL6kKJGABVmAD+l2wowA7UIGW6NHt32deX9X8Y8kLrNo1+te8wipQga5wtR0vsgr0OQO/IY/jgRV4Xe81rte80ipQgB2oQEv0kB7obsWxACuwARkoQB/W9cfncXw/B4/jgXg6Hsf+NeU1WIEMFKDfhT9fj+OBluhxLP6oPY4HFqC7+aP2OB7IQHfzS/c4Fv8BPI67P2qP4+4PyuN4IAEv3e7PweN4oAA70HX93jxi71biETuwAhtQgD7n4uid7oEE9BkevzfvdA9sQAYKsAMVaIFerhV4XeQ1ptW8MCuQgQL0m2dHBVqih+lAv4vqWIAV2IAMFGAHKtASvSN9zaK2VirQ70IcGSjADvS7uP+ZJXrwDiRgAVagz5r6k7ynoW8UYAcq0BLvyekbCViAFeh3cWMHKtASPXi9C+r1W4EFWIF+F/673bPUNwqwAxVoid57HkhAn7I7HBkowA70aTtytEQP04EELMAKbEAGultx7EAFWqK/hNUbl4f0wAKswCh0aF6pFSjADlSgJXrMDyRgAXoJhrczfwmrR6G/hAcq0O/ieupev9WuAq/m9VuBBViBDchAAXagu10Nxuu3mg8l8V0y4n/BX6w+lOT1W4GW6B/TA12hOBZgBTYgAwXYgZrX4ANiN/qA2EACFmAF4i7uqq4bBeh3cf3yXr8VSMACrKNms/Fdh3kjAwXYgQq0xLsO80YC+lIG/7m94nKgAP3p3KhAv4urRXmBVyAB/S78jv11O7ABr2lMHxzyCrDADlSgJfoomA9peAVYYAFWYAMyUIA90aeyfYzDq7p8gUTzEi72j16v4QpUoF+Z/107gH5l/hysACvQr8yfgzFQgB2oQAv0Qq5AdzPHAqzABmSgAHvcsVd4sY9JeIlXYAFW4KXrGcaLvAIF2IGx6Kb59mADvQ5zIAELsAIbkIHX07m2kGle/TWwHkAC+l1UxwpsQAZeEXDfZu1ABVqi11MPJGAB1sT7YDT/3e6T0W5koAA7UIGWeJ+PdiMBCxBuArd7ctp/+Xt2+sYOVKAl3iel3Xjp3j+sHxE0kIEC7EAFXrr+cvdyr0ACFqC7efP0w4IGMtBS108EGkjAAsSlGy7djwW63fxcoIEdqEAL434fiHYjJd6Hffjo1r1FVrCB7/M+XPDeJeu4/+194sfgOnGbmJ27s0zcJ1ZwvfXV+dYxZ55YJtbp7/s1+yDYvSVWME1cJq4Tt4l5YvfyEbI+Duu5WSe+fa9Y7OO8nptp4tuXnOvEbWKeeLpH7hPrxAaWY2KauExcJ56erUzP1mPofpweQwMJWIAV2IAMFGAHKhBuCjeFm8JN4aZwU7gp3BRuCrc79LyZ3aF3IwELsAIbkIEC7EAFpts4i/BGAhZgBTYgAwXYgQqEG8GN4EZwI7gR3AhuBDeCG8GN4FbgVuBW4FbgVuBW4FbgVuBW4FbgVuFW4VbhVuFW4VbhVuFW4VbhVuHW4Nbg1uDW4Nbg1uDW4Nbg1uDW4MZwY7gx3BhuDDeGG8ON4cZwY7gJ3ARuAjeBm8BN4CZwE7gJ3ARuHW4dbh1uHW4dbh1uHW4dbh1uHW4KN4Wbwk3hpnBTuCncFG4KN+QSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSQy4x5JL7WFD/3rnPBfXPuPtg0IGW6LlkIAELsAIbkIEChJvCTeFmcDO4GdwMbgY3zyX+oXkfFTqwAxVoA/k+LnSgu7FjAVagu6mju5mjADtQgZbouWQgAQuwAhsQbgQ3ghvBjeBW4FbgVuBW4FbgVuBW4FbgVuBW4FbhVuFW4VbhVuFW4VbhVuFW4Vbh1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDGcGO4MdwYbgw3hhvDjeHGcGO4CdwEbgI3gZvATeAmcBO4CdwEbh1uHW4dbh1uHW4dbh1uHW4dbh1uCjeFm8JN4aZwU7gp3BRuCjeFm8HN4GZwM7gZ3AxuBjeDm8HN0o2OA0jAAqzABmSgADtQgXBDLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5JKCXFKQSwpySUEuKcglBbnEq+j0KiRjr6ILVKAlei4ZSMACvNyu+jP2XcYCGej3po4d6G43WqLnkoEELMAKbEAGult37EAFWuKdS24kYAFWYAMyEG4VbhVuFW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbgw3hhvDjeHGcGO4MdwYbgw3hpvATeAmcBO4CdwEbgI3gZvATeDW4dbh1uHW4dbh1uHW4dbh1uHW4aZwU7gp3BRuCjeFm8JN4aZwU7gZ3AxuBjeDm8HN4GZwM7gZ3Czd6nEACViAFdiADBRgByoQbgQ3ghvBjeBGcCO4EdwIbgQ3gluBW4FbgVuBW4FbgRtySUUuqcglFbmkIpdU5JKKXFKRSypySUUuqcglFbmkIpdU5JKKXFKRSypySUUuqcglFbmkIpd4fd+dq/2k1UBLvHOJOmZW9qq/wAps+GcMFGDH31VgvgPqnRT8797h3xwt8Q7/GwlYgBXYgAwUYAfCrcNN4aZwU7gp3BRuCjeFm8JN4aZwM7gZ3AxuBjeDm8HN4GZwM7hZurXjABKwACuwARkowA5UINwIbgQ3ghvBjeBGcCO4EdwIbgS3ArcCtwK3ArcCtwK3ArcCtwK3ArcKtwq3CrcKtwq3CrcKtwq3CrcKNw//q6SfvUJQr4J89grBwApsQAYKsAMVaIke/gPhxnBjuDHcPPyvRQHsdYOBHahAS/RPiYHudjgWYAX2SBXtThU3WuKdKm4kYAG62I0NyEC/dHHsQAX6pV+Zy4sFAwlYgBXYgAwUYAcq8HJjv3lPFQMJWIAV2IAMvNyuFQbsJYSBCrRALyEMJGABVqC7sSMDBdiBCrRETxUDCViAFQg3ghvBjeBGcCO4FbgVuBW4FbgVuBW4eaq4KuDZixADNdGTwkBX6I4MFGAHKtASPfwHErAAK/Byu5YVsJcbBgqwAxVoiR7+AwlYgBXobtWRgQLsQAVaoof/QHfzu/DwH1iBcBO4Cdw8P4y/q0BL9PzQ/dI9PwwsiR6x3Vu1R+xABmbPnTFOwBgnYIwTMMYJGOMEjHECxjgBY5yAMU7AGCdgjBMwxgkY4wSCcQLBOIFgnEAwTiAYJxCMEwjGHAVjjoIxR8GYo2DMUTDm6OWGei2OYC83DGxABgqwAxVoiR6x1xIE9nLDwAKswAZkoAA7UIGWWOHmcXytZ2AvQgyswAZkoAA7EG4Vbh7d11oC9iJEvYr32YsQAyuwARkowA5UoCV6dA+EG+f4zl3nOLAB3c1/Y4/ugR2oQEv06B5IwAK83NR/Y4/ugQwUYAcq0BI9ugcSsADh1uHW4dbh1uHW4dbhpnDzrHEtCmDfwE7Vf1jPD+rP1/PDQEv0/DCQgAVYgQ3IQAHCzeBm6XaXPA4kYAFWYAMyUIAdqEB3u35Y3/IukIANeClcCwjYSy0DLdFjfiABC7ACG5CBAnS36qhAS/SYH0jAAqzABmSguzXHDlRg9rD7/UF/IwHd7cYKbEAGCrADFWiJHvPmv5DH/MACrMAGZKAAO1CBlihwE7gJ3ARuAjeBm8BN4ObRbd52rji2w3/YK47t8Od7xXGgADtQgZZ4xXEgAQuwAuGmcFO4KdwUbgo3g5vBzeBmcDO4GdzM3fyHtQ7UQK+qDHQFcWSgADtQgZZIB5CABViB7qaOrnD9WF4TGUjAAqzABmSgADvwut6rNv9ES7ziOJCABViBDcjAy+2q9WaviQxUoCW2A0jAAqzABmQg3BrcGtwa3BhuDDeGG8ON4cZwY7gx3NjdvMGwJcoBrEBX8J9bOlCBltgPIAELsAIbkIHu5i3K43igAi3R45i8aXgcDyzACmxABgqwAxV4uRVvJR7HAwlYgBXYgAwU4OXmQz1e5xhogV7nGEjAAqzABmSgADtQgXAjuBHcCG4EN4IbwY3gRnAjuHl+8CEZr3MMJGADuoI4KtASPeYHErAAK7ABGShA171alFcemndsvPIwUIAdqEBL9IgdSMACvK7s2g+EvfIwkIEC7EAFWqJH7MDLrfqjvt68gRXYgAwUYAcq0BI9ugfCrcOtw63DrcOtw63DrcOtw03hpnBTuHl0+3eUVx4GMlATPWKr/9wesQMrsAEZKMAOVKANFK8mDHQ3dSzACmxAdzNHAXagAi3RI3YgAQuwAi+3azxVvJowUIAdqEBL9IgdSMDL7do2QryaMLABGSjADlSgJXp0DyQg3CrcKtwq3CrcKtwq3CrcGtwa3BrcGtw8P1zDxuLVhIECtESP+ebtwWN+YAMyUIAdqEBL9JgfSEDX7Y4MFGAHKtASPboHErAAKxBuHW4dbh1uHW4dbgo3hZtHd/NG69E9sAEZKMAOVKAl+rt74OV2bXgjXgto7E3ZM8HABmSgADtQgRbotYCBMZsqdy3gwAp0t+rIQAF2oAIt0TPBQAL6vXXHCmxABgqwAxVoiZ4JBhIQbgVuBW4FbgVuBW4FbgVuFW4VbhVuFW6eCdgfqmeCgQK0RI/ua68e8fq+wAZkoAA7UIGW6G//gZTo72Px9uDv44ENeLldm/mIV9wFdqACLdEjdiABC7ACGxAWHnrXHkDipXOBFej/zFuUh95AAXagAi3RQ28gAQuwAtPCa+Ds2tdHvAYusAD9n7FjAzJQgB2oQEv0GBpIwAKEhQfDtduieDFbIAH9n3XHCmxABgqwAxVoiR4MAwkIC3+/XdsiiVelDfT320D/Z+ZYgBXYgAwUYAcq0BI9AgbCwl9113yLeNFZYAdeYtd8i3jR2UB/1Q0kYAFWYAMyUIAdCDcPnGvKQby8zLq3Pg+cgQ3IQAF2oAJ9OMTv7R5uupGABViBDchAAfrT8QjwyBpIQL8Lb6keWQMbkIEC7EAFWqAXkgUSsABdVxxdtzt2oAIt0UNvIAELsI7xdblLxgYyUIAdqEBL9CHmgTHxJ3dx2EAGxuSY1Cxal5pF61KzaF1qFq1LzaJ1qVm0LjWL1qVm0brULFqXWuFW4VbhVuHW4Nbg1uDW4Nbg1uDW4Nbg1uDW4MZwY7gx3BhuDDeOiT+5i8MGdqACLfGeQLqRgAUYE3/iW8IFMlCAHahAS+wHkIAFCLceE39yV5oNFGAHKtASfQJpINwUbvdktDd7jYk/uSvNBgqwAxVoiXYACViAFQg3n2yqHgEmwA6MiT+5K80c70qzgQQswApsQAbGVJzclWYDFWiJdAAJWIAV2IAMhBvBjeBGcCtwK3ArcCtw86xxzQzKXT3myeauHrumzOSuHhtYgBXYgAwUYAcq0BIb3BrcGtwa3BrcGtwa3BrcGtwa3BhuDDfPD+o/rOeHgQ3YEyUm/uSuCBtYgBXYgAwUYAcq0BJ7TPzJXTI2sAArsAEZKMAOVKC7+S/vMT+QgN4ZZMcKbMCY+JO7ZGxgByrQEj3mBxKwAGMqTu6SsYEMFGAHKjAm/uQuGRtIwAKswAZkoAA7UIFwI7h5dF8zg+JlYPe3kZeB+ZSZeBlYoCWWA0jAAqzABmSgAOFW4FbgVuFW4VbhVuFW4VbhVuFW4Vbh5p/518SfeMlYIAEbMCb+xMvAAi2RDyABC7ACG5CBAnQ3/7EkJv7ES7sCG5CBAuxABVpiP4Ax8SfcC7ACG5CBAuxABcZUnLAeQAIWYAU2IAMF2IEKhJvBzeBmcDO4GdwMbgY3g5vBzdLNC8kC3Y0dC7ACBRgTf+LFYYEELMAKbEAGCrADFRgTf+LFYYEELMCY+BMvDgtkoAA7UIGWWA8gAWPiT6RWYAMyUIAdqEBLbDEVJ14cFliAFdiADBRgByrQEhluDDeGG8ON4cZwY7gx3BhuDDeBm8DN80PxFuX5YWAD9sQeE3/iBV+BBViBDchAAXagAi3Ro7t4i9KY+BMv7Qq0RDuABCzACmxABsbEn4h1oAJj4k/6cQAJWIAVGFNx0g8GCrADFWiJdAAJWIAVCDeCG8GN4EZwI7gVuBW4FbgVuBW4Fbh5dPt3lJeBBWqix/HAmPgTL+0KFGAHKjAn/ry0K5CABViBOfHnpV2BAuzAnPjz0q6BfAAJWIAV2IAMFGBO/HVWYE78dTmABCzACmzAnIrrIsAOVGBOxfV+AAlYgBXYgHDrcOtw63DrcFO4KdwUbgo3hZvCTeF2T0F5i7qnoG7M6cC74GtgTvzdpV0DO1CBOfHn2+gFErAAK7ABcyruLvgamFNxd8HXQAIWYAU2IAMFCDeCG8GtwK3ArcCtwK3AreTE310cNrADFZgTf3dx2EACFmAF+vRPccyJv7s4bGAHKjAn/u7isIEELMAK9L6eOjJQgDnxdxeHDcyJv7s4bCABC7ACGzCn4u7isIEdqMCciruLwwYSsAArsAHhJnATuAncBG4dbh1uHW4dbh1uHW4dbp4JfOLvLiQbmNOBd8nYwJz4u4vDBnagAnPi7y4OG0jAAqzAnGa8y7V8DvAu1xrYgTnxd5dr3UgHkIAFWIENyEABdiAs7umq4shAAebE312jNTAn/u4arYEELMAKbEAGChAW93RVc2xABubE312uNVCBOfF3l2sNJGABVmADMhAW9zyvOFZgA+bE3113NbADFZgTf3fd1UACFmAFNiAs7nledSzACsyJv7uAaqAAO1CBOfFndgAJWIAVCIt7ssnb+j3ZdGK/a6kGxsRfv2upBlZgAzJQgB2oQEukAwg3D5xryqHfVVPXvF6/q6YGdqACLdFfdQMJGBN//a6aGtiADBRgByrQEj2yrmmEftdHDWzAmPjrd33UwA5UoCW2A0jAAqzABoSbh941M9jv+qhrgqP7vmqBBCzACmxABsbEX7/3VRuoQEuUA0jAAqxAn2TxRnBPIN2owJgc69hBrWMHtY4d1Dp2UOvYQa1jB7WOHdQ6dlDr2EGtYwe1jh3UOnZQ69hBrWMHtY4d1Dp2UOvYQa1jB7WOHdQ6dlDr2EGtYwe1jh3UOnZQ69hBrWMHtY4d1Dp2UOv3Dmp3ZFlM/PV7B7WBBCzACmxABsbEX793UBuoQEukA0jAmBzr9w5qAxuQgQLsQAVaYjmABITbvesROTYgA93NHDtQgZZYDyABC7ACY3Ks3zuoDRRgByrQEtsBJGABViDcGtwa3BrcGtwa3BhuDLd7Wqk6Zia4d0VTf75siXIACViAFdiADBRgB8JN4Nbh1uHW4dbh1uHW4dbh1uHW4dbhdq9Q9B9WCViADIzJsX7vdHajHUACFmAFNiADBdiBMTnW753OHO+dzgYSsAArsAEZKEB3a44KtMR7pzN2JGAButuNDchAAXagAi2xHMCYHOv3TmcDK7ABGSjADlSgJdYDCLcKtwq3CrcKtwq3CrcKN4/ua9Kt33Vi/tlx14kd/nybADtQgZbIB5CABViBDQg3hhvDjeHGcBO4CdwEbgI3gZvATeB2T0z5D3tPTN1oif5lPjAmx/pdMjawAxVoiXoACViAFdiA7uY/lsXkWL+LwwYWYAU2IAMF2IEK9CmSqxHcxWEDCViAFdiADBRgTFf1u2RsoCXSASRgAVZgAzJQgHAjuBHcCtwK3ArcCtwK3ArcCtwK3Arc7smmq8HUe7LpRgI2YEyO9VoVaIntABKwACuwARkoQHdTRwVaIh/AmBzr9V6heGMFNiADBdiBCrTEewLJW8k9gXRjAVZgAzJQgB0Y01Xdi8MG9gNIwAKswAZkoAA7EG4dbgo3hZvCTeGmcFO4KdwUbgo3hds9XeUt6p6uurEAGRiTY71aTI71dhxAAhZgBTYgAwXYE++1iOoYk2O93esLb+xABVpiOYAELMAK9CmSw5GBAuxABVpiPYAEjOmq7qVdgQ3IQAF2oAItsR1AAsKtwa3BrcGtwa3BrcGtwY3hxnBjuDHc7skmdmSgAC1RYnKsN6nABmSgADtQgZbYDyAB3c1b1L1C8cYGZGBMjvV2r1C8UYGWqAeQgAVYgQ3oUxneSu4JpBs7UIGWaAeQgAUY01XdS7sCGSjADlRgTI51Pg4gAQuwAhuQgQLsQAXCjeBGcCO4EdwIbvcUFDsKsCfek003xuRYv0u7BjJQgB2oQEusB5CABRiTY/0u4hrYgQq0xHYACViAFdiAcGtwa3BrcGtwY7gx3BhuHJNj/S74GshAAXagAi1RDiABfYqkOMbkWL+LwwYyUIAdqEBL7AeQgN7XU8cKbEB3q44C7EAFWqIeQAIWYExX9bs4bCADBdiBCrREO4AELEC4GdwMbgY3g5vBzdLtLg4bSMACrMAGdDd1FGBPvNct3hiTY/0uDhvIQAF2oAItsRxAAhagj3jfqEBL9OgeSMACrMAGZKAA4VbhVuHW4Nbg1uDW4Nbg1uDW4Nbg5jF/nYfd74KvGz3mBxKwACuwARkowMvNh93ugq+Blugx74Nxd8HXwAKswAZkoAA70N287XjM3+gxP5CABViBDchAAXYg3DrcFG4KN4Wbwk3hpnBTuCncFG4KN495H7i7y8sGFiADLwUfdrtLxhzvkrGBBCzACmxABgqwA92tOFqiR/dAAhZgBTYgAwXobs1RgZboMe9jbXfJ2MACrMAGZKAAO9DdzNESPT8MJGABVmADMlCAHQi3CrcGtwa3BrcGtwa3BrcGtwa3BrcGt/sAVx/aGwe4Di4T88TqTM4Gvg9kHUwTl4nrxG1inlgm7hPfvt48+q3vLaGXiW99/yV7m5gnvvXFuU+sExtYj4lp4jJxnbhNzBNPvjr56uSrk69Nvjb52uRrk69Nvjb52uRrk69NvgZfLzo7uTvTxGXiOnGbmCf26T+XpPufqnOduE18/1Nzlon7xDqxge/zmgfTxGXiOnGbePIaZzEfzmXiOrH/2+tg6q7jjOabZeI+sU5s4Pu85sE0cZm4Tjx53TUsfjl3DcuNBRjVQP2uAxvIQAF2oAItUQ4gAQsQFncNyxWjd0HXQAJGNVC/C7oGNiADBdiBCrREPYAEhMVdw9IcLfGuYbkxqoH6XcU1sAIbkIEC7EAFRu1Rv7f4GliA/s/EUYGWSFEN1Efx140FWIENyEABdqACLbHA4i7+UscOVGBUA/VR/HUjAQuwAhuQgQLsQE1ssLi/kA/HBmRgVgPdJWEDFZjVQHdJ2EACFmAFNiAD4XZvZnC19XuvLi8BuvfqGliAFdiADBRgVgPdNWMDsxrorhkbSMACrMAG9KfTHBVoiZrVQHdR2cACrMAGZKAAO1CBWXt0F5UNdF2PAMtqoLuSbKAAO1CBUXuko77sxqgG0vvkz4EV2IAMFGAHauL9ZqPi3Cbmie+3RHXuE+vEBr7fbINp4jJxnbhNzBNPXvfHVvPruT+2BveJ/Xqa35cYuB8T08Rl4jpxm5gnlon7xJNvn3x18r0/qq4xPj3uj6drBE6P+4Pp/u/3B1Pz3/v+YLrOWtDj/mAa3CbmiWXiPrFOfF/bmYuU7g+mwTSx+17DUEr3B9N1lILS/cF0jYAp3R9M14iRejHTuBevZkrGPdL9JXXNlSjd7W1wm5gnlon7xDqxge/2Npgmvn39vu72Vv2+7vY2mCeWid23+r0XndjA9ZiYJi4T14nbxLe+P8/7q6r687y/pK6pCqX7S+qailAvSUrmiWViA98doerPn+vEt053vq/Bn9Xd4an+rO4Oz+A28d3e/PmMGLy5T6wT3+3N73fE4M2EvzNi8OY6cZuY8XzuGBzcJ1bw3eG5n4NOz0Gn53B3eJy9Toevk17U63QCO1CBlnh94QQSsAArsAHhRnAjuBHcCG4FbgVuxd2ao+uyowA7UIGu6zdf/cq6IwMF2BOb/111ZKAAO9DdzNES+QAS8LoLzzleOcOecrxyJrADFWiJ16cKe3bywphA/2f+oK72d84OOBKwAK8fi/3p9AZkoAB7orquP0l1BX9Q2oAMFGAHal6kWqIdQAIWYAU2IAMF6LrXz+IlMIEELEDXNcfryq6+mXpZy0Bv9gMJWIAV2IDXlV39LfWylsCe6A386m+pF7Dw1cFRL2Dhq8uhXsByPzMvYAlkoAA7UBOr35A4WmI7gAQswAr0G3Ixj4CBAuxAd/OH6m1d/KF6W+/+SK68HNiADBRgByrwuovuj+/6bg8koLv5Q5UKbEB38+crAuxABVqih9NAAhagu/kz83Dq/hy6K/hz8MAZSMACvK5M/TY9cAZ2oAIt0QNnIAEL8Loy9afjgTOQgQLsQLe4npmXlAS6WHX0f9YcO1CBlugxNJCABViBfpHs6BepjgLsQAVaokfWQAIWoOua46VwjZirV4ycM3eO1z8zv+Pr4yawAhvwEjN/JP4WGdiBbuH35lF4o0fhQAIWYAU2oLv50/EoHNiB7iaOlujvoYEELMAKbEB3644C7EB384fqsXmjx+ZAAhZgBTagu/nP4rE5sANPNzn8F7pi85zivPCKTTn86VyxKYc/hys2AyuwAflCv4vrVSeHX8P1qpPD3boCLVEP4OVGfjlXHIv3Hr26RLwT59UlgQwUoLt561MFWqIdQMqW6tE9sAIbkIEC7EA0ew90R68jkav2Ub2OJLABGeh3wY4dqEBLvMI/kIAFWIEt8e63FLe7+y2DZeK7vyTOOrGB737Ldeaq8t1vGVzAV1x1D2iv1QjsF1ZHBVriFVeBdKFf1BVXgRXYgAwUYAcq0BLlAMLt7qb4O5jvbsrgPrFObOC7mzKYJi4T14nbxJPv3U3xlz/f3ZTBOrGB76GCwTRxmbhO3CbmiSdfnXx18r2HDfxrhO9hA/+Y4HvYYLBObMlyDxv4t4XcwwaDy8R14jYxTywT94l1YgPT5EuTL02+NPnS5EuT7z204J8+cg8t3Hy9IvtVH6xejRFYgBV4tdur0Fd9q55AAXbg1W6LP7orAgdeARhIwAKswAZkoAA7EG4Vbg1uDW7Ndf2heFQXfw4eyuWKXy/BCCRgAVZgAzLQL7I5dqACLdFD+b4GD+WBBViBDchAAeKGRBPvGO5+aXcMD77bil/GHcODBaxH5ECvogi8RmL97XmftDawARkokRm9iiIw85pXUQy0A0jAAqzABmSgADsQbpZuXnEReD+K64L7CK2b68Tz3+GJZeI+sU5s4HvUbjBNPPmWybdMvmXyLZNvmXzL5Fsm3zr51sm3Tr518q2Tb5186+RbJ986+dbJt02+bfJtk2+bfNvk2ybfNvm2ybdNvm3y5cmXJ1+efHny5cmXJ1+efHny5cmXJ1+ZfGXylclXJl+ZfGXylclXJl+ZfGXy7ZNvn3z75Nsn3z759sm3T7598u2Tb598dfLVyVcnX518dfLVyVcnX518dfLVydcmX5t8bfK1ydcmX5t8bfK1ydcmX4PvKLkYTBOXievEbWKeWCbuE+vEky9NvjT5TvlKp3ylU77SKV/plK90ylc65Sud8pVO+UqnfKVTvtIpX+mUr3TKVzrlK53ylU75Sqd8pVO+0ilf6ZSvdMpXOuUrnfKVTvlKp3ylU77SKV/plK90ylc65Sud8pVO+UqnfKVTvtIpX+mUr3TKVzrlK53ylU75Sqd8pVO+0ilf6ZSvdMpXOuUrnfKVTvlKp3ylU77SKV/plK90ylc65Sud8pVO+UpHvrq6Cjry1c00cZm4Ttwm5oll4j6xTjz56uSrk69Ovjr56uSrk69Ovjr56uQ78sz1+eyVI907ol45EmiJdAAJWID+KdgdG9A/Bd2CBOhu5qjAy80n+vyUt0ACXm4+U2f+5T/wcvM5O99tKPBy85knLzgJvNx8Hs8LTgb6l/9Ad2PHAnQ3v03/8h/obn6b/uU/0N38Nv3Lf6Al+pe/z92Zf/kPvNx8Zs0rUgIvN5+f84qUwMvNZ9e9IiVQgZebz0V5RUrg5eZzRl6REliBDchAAXagAi3ROwwD4SZwE7gJ3ARuAjeBm8BN4Nbh1uHW4dbh1uHW4dbh1uHW4dbh5r0Nnw/z6pXAAqzABmSgADtQgZZocDO4GdwMbgY3g5vBzcLNvHqlX9Nz5nUq/ZqTM69T6deEmXmdSqAAO1CBluj5YSABC7AC4UZwI7gR3AhuBLcCtwK3ArcCtwK3ArcCN88P11yU+e5IgZbomWCgK6ijADtQgZboMT+QgAVYgQ3obuYowA5UoCV6zA8kYAFW4OUm3h485gcKsAMVaIke8wMJeLmJNy6P+YENyEABdqACLdFjXvx385gfWIAV2IAMFGAHKtASFW4KN4Wbwk3hpnBTuCncFG4KN4Obwc1jXrz1ecwPbMAe6AVE/RpQNK8fCizACmxABgqwAxVoiR7z11Cd+T5IgZfbNYhjXlfUr7Ea87KiwMvtmoU0LyoK7EAFWqLH/EACFmAFNiDcCtwK3ArcCtwq3CrcKtwq3CrcKtw8P3R/UJ4fBirQEj0/DCRgAVZgAzLQ3cyxAxVoiZ4fBhLwUlD/3TzmByrQEj3mBxLwul7139hj/kaPzWuq1LyWKLAlerNXf2be7AcWoP8zb+De7AcyUIAdqEAL9G2DAglYgA3oYuqoQEv0CLjmaM2rjQILsAIbkIEC7EAFWmKBm7f1az7MfP+ffs0Im1cbBQqwAxVoid7WB/r7ojgWYAU2IAMF2IGa6E35mq41PzIusAEZKMAOVKAl3lNbNxIQbgw33+jr8Gfm50sNFGAHKtASffuvgQQswAqEm8BN4CZwE7gJ3DrcOtw63DrcOtw63Hz7r8N/WN/+a6Am+kZfA13Bf6x7gPxGAXagAi3Rt/8aSMACrEBXqI4W6HVQga7QHAuwAhuQgQLsQAVaom/pNRAW9wgU3+w956umzOo9AjXYwPcI1GCa+K7ZFee7Nrc7y8R9Yp3YwPdI02Ca+NZX5zpxm5gnlon7xDrx7XtlmHqPNA2micvEdeI2MU8sE98Tnoezge/RpcE0cZm4Ttwm5oll4j7x5MuT7z265B+s9R5dGlwmrhO3iXlimXj6TWX6TWX6Tfv0m46J3+J8X6cHwD2q69zuUd3BNHHJttpGXfjNbWKeWCbuE+vEBr5HdQfTxJMvTb40+dLkO8VUu+PI77fdcST+3+94GVxxj/eI7WCeWCa+f2t21okNfMeRf1K3O44Gl4kn3zr51sm3Tr53HA3Wiaffrk2/XZt+uzuOBk++bXj9r3/42/m3//Nv17+Rqyr4+gc31IAWwAES0AM0wAZcwXZDKHMocyhzKLMrn8mBJaAHaIANkCOAAkpADWgBoSyhLKEsoSyh3EO5h3IP5R7KPZR7KPdQ9nop38VDA2yAV0rdKysCSkANaAEcIAGhrKGsoWyhbKFsoWyhbH7NV27kAAnoARpgA7wXJ9cgjnfX5PrE8t7aIE2yIC9uuomSSlJNakmclB6UHpQelB4lPUp6lPQo6VHSo6RHSY+SHsU96kUWVI8kSipJnOT/tl3k//ZMAd7JGkRJJakmtSROkqSepEnpwenB6cHpwenB6cHpwenB6cHpwekh6SHpIekh6SHpIekh6SHpIekh6dHTo6dHT4+eHj09enr09Ojp0dOjp4emh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh4WH9ygHUZJ79ItqUkviJEnqSZpkQXf8OlFSelB6UHpQelB6UHpQelB6lPTIyCsZeSUjr2TklYw87yHK9RHpXcFBPUmTLMij8foM871hB5WkS+/6oPI+4iBOkqSepEkW5NF4EyWVpPTg9PBovD5Oyh2N7aKepEkWdEejEyWVpJrUkjgpPSQ9JD0kPXp69PTo6dHTo6dHT4+eHj09enr09ND00PTQ9ND00PTQ9ND00PTQ9ND0sPSw9LD0sPSw9LD0sPSw9LD0sPCox5FESSWpJrUkTgpl7xuKOFGStxy5qCa1JG85/SJJ6kmaZEEeb1fFp/cbB10eV1WnL6wZdHlclZLejxx0eVzjrd6HHKRJl8c1BOu9x0GUVJJqUkviJElyD75IkyzII/kmSipJNaklcZIkpYdH8jWG6n3EmzySb6KkklSTWlJ6cHp4JF+T394jHGRBHsk3UVJJqkktiZPc4/oFPZJvujyu5S3e97vJI/mmy+NaxeILdAbVpJbESZLUkzTJgjySb0oPTQ9ND00PTQ9ND00PTQ9ND0sPSw9LD0sPSw9LD0sPSw9LDwsP7/UOoqSSVJNaEidJUk/SpPSg9KD0oPTwOL/WFHnP9iaJmmNfFDKIkyQp6o19QcggC/JprJui+tcXgwyqSS2JkySpJ2lS1Bj7IpBB6aHpoemh6eEzVFf5sS/p8ApdX8bhpcO+imNQS+IkSepJmhRFxb456CBKKklRUOwLOgZxkiT1JE2yIDqSKOmudqkXCvCujbmsR4mZoyWieIxR58Uo8+I6/YUGZKAAO1CBWe/EKO9iVHcxirsYtV2M0i5GZRejsItR18Uo62JUdTGKuhg1XYySLkZFF6Ogi1HPxSjnYlRzMYq5GLVcjFIuRiUXo5CLUcfFKONiVHExirgYNVyMEi5GxSmj4JRRb8ooN2VUmzKKTRm1poxSU0alKaPQlFFnyigzZVSZMopMGTWmjBJTRoUpo8CUUV/KKC9lVJcyiksZtaWM0lJGZSmjsJRRV8ooK2VUlTKKShk1pYKSUkFFqaCgVFBPKignFVSTCopJBbWkglJSQSWpoJBUUEcqKCMVVJEKikgFNaSCElJBBamggFRQPyooHxVUjwqKRwXhLygdFVSOCgpHBXWjgrJRQdWooGhUkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEvEstBULOtb+3EACViAFdiADBRgByoQbgQ3ghvBjeBGcCO4EdwIbiMT6DlEX64heu9GXZWt3oty4AAJ6AEacH2EXpWv3n9yuD5Br1JX7z05XMpXmav3nRwu5VrGUL9DD7iUax1D/Rd4r6m2MdTvUAJcmcdQv4Mryxjqd+gBrtzHUP8F3ldycOUY6q8x1F9jqN/PiuYACfDB7SOG+o8Y6j9iqJ9iqJ9iqJ9iqL/EUH+Jof4SQ/11DPU7aIArtzHU70ABrsxjqL/x+YPW6wf1Hvz1HewdeAf/1a5Raf/VriEv/9WuaZqW/4T6+Atk539n/+/+9/v5P8X/pwvK+T97Tu5cB2X4L16uC9Drv3tX/qqO8Z78VQXjHXkHCigBNaAFcIB3g2w0PwcNuJSvChJvfg4UUAJqQAvgAAnoARoQyt78rroSb34OJaAGtAAOkIAe4MplNL8LvPk5UEAJqAEtwJXraH4OPUADbIA3v/ussQBXbqP5Obgyj+bnIAGu3Efz87OvbIA3P98igAJKwNXrOcZMU/e9A64+z1HumaYbesDV4fFNBa7+jhctHAFXb+da2eidNoca4MpyzzT1a0cB77Bd+wl4f81BA1zZZ5q8n3pcdGmTzzmVpJrUkjhJhjd5b83pXpBbxzzPIE2yIC9JojbmeQaVpJrUktz38vBipJt6kia5h4z5oEGU5B59zAcNakmcJEk9SYPGF1Adkz+B99umjemfwPtt087Qtwj9fm3ScD+Mcof+DRRQAvwiyzVXfCALXemF/po8/mvy+K/J43/4a/LY6a/J478mj/+aPP5r8vgf/5o8Tvpr8vivyeO/Jo//mjz+a/L4r8njvyaPHf+aPHb8a/J44F+Txzf+NXl841+Txzf+NXns+Nfk8VuTx+Szx76VOF3j/3RPPvrcsf/vFv//82e7/rfPKPoW7L6jjwT0AA2wAb7xugMFlIAa0AJC2ULZQtlC2ULZp4YGUVJJcvU2Rpn9hAu6D+/gMco8yILukztkjB774RZ0n8XRx+jxIA26D9fQMQI8qCdpknvYGAEeREkl6brma2Tdp5D8EAufQhqkSRbk+6PfdKn4yLNvaO50n6BRxzitH2lB9/kZbYzTDnJlHuO0nOO0nOO0nOO0nGOyfsCFj7/6QQo+/nrTfaxGH+Ovg0pSjau6j9SoY/x1kCT1JE2yoPuIjTrGXwe5no6x1kGS1JNcz8YYqh9F4WOogzhJknqSJtkgH0P18yp8DHVQSXK9MsZL/QSL+xiZa13ofYpMjpdyjpdyjpdyjpdyjpeedMWjT+n70/bj9SigBNSAFsABfi39nl66QQNsgD9j3x6aAvxf2Qj5PqaObrABHvJ9TB3dUAJqwHU911iQP2wHCXDlMkLewQbcId85Qv6mklSTWhInSVJPcguJNHDtZHKngZv831qkgZt6kiZZ0H16wtU4/FiSm1oSJ0lST9IkC/J0oRTp4qaSVJNakiuXSBxOniSuHVJ8msgPkPBpokGcJEk9SZMsyI9JuImS/Ko8hbjH9fz8iISbOEmSepImWZCnn5tc73q693EHRySdqzLjTjpXkcWddG6ipJJ0qVgmHcukY5l0rsqKO+ncpEkW5AFxEyWVJPfgSEQ3cZJ7SCSimzTJgjx8bqKkkuQePRLWTZzkHhoJ6yZNskF3wrqJkkqSe9iY9BnESdfg1EEjifnpEvekz9FGEvOjI+5Jn5soqSRdg1NHTvpcRR/3pM9V9XFP+tzUkzTJK5woJn28VsEHocknfUpSTWpJ7nElbR+EvqknaZKNtlbuA0+cKKkk1aSWxEmS1IN8wPmqGLmnjm4qSTXJr5lj6ugmSepJmmRBPuB8EyW5x1XhRV765bnqqvrzVOXQAjhAAnqABtgAfz4OFBDKNZRrKNdQrqFcQ7mGcg1lz1t1FIZx1CVy1CXecClHXeINEtADNMAGeAarozDshhJQA0KZQ5lDmUOZQ5lDWULZU9RVFenZ6CqG9BRUR/UgXzWQnmyu+kbPNVddoqca35DzCKCAElADWgAH+BX2+CKPt3KLt3KLt3KLt3KLt3KLt7KDf9jGW7nFW9lBA1w538o3UVJJqkktiZMkqY/ndL+Vb/LH4V0P/avN/tVm/3/WZu96ukvrqsrzpkrRVCmaKkVTpWiqFE2VoqlSNFWKpkrRVCmaKkVTpWyqNZpqjaZao6nW0VQdKKAE1IAWwAGh3EK5hXILZQ5lDmUOZQ5lDmUOZQ5lDmUOZW+q1xSLN1UHCmgB/q94tGIHG+Cfhg4UUAJqQAvgABngzdk3mS4BNcD/VR/N2UECeoAG2ABv1w4UUAJqQAiOg3Wlj5YX2IEKtMR7/OhGAhZgBTYg3O7xI9HR7QlUoCXeY9E3ErAAK7ABGQi3ArcCt7EJko1eDvnhQ+PI3BsVaIljJNnHSAhYgBXYgAwUYAcq0BIZbgw3hhvDjeHGcBsjyWV0kQbeY8Y+WnOPGeeATGAFNiADXfces/HrzaGaQAIWYAU2IANvXR2dp0AFWuI9OnwjAQvwdrPRhwpkoAA7UIGWeI8O33g3xGP0oAIbkIEC7EAFWmAZG6MdoycVWIAVeLvFkFCgADtQgZY4QppGn+r+AQoVYAXmj1VGbJbRJbo3+irY16xgW7OCXc3K2BywjX5RoCXWA0jAAqzABmSgAOFW4Vbh1uDW4DZ2Liujw3Rv4FbuML1R84bGjn91dJACCXj/bt5bqsAGvB+U/MNdYRfYgXBjuAncBG5jkz9H/CyCn0Xwswh+lnFgnSPcxhF112dHOWIUn4svEbsr8f3TYFTZ39ADNMA/Oq7q/VJi7RCfXcbzP/zrv/9f//Qf//Lv//Zf/uO///M/X/+/+A//42//+H/859/+2z/993/+t//42z/+2//813/9h7/9v//0r//T/9L/+G//9G/+53/8038//79nFPzzv/3f55+n4P/zL//6zxf9r3/Avz6+/6fFriEH/9f1fNQpYH1XoXruGwrWU+H8FNyWoGuM45Y4A+Fbifq9BPlAoUucKbtMEu2DRPteol3DbK7AvmJsCLS+fQ1aQuFMuPrtNcj3EuwlafdF3HNDtwTTtkJv8XOcY7HtOwVdNAm+RnRc4QxB+k7BvldQjpvQjiZ1fmh8EKBVs6Sr53Jfw/nCT41WPkrQQkLRsL8VWD9IwoPU7x4DLRtEj9/ifCfWbxsELVrl+RGUDfscrP/2MtoqxtXyUdTj+8uQ1WX0lpdB063op1+kf6/ho5Euca+UDIX9O6n+4r3v5Pxg/v5OFo3z/OYu+auc3zLzz/Ix1Mvx/vMo9PbzWN3L+cUTjfTsHxzt+3upq2C7PoVHsOmUfvXjUy2rNuZLGG+NXtBM5Rf3UlXzXlpb/C6Ldnq+3OPHPV/uUxo/7+uDRl+9jopmK+NZ49N1LJJorT1barX6vcbqOkrjfC3q99dRF+20WV4HH4d9q7H+ZeRAK+sf4u7TlZRV7Fom5DL/Mp81Vi3Vq6RHKyP7XmPVUssR2fCc0+ivabSar8im37fUumipvrz9jn7BVVT5GDF10T4M8XJMD+OLxKKZSsmEKkUXl7FqHir5NC5u36usftreWv607fvmsWyoZ9TFQz3nbrl8q9LK6gWhnPdzxsnxTTJr9Y+mw3bkp+A5wNK+b6hXkviDr5jmq0vHdciisbdFUz27oXEhZ99zTmUfvwmbvvtMl1fRKNNHa8e3V7H8BKkyJXb59hOEFy/+Kvgg63Vu67Kt0Wo+jVZZvteo73/EcPujH3XtyA5k+xD57Rca6IS21a+yaB2EJjp9FJb+8cOBFy1Usxur1b5XsFVKj9sw+15h+ST4yPapQt93Qmn1wtdsF7XOH5Uf40RWr3sf+bivg/V4SaOV7NSfbbx8r9Heb+PydhZdPtGanclzyLl+fyd9+eGC7FW/fxrL1qH4LLXSXos1q/lZavp9r7Yf78Zap3djrZc/GmtmcRHt/Fm/fxLLjlPBW+1DnHxsn33RPpVqPoxz4PslDfMZoPtxHGbfa/T3Y63rn3yfNMpRl1ZIXmrjDR/4rS+GTJbjRwfGj6Yf5dPAzWpYtNRMobXrt8OiWpefGkd+atj3TWOpoZLXoUZva9hRXtQ4amrQ96Gi/d20ofpu2lgqSEbJMT2KLxKrR2GEPP6hb/DxURi9Pda8lNhr42uJAompO/4ria0hb+Nlh17QM3hRIkeNTgl5SYJzNO+cB/v+F1mmz/xIOAdt2isSbPnVtZTgt6cQ6Fi+4OMX0WaLSQR6fx6ivj8RcbQ3ZyLWV3EYRminOPuisXgfqcZPYlQWD6Mv5zNyDI9Up5sp1l5sHN9PrByLflKXkOj928fxQ87Ymt1ZzTDtJuGlSDtK9nEOtYXI8i2PCVSZP1c+TV6ur4QyB56DC21xJfzu+5VWU02b3+XrW8HgCNHqocrbr+n1hQh+3T5PA3y+kNVc0+YzXU01bT7TpcQTj0MzYs5h89XjaG/G/vIyzgSUXz7Ei5a+mmmqxXKWqE6vSfmFRM0+V63T6PtnCV219LyKs7PzrcTu0yiLT/O1SM9hJ+59EXF1NWXfc3TiRP3uZlYS2/PUq7mIzT7oUiJnM2T6avidhGCCSBcSq6fBlHMIPA/kafnNI8XYFc+j1V9EFu2UbBpTtGKvtVQt8XHLxvp9I2vrGdGM/emJnM3towS9PbuzugpGr6fp4ipWEjl1x7q4keUDNYv3glSm10JfWqds66/mD6k5PnDO4C9Scnu7c0/t7d79WuKBF6WgnE1k9S3Gy+i3HDA5ecqGv4i58x1L+bpdfZ/ycjpUGIn9247tDxroA+n33dKlRsXcfy3fDzb8pHG8rdEou4StHK9pVHx/NFpo2FZX/0wF/SWNzRGH3etYayyfac3ftvH3Yw5S338emxpv3EufpjP1bY05Lf+ujZXs4TItnsfqzY8RaOptMfKwvJCOMZS5H/X5QlZzTrs/7kpjt7FvXsfrDQTDF3WVDFczT+cAC8pc5kGDX/0wWhrmBr5vqV1WQyDZKSyL9rGceUIyPL/cEPznvMkvrqMe2VfXxeNYv3Ir+h/G334b6rEWKZOIvCKy2TH86Wb2rmPVi9EeT/WcSPt+0oZ0NYJ6oGaP5mGUz+Nby/5UTnfIh2LK33TJ8KWri0KAt2c79O2ZCn17okLfnqcgo/cz6XIQd3Om4v1JhveH5lcj4ptD8yZPDM1vr/z4PpmvZo/2RuceWEWzXPGg+Wor9mH891NF+2r2aG+Aby2xNcBXVlM/m3l8+TDyI67YopahHG+P65fj7XH9tcRm17q/PTDX3x6XkweG5eT9UblC5YFRuVXfrVd8VU+XsS1wTsLkSNbJfR6G+rRYYjXztBmuS4m9cF01jr1wXc327A2CL9cVbTXxpcJWE1+uj9ps4us1VptNfLW4abeJLxdIlZwQKKXMdeNtX8M3UxnvVv5eY70Qp1DW4pcyq3yOlPW6oq1IWUrsRUqxt19s+49DFoljuWIMn8Myz0l+XjG2rdHf15jHSX6zcs13RLh/lkO+X+1VKi8/JacvycXStdXqJnxzaKMXJTiSkHJ/UaLlVczTRS9KSH3tgRbfBCpCv7wqgtfCvd3cKz+tIWBs8busVhRWyd7KtY7lJY2zD4vFK4smtrmy8RwiXfy6u6s0Vxq7K077Im7bu72m5VV0VNTrschivHikVvNVaeeg3Hcfc2W5tqlibVOdt4P49ER58Vl6vp9QMTfPKH7WWL33aVo/dw516rd3I8uuU4476YeX9i/yuman5UT5VmP9puOs0aAPFZVf3nSrFU6G1ZHHPNDwqX+/XPlKlO1stSixrKZ7NGedP5Rxf2mqq4VSGLs+Dl38MKuvXOx9IkbfN/fVEqVz+BtLL6R8HzKrX/fIsoazT75qZavRfJMcATdbfcbw+wlA5P0EsFzqtJkAlvNO2wlg+dvUfNudcwzltcb6UcS+FVkvW8/NAM4v8++//Nca+VhLXS3jX2nULKouHzY2+KyxqtPI/r7qa+vWz7neXJ/Tpjv5jcY52JnzgaTtNY2WExM8T8L/SsNPfB5zAlM393ca2LxoHvz9nUZ2HljL98/DG9H3byqMydOH2P2tDNLZGzJ12h/l7BG9LoMtY+ox9QO+yqy+vgtmbU8WWsgsRw9ZsSXQPOj2a5l87bAcx8s3hd0fzptaXc1ymwHFHiNNqbwsw5gI1q4v/+DTCmgqi6ux1fBqowN7J1Djl2VkklF6WQbB0K5BtO9l+JFf6geZ3Ejh+qX6yzLP/ODY8+dkfjWTz4tK+msahrJO09feBnLk20CIXrsOoRz4EFpkvLWGopB69UxX5WWP7FDTMRqtnelFFUU0q9LxoopN12J1cS3LYsiOjZAW3cG1hmHHnQ9Lg3+hoQ3DDvz91+C6c2sFw7hmiy2ZVnNZe0X7a4mtiZO1xNbMyQ/bD+G9TDZ9zH1qHsu1S1gDb/Tt+PxaomSRu5Wir4zPVyZsx8SLTstaRSyfR+206PqU491Jj7XE1qRHLeWPTnp8fBzl5YeKb8hTRV5U6RWf150Xeej9lVT1/ZVU9YGVVPuPYzEf9dNPo5PKYhMzfjeVLRX2yhyWH+M1KypPXr5i2rsT4kuJMxti/LRLe1GkY1+4k+1FkRyoP1nllXbWGjQal+93/WzLzVoe2ditGIaUPowY8msa87j0bzQYw2M8R94vNOqR4+Nn/69+q8Hvr5Jd7ux2ZBXe2Wecf9xf7A5H2Dnr/Ib4VqO2t+sE1hJ7ebm9XSewfBgFm/mUD/vofLqMpYgaphvnMvUvImXVQdyolVpfBrqHzeYZ/l/dC2ZP+CjtZZEctjyaviySPebjxV0Mt3dCbO++LpcKW6/L5YzlZsnUekfHvZKpKk9UBa420MK7smn5vui0rua09opO63JGa6vodC2xWXS6ehqlYImLvFbT3GqubG8f1sl8eaKr0ZQcVZdpr7nyaV5tOVJ2VHTW5xbWPjaO5c57e0+0r+uRo33psVgvvNTwA0Rvjd7LaxqW1R/nC4Je0jj7+PGZbEfh7zVWU/u72/fpu0lwqbCVBJcLuTaT4Hobws0kuGznm0lwtcLu/GjKJZilf7/5Xl0toKKeLezquqTI56KNpQbW+Ze5XOKLxnIT1K0FO0uNzQU7P9xLfgGVo5bvNVZ9/a0Vh3U509SN8LvY9Ir7vOBmfSVbaw6XD6TQkV2fMyW/9FALYUN7mtLHZw2rbz9UW/WON5dxrq9j65Eu09jWSsG1ws5CwWWB0947crkFc8uVVHVe6PerbZwt979rH2pofrWNMzTKi9s4b28F/faYmLw9JrYs09p8v623tN57v7XlXn6b7zdZrrp+YFdr7ITzsTj6NxrY+uEc/Pl+r/FGb28o3ejtHaXXEpthv3yiObFe2Mriaazm1Xf3jlm/qVPC5PvNxttqQdXm1jE/aGxtHbPU2Nw65ieN422Nva1j1hp7W8e08v5WKUuNzU/K3etYaqyf6dbWMW219Gb7efQ/fS9bW8dsayy2jvmhjW1tHdNWR0btbh2zvpC9rWPaatZm98et7f3GvnkdrzeQva1j2nI3v82tY9YXsrd1TFtu5rfV52iN3u9zrK9jq8/x0xt3a+uY1tpaZGfLlqXI3ozLjzezdx2r17bi/AOS7/svbXlq1ObWMcvP/q3+4Fphqz/Y3r2GtcLONawnWbMy4UT7Xy9N1PY6nfN2vKYhmDAWq69paBbAFDv4JY1z4infcUf5/nnU1t6fdV6KnG0i+7bavy0ZW0pYDiOJlf6aBHrYxt8mju3W0V5sYQUaddE6Vn3svbnvtcTW3HcT+aMSm8l83QP7u/U3v/tNsPKo26uZY7qOVzVwJMSJr2q0sqXx9hulvf1G+aHCM8eirJQXi0Sz4u3EbyuilhWzW4/iB4mtZ7GsY84lmOXjplO/qYXOj9FzlKG/qIGjmLW/eh1YkK59cUjuuta9oUp9ruz+ZcX8rLJYfvWTSoNK/35NRFutd9pc7duWp0ftrfb9of6/YHsNmypvf/lMcCy82vHyWoT5WurLKui4qLXFSsrlulKMA9fV4d/LfXqyKKCUeTXCpz12mr3/5rf33/wmf1Ricyuq1fOsKKqs/Vg8z3f3B1teRcO3Q/uwjPvT2a7H+2v9+Xhgrf9yF6iCHRbnUo9f7SQ17775/fMoy10pNrejWors9TrWElu9jh8kdnody+3Otj5B1go7XyDLXQX3dqft717DahALBWZTxrkWQ24L5PToXFVaZVcAGyXxhwPbdFega87Q9g/n2zZ7SaLKtxJMq7KOTL3z2Hf5PFqzlMhzYXkaWvgisVqw1HtW+Pd5hd/5pfpJZLWhD+MorUni+Cyx2s+HMF5zTqO9KIKuxvmeLy+K9CzaKfO5rr8TqTk1el4TvXo7GH+qx/e3s9qu6dBcoUfz1Pl+Y8cyAZrPHrbtayg5a/7h4OFfCGDAZy5l+IUAY0zSXhFonGP38yZxv7iC/MIp06L6XwjUrP/8sCvLJwFe7ez2du6erqEei2vo739jrWaWNr+xjp18VecuwC/aQ1ZNtfZSTDRqf29Sal9AJKeTTvx+hfhKAmfiSu/HKxL9yPvoR5WXrsKyl/qqRD9yH4J+9JeexZno80Zqee0qaq4f7HWxs8OuxGIoZCmhkDB9SaLl4Hhvtb4kodn/6CqvSbRch3CivSQhOXjZpbz2i3BWwPW5UOo3Ej0nwru+FqkfbuRVCWwfKf21doGTvHun9tpV5Aq5U4JfuwrGPpjc3v5F6PvWybJcRrW7q8wyTvJb89W2cRVXYC+ISi9dBwljyY7wa6nn2qMdtZ6sL4oIak6lH/01kY7tQq7X3IsiWat5sr34YBW/jijRi1cyPdjVdko+kPatzPbeYrw8E2p7b7EfZfb2Fvvppjb3FuP1eqDdHat+knk/KZw/N08NT15teFlRfzK/GEc2VW/P9bm/E8EuXmf+f+lVTp2wAWqn174Tz3+IHQP73Jv9pUiHiC1eHw9MNfEDU03Lmyn5AX8xv/ZEyrTpRXn1sZaK36a0+qKITFfyalOrB1Zt1VJeFGmTCL/4YGudRV5s9HWqkK366jPpk4i9+BO3qbG18uJP3I5ZpL3YTrDb7tnH+f7XkWN5+EjNbThOXrSUn2Sw80yri63n5ChPvHt+upqcsTl50Xn7zU29IZN15tf+QKtHLP87no3hptrRnripN2S8djpkFj11oeN/w7PBqYMnN37kptqLifM4sJfTcbz4/W/YRa2v9hde9s42dxhfaOCgOp1nx/v2HED+LvPU56d/L6R/+C5yBxadt5L7dBWrqap5bWZ9TUEx/akvKhwYrHzht+itYmxtnk7Zn485Z8dyWp6mPXF/IzGXGOhLs0I1c0ajuWK+bY+AV8xGzFuE8PZEcHaSWF4TyE8ankvgfiGQm6N+WNn6ksA0MvALgXk+/3hJALsAW3tFoOfSiT7PS70kMOeFXwhgh5bjpVvAlr362i1ojkDovALtJQF+6We0fGfaaw/RUKPbXmqJ2OPGRN4U6C/9jHTkJC0d8tJjVCO8aqcRbir7Eji4wo55n+LyeSOD1QmROC+KP+xc9Ck/L0X40NwlnMqxELHVvHW+tksv3603W18HVRS6iLx2Mx/mKuV4VSTfnDKfgPE7EdQry4fS/v13p1F2YY2mgplfNLMPElNP+ksz4+WB0FNR7rQ9Xyu/eRyEx1Ff/WF0qmyzRXtf7Yay+8MsRfYKYn+4GewAMq9Z/V3wlhzu5NIWQbOaotorU15LbNUYi/AflXjgV2FI8IdTUb880FU/iHHuOH84DP74jQgGoT/svfErEZR/nFNt7QEReflKtE9DaS+K4Fwh6nN34LPIckbJDJdi8wFnn7fbWsq0nhuhtXmdzxeR5Q2p5GDIXLP85YbWSQCnLX04z+tzm11tM1WmY9Lo2xS/3Khqq4R7LbFVwv2DxE4J96rTixGIou21ut+pDGNK7OdoxIfb0FXrUhwodrwokWV4PJ8j/Eli2eXCbdjiGpZfqChgkykTVvr0/aFvN01dZ7CCNPjiZXzIYHP9xK9EOhsyWHtVxPBBNn2y/05EkdXnbapeF5nrJ76ILBtJvvlbp4XIaolSKThNtMzzaL8UyXWXRexFkXpMe9DTqyIF66X45SvB8vU6bXj1O5GGfDiP4f1SJLc3KHNp9G9FsuK+9VcfLNZTnN93r14J54qKawnVyyLT4qtXWyznqP/5FdBeFBGazovXl0Vwqri8+kyQY8/469+KLMd78/0/l0y37dce4QOA5pG+yq9JTEtufiOBgS6ah8p+J1Eg0V+TaNh3r710I5xjZfxhXxN6QeDDJi/bAnvHeW3OKNFLAlubfS4H8HeW9G3OALz0DKiiTqxO50bqx4bQC787l7OU2JvNWUtszeesJbZmdHYlFnM6S4m9WZ21xNa8zlJib2ZnV2IxLbGW2JrdWUrsze+sJbZmeHYl+MUfdW+WZy2xNc+zltia6dmV6C/+qA/M9hBWcVGb1hJ/znzLnbkoCwIqzctn5dNZBKt9euqR+9fWYy5a/LSvhc+BfCvSc0bg2r5xIbK8kvz+PQeMdSGiq5DNAc5zlmVatvppSXFfTTydA15Y2zwfZ8z1FyI1t0o+kV8VyWIt/lA++UVktWbxIDyTqRf75ZmsTu7ZXavdV1v87a3V7rxoJbtrtdcim2u11yKba7XXMYwFNLVOBaVfY3i5JQz2+atTcdEXEVmWMuRqbT2mFRFffuC1yGb4yfFAe5Un2qu8317lifYqT7RX+ePtteUXe21Tavza1Gz14sqdyOp86jx9Orqm/1DQnWOe81f7p5dFp70uWH1NYaeo7weFjaK+H34Swu7gU0Hdl59kdcYTH4Sqj9a//0lWPTHDNOcxT4J/1lgN26ILc47tHw9o1G819h/q4ttKlx95B8qJ5137Pl3I6pync/wNW2rb9w9EV9X5h2HVHM0L3d9R+fYHXj8R3fnsXeaxze1Nfsioe9ubrL8Adq+En7iS9Xdirinh+Qvglx+bODGzHfTSuNzml/PxZ69i86t5VSGMAxGn/kyxT/Fiq/4M4U1ZvpVYXUOeTt+mKeOv19Af+AoyffsraLXJ3vZX0FJk9ytoKbL7FbQU2Q389e28vcMSV2xIVqe35W8G4/Oo7jJ9f3w+z0dXC5z2TibS1WlPeycTrSX2TiZavpxsWlv+7bEiSsu+Sx63+aFGi38hwTj1UxYSq827DhwoRNMKpE/lDbo6HUnzjWJUFpex3DMVxzq2aQ/7z0dX7P4m/dvfZNnApwXCcyHT8flnXe7tvVOKvJzzwuTdh9HP4xc30qcKs/L9jZTj7Vhdbbi3GauF/mSsFsKmq/PS8a8PY1W0d+3xERdyTnx8V9j1k0idd0yo34qspqi1YhR2XtP05XaWxzPltL0cBR+B2vc1BPEm8wawv9FgY5S6y/cadbXECwsP67xls/3iOnrJd9u1fdD317Hq9PRpMedcsFY//TCrHc/5+LuTzV8k2p99HtPv0ufdYL48j0VDZcntzlin6p/P17Hah293pHH1aYyBl9apvJJOmxAkyuK90N5Pp+39dNreT6c/pbFpu5XO352VoO2JXPj+8U7rdMo5ql4+1Mp/+W2XJ5BiF4356PTPzXQtgs+ocpSViL0fMD+I7A3NL0V2h+aVy/udUl3NR+11SnU1G7XbKV2LbHZK1yKbndLlW0YP9Bvq928ZXhVF1ywyL60uWis/0VrrVu+D5i0UvtyN0Or3xWE68/kxXy5kdTj0/t0sD4os2Demr25neRDXgZJ1XYnwA7/w6sym7WeyvB2MPHw4bPbr7egTP/ETDXbz40oPfe3DWXrJosI+HbX26sf3vBbgs8ZyX7vtxUxLmd3FTFqXx19OyyzqXKj49VpWy00JEw9U5lM05TfXUvMHotqNFre07NvkAV3nAAl9/w290sBJq42mjSo/a+gDk/W6mp/aHfFfi2zWyvwgsjfqv3wm2x84yg984Kw26dv8wFmtgdn+wFmK7H7gLEV2P3CW/Xmu037I349v2Oq0iEwmdS48+DQuamXVA0a1cJ8P5iz6KXz5mUzSHsgk7f1MYvJAJrH+QCZZiuxmkrXIZiYxeT+T2OpYqN1MYqvN+fYyiR31/UyyFtnMJGuRJ7pKjEYyb5Lw6cvTVtNNDfuOtqLt+zSw7m/h87VKf7W/tRl8/EDH3uiJ1krvt1Z6orXSE62V/nRrxSGIxvx9a6Xlfjx5/grTXGf2ubWu+tNMBBGWhUh5oLWuRLZba3mitZb3W2t5orWWJ1preaK1rvr1xXDkkvH3A1G2+tRrR06ZtGMewP3S1PiB7CpPfNrIE98C9Yn2Wt9vr/WJ9lqfaK/1T7fXipGBc2zs+3EoW01pfRjqmOf4vrRXfSK/PvE1IE98DbQn2mt7v722J9pre6K9tke+BlYzsCVrFs4Jevm+z7fSaDmbzNy+7fNZW+/Lm4vgaN68//jNhXAOArNMK7k/Xwj/ejfYTxXFxvRbhc/7yf4wp70ZdiuR7bBbzSVth92qKHkz7FYb/G2H3VJkN+yWIpthtxbZLPn84Xb2Sj7XWWT3Stb5bPNK6hNXUp+4kvLElZQnroSeuBJ64kqOJ67keOBKfhhP21ud8IPI3rqA9Tj05jP5YUR885msZys2n8laZPOZbNce1u9rD62v9+za2c51eSGV6rSe/fuKLFtN4Ox2+n4Q2ZslN32gcuAHkb3viqXI9nfFE5Na9v6klj0xqWVPTGrZM5NaqydS8jiE+uF45s+N3h4YmVuK7NZSeJXx241+LbLZ6K0+0OiXE1u7jX715tps9KYPNPqlyG6jX4o80+hzuKTWxWqIpUg78nbawd9HDh2rD5xnVPa2qf1BY2uf2p80djaqXf/Au5+N66a2+QH7xMeaPfKxtqzP3P1sXFeKvr/ej1F8P0059v0zF4+eu8Zd/F2V91oC55AdOmW0X0hgQ6qTpy2pfiFhecr3yUIvSeBwwg9Vpr+RyIG0S4JfkDj/2bSqvsi3cb+ay9q9l7XKXuX9sczrG5v+rwS29us/74L/rMbbT4IKtmSeN/0l3V/6WFCEWeb1fq9KyEsSFQsX66GvSeDQ2nnH4N9IcC7WIW6vPYuKlaTzYtSXJV77Ued93yq9JoHzCprIixK4kXlN7G8ksA9s09d+1IYdx/k4XmwXWB5cXvpRW8fM3UsPE02Ty/fPgY7lcKzmLnxFdW4W21eRH37zhM5vbiMrRD7su/MLAcZUTntJILuObPU1gdyE1dp7Ah+2YP3NQ8RmPS/lSsk9P6Tam1fw2s9I2IaRjqmC8hefqYSBPJp3cvyVBL5TSV+7imp47dhrV8E4+H0Oq19JINWy2ms3gi/EWl67kZrpgSq/dCM9S417k1cELI/IMn7pJuz4e1vQ/kYg25R1fvMWXhPgkiewLMZOVgLZpoVeuoLd8ZtVYxJ8gEh/rT32jk057KW+8DlDkFFh5TUJQk+2zOccVHlJgugViWI5iVOP+a1Rtl/+Z4LILs+H3TA+SVxd/kWEZ4AjQeyfcFB6DtqWviiIXklww0EN07iv8ee7WG6r1HLtd5kOFpPP/T9dP9CcE6Npd/2vIqtOOXcct8Dz3jOfh49PndVuPoQjSubtMot9/sTUuuwLCvqC9qpKlQzcNh0i9XdUVndUMhOfMw3f39GqrTRsACNT1c6XtrI8JIgIa1+mOQK2X3xkTP0gmjKA7R/biqO9tE/rJPlzI7F1J7vhOqbw488PxJZNNlvafOY8fU4j9sDy/lPl7fX9p8YDI650rPbx2/0U/eFaNt+7p0p//715jQe++yW21tjtJvxwP5sv8R/aPg62Oz/T5fu2T6tlUtJzfX0v09Ylpp9F6u63+nwptp8O8m7OoYDybTqgY3mkCaYKPqxx+nQdp8qqNAQ7vp4zINOwROFfqFT0os6+h76qIjlQU/uHEusvKqs9Tre2Yjrz+Pt7U50ij6xrP2XKcv5ga2H7T1ezux71h0ezt5j0Khh+f+b+VHlg6v5UeXvu/tR4YDKU/Gvk7dfQWmVzLOFqS2+/QGg9ZbX5Atm9ks6v/j67r2ZaHgqz+2qmVVHD9pOV95/JSuMXvw4/8Hpf5+yt1brnoONqanNzue76Sva2WDqvZFmWu1dbeKq0J3JkfaCm71SR93Nk7U/EYNUnYrDa+zG40tiPn+X9PBI/e+uHz5H65RaWewuIf4ifvV29zktZnqiyV6d4qsgTAdT6EwHU9P0AavZEAPHxRADxA58H/MjnAR+PBNDyeLOGroeuukGrNVXWsaO2TtPdX3pk61VVnC3u5Kk39bVjt+oe+iHvdzj3qXjqa/dwtX3FeaXZaZhPQD8H0z+rrFru5oLx8wN4NY2/uWJ8fS27e+zdH+Pvv+LlgQLmU+WB5YCnCr+foeSBZXinyhMjYCTvj4AtNfYzlDwxArZut5uL2M++7qLd7q5i/+la9jZ2PK+lPfGW748MJfRHhhL6A0MJ/ZGu6mqKbD+G9Hg/hvR4IoaW97MfQ6t4xp7i9OHU4S9vM13tXl3zW6Gdc0Pfj4Dpenu4nXOxfxDZO2L2FFk12s0zZk+V1Qfu5iGzp8oqsdTsw9c6rQ/8pUrrGI0+9FUV1kxy8wHwv1TZPDf3p6e7d3DuOTD4yIiCPTKiYA+MKNgDCz+IltNc26OuS5XdUddyvJ9wlxrbCXf3SpYjjMvfBydfFpm3GP56Je2RJ8sPPFn+w89k9/VejidGwcphDzwTe6S1PTIKtnyTbR6SfE43PNEpK/REp6zQ+52yQg/sSHKq9Aey5Ppatls/PfFxW8oDubY8kmvJ/njr3zy3+byj9V5pOwc3nyLLSaFccXt+kHx7avJa5Lz7fHscpS5EVluKZEthm4vtf3UdDRVT8zqvL9dhf/Y6KNdYFfqwNvR3IvSASK4DeUNkTktl0Ubq8tsAmaBOJQ2/E8EprGeH6hERflWkYNFWay+L4ABmtgdu53WRjttRfV9k7sz9TmReRDYvLvwsspwg24vh9XUIFjmuImc1O7Z3HT+8K/YOlD8vZLnl8NaJ8muRzSPlT5FFet08U/43It8eKv+bJ7sYTSmr87M2j5Wnsjo/S/qBc2LK8aKIZmX6OaEkL4pYNvs+H1/3K5Feskikf1gs/TuR/KI+ReprIme3ADvg2KLd87LjhMrLq+BUnpGxF2+p5qyYzmeZfxFZTYr94pZ+I2OLSFwOjqJscj04uhrrRQlnE/12K9bzhtYnE23to3qqLFcy7JwVf2roE71Ssfd7pf14olfa6YleaX9gwdypUp/ola4mxXZ7pSuN/V7p+oiw7V7pKoA6xZuszTXdXwJoufXgQViPeNA0vfC5mKEsJ5EODOmfD2YuvP8ss5rR2g1EpScCUcv7gajL7T/z0Z496WXj33+002zu734hwgFQ11ReeVVGppJ5Kbz4oZcHwGTTbbT6oXU5VZ6fg2Wl8UDmXy2g2W9wy7O1NhvcavHYfra1R7KtPZBt7ZFsa09k2980/Kqvxg82mTvZvo+fH3I/DtmaP/s/5/66mojaHo6vT5yyde+F9Gbzr0+cbnWqtAeaf31gUmypsd381/fzSH3H2b3PZ8u1fF/fUVdTWoKly1IW3xp1tUxqv4rzh2vJXUGlTisWv17LcjQBX088l2u1XxWU2pHRPB+WTl+vpa1uKC5F2uoHWs6KbS5Bq/REdXilJ6rDK71fHV7JHviOW/48PUtsdfnzrBZsaQ4lmCwa2/I6NB/rvNfq37mO1XitZhyzruK4tAfiePUK09zIUnXaeYO/3M1qEGF39X9dzYdtrv73paLvt/ny/iBCXR2RvD2IUNdnPm8WmNTVsVt7Wxf9cD/b3wb1kW+D+sC3QX3k26A+8W2wjp/dHQTqatHX7g4CtR2rG8rCZ7I+D7bKKynFaJFSVidv9Yr9gBp9fx2nSl02/Gz59GGa4Vcq2GXJypzyv6oszwPMNWznFNqkYvU3KiVnUMs8cvx3VBap1nL9jc1bFX7VWH0Y+NFa9/CBTrUH5+fRr1RyX6BzkvwNlazwtcovq+CObJoh+KWKoU7YlF9XyXfQMZ+t8uodtePDS/U3Ku3APkWHHK+r5KbGR5cn7mj6XvnttWA6lQq/rpKLvqiVB+6IpqndX14LRqFbOV7+jSj3jf6w8fTrd1SmpQy/vJZKWMpQV89FltsnbW5Q8sO1ZH3TOeW9ai/LxVb717JSOTAMffDqDbA8qHP7Q3k1O7X7obyaJ9v/UO7lgdm29bVsf+T2Rz5y+wMfuf2Rj9z+yEfu8suFKwbA5OXvn5YlOacgL1SWi8dy5uOaEEqR/vlLWemJQRp9Yru6qu9vV1f1ie3qqj6xXd36WrbjUJ9YrFv1/cW6S439ONQnFusu2/45n4fBmukt9LXxL7uJWCJoU1/zi8j6oK0cSJuP2eqfh0rXmyxSno3zYaHuL1UqdgRtr6vQpKIvq/C0Oyk9cS399aebs2RlPsHjjWux5dNd9cKxfbbKixo6lWpML48vIm01S7adsttqVmkzZbeDH0jZ7ZAHxhi98PPNNLnU2E6T66eyu7SvrSbJ9p8Kvb8Xza5G51d/493X8vrJ7r6WGz2xVV0jeeDJPrHN3Pp+nnktWx6i+aGq4fMbta3WfPXcwbxP24YX+3w7qymyzcNg1heC83j1Q1nQ8RuNvA7V40UNw9lP8yja3xFZzS5TnhfHJGWR8MsT23i08v42Hq08sSNoK0/sCLq+lu2Uspwm204py2myzZRSyxMpZXk/z6SU6XNnlVKWIoVz8qMIt+/z0mp/xXtd530lZfqVK7fPKqueWMW0RTv695mpLrfxwKbSdV4g8fkTcDVLdkZNlk5+OLT8VyJYqljnuuFfiuDMw0KrK1nVfUnBaQbL21mOEu0trF2K7C6sbavNFfcWof1wHXsLa9tq1PiJ69hcWPuTCD0gsrewdi2yubC28XKT+72FtWuRzYW1vxDhV0X2Ftb+JLK1sHb/dl4X2VtYuy2yWli7FtlcWNtWC742Y3h9HXsLa9tqI8XdXLLM8ozzjVY5bblebDfLL/di3M3y8n52XV/HZpZfzYE9cR27Wf4HEXpAZDPLizyQ5ZdTV7tZfimym+X3RfhVkc0s/4PIXpbfvp3XRTaz/K7IMssvRXazvL6fXdfXsZnlVf5slu81+2vzINDX69AHgm8psht8+yL8qshm8P0gshd827fzushm8O2KLINvKbIbfPb2Pkg/XMdm8Jm9H3yr3njJGs/zxff9z8ur9WC7vXFeLQfb/U5biux+p/Hxdm794Tr2vtP4kD97HZvfaT+J0AMie99pa5HN7zRen92196pYi2y+Kn4hwq+K7L0qfhLZelXs387rInuvim2R1atiLbL5quDydl/rh+vYe1VwKe/nEnq/N87lgTHXpch2li/vZ9fywJgrF/2z17Gb5csDY64/iGxm+fLAmCvXB8Zc1yK7Wb4+MOb6g8hmlq8PjLnu387rIptZvj4w5roW2c3y7f3sWh8Yc+XW/myW3+yNc5MHgm8psht8+yL8qshm8P0gshd827fzushm8O2KLINvKbIbfPz2Dp4/XMdm8PHbowLr0gXJDSpK5+/rH3i5ieFu6QKvzgfbLV3wJ/du6QKvJrR2SxfWIpulCz+I7JUusPADgyVPTGrxE5Na/P6kFj8xqcXvT2rxE5Na/MSkFj8xqcVPTGrxE5Na/MSkFj8xqcVPTGrxE5Na/MSkFj8xqcVPTGrxE5Na/P6kFj8xqcXvT2r9kOU3B0uWkwS7WX4lsp3l7f3sur6OzSxv5c9ex26W/0GEHhDZzPKqD2T51YTWdpZfiuxm+X0RflVkM8v/ILKX5bdv53WRzSy/K7LM8kuRzSwvD0xrra9jL8vLoX82y28Olsh63dZe8K1FNoPvFyL8qshe8P0kshV8+7fzushe8G2LrIJvLbIbfPR2ycAP17EZfKs1W7vBV94vXZDywEICeWJSS56Y1JL3J7XkiUkteX9SS56Y1JInJrXkiUkteWJSS56Y1JInJrXkiUkteWJSS56Y1JInJrXkiUkteWJSS56Y1JL3J7XkiUkteX9S64csv9cbl/bAmOtSZDvLv79M64fr2MzyfPzZ69jN8u2BMdcfRDazfHtgzFX4gTHXtchulucHxlx/ENnM8vzAmOv+7bwuspnl+YEx17XIbpZ/f5nWD9exmeVF/myW3+2NywMLCdYiu8G3L8KvimwGnzywkGD/dl4X2Qy+XZFl8MkDCwmkv10y8MN1bAZff3tUYF260POhFq2L/dWWIqq5N5pReVUkt/k4RV68knqU3BN53vv3i8h6A8nc5Lnwetvq5VRStrTy4TjW36kYtp2z1Tbcsj6QNW7ojGaI8GeJRYNV7K2m5cMuufRZZdViS+5lyaWhzbbyK5Hcz4/rdDtfRFaneH3Y3Xbaie93z4SPfCZ99UxWe8VtP5O1yO4z4befyXI/fS1H7qY07034ZQ97WS/Vyq961oNXT3Z1MI1mMVQ3opdVcnebPme3X6oYNqGcd3H9rUoWVenRj+9V+nLN1tENBxXOz5c/q6yaXMsdiLjV9qJG/kLcTF5rcX5O0v1MzkT3fYvrq+mt1vJQi/ODa95LvP5ChVtmhPPW7EWVrllPeLY4flXFcjexPp+w8dtr6Wj92hcqy8Uw2y1udYbXbotba+y0uNVucZZ736lN3ZXPp4705VZ+uwcZdVrXv2JQavpl9LPGE4d39QcO7+rrw7s2d4vr5YntNPtqnmvzIKP1/ezuONfLE2d89vL+GZ9Lje0d59b3s7vj3Dp+dg8y6qvprt2DjPpye8IPDW6+lO2z0ezIbeJtPjH+S0pZbeXHnIPlzKbfXsepslqqi2Pn61HnU+f4FyqV84TDOh8X90sVyU2h63xs9t9RWa0zyNP8eNaonz+Y6iLRVjUctTMNx3w+bLEv9yaskpt/nzzvZGnts85q6GD3dI8frqZidKh2o9XVrB7N5jmUvT1xxEFvTxxx0Nv7Rxz07e3nlq+y9sQRB2uV7Rdie3/X7d6e2HV790o6v/r7bL+a+YnNYDu/vxnsrsbymfATG8qun8n2632Zs/Pr+MOb7EvO5uXB9Xk82jkOPn1iF/3FlShGM6YBnr9zJasPQXRQS5veqV/zkjxxBniXJ84A7/L+GeBdnjgDvMsTRyB1ef8IpKXGfvxI+9PxY1kdZ1NL+dpqVwd38ZF1enwODL4aPzkzQMchi0tZnpZFeVbox7NXvjTa1cld+wHUnziUo/f3D+Xo/YlDEnqXJwKoP/B50B/5PFjez34ArRJcb+h66KobtDq5y3q2ftPprMQvPTJd78C0d/j2D91DwbhXl8XJ9X211OteVHo/XZlngz8fSt51Oal15Am1xqvX6mq5VzuyZ9eOZosEtbqWeuQYQD10laGWy3m2X/Gria39DLVa9LWfoVbzY7sZarXsaz9D2SMjYPbACJg9MgJmj4yALdstRgHOttcX7dZW542eDSR+Zv0wxPKrGDr/33Et8/v5y7XocTzwltfjiaEEPZ4YStDj/aEEPZ7oqurxxFFIerx/FNJSYzuG1vezH0OreBbNIpxO+v3bTFcLa86ZKJwfPJ1+8nkETNe7G+Kcwzp9cGj9jYifLjRmlaZika8iq0ZLeapZpbnpS/mssvrAPfJQpXpMG3ec/+OzyiqxVBxxXu14VaV1jEZPhWO/VPH1vLeKTOP8v1Tp+elzfmPSSmX5dDOIKrXVHZUnRhS0PDGioOX9EQVdFpLujrrqcpprd9R1rbI76qrlgYRbHkm4m1fS+dXfZ/e8RK1PTPBqff+8xF2N15/J9uu9PjEKppUfeCZPjIKt72f39b5+kxXsQFWnquOvb7L6RKdM2xOdMm3vd8q0lSey5GqWbD9Ltic6iNoe+bhtD+Ta9kiubfzHW3/LL8rapi/Kr62fl8e+ZSXM+aUxF9d9FllOCu0twVuK7C7B09URSXsV8z9cx94SPH1/88P1dWwuwftJhB4Q2VuCtxbZXIKn8sCeHGuRzVVAvxDhV0X2VgH9JLK1Cmj/dl4X2VsFtC2yWgW0FtlcBaTy9uqbH65jbxWQ9rf35PjhXZHP43xXlMW7YjU1xke+zXlePvDlXbESaZaFwnzMLe2LyCK9nk00etntw9qb10Xq9yL7T3Y1mtKXS9/yLXydXLu4n0V7lZ4vUOnleFHEe4m3iM6Fl78SsWz25zWV10R6ySKRXuxlkfyiPkXqayJntyCXRh22aPe67Dih8pJorgJ9S8ZevKWas2JnR23xcJf7IP7ilvSRW1oPjqJscj04uhrrRQlnkymcv4z1rqbFzpvI47JpXt7xZfRuNY2EN3L7cPL952eymtDa75Uav98rtd0dGJa90uUGc9u90uW1bPdKV6d8bfdKbTUpttkrXWrs90qX97PfK10FUM9S9zbXdH8OIDuW87CEA+ePeV/wz8UMtpxEOjCkfz6YaWnfV5lVHUKOMrVG3weiLylZzKDmV0JZacjbCcF/xrcTgq1+5M2EYEQPJASj8kBCWF/LbkIwemKQ1uj9QdqlxnZCWN/PbkL4TRBO8/6/i2VirF0++1LlVRmZFlfI1HH/IrOaE9tNCcsZsc2UsLyOzZRQnvhGsPL+N4KVJ97Lvkj6/TBcLR3bDcOiT4Th8n6eCcOPDb/qy/Fj2VO91qV8L7PagE6UW/YyOyJIfqNhWbovNqWV32m0vA7j7zXWjwQiJxu/+rHSOH/ng+n7atIfvr86xmim1+qX769HpsTskSkxe2BKzB6ZErNHpsTskSkxe2RKzB6YErNHpsTskSmxZb1XaVntWLhOoxqf671sNSUmJX/n83Nl0ff4Yc5ks6r7h2vJnSKkTiuYv4os9y5Fb4rn8s32qwJz75yMcei+KDC31cSY5MJhacsf6IElqbZaPraf41ifyHGrBWS7OW411VBK/sil9FVeWf08PUvudfnzyHodTmQVWTS25XVoPtb58+DvXMdqC0VsOMa6iuPlUQK7cbxc/p/l00ZTWuIvd7MaQcD6jir2rcjqMnAAnZX6kgLW2p8Jp72k0Es2jvkb5zWFaaz4FwoChT5tRPfl51hNYxWvBrqbhTZ95TL8M+G+DOttcRmrOgPquSlE+bDPzOdGvlpTVRQT/KayUnkko/ZHMmp/IKOut07c/VLTJxaRm76/iHypsf+lpk8sAP+h3WYH8Gy3fdXiVioli9D5ah/fqyw3TyyWpex1/mr8qqJPxNAjK8TskRVi9sAKMVuuENv+Kln+QjV72LUuPz1Xk2Fs2HPQbPEtvdxC0es37+avcwVS+82lyGH5GTx/wX69lP5IF2P9cLH3TZvLIL5ejL37XX/X+H17JXu78JTjWC602d2F59RZT+Ju7cLzwy3tdVVOkfZ+UjhV+P2kcKrIu0nh/N/9/eGY838vdwTfWydw/m9798W61th9sW5fSedXn8nmENUPv8/mh085npgOO1X4/d9nU2P5ZJ+YUvvhmWx/PC1zba5qlLka6UuuXW+juL092PJa9gYMylEeGDBYXcfegMF5He8PGJwi/MhbeTV+2DrGIKdu3ect4OyJ5fnnDekf/+CvqB39UP795eGu1obVno229rk2/6vKamx2cw/EtcruHog/qGzugViO1XqqvT0QTw1+4OtrtVvgb76+lrsXbn99LW9p9+vricmwcjwxGXaqvN0lOzUemAw7VeoTX1/t7U071hr7b+bNK1l+IzwxQfjD77OdtdsD1Ynl4OP932dTY/lk+XjkN36gwvGHXLu1d+F5P6ulB5t7F66vZG/vwvNKVt/6mxsbnSr6RI7kB4oTyyHH+zlS6IkYXE2E7cfgah/F3RhcaezHz/J+Homfvb0LzytZHR+yuXfhD/Gzt3fhtQp0+b2/tatROfrxRAB1eiKAenk/gHp9IoD6I0MI/YEhhP5I97+3RwJo9RG4uXfheS2r4aa9vQvLoccDnd0frsU3wxnX0vriWhbNdq+W74f+JS7k7AN9PxZ+XskDmyieKg9soniqPLCJ4vpadjdRPFUe2ETxVHmkP2aP9Mfsgf7YM6M0T2yieKo80B+zR/pjT2yi+EO73dxE8byWBzZR/Ola9jZRLPTEJoqnygObKJ4qD2yieKq8vYniqfHAJoqnygNFtafK20W1a43tGKInNlH84W22uYlioQc2UTxF3t9E8QeRvU0UT5EHNlE8VR7YRPFUeWATxR9UNjdR/EFlcxPFH1Q2N1H86enubaJY6IlNFE+VJ3pm9P4miqfGA5sonioPbH94qrzfM1tq7KfKzSvp/Ooz2R3+pSc2USz0xCaKpwq9//u8v4niD89k+/X+xCaKp8oDbbY+0maf2ETxhzfZ5iaK57U80SmjRybJ6IFJMnpkEobaE50yemCSjB6ZJFvfzzMtbnPjwvNadNm129m48BRZzghtbVy4Fil7GxeePbd3N/n66Tq2Ni48r6P+2evY27jwRxF6QGRr48IfRPY2Lry9vn8fb21c+IPI3saFvxHhV0W2Ni78UWRn48Jf3M7rIlsbF+6LLDYu/EFkb+PCO8TejOH1dWxtXHheh719HU9sXFhouYPi3saFa5HNjQtPkdWmXnsbF/5GpH4v8sTGheelrAaq9jYuLLRaOLa5ceEPInsbF/4gsrdx4Vpkc+PCn0S2Ni5ci2xuXHi+G5e1A5u7/P1Oxl68pb2NC89rkWduSR65pQc2LvxhfHVv48JCq0mx3Y0LT5W3NyU6NR6ZWrAHphbskakFe2RqwR6YWrBHphbsiakFemCzwFLWux9ubhZ4yqyicHf/nZ9kNvccPGVWr/itDcZOjbaccMwXfFlpvL0J6akhD8RyWe6guBfLZbU8ajuWy/FEaW2h90trlxrbsby+n91Y/k3D/36fvx9kdvf5+0lmc5+/8wHL+2FI/f0wJHk/DOmJ6tpS3q+uLeWJ6tpSnqiuLeX96tqlxn4YlvLHw3B3n78fZfb2+TtvSVedsp19/n7Q2Nrn7yeNrdrAHx7J5j5/P33zbG3Qdza4+sB0S6ntiYxQ+f2MUOWJjFD7Exmh6vsZoeoTGaE+sPPnun5nd1O8UlYTYpub4p0idTkev1ku/MO1bG2Kd4qsejCbm+L9UDDsW2vcrf9o3+9Mcl7LarBnbxF1aeslONFsF4uo19exuYi6rJZq7S6iLo/snrhub3uLqNfPZHNjk8KrntjmOtSy3BJvO+fzI50xfqAzxo90xviBzsvuRmzza/3zdaxWjHHW4LHM6/nKZ41leVfeS2WeBiWpfVZZfRvknOeH/Ym+aizXk1PezjHNedbPGqtCmdwu1Kq8fB3Yc3R5HasvfD4yMS6fx/KXyTRfP6SBryqrturJakwCy+qZrJaKnSI5qd2mBPt3VJaDtBl9jeY7+jzUW1ZLxT4U5E5fS1f52yeV9U7e2NBk3gxOP4usFvOV/DrXaw7re5G6mnVp8WzPCRh5QGROBr8TsczTlV4VodzZrs9Vyr8TQb30iatfpyznOPJrq334ifk3jbYaxkHmAogvjXa1UKy3aLN9eo1q+YWEZbO3advBrxLL0dm9+qWyPA1ss35pKbJbv1T07ZqDH65jr36pqP3Z69isX/pJhB4Q2atfWots1i+V5aKuzfqltchm/dIvRPhVkb36pZ9EtuqX9m/ndZG9+qVtkVX90lpks36pHm/XIP5wHXv1S/Xg93PJ6kVhmFOcYu/zm6Iey80O9qqXliK71Ut1NVO0W730C5HvK1vWXwKYrG1t/n0/fwnU5elhhoXa846wpPZZZdXBqLkzu7Xj+w+kulysVLEnWZ1Ldb7cz3KZNmr5j1pfFMFLp86z6b8U+f9o+7dd13Etihb7JZHj/jFBEJynAwQ5QJLX/HssyhZbrbWLk9N27afuVXOzUbdmihyWav7Yta16spoh8PtRIY87vFUjX6jOltWq154JfujH3uhGVmtE3+jH5nBA+jc03z/W6w/92NR8j8936vJMtXvI6MuD+4UfIywb2T7dpX1+ZL5xuov8t/3YHMz/1Ej7QiN7g/l1I7tXr3zhxwjrRjYH879oxN5tZG8w/1MjW4P5/c15v5G9wfx2I6vB/LqRXcvr53aVL/wYQbT+W8uH3M/eCF/sVGtfuPiWjexefPuN2LuNbF58PzSyd/Ftb877jWxefLuNLC++ZSO7F59/Pm5d92Pz4vMvjFtXdxT9fuTf44tvcXhX60nbdxT+hUnXZSPb47TPf+j1Qz82x2mf/9Br3Y/dcZp/YdL1h0Y2x2n+hUlXiS9Muq4b2f2qiC9Muv7QyOZXRXxh0nV/c95vZPOrIr4w6bpuZPerIj+/14pv3I3n57MCa8tv3o2vFrS2Bb164uHmxqz7sSnoOv7bfuwabfWzru0ztT4/U9f92DxT6z8+U3fvKFbvAdv+mlg2svs1sd+IvdvI5tfED43sfU1sb877jWx+Tew2svyaWDayefHp6sdcuxdffH7x6fGxWddrSH5XYKjHoppEl7/BkpqVLagyzfZnI6t6V71/9NT5Dr6/foyvy+WsyNdXxT/q38X0N63kcZ/1CSf9j1a2tyhXW7RqxeY3uUVftbL6dcG/vITyf2xRfGXvxlf27nKL7t/adT4d4JNW4t1W5K5ePxd+321F78c3PE6d/nYr8wZQ/e0t0ruYt3Nx+Zet2P3t0U3l3eso7d4v6cfiClgtce0uUevqR1S7S9S6WsDYXaJeN7K5RP1DI3tL1Cr98wklFfl8QmnZyO79isrHQ9of+rF3v6IS/20/NieUfmqkfaGRvQmldSObt1+q/fM7hXUjm3cKv2jE3m1k707hp0a27hT2N+f9RvbuFLYbWd0prBvZvVP4/ImGP/Rj807h8yca/mD5vQkltS/M+Kt9fPv1Qz82BW353/Zj12irBa7tM9U/P1PX/dg8U/0/PlM3J5R0ucC1+zWxbGT3a2K/EXu3kc2viR8a2fua2N6c9xvZ/JrYbWT5NbFsZPfiWy0a7F589oWLLz436/KOYnOJWuMLRa8aX6gC1Px40eCHfmx+12T/b/ux+12TX1hm08+Xt37ox+bp/vnvtX44UzdHRfmFotdlI9une30+CshvnO6fL2+t+7F775tfKHr9oZHNe9/8xtVbXyh6XTeyO6ipLxS9/tDI5qCmvlD0ur857zeyOaipLxS9rhvZtLwdn9u1vlD0akf9t5bfvKOw9oWi13UjmxffLxqxdxvZu/h+amTr4tvfnPcb2bv4thtZXXzrRnYvvs9/rPVDPzYvvs9/rPXD6s+9bvOIi1VU68vnvL06EngytL25ClVY4/vlam7JPUzju7//RyvLBfd7kNUUN0h/Lrjbci1rPo/iEf/9aSHLRnI+cST/feHfVs8P2/1F7S8aefMXtSb346Ueq5X279UQtlqmkON+NJt0X7ayLOCb70CLVqtWloW8bY49+bvpv1tZzAvk/fS8wjOh//qF8LKNqvvb76Aa/25k/RzMrafk2PI9XZtPyVn2ZPcpOfuNLJ6S80Mje0/JWTey+ZScdSObT8lZnift6PNJ5ro623TVyu6v2k2/UDJg+oWSAdMvlAysG9ksGfihkb2SAbMvlAyYfWG13+zjqdcf+rE342GfL2qt+7E5RWDfePmSWX2+Md+49ft8UeuHM3Vvgs/8C8Uty0a2T3f/eOr1h35snu6f/2pr3Y/NCb6fGmlfaGRvgm/dyO7VG18oblk3sjvHEF8obvmhkc05hvhCccv+5rzfyOYcQ3yhuGXdyK7l83O7xheKW+zzX22tLb87wZdfKBlYN7J78eUXSgZ+aGTz4ssvlAzsb877jWxefPmFkoF1I7sXX30+bs0vlAxYfT5u1S+UDFh9oWTA6gsLsctGdsdpfnzu1vrCQqx//hjCdT92x2n1hYXYHxrZHKfVFxZi/fjCQuy6kc2vil80Yu82svdV8VMjW18V+5vzfiN7XxXbjay+KtaNbH5VePv4XuuHfux9VXj7fFagvlBu48tXb+0K+vOFrR/6sSnorv9tP3aN1v0LZ+rnTyH8oR+bZ2r/j8/UzTsKly+UDKwb2f2a2G/E3m1k82tCvlAysL857zey+TWx28jya0K+UDLwWF39+OKTL5QMuH5s1vUa0njKy+u6qTdXLP/ZSl+1slqBFbtFIFyJ+t067vhh3NWK5qIVX77H6X7Jj/OHwe5/trF8rdvcKwd/GPyrVvo8yo9BQ77bSswBffJd3X+1svqRVpm/rp7iy1Z/2YrcK6il676sVgrssPlKtgMvyPntNt175pNt6nexSnX9SiuQ7S+PdfW7DKhCVn1Zvdiw7rmGdhyyugiWb9xqgrfES+tfaiffbqfbfOPp47J4cyeL2Xz71vutpL8uhcfa97ui0eP+Mnl8W8u7rTS53/HUj7ZoxVdfBZG3Ix4r53hT2/9oZ/Xki8Nl2tPV3m3nod67P4//9S+1U99pp7+/XfvX1bqd/evhN/3Jt8+f+eqJloevzuZYTdle72m82jlfT/h2OzpfWvZo8ni7HYvZjtUH7bh8p5350tmzWOnd45Vyv7T5kZdfw79oZ/m1tW5nzpE/2jn0/f7Id/qjaEfN37Vzny91Xw8wctmbaHb3Jqy93U7qbCdNvtOO9w/amXs5lxZbPflwt2rSVz8N262a/GGLCudN6eI8XhfH5v3YssfAf1nWumxF5+2DLW6q1kXDeg8NzNq7rfh8I58H34v5q1ZC7oMU6ovHuflq7mq7gNmXCyW7BcxxrN70uVvAHKvltN3i4zhW70zcfqfl6gjFPQcWEfrmcU6fb8v25UsgV63UcQ9G6x/vw/pdK/1+mlv19/si8yZcj+PNVh5Hd06nHe2w1flSy0nGOT/IheDUX7VyzKlKXgHvt7Lqy3rPtFkm/hjJ9nc99fj/3vNZj1yLMzhW7/pqj5vvWect+e8l579pBm+u/m0z8/7u+Mf598tmbK+ZH95ufP/eotvqTcuxt9zm/FZq9os2ZlGFczr3rzZWy0uPAdBrax7f/jC4/vka++XbpzNfV6QUS/H/2id9Nb0mPsfjwgee2p/fBKtFt97sfoP8I0f+WzOrn3Adsy7i/M3DPER/vnM9Vutd1u4bMOv89cffG7R6sPV8YXovXot/t7L6Ldhxf1fnwd+25V9bVKtvSJ3fkPgpyt+trH4PJnbfWDS0cfzVxu7CKH4g9z9aWdU4Nr+/S85XPb/Zl7hfgHlu+KqVlaDmzyD/8fzW/9HK6q32991N4X3nv2vjccr3ORFm725PHbdvH4OPRSvra+iWwuMaitXZv2ql37Oe1vFG7L9bWa3CSb+XEUTwDNj/0Ur7xvW8Wonbv55VvnE9q35+PevyaWv/+xnI/6OV1RGa91gifGT23/t2VepQ9xEy/kDt70ZyOQ3T5t10+/ev1mVX/Lif3u0NX61/dcWOL3wl/rRz7zs14UPA/965q3Juv39C6Bw+9T8P82ol7rFycfeEExX15yjXlm+vcelzvEH715/jltVzAs/59Tmdjfkt8d9sUt03R8oD/fcmxTeksFqH25fCatlrVwqrpxbuf8n7slJnfhGxhup/tNI//2JdtbH/xbrZk7B398n2wGd5fLYHPsuFnO2Bj+cXjk9+Yc/mV45xfGPwtHRtzrnlWLg2lrdlMou6JPBN9j80uZqhm7NiS++vlpDynisvX9ysLvuRt9ySA4S/+7EaIOR99Vjix9p/fREuH1y0/628ut/VuOuG8HaP9teXz3LwtX0dr35z9qUBv9x9sX9UvP61V1a/O5O4T1oJ1u/+3cpqLqHm4wEO4dliv2hF7B7yCA/zL1vx8HuL+OyFv1tZnbn3VWhsQ9qfbeQXRl/L5yr+YvS1Wj/bH30tN2l39FVfuSWrr9yS1RduyWr3AdjL0Vf5N0Zfq3cy7X67L9/rtP3NvNmT5RhhuU+2R1/1DWvn0b8w+srVb9E2j89uG6s9u2xj+xiv98n2N9nStX7PXFX+u2vzWBZh3K/60c5p/p6/6MlDR/eYRxY9WT3W7Hr78XW2Kb4L//JSrh6xtu3IXL0CbNuR2eRjR2bTb1yDq3dH71+Dqxc67V6Dzb9x/Sy35yvXT90LXHwY399n7fJZi8ddm2UN6zi/vH5QVn/4qit9Od6/L6COJ3D9fdKuVsn2L6D1Exd3L6Bun19Aq+H+/gXUvzGFkP3zKYRlG/sXUP/K7f/yliF03jLk4vYlV2tkFffZX4ll8z/vpPKHd0xt3uyu+zJk/OyLxqIRW82K3EtKzjkA/00bdX+leuFi/l0b92KFl/1rG+v73LlDHvdiizn5XD11sdl8Ip+z2OjPWZFcrQ/0OuavQGw1zlgtj+lx36LqofXvxl72RY57qkiOXCl7tTy2P+ZZLY/tK3s1R7Ov7NWzF3eVvVqT2lf2cn1sW9mr55PsKnvVxr6yl9uzq+z1eTunMx7nXizO29ViksZdpKT5j7miX11DLebTJPuyL/aNYc/qEYz719BqfWz/GrL8/BparY7tX0PLt3ptX0OrtaDda2i5nrR9DS23Z/saWn6bzWWPFi0X32arpzHqfIy3snbxzynBXP4WQ+ZPeQQjsJTfNDIf3ds0fNHI6qRtd8W38CHCfz3bfPyY7t+/VuevBw8sfMif9aUZy0KCe1JDhL8n+l0rGnNaHYXjv2zF7ndMi3d/t5W4hz6PQXdbtLLeu/dFJE2XW2TfUOXqdWP7qlwtlO2qcrlOtjsNnVFfmIbO1SvHdlWZxzdUudmT5WTpcp/sTkOvjw9+S+Kolvof22NfOT5fmALbbCPe3ifbX+/LNbLtr/f6wjlb3zln6xtf78tvsj4fty6rd45kfeWmrL5yU1ZfuCmrr9yU1VduyuoLN2X1lZuyyv/8jJs/yBbFKO6vM65WS1OPW7uY3+6Y0PY/G1kWVe89BXPZyO5D1ur4+OGiP/Rj7yFrdeR/24/Np2D+1Ej7QiN7T8FcN7L5zLhqy7KvvcebrRvZfLzZLxqxdxvZe7zZT41sPd5sf3Peb2Tv8Wbbjaweb7ZuZPPxZvX5Axt/6Mfe483q8wc2/vBdce+Px3dFX3xXLIvgjlkEd/CX1f6LRnQ+18T+8RPivxpZFSBsvgDsF438+wvAfrFnFzMYtX6m3/0t3BTPIPlre1bLUB73F6hHP95sZKyLPpeh1N9spO7T/tGn/l4j5y/mX430eruRexT7aETea+QxFO/3qLwW570sl2ALDzw6xL/TTL25SXKvRKXoYudq+8om/aaZWlyJywlJ/Op9OSG5ml+d9Z/quJz/nF8tXf/2Zj4Cig/2O/5qZSXK+aAbDA16/bVrv7G0UPr50kLpN5YWyr6xtFD2+dLCso3tO8H19uzfCa5O2mivbw9lEfZfJ+3yB2OPL/f5XIS2+P1A2bJUS/FAA2vHu83MGfDH/sVj3f5uZlmoeO8YbYtraPmTsTZvs/uqjfz8Wvb2jWt5+VSEzWt5+eKp7WvZv/HL8vLPf1m+bGP/WvZv/LL8Nyd+jzevn2bzsVmNz3P9ZTOOHzI47nP/amb1CJjdy3D14qfdy3DZj83LML5RpFjxeZFixTeKFCu+UaRY8XmR4rKN/csw4j+/DP954ku+ff3UfWPXQhfXz6qebrM2cN3GXm3gD21s1Qb+sEtmI49c/75LfhjzxJyLwC3mX2Oe/MbjZyq/8fiZqs8fP1P1jUe+VH3jtzdVn//2ZtnGvhHqG7+bWdbv/OMRW7L4rXCtFsS8+/xh7GqMXV/5je4Pfbkf2uji//pAETlWT1tsOu8arK9+/rwsGK68RwiH/vsTUh59+fjH3HIc618yvE7bxY+51/3Y+zH3o43Va3f3fsz9aMS/c6Ks7l62fsy93id7D1h5tLG6E9v7Pexjauv43PmPVr5wM/Zo5eObsUcbX7gZe7TyhZuX/cfToWrN/urJapHhrsIzPjG19z/bWBZ4HfOlBHjU9J+P/pNxLvzrmXKvev7jSUl/t1HLJZN7cw6sesofbax+LTYWvC8lib/dj8N3+rHaH3W/Z6R8uT+WR+YWvfjiQZWPPbI6W7vOZWBf7ZO+fkPOvaytUOz/aGU5TXtff9q4RcefVlr+tIolucZHttqfreRyjL/z2O5HI4tTZfOx3eue/OPJx+ZfaOTfH5/8UyP3U2xD2ruNtPsZe8E65d81MiumH3F1dGK5ynGPt/Qfh9h+c9JKzZmQxROY5ZDV6sL9APLAF2n2XzRR92lfeADi300s52e3Kpjk0OVE/FYF07qRzQqmRyOfVh381I+tCqZHI/rf9mOvgunHRtoXGtmqYPqhkb0Kpkcjy4rvrQqmHxrZq2D6TSP2biNbFUw/NrJTwfSLzXm/ka0Kpv1GFhVMPzSyV8Ekh+Xn1/D6R7g7FUxy+PFxP5ZfFPNZ9By//vVNsVr72qxfWjeyWb/0aGT1eLS9+qXfNCL/3shyJDCXa1VTFyOB9YMB50+1+WzaP1+X8WhldYMhef+OXo/FAGn5cyWZT0cTFuv8uT3LX04ds5r/EHmzkfmlI1xP/2UjNX/u2lY9Wc0RzKfyd19uzuf12Y9G7GMTxOf12Y9G4r/tx+5wIL6h+fxcr/ENzefnQ9f1mbr1uvZHPz7/OcK6ke3TPf3jPZLfON0z/9t+7A7m8/OfI/zUyOZgPr9x9dbnP0f4oZHdwfx+I/ZuI5uD+fr85wi/2Jz3G9kczO82shzM1+c/R3jMZHxu1/r85wiPfuh/a/nxoo/nmoXnoh/++cW3bmTz4vtFI/ZuI3sX30+NbF18+5vzfiN7F992I6uLb93I7sXXPh63/tCPzYuvfWHcunxfzP3wwccX3+LwrtaTdu8oWv/CpOuykd1xWvv4p14/9WNvnNY+/qnXD/3YHKf91Ej7QiN747R1I5vjtNa/MOm6bmT3q6J/YdL1h0Y2vyr6FyZd9zfn/UY2vyr6FyZd143sflVIfn4Nf+FuvOnHswI/WH7vbrytFrS2Bb165uHmxqz7sSlotf+2H7tGW/2wa/tM1c/P1HU/Ns9U+4/P1N07itVLWLa/JpaN7H5N7Ddi7zay+TXxQyN7XxPbm/N+I5tfE7uNLL8mlo3sXnyrn3NtnvTrfmxefP6xWddrSH5XYCjfkPvXGlJb/gpLala2oM4025+NrCpex/M6Lw+koxryj5/jS/P4fCGqLZ8MsLkQ1X54+N7WQtQPe/b+5nt8ycq/79nlC+RnVVguDs7qJ1y7q56/aOTNVU+TuwjYVGxxxi5/xHXcBfTSfdnK6pTFk+qC73z/u5XVk7ZamzdbXNv+u5VVyev9G4dqx7+v4i7bqMJrCXLRyGpJa7eSsa1e/bVbybjsyW4l434ji0rGHxrZq2RcN7JZybhuZLOSsf3wc7/5e3NdnW2ZX6g8aKufcG0Lf/kLrl3hr37CtS38ZSOblQc/NLJXedBWDzTcnidcvlJq9w6yPl6K/aEfm3eQlf9tPzbvIPvyh1ubg9h+fDyI/aEfe4PYfnw+PbA+U/fmOvphn89oLxvZPd37EZ8fmS+c7n31m61v9GNzRvunRtoXGtmb0V43snv1Ln+vtTlVsW5kc6riF43Yu43sTVX81MjWVMX+5rzfyN5UxXYjq6mKdSO7lu8f2/WHfmxavtt/a/nNecK+/rHW5sW3/iHP5sW334i928jmxfdDI3sX3/bmvN/I5sW328jy4utfmKTv8vG49Yd+bF58X1jWWt5RbFYe9OWvcDbvKPrykYO747RVI9vjtM8Xtn7ox+Y47fOFrXU/dsdpPzTSvtDI5jht2cjuOG35gL/dr4plI7tfFfuN2LuNbH5V/NDI3lfF9ua838jmV8VuI8uvCvvG3bh9fq9l37gb/3xp6wfLb96NL59TuCto/7gk64d+bAra/b/tx67RVsta22eqf36mrvuxeabGf3ym7t5RxBd+SLBuZPdrYr8Re7eRza+J+MIPCfY35/1GNr8mdhtZfk3EF35I0D//mdYP/di8+PLzYtflGpIkrpt6c8Xyn630VSurFViZrxQVrkT9bh1X5dWXx5rhopW+Ws9yvZ/YhaeYnY/K+Wcbq+WsPo/P49s+320l5lA8+Sz0v1tZvWHb/HXeFx9m+8tW5F77LF33ZTmVddh85N2Bxw/9dpvuPfPJNnW5n8rU9SutQJO/PNbjNSbXsa6QVSurtdi6Zwnaccji9JXlulITPIVfWv9SO/l2O93mE2V72Js7+WGZ+Wyz91vJ+crUrHcVocf9NfD4npV3W2lyP0Hrsdq42r/L5xjn7YjHmjeehPc/2lmWJbjMAhZXe7edduCtFm19/v2infpOO/397frFdZVfuR5+1Z98+/yZD/ZoefjibJbV8wtb7/djsR7Z4u125vv9HjmOt9uxmO1YfdCOy3famQ/17SZvH6+U+6HYj7z6Gv5NO6uvrR/ambPbj3YOfb8/8p3+KNpR83ft3OdD85cDDFkuQWS0+3XhGdbebid1tpMm32nH+wftzL2cS4utXgC2W+8oy5c6bdY7/rBFhfOmdHEer8ta8y4Kfwz8lwWpy1Z03j7Y4nZoXe6r99DArL3bSsi9e0N9UeYuq3W07aJhWT6NfLdoWNaPxdssGpbVQsluwa/o8kVtu8/6XL4evs+nMoe+eZzT53PEfflwzFUrddzDyPrHc8J+10o/+n1j9n5fZN4+63G82crj6M4prKMdq3P3h8f9zTk5Lr6m/qoVvO6NV8D7raz6st4zbZZmP8ag/V3DPP6/9xzSI9fiDB6Dln8/UhKztlry38u8f9MMXtXx22bmndnxj/Pvl83YXjM/PPUZ73FYPYFa9pbanN8nzX7RxixkcE6h/tXGaqktxysRL1eVrF5YsHwqd+bripRi+ftf+8SXixg+R9LCH4L9+dIC8fXjnfZeWrB8Fr3KfHOI4unEfz6LXpavlJT7FaQPx+AY2V/HaF1+M1ch52jqr5N/tdq1/b4BWf6a7L7D5fTnX28KWLex984CiS+8p+bRyhfeUyMSH7+nZt3G7ntqftiezXcw/HDOamKJyBfn7GoZwuO+H3kMx6bh6s+Tdr2uMjdIOrvymwt5zl4chmvwrwt5+YTEdrdi/R8X8p9mWv2erM83QvRKX7WyfJvw5gtIZPXGnH0hrJbgdi/m3K1nP1anba7flHZfQuez7N/sy7ZYlr8p2xbL8jdlm2JZtbEvlvVv5HbFsr6G7m/3xzUUq7N/1Uq/Fx6s45H/f7eyWoN7TFndyxfCl3H93Yp943pe/bBs/3quL7ypWaTy8+t5tf7W+/1Gr95jdQ0tj9CcLDnHAv++b3X5+7K6j5Dx151/N9KXM6FtTmi1fx8jL7vix/14AufLp/7uyjfGtj/t3HvK5bGbZbVzfXX/sfVKLj2Wdw6zJ5wr/POVXLpcwpH51vVHpv1L/2yn1ktcc0UJU8x/vqlsvUmbbxnT1fvBtqWgq/eDbUtBV28I25SCNv3Cl7w22x0Q5qoV//iLddnG9hfrbk/C3t0nuwOf9fHZHfhob18Y+OjqYYq7x2ezjeWeXbWxf4yX+2R38LR2bc7lnVi49od3hM2KSIlqK02uZsn3XpOpy5eE7b0mc9mPzddk6mrdbPc1mbpaN/vNt3J94xqUL7yJ8YdhtsxXnfyj1PvvHbM4Qo/pivsREMHC9b9bWZU01nwuxiE80vaLVh7fYq/hivAQ/bIVv18bLcGHjvzVyvLRivcVZGxD2p9ttC+MnLR/Z+S0+hXa/shpuUm7I6fVD9H2R07q3xg5aXw+clo9ZHF/5LR+bdjuyGn1657db+blL4S2v1U3e7L8fl/uk+2R0/L4bFvb7BsjJ/vCyNa+MCa1r4yOl/tke+S0dO29BGOVC9euVsm03y8V1s61tp6/6Ekedo9XZNWT1U+w5C6D6orvwr+9tFoi23fk6rGA+45crTfsOnK1QrZ/Dfo3pm3VP5+2Xbaxf/14/tfXT92rzIUz5e+zdrW+Zcdd2miPZfh3r59EnZCvurJ+BM99AXU8eu7vkza+MWer8Y05W43P52w1vnLrsbpp2L+AVqtkuxfQqo39C2i5PdsX0PKWIXTeMuTq9mW1MlVxn/2VqF35605qtUi2f6O67ku2+2mHqYup7NWi0uNmQ+/yFdy/+2/aqPsr1QsX8+/auBcavOzf21je584d8rgXW82n1/pxzPdNlLPi768ZjdU7mnod80dUthpnrFYI9LhvUR8LErUw9qovctzTPOd77lZ98W+MeVYLZPvKrm/U0Wh9XgNjx/EFZdvxjRlbOz6fsV22sa3s9fZsK3t53s7pjMe5F/9+3tpqfvLxjXv/Li3/MVf0q2to/PT46gsHLP+jL/mFYY8d9YVr6DHK+8I1ZKsVst1raLU+tn8NrdbH9q+h1QrM7jW0fEre9jW03J79a2h1Pc8lixYt//3bzNrivNX56HllAfGfU4LWlpNf85dwghFYym8amc+sbo97g39vpC+fiXz/7EL49Oy/Xi9gq4UpOeaPbw8sWsifRd62eiqjyD2p8ViXON5tRWNOq+PXG79sxfKWnKPS75etxD30eQy626qV5d69L6Lz9TerVvIbqlwtk+2rUo7PVSm7TzNbTUOb9C9MQ5t8XnK7bGNflZs9CXt3n+xOQ6+PD37Q5ah0+h+t5FeOT33h+NQX9uw3ysRNv1EmbvqFc1a/cs7qN8rE199kfb5nQPBMo7+/yfQbN2Wm37gpM/3CTZl95abMvnJTZl+4KbOv3JRZ+8/PuPk8g3Pyb3HGrZamHrd2Mb/dMaHtfzayqqTZfPzrspHdpwva549s/KEfe08XtM8f2bjux+bjX39qpH2hkb3Hv64b2XxYovkX3lG+bmTzuX6/aMTebWTvuX4/NbL1XL/9zXm/kb3n+m03snqu37qRzef6WXz8COcf+rH3XD+Lj1898sN3xb0/Ht8VffFdsVoVe8w03kVwBx9v4L9oROdjgewfv+P/s5HVetbum+9+0ci/v/nuF3t2NYORy3dT3N/CTfEIn7+3Z3G+etxfoB79eLOR7H4vQ/Hnjr9qpO7T/tGn/l4j0e9Klej1diP3KPbRiLzXyGMo3u9ReS3O+1ouwRaeF3aIf6eZenOT5F6JStHFzl0+ufEXm6Rf2aS2++iJ1YTkcn511n+q43L+a3611o+Gm09Q43Mx/5oxWy2KzW9kDg16/bFP/PjG0oIfny8t+PGNpQU/vrG04MfnSwvLNrbvBNfbs30nuDxpo93vC2YR9p8nra+f09h8PpykLWr/ffmbsUPxVBFrx7vNzBnwx/7FUxH/aqYtCxXvHaNtcQ2tFsWkzdvsvmqjfX4trxaz9q/l1c+jdq/l1c+09q/lFt+4llfn/u613PIb1/Jye3av5d+c+D3evH6azafONT4O+ZfNOH7I4LjP/auZrp9fhqvnDO1ehst+bF6G/RtFit4/L1L0/o0iRZdvFCm6fF6kuGxj/zKU4z+/DP954ku+ff3UfWPXQhfXjyx/7bhVG7huY6828Ic2tmoDf9gls5FHrn/fJT+MeWLOReAW868xj37jV+Wu3/hVuevnvyp3/cavll2/8dsb189/e7NsY98I+pXfzazqd/7xnDtZ/M7XVwti3u/F7ce3zGKMbevXsW2WLf/Ql/vJqY+rXhaNLF/DMu8arK9+urwsGK68RwiHLp5u4qsfSG3+ENtt/UuG12m7+iH2sh+bP8R2W70ecvOH2L5aDfvNibKaztt7sIn7F37L6v6NR325f+NRX+6fP+rL/RuP1/LlIsOm3/YfC6f//lg4X/3Cyu4KOuMjh3v/s41l2cEx38eBp6z/9exMj9Vvo+4Vy388oejvNtpyuePenAMrlvJnG6uig+N1gEv87X4cvtWP1a/W7lfslK/2x/rI3JIWXz3p1eOH9zDcS7i+3Cfr1zrdS9IKPf6PVlaDyHZff9q4RX9O1HrsltMan3n8xw+afPXjqt0n1vtqSWv3ifXLnvzj0eHmX2hk8fzxHxq5HwMd0t5tpN3PtgvWGP+ukVnt/IiLoxPrFYp7rKT/OMT2m5NWas5irB5h7qsnIcb9UpXAF2n2XzRR92lfePDgX00s32C9WX3ky8r6zeqjZSO71UdeH7+B74d+7FUfefl/24/N6qOfGmlfaGSv+mjdyGb1USx/TLVZfbRuZLP66BeN2LuN7FUf/dTIVvXR/ua838he9dF2I6vqo3Ujm9VHsfpV2N41/EM/9qqPon38dtP1F8V8mQPHr39+U8Rq9Wu39mjZyG7tUaxWv3Zrj37RyL/XpaxHAnOpVTUXL7eIZd1EzZ9Z85mwf71vJvrqBmM8F/saDejx7wOkWBZTyXyymbDQ5s/t+eH3SveY4hB5s5H5pSNcC/9lIzV/qtpWPVnNEczXWnRfbo5/PrqJ/nEd4g/92BvdRK//th+7wwH5hublY73+0I9NzYt+vlOXZ6rdQ0ZfHVzxzwfzy0a2T/fVb792j8w3Tnc9/tt+bA7mf2qkfaGRvcH8upHdq3e5KrQ7mF82sjuY32/E3m1kczD/QyN7g/ntzXm/kc3B/G4jy8H8spFdy9vndl33Y9Py5v+t5UPuJ2eEL3aq5RcuvmUjuxfffiP2biObF98PjexdfNub834jmxffbiPLi2/ZyO7F55+PW9f92Lz4/Avj1tUdxXwn8uOLb3F4l28L272jiC9Mui4b2R6nxedujS9Mukb4f9uP3XFafGHS9YdGNsdp8Y1J1/zGpGt+Y9I1vzHpmt+YdM1vTLrmNyZd8xuTrvmNSdf8xt14fX6vld+4G6/PZwXWlt+8G18taG0Luj7+He0P/dgUdMV/249do61+2LV7pubx+Zm67sfemZrHf3ymbt5R5PL3WJtfE+tGNr8mftGIvdvI3tfET41sfU3sb877jex9TWw3svqaWDeye/Gtngi4d9L/0I/Ni699bNb1GpLfFRjKV0z/tYaUy98+Sc3Klj63Jtufjayeyan3T5Y638L310/pc7mcFfn6qvhH9bqY/qaVIb2rlYST/kcr21uUqy1atWLzm9xi8fCGXD0M8N9eQ/n3Fq1+QbW/d5etbO/d9Rbdv5Tr/G3/J63Eu63IXXv+iPVuK3o/fOFx6vS3W5k3gOpvb5Hexbydi8u/bMXub49uKu9eRzlf+Z5+LK6A1RLX7hJ1in2+RJ3LnztsLlGvG9lcov6hkb0l6lw9m3B3Qin1+HxCadnI7v1K6sdD2h/6sXe/kqr/bT82J5R+aqR9oZG9CaV1I5u3X7l+9dfmncKykd07hf1G7N1GNu8Ufmhk705he3Peb2TzTmG3keWdgn7jNt3y82v4G7fp/vF0wQ+W35tQSv/CjH/657df/oUZ/3T7b/uxa7TVAtf2meqfn6nrfmyeqfEfn6m7E0rLBa7dr4llI7tfE/uN2LuNbH5N/NDI3tfE9ua838jm18RuI8uviWUjuxdffvy42B/6sXnx5edmXd5RbC5RZ36h6DXzC1WAmR8vGvzQj83vmqz/th+73zX1hWW2/Hx564d+bJ7un/9e64czdXNUVF8oel02sn261+ejgPrC6V6fL2+t+7F771tfKHr9oZHNe9/6wtU7HvPz6aBm3cjmoOYXjdi7jewNan5qZGtQs7857zeyN6jZbmQ1qFk3smn5ah/b9Yd+7Fm+mv+3lt+8o6j2haLXdSO7F1/7QtHrD41sXnztC0Wv+5vzfiObF1/7QtHrupHdi+/zH2v90I/Ni+/zH2v9sPpzr9s84mIVtVa/koq7I4HnOtubq1CFNb5fruaW3MM0vkH8f7SyXHC/B1lNcYP054J7Ldey5vMoHvHfnxaybCTnE0dSF/1YbMzuL2p/0cibv6g1uR8w9VittH+vhqjVMsVjAfh+zW/3ZSubbzCLVqtWloW8bY49+bvpv1tZzAvk/ey7whOd//qF8LKNKryuPleNLN8ssPeUnFo9VnD3KTnLnuw+JWe/kcVTcn5oZO8pOetGNp+Ss25k8yk59cNb3eZzyHV1ti2fS7j7q/ayL5QMlH2hZKDsCyUD60Y2SwZ+aGSvZKDsCyUD5V9Y7a/P39T1Qz82Zzw+X9Ra92N3isC/cevn/vnGfOPW7/NFrR/O1L0JvoovFLcsG9k+3ePjqdcf+rF5un/+q611PzYn+H5qpH2hkb0JvnUju1dvfKG4Zd3I7hzDfiP2biObcwzxheKW/c15v5HNOYbdRpZzDPGF4pbKz+0aXyhuqc9/tbW2/O4EX32hZGDdyO7FV18oGfihkc2Lr75QMrC/Oe83snnx1RdKBtaN7F18j9mZz8et9XnJwKMfn49b7fOSgUc/Pi8Z0PEw5Q/HaetGNsdpj0Y+detP/dgap+nx8WMIf+jH3jjtx0baFxrZGqf90MjeOO2xWz9fiP2hkb2vit80Yu82svVV8WMjO18Vv9ic9xvZ+qrYb2TxVfFDI7tfFV0/vobb53fjj3745y75vNzm0Y/8gqA/Xtj6qR+bgpb23/Zj12giXzhT5fMzdd2PzTNV/uMzde+O4tGPz0sGfmhk92tivxF7t5HNrwn5vGTgF5vzfiObXxPyecnAD43sXnwan198+YWLTz8uGVivIUniuqk3Vyz/2UpftbJagRW7RSBcifrdOq4Kfo77763osVrPGu+xu1ZP+cNg9z/bWIltHp/uLd9tJeZQPPmO7L9bWZyyj9vK13lffMnpL1uRe+3zsSK/7MtyKuuw+Sq0A6+2+e023Xvmk23qd5lJdf1KK9DkL4919buAp0IWraxeuFV1zxK0x4zE6vRdris1wdvZpfUvtZNvt9Ntvmn0cVm8uZMflpnvzXq/lfGDt6uVrHcV8dji19fA43tW3m2lyf12pn60RSvL38VE3o54rHnjLWv/o51lWYLLLGBxtXfbacc92m6P//UvtVPfaae/v13719W6nf3r4Tf9ybfPn/nSiJaHr87m5XPher9fufTIFm+3o/N1Y48mj7fbsfnKv4fbP2jH5TvtzJe9dpO3j1fK/bLkR15+Df+ineXX1rqdObv9aOfQ9/sj3+mPoh01f9fOfb5MfT3AWC5BZDS7exPW3m4ndbaTJt9px/sH7cy9nEuL1fqt3Tv1jo9GFqO4zXrHn7aocN6U/vt5/ENZa94PHHsM/JcFqctWdN4+2OKmal3uq/fQwKy920rIvXtD/d8foaZttY62WzT8aGX1gMrNouFHK6sB+2bR8KOV1RvA9wp+dbwD8F937u57JJdHKO55p4jQN49z+ny/tC9fvLhqpY57GFn/eAfV71rp9xPUqr/fF5m3z4/ZzDdbeRzdOYX1WExcnbtt/bjKOSfHxdfUX7VyzOlBXgHvt7Loyw97ps3S7McYtL9rmMf/955DeuTS1R5eTVE8bptnbbXkv5Z5/6qZsrebmXdmxz/Ov182Y1vN/PRG4fs3Dt0Wbzd+3NBuLWA4v0+a/aKNWcjgnEL9u43VTxzSX1vz+N5evch++cbnzNcVKcXy97/3yXIRw+dIWviQUfvzm2C14Lb9Mvvle84x3HzcjqArxx9dWb5x6zGpcH+3PW4K55G2/qtmcp65j1FiXzSzGjm43EcpsEl/DjSbLJ9HG/ev2x4Zt5WPAduf7SyHDvMRlnyj7/lozT9aWb4kfD5mtGP+/petyLwzVfxu6X+0stqi7vcjLDkd8T9aWR/r+7XND51J/fuxXv60LF5fSyr41pf8VVdK52lX+LHP311ZvgHEaxZLxZH/flmvFlm2L+ufejOe2PzsTeG2/+9mbDn5Puee8LUvvquYx5rV69T1Ayfd41vy//d/e3z6f/wf/+f/+//+//y//o//x//3//y//l//n/P/2GTI6AFueie7k98pRnqcAC3vVCM9dmA/xlzeo2e93amP9Ljsu9xJR3p8E3a7k98pRnq03HPsg8c+7fVKctypXaObR+p3kjvpNd55JLuT32kwzrs7yTvVK+lgnHdUOhjnj7y032kwziUL1TsNxjnjrH6nuNNgnOMVrVeywTi/qm0wzm85G4xTOyZ30jvZnfxOJ2OMwy3vVK/kx53anfqd5E56J7uT3+lm+M3wmxE3I25GDEZ7bHnInQbjHF2H3WkwTlnHYJzf4DEY55JPDMb5rZODcQoy250G4zxGKXcajLOgJe1Og3GuiuVgnMOAzDvVK9Vxp8E4L8Lqd5I76Z0G4/wxVPmdBuNUfg3GuZhU9UqPC+J14B43KTNemHZGmXGAzqWQx+3MGWP87UCNS/GIGXPGen11Pa6hGcc21YiDds4nt3HVy3nNtXHZP6PN6DOeNDmPZBuX/jPWiI/tbePil/OwtnH1y/k7zDYu/2cctHPiuA0BPOOgnVddGwp4xkE7j2kbEnjGuuPQwDO2GfuMMqPOaDP6jJMmF+3cUVJ31GPGNmOfUWbUGW1Gn3HQzvuANsTwjIN2/sSgDTU8Y5tx0M4v8Dbs8IyDVkPXNqPPOGjjyA9FPGPd0S/aeT54m7HPeNHqjCdt/GK/DVM8o88YI56HcMjiMZ93xrrj0IWeUztt+OIZ+/iD8wAMY4y78DaU8Yw2o88YM+aMdcchjmdsM/YZJy0nLSctJy0nLSctJ60mrSatJq0mrSatJq0mrSatJq1uWj+OGduMfUaZUWe0GX3GmDFnnLQ2aW3S2qS1SWuT1i7a+Z3ffMZBkxFzxrrjcMkzthn7jDKjzmgz+oyT1ietT5pMmkyaTJpMmkyaTJpMmkyaTJpMmk6aTppOmk6aTppOmk6aTppOmk6aTZpNmk2aTZpNmk2aTZpNmk2aTZpPmk+aT5pPmk+aT5pPmk+aT5pPWkxaTFpMWkxaTFpMWkxaTFpMWkxaTlpOWk5aTlpOWk5aTlpOWk5aTlpNWk1aTVpNWk1aTVpNWk1aTVrdNDmOGduMfUaZUWe0GX3GmDFnnLQ2aW3S2qS1SWuT1iatTdp0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlMl8h0iUyXyHSJTJfIdIlOl+h0iU6X6HSJTpfodIlOl+h0iU6X6HSJTpfodIlOl+h0iU6X6NMlfsZBG7f9l0uumDPWHS+XnHNAernkioN2Tuno5ZKzyEYvl1zRZrxodcaYcdBsNFZ3vFxyxUE77071cskVB83HnITOaDMO2nkPqZdLrjho5w/i9HLJOf+ul0uuOGjn+/L0cskVB+0sJNHLJVe0GQftvE3VyyVXHLTz3lQvl4x4ueSKg5ZjFqXPOGjnrJJeLrnioJ23JXq55Iox40mz815Eh0uuOFxi59KpDpfYufKswyXPKDPqiGcfhkue8aRZG43FjDnjoJ31KDpc8oyD1sdsUJ9RZhy0czpLh0uecdDOu2YdLrHzwTs6XPKMg3bOc+lwyTMO2jm/pcMlzygzDtq4AoZLnnHQzglSHS55xpxx0MYJPlzyjIM2zurhkmcctHMeX4dLntFmHLSzvk6HS55x0MZJO1wyog2XPGObcdDOCRUbLnnGQTvPahsuGWXZNlzyjDHjoJ1ntQ2XXHG4xM5T2YZLnrHPOGjnWW3DJc84aOepbMMlzxgzDtp5VttwyRWHS+w8q224xM6ZbBsuecZBOwsYbLjkGQftvHO34ZJnjBkH7bwYbLjkisMl4z17NlzyjH1GGfHsznDJM540P6d6bLjkGU+an4/IsuGSZ6w7Dpf4eQdowyXPOGjnWW3DJX6eyjZc8ow246CdZ7VpzDhoMhqrOw6XPOOgnWe1DZc846Cdp7INlzyjzTho51ltwyXPOGjnWW3DJX662oZLnnHQztk6Gy55xkE7BW3DJc9oMw6ajYncmHHQTkHbcMkVh0uecdDGCT5c8oyDNs7q4ZJnHLRzocaGS54xZhy0s1DHhkuuOFziYyp6uMTPJUYbLvHzKWQ2XPKMgzZO8OGSZ/QZY8aLdm5m1h3rmPGeVbPhEq8xkS0z6ow2o88Ys4VBGxfDcMmIPlzyjG3GPuO1bXFGndFm9Bljxpyx7tiOGS9anrHPKDPqjPeMobdr2+qMMeNJi/NLzYdLrtjv+UnvbcY+/qCdUWbUGW1GH1HPGDPmjHXH4ZJnbDP2GS+anVFntBl9xpgx76gXQs7YZuwzyoxzg3RukPqM96nhmjNeG3QeITtmbDP2GS/aeYRMZ7QZfcaY8dqg87hZ3XEIJM5Bgw+BPGOfUWYctHN+3YdAntFnjBkH7awo8iGQK8YxY5uxzygzXoix5uMzxow5Y92dzLlBOTco+70fhjXiXOfxYY1nHDQZf+szDtq56uPDGs9YdxzWiNPrPqwRp4p9WCPOZRkf1nhGnXHQzrGGD2s8Y8w4aKdTfVgjzlW6GNaIs7YshjVG0UUMazzjoJ0XegxrPKPNOGinYWJY4xkHrUa7Jy3PHRXDGtnGYlqbsc8oM+qMJy3H6tmwxjPGjDlj3XFY4xnbjH1GmVFnnLQ+aX3ShjXyXN2JYY0rDmuMktkY1sjzxiaGNfL8WoxhjfF84xjWGIUpMayRPtYSfcZBG0doWOMZB+2sPI8hkGcctHOoFkMgeX7VxRDIM+qMNuOg5Vi6jBlzxrrjEMh48UkMgTzjRTu3Yggkz3WcGAJ5RrsP4RDIM17bdu4zyxkH7RwYxhBIjYXWIZA6n9IcQyDPKDPqjDbi2Z0hkGeMGXPGk1bnWC6GQJ5x0Mba7BBInWOuGAIZhdkxRiDPaDP6jDFjzjho56puDJc8Y5uxzygz6ow2o88YM+aMk1aTVpNWk1aTVpNWk1aTVpNWk1Y3LY9jxjZjn1Fm1BkvWpzRZ4wZc8a6YztmbDP2GWVGnXHS2qS1SWuT1iatT1qftD5pfdL6pPVJ65PWJ61PWp80mTSZNJk0mTSZNJk0mTSZNJk0mTSdNJ00nTSdNJ00nTSdNJ00nTSdNJs0mzSbNJs0mzSbNJs0mzSbNJs0nzSfNJ80nzSfNJ80nzSfNJ80n7SYtJi0mLSYtJi0mLSYtJi0mLSYtJy0nLSctJy0nLSctJy0nLSctJy0mrSatJq0mrSatJq0mrSatJq0uml1HDO2GfuMMqPOaDP6jDFjzjhp0yU1XVLTJTVdUtMlNV1S0yU1XVLTJTVdUtMlNV1S0yU1XVLTJTVdUtMlNV1S0yU1XVLTJTVdUtMlNV1S0yU1XVLTJTVdUtMlNV1S0yU1XVLTJTVdUtMlNV1S0yU1XVLTJTVdUtMlNV1S0yV1ueQclNXlkivajD7joJ2jtrpccsVBG3VTl0tG8dPlkrP+uy6XXHHQzocl1+WSc66iLpfEqKPyGWPGQTun6OpyyYiXS67YZuwzyoyDdo4G63LJFX3GmPGinRsUdwVQXS45Jz7qckmOf+0zDlqNOGjn/XxdLrmin49YOufP6nTJK+aI4w/qjqdLXrFdT4g6Yx/xRJwueUUd8Tyap0tecdDO8VlVzJgzDtp5R9WO43g9COqRB8+uf+/IgjyQdv29ITvyoF7la8fAnsf9kWvmNrij/Olog3se70ce3BxVcE2Q7019ZEN2/H8HN69/T+SauQ9uXbV3gzuqm47ekU/uqEJ9ZB159OG0TG/nQP2RHTmQE7lmPlXT29Xn0zV37siCrMiG7MiBnMg1s4Kr4Cq4OrhyZUUe3Ovc0MG1sZ91cG1slyZyXfXUZ7YDuV211SN3ZEEeXBv73wx5cK9zxgI5kQf3Ogf8QB7cGH3wwY3x9y7IimzIgxujDx7IiVwzx+DmYEVDHtzr3AtBHtwc/YzBHfXURzhyIOO8CpxXeSBf23tVhXZkQb64o89pyIM7iv6O4ahRzXtWeSPXzENTr9yQO7IgK7Ihn9x+9X/Y6pUTue48ymgfWUduyB1ZkAf3/NVNG7W0dx7cfuXBHdfCKKe98+Ceqw9tFNTeuSF3ZEEe3PN+uY2q2js7ciAncs08fPXKDbkjCzK4HdwObge3g9vBFXAFXAFXwBVwBVwBV8AVcAVcBVfBVXAVXAVXwVVwFVwFV8E1cA1cA9fANXANXAPXwDVwDVwH18F1cB1cB9fBdXAdXAfXwQ1wA9wAN8ANcAPcADfADXAD3AQ3wU1wE9wEN8FNcBPcBDfBLXAL3AK3wC1wC9wCt8AtcGty+3EgN+SOLMiKbMiOHMiJDG4Dt4HbwG3gwlcdvurwVYevOnzVn74axftPX115jK/yyh1ZkMe4bnxfXzW843ah9aevxk8Knr66ciLXzE9fXbkhd2RBVmRDBlfAFXAFXAVXwVVwFVwFV8FVcBVcBVfBNXANXAPXwDVwDVwD18A1cA1cB9fBdXAdXAfXwXVwHVwH18ENcAPcADfADXAD3AA3wA1wA9wEN8FNcBPcBDfBTXAT3AQ3wS1wC9wCt8AtcAvcArfALXBrcuU4kBtyRxZkRTZkvz0g1/3gubjQrrLgcVfc5LofHOOlqzD4uvalzfGktI48uOfvU5tcvnpmQx7c54+DAnls7/XjnstXOriXr8b9i1zjq2fuyII8fSXwlVy+ev7N4I77Zbl8NX7YNGqFn96T637wuPLg+mjz8tXzZ0yDe7V/+eqZDdmRAzmRa+bLV8/ckDsyuAru5atzmbSJgqvgKrgK7uWr6/97+eqZO7IgKzK4l6+eOZATuWZ2cB1cB/fy1biXlMtX415JLl89syMHciLXzJevnrkhd2RBBjfADXAD3AA3wE1wE9wEN8FNcBPcBDfBTXAT3AK3wC1wC9wCt8AtcAvcy1djvkguX10/nbt89cwXN0fuyIKsyIbsaCeQE7nm31/jq2cGt4HbwG3gNnAbuA3cBm7D9nZsbwe3g9vB7eB2cC9fPXMgJzK2V8C9fPXMHVmQFRlcAVfAFXAFXMV+VmyvYnsV26vgXr56ZuxnxX5W7GcF18A1cA1cA9ewnw3ba9hew/YauIbj69jPjv3s2M8OroPr4Dq4Dq5jPzu2N7C9ge0NcAPHN7CfA/s5sJ8D3AA3wE1wE9zEfk5sb2J7E9ub4CaOb2I/J/ZzYT8XuAVugVvgFriF/VzY3sL21txeg6/saMgdWZAV2dCOIwdyIoMLXxl8ZfCVwVfWwG2G7MiBnMjgdnDhK4OvDL4y+MrgK4OvDL6yDm6fx9fgK4OvDL4yAVfAha8MvjL4yuArg68MvjL4yhRcxfGFrwy+MvjKFFwFF74y+MrgK4OvDL4y+MrgKzNwDccXvjL4yuArc3AdXPjK4CuDrwy+MvjK4CuDryzADRxf+MrgK4OvLMANcOErg68MvjL4yuArg68MvrIEN3F84SuDrwy+sgS3wIWvDL4y+MrgK4OvDL4y+MowvjKMrxy+cvjK4SvH+MoxvnL4yuErh68cvnL4yuErh6+8gdsEWZEN2ZHBbeDCVw5fOXzl8JXDVw5fOXzlHdweyImM/QxfuYAr4MJXDl85fOXwlcNXDl85fOUKruL4wlcOXzl85QquggtfOXzl8JXDVw5fOXzl8JUbuIbjC185fOXwlRu4Di585fCVw1cOXzl85fCVw1fu4DqOL3zl8JXDVx7gBrjwlcNXDl85fOXwlcNXDl95gps4vvCVw1cOX3mCm+DCVw5fOXzl8JXDVw5fOXzlBW7h+MJXDl8FfBW4HwzcDwZ8FfBVwFcBXwV8FfBVwFfRwG0NuSMLsiKD28CFrwK+Cvgq4KuArwK+CvgqOrjdkB05kBMZXAEXvgr4KuCrgK8Cvgr4KuCrEHAFxxe+Cvgq4KvA/WAouPBVwFcBXwV8FfBVwFcBX4WBazi+8FXAVwFfBe4Hw8CFrwK+Cvgq4KuArwK+CvgqHFzH8YWvAr4K+CpwPxgBLnwV8FXAVwFfBXwV8FXAV5HgJo4vfBXwVcBXgfvBSHDhq4CvAr4K+Crgq4CvAr6KArdwfOGrgK8CvgrcDyZ8lRhfJcZXCV8l7gfzMGRHDvx9IoOL8VVevhq1KNnmfF02QVZkQ3bkQE7kOU+Y/UBuyOB2cDu4HdwObge3g9vBFXAFXAFXwBVwBVwBV8AVcAVcBVfBVXAVXAVXwcX9YGL+KjF/lfBVwlcJXyXGV4nxVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV+lg+vgwlcJXyV8lbgfTMxfJXyV8FXCVwlfJXyV8FXCVxngxvRkwlcJXyV8lbgfTMxfJXyV8FXCVwlfJXyV8FXCV1ngliBjP8NXCV8l7gcT81cJX9VxIDfkjizIimzIk1uYby/Mt9cx93NhfFW4HyzMXxXmrwrz7YXxVWF8VRhfFcZXhfFVYb69ekPuyIKsyOBi/qowf1WYby+Mrwrjq8L4qjC+KoyvCvPtJYaM/SzYzxhfFe4HC/NXhfmrwnx7YXxVGF8VxleF8VVhfFXwVSmOr2E/G/YzxlcFXxXmrwrzV4X59oKvCr4q+Krgq4KvCvPt5Ti+8FXBVwVfFe4HC/NXBV8VfFXwVcFXBV8VfFXwVWG+vQLHF74q+Krgq8L9YGH+quCrgq8Kvir4quCrgq8KvirMt1fh+MJXBV8VfFW4HyzMXxV8VfBVTV/1Y/qqH9NX/Zi+6sf0VT/m+Kofc3zVj+mrfkxf9WP6qh8HuA3cBm4Dt4E7fdWP6at+TF/1Y/qqHw3cuT7Yj+mrfkxf9WP6qh8d3A5uB7eD28GdvupHx/YKtlewvQLuXB/sh2A/C/azYD8LuAKugKvgKriK/azYXsX2KrZXwVUcX8V+Vuxnw342cA1cA9fANXAN+9mwvYbtNWyvg+s4vo797NjPjv3s4Dq4Dq6D6+AG9nNgewPbG9jeADdwfAP7ObCfA/s5wE1wE9wEN8FN7OfE9ia2N7G9CW7i+Bb2c2E/F/ZzgVvgFrgFboFb2M/wVYOvGnzV5v1gb3N9sDf4qsFXDb5q836wt3k/2Bt81eCrBl81+KrBVw2+avBVa+DO9cHe4KsGXzX4qnVwO7jwVYOvGnzV4KsGXzX4qsFXTcCd64O9wVcNvmrwVRNwBVz4qsFXDb5q8FWDrxp81eCrpuAqji981eCrBl81BdfAha8afNXgqwZfNfiqwVcNvmoGruH4wlcNvmrwVXNwHVz4qsFXDb5q8FWDrxp81eCrFuAGji981eCrBl+1ADfAha8afNXgqwZfNfiqwVcNvmoJbuL4wlcNvmrwVStwC1z4qsFXDb5q8FWDrxp81eCrPuevep/zV73DVx2+6vBVn/eDvc/59t7hqw5fdfiqw1cdvurwVYevegN3rg/2Dl91+KrDV72B28GFrzp81eGrDl91+KrDVx2+6h3cuT7YO3zV4asOX3UBV8CFrzp81eGrDl91+KrDVx2+6gqu4vjCVx2+6vBVV3Dhq47xVcf4qsNX3cA1cA1c+KrDVx2+6hhfPevbz/nP/qxvP+fc+rO+/Zk7siArsiE7ciAncs0c4Aa4AW6AG+AGuAFugBvgBrgJboKb4Ca4CW6Cm+AmuAluglvgFrgFboFbOL6F86pwXsFXHb7q8JVgfCUYXwl8JfCVwFcCXwl8JfCVwFcCXwl8JfCVNHAbuPCVwFcCXwnuB6WBC18JfCXwlcBXAl8JfCXwlXRw5/pgF/hK4CuBrwT3gyLgwlcCXwl8JfCVwFcCXwl8JQruXB/sAl8JfCXwleB+UBRc+EoUXIyvBOMrga8E4yvB+ErgKzEcX8N+NuxnjK8E94Pi4Dq4Di7GV4LxlWB8JRhfCcZX4uA6jm9gPwf2M8ZXgvtBCXAD3AAX4yvB+EowvhKMrwTjK0lwE8c3sZ8T+xnjK8H9oCS4CW6Bi/GVYHwlGF8JxleC8ZXAV1I4voX9POsZOurbO+rbO+rbO+rbO+rbO+rbu8JXCl8pfIX69q4N3FnP0BW+UvhK4SvUt3fF/JXCVwpfKXyl8BXq2zvq2zvq27t2cGc9Q1f4SuErha9Q394V81cKXyl8pfCVwleob++ob++ob+8q4AqOL3yl8JXCV6hv74r5K4WvFL5S+ErhK9S3d9S3d9S3d8X4SjG+UvhK4SuFr1Df3hXjK4WvFL5S+ErhK9S3d9S3d9S3d3VwHccXvlL4SuEr1Ld3xfyVwlcKXyl8pfAV6ts76ts76tu7JriJ4wtfKXyl8BXq27ti/krhK4WvFL5S+Ar17R317R317V0xvlKMrxS+UvhK4SvUt3fD+MrgK4OvDL4y+Ar17R317R317d0w325zfbAbfGXwlcFXqG/vhvkrg68MvjL4yuAr1Ld31Ld31Ld3w3y7zfXBbvCVwVcGX6G+vRvmrwy+MvjK4CuDr1Df3lHf3lHf3g3z7TbXB7vBVwZfGXyF+vZumL8y+MrgK4OvDL5CfXtHfXtHfXs33A+a4fjCVwZfGXyF+vZuuB80+MrgK4OvDL5CfXtHfXtHfXs3zLeb4/jCVwZfGXyF+vZumL8y+MrgK4OvDL5CfXtHfXtHfXs3zLdb4PjCVwZfGXyF+vZumL8y+MrgK4OvDL5CfXtHfXtHfXs3zLdb4fjCVwZfGXyF+vZuuB80+MrhK4evHL5CfXtHfXtHfXt3zLc71gcdvnL4yuEr1Ld3x/yVw1cOXzl85fAV6ts76ts76tu7Y77dsT7o8JXDVw5fob69O+avHL5y+MrhK4evUN/eUd/eUd/eHfPtjvVBh68cvnL4CvXt3TF/5fCVw1cOXzl8hfr2jvr2jvr27pi/csxfOXzl8JXDV6hv7475doevHL5y+MrhK9S3d9S3d9S3d8d8u2N90OErh68cvkJ9e3fMtzt85fCVw1cOX6G+vaO+vaO+vTvm2x3rgw5fOXzl8BXq27tjvt3hK4evHL5y+Ar17R317R317d0x3+5YH3T4yuErh69Q395R395R395R394dvkJ9ew/Mtwfmr1Df3lHf3lHf3lHf3p/17WP+81XfbiPP+bpXffuVG3JHFmRFNmRHDmRwG7gd3A5uB7eD28Ht4HZwO7gd3A6ugCvgCrgCroAr4Aq4Aq6AK+AquAou7gcD81eB+SvUt3fUt3fUt3fUt3fUt/eArwK+Qn17D/gq4KuArwK+Qn17R317R317D6wPBtYHA74K+CrgK9S398D8VcBXAV8FfBXwFerbO+rbO+rbe2B9MLA+GPBVwFcBX6G+vQfmrwK+Cvgq4KuAr1Df3lHf3lHf3gPrg4H1wYCvAr4K+Ar17T0wfxXwVWB9MDC+CoyvUN/eE+OrxPgK9e09Md+O+vaO+vaO+vaO+vaO+vaO+vaO+vaeGF8lxleJ8VVifJUYXyXm2xPrg4n1wUQ9Q2J8lbgfTMxfJeavEvPtifFVYnyVGF8lxleJ8VVivj2xPphYH0zUMyTGV4n7wcT8VWL+KjHfnhhfJcZXifFVYnyVGF8lfJVYH0R9e0d9e0d9e0d9e0d9e0d9e0d9e0d9e0/4KuGrhK9Q394T8+2JeoaErxK+SvgK9e09MX+V8FXCVwlfJXyF+vaO+vaO+vaemG9P1DMkfJXwVcJXqG/vifmrhK8Svkr4KuEr1Ld31Ld31Lf3xHx7op4h4auErxK+Qn17T8xfJXyV8FXCVwlfob69o769o769F8ZXhfFVwVcFXxV8hfr2XhhfFXxV8FXBVwVfob69o769o769F+bbC+uDBV8VfFXwFerbe2H+quCrgq8Kvir4CvXtHfXtHfXtvTDfXlgfLPiq4KuCr1Df3gvzVwVfFXxV8FXBV6hv76hv76hv74XxVWF8VfBVwVcFX6G+vRfGVwVfFXxV8FXBV6hv76hv76hv74X59sL6YMFXBV8VfIX69l6Yvyr4quCrgq8KvkJ9e0d9e0d9ey/MtxfWBwu+Kviq4CvUt/fC/FXBVwVfFXxV8BXq2zvq2zvq23thvr2wPljwVcFXBV+hvr0X5q8Kvir4quCrgq9Q395R395R394L94M11wflmL6SY/pKjukrQX27HPN+UI7pKzmmr+SYvpJj+kpQ3y6obxfUt8vRwJ3rg3JMX8kxfSXH9JWgvl2OBm4Dt4PbwZ2+EtS3C+rbBfXtcnRw5/qgHNNXcnTsZ8F+FnAFXAFXwBVwBftZsL2C7RVsr4KrOL6K/azYz4r9rOAquAqugqvgGvazYXsN22vYXgPXcHwN+9mwnw372cB1cB1cB9fBdexnx/Y6ttexvQ6u4/gG9nNgPwf2c4Ab4Aa4AW6AG9jPge1NbG9iexPcxPFN7OfEfk7s5wQ3wU1wC9wCt7CfC9tb2N7C9ha4heNb2M/wVYOvUN8ubc63S4OvGnzV4KsGX6G+XVDfLqhvl9bAneuD0uCrBl81+Ar17dIauPBVg68afNXgK9S3C+rbBfXt0jq4c31QGnzV4KsGX6G+XZqAC181+KrBVw2+Qn27oL5dUN8uTcAVHF/4qsFXDb5Cfbugvl1Q3y6ob5cGX6G+XZqCa+DCV6hvF9S3C+rb5Vnffs5/yrO+/Xy9ozzr289XvMizvj2vvx/cGn9/+arG31++Khu5I59cOV+PKld9+yvbyKP94atXPrnSrvZz5Ovfa+bhq1duI49tH7565cE93zUuV337Kw9uH30evnrlwZXBHb6S81m+ctW3P/Pw1SsProxtGb565cGV0Yfhq1c25MGVGjmQB1fHfh6+eubhq1ceXBv9HL565cG10bfhq1ceXB/bPnz1yoE8uD72w/DVla/6djmfYStXfbucz4mVq779lQV5cM/nA8tV3/7KgxtXm4GcyIN7zvfKVd/+yoN7vk9Ervr2VxbkwR3n6lXf/sqDe77jQ6769lce3POdknLVtz/z8JXU2Jbhq1c+uXq+EVeu+vZXVmQbebQ/fPXKJ1fb6OfwlbarzRp5/M3w1fPfh69euSMLsiIbsqPNwL8n/r3mvyu4Cq72+fcKroKr4KojB/6/2F4F18C1Nv/esL0m+HdwzfDv4Bq218A17GcH18F1cB1cB9exvQ6uY3sdXMf2xjH/JrCfA/s5sJ9D8e/gBriB7Q1wA9wEN8FNbG+Cm+AmuInzKsFNcBPcwn4u7OcCt7CfC/u5wC1wC9wCtyb3qm9/5YbckQVZked5ddW3v/49kBN/A24Dt4Hb5vG96ttf/674d8O/g9sCf5P493k+X/Xtz3/vDf+O7e3gdmxvB7eD28GFr6Rje2WeVwJfCXwl8JXAVwJfiYAr4Aq48JXAVwJfCXwl8JXAV6I4vvCVwFcCXwl8JYbtNXANXAMXvhL4SuArMXDhKzFwHVwHF74SBxe+EvhK4CtxnM+O8xm+EvhK4CsJcOErCXDhK4GvBL6SABe+ksTxTZzP8JXAVwJfCXwl8JXAVwJfCXwl8JUUtrdwfAtc+EoKx7ewvYXjC19JzetX4SuFr/To+BvBvyuyITv+PvDviQwufKXwlbaODG4DF77SBm4DtyX+fe5nha+0g9uxvfCVdsW/g9vB7eB2cOErha8UvlL4SkXwN9he+ErhK8X4SuErFexn+ErhK1VwFVz4SjG+UvhKFVz4ShVcjK8U4yvF+EoxvlL4SuErha8U4yuFrxTjK8X4SjG+UvhK4St1HF/4Sh3HF75S+ErhKw1w4SvF+ErhK4WvNLC98JVG4N+xvYHtha8U4yuFrxS+0gQ3wU1w4SuFrzTBha8UvlKMrxS+0sJ+xvhK4SuFrxS+UoyvDL4y+MowvrJjnlcGXxnGV4bxlR2Bf0/8+9xeg6+sNfw7uPCVwVcGXxnGV4bxlWF8ZRhfGXxlGF8ZxlfWsb0YX1nH9mJ8ZfCVwVcGXxnuB03Aha8MvjL4yuArg68M4yuDrwzjK4OvTMGFrwy+MvjKML4y+MowvjL4yuCrq7798e0w8uCOuZqrvl3H/MxV3/7KimzIjhzIiVwzX7565oYMroPr4Dq4Dq6D6+A6uAFugBvgBrgBboAb4Aa4l6+6jlwzX7565oZ8cW1kQQY3wU1wE9zE9ia2t7C9he0tbG9hewvcArfALXAL3Jrcq779lRtyRxZkRTZkRw7kRJ77+apvf+WG3JHnfr7q218Z3AZuA7eB27C9Hdvbsb0d29uxvR3b28Ht4HZwO7gdXAFXwBVwBVwBV8AVcAVcAVewnxX7WbGfFftZsZ8V+1nBVXAVXAVXsb2G7TVsL3zl8JXDVw5fOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDVw5fuU9vuGM/B/ZzYD/H9IYH9jN85fCVw1cOX3lgewPbm9jexPYmtjexvfCVw1cOXzl85fCVw1cOXzl85fCVw1cOXzl85U9fjX319NWVsZ9r7ud4+spGbsiTG/BVwFcBXwV8FfBVwFdxzO2NdiA3ZHAbuA1c+Crgq4CvAr4K+Crgq4CvAr6Kp6/G/nn66sqG7Mgx99vTV1cGF74K+Crgq4CvAr4K+Crgq4CvAr4KAVfBVXAVXAVXwYWvAr4K+Crgq1CcV3YgN+SOPK/fMEUGF74K+Crgq4CvAr4K+Crgq4CvAr4K+Crgq4CvAuOrwPgqML4KjK8C46vA+CoC51XgvAqcVxHIOK+evhoZvgr4KuCrgK8Cvgr4KuCrgK8Cvgr4KuCrgK8Cvgr4KuCrgK8C46vA+Crgq4Cv8jiQG/L8XshDkCc34auErxK+Svgq4auErxK+Svgq4auErxK+Svgq4auErxK+SvgqO7a3d2RBVmSb++HpqyuDi/FVwlcJXyV8lfBVwlcJXyV8lfBVwlcJXyV8lfBVwlcJX6ViexXbq4bsyNPPqYkMLsZXifFVYnyVGF8lxlcJXyV8lfBVwlcJXyV8lfBVwlcJX6Vjex3b69heD2Rsr09vJHyV8FXCVwlfJcZXifFVYnyVGF8lxleJ8VXCVwlfJXyV8FUmtjexvYntTWxvYnsT2wtfJXyV8FXCVwlfJXyV8FXCV4n7wcT9YOF+sHA/WBhf1THP5zoU2ZAdeZ7PdSQyuPBVwVcFXxV8VfBVwVcFXxV8VfBVwVcFXxV8VfBVwVcFXxV8VfBVwVcFXxV8VfBVwVcFXxV8VfBVwVcFXxV8VTK/jwr3g4X7wcL9YOn8PircDxbGV4XxVWF8VRhfFcZXBV8VfFXwVcFXBV+VYT8bzivDeWWBjPPK5nVU8FXBVwVfFXxVGF8VxleF8VVhfFUYXxXuBwv3g4X7wQqcV7gfrFBkcOGrgq8Kvir4quCrgq8KvqrE+QxfFXxV8FUlrl/4qjC+Kviq4KuCrwq+Kviq4KvC/WDhfrAwvqo5vtJj3g/qMe8H9Zi+0mPeD+oxx1d6zPGVHnN8pcccX+lxJFjgzvkrPeb8lR6tzz7M+Ss9GrgN3AZuA3f6So8Gbge3gzt9pUcHtysyuB3cDm4Ht4Mr4Aq4Aq6AK+AKuAKugCvYzwKugqvgKvazgqvYzwruHF/poYEMroJrOK8M55XhvDLB3yuyIYNrgXYSGVzH9jq217GfHdvr2M+Xr876TL3q2185kBN5cKWd+fLVMw+uDNblK/GRBVmRL26O7MiDq1ebiVwzX7565sHVsW8vXz3z4J61mnrVt7+yIQ+ujT5fvnrmwbUYuWa+fGU1ckMeXB/bdfnqmQc3xn6+fPXMjjy4cbWfyIOb5zZe9e2vPLhnLbFe9e2vPLhn/bBe9e2PVcuRDdmRB7d05EQe3Dr7cNW3v3JDHtyqkQX55D5WG0c2ZEc+udZGP4evXrlGHn0bvnrlk2t9bPvw1SsL8uCO6+uqb3/lwR3n+VXf/sqJPLh9bNfw1Ss35MEd5/lV3/7KgyvX3wyujm0ZvnrlQE7kmnn46pUbckcWZEUGV8FVcBVcBdfANXANXAPXwDVwDVwD18A1cB1cB9fBdXAdXAfXwXVwHVwHNy7uOK+iIXfkizvOn1BkQ3bkQE60UzMnuNnm32dHBjfBTXAT3AQ3wU1wC9zC9ha2t8AtcAvcArfArUSuO1/17a/ckCf3qm9/ZUU2ZEcOtJPI4DZwG7itIwuyIhsyuJevnjmR536+6ttfGdwObge3g9vB7Y6M7e3Y3o7tFXClIWM/C/azYD8LuAKugCvgCriK/azYXsX2KrZXwVUcX8V+VuxnxX5WcA1cA9fANXAN+9mwvYbtNWyvgWs4vo797NjPjv3s4Dq4Dq6D6+A69rNjewPbG9he+KoHjm9gPwf2c2A/w1c9wA1wE1z4qsNXHb7q8FWHr3qCmzi+8FWHrzp81QvcAhe+6vBVh686fNXhqw5fdfhKjsmVoyF3ZEFWZEM7jhzIiQwufCXwlcBXAl9JA7cZsiMHciKD28GFrwS+EvhK4CuBrwS+EvhKOrh9Hl+BrwS+EvhKBFwBF74S+ErgK4GvBL4S+ErgK1FwFccXvhL4SuArUXAVXPhK4CuBrwS+EvhK4CuBr8TANRxf+ErgK4GvxMF1cOErga8EvhL4SuArga8EvhKMrwTjK4GvBL4S+EowvhKMrwS+EvhK4CuBrwS+EvhK4CtJcBPHF74S+ErgK0lwC1z4SuArga8EvhL4SuArga+kwK15fBW+UvhK4Ss9JlcPRTZkRw7kRJ7bq/CVwlfawG2CrMiG7MjgNnDhK4WvFL5S+ErhK4WvFL7SDm4P5ETGfoavVMAVcOErha8UvlL4SuErha8UvlIFV3F84SuFrxS+UgVXwYWvFL5S+ErhK4WvFL5S+EoNXMPxha8UvlL4Sg1cBxe+UvhK4SuFrxS+UvhK4St1cB3HF75S+ErhK8X9oOJ+UOErha8UvlL4SuErha8UvtIEN3F84SuFrxS+UtwPaoILXyl8pfCVwlcKXyl8pfCVFriF4wtfKXxl8JXhftCOjizIimzIjhzIiTy31xq4rSF3ZEFWZHAbuPCVwVcGXxl8ZfCVwVcGX1kHtxuyIwdyIoMr4MJXBl8ZfGXwlcFXBl8ZfGUCruD4wlcGXxl8ZbgfNAUXvjL4yuArg68MvjL4yuArM3ANxxe+MvjK4CvD/aAZuPCVwVcGXxl8ZfCVwVcGX5mD6zi+8JXBVwZfGe4HDb4yjK8M4yuDrwz3gxbgYv7K4CuDrwy+Moyv7OkrG3lwz+cn6FXf/sqOPLjWRk7kwbXRzuWrZx7cMQ9/1be/8uC6jjy4Y+79qm9/ZUce3PO5CnrVt7/y4MbZh6u+/ZUb8uCez1XQq779lQc3+8iG7MiDez5XQa/69lce3PO5CnrVt7/y4J7P+tCrvv2VBXlwx5z8Vd/+yif3sRUjx8ijD8NXr1wzD1/5MfozfPXKfeTR5vDVKyuyjVwjO/Lgnr9J0au+/ZVr5uEr76Ofw1evPLhjDv+qb3/lwR3z9ld9+ysProxtGb565cEd60RXffszD1+98uCOc/iqb3/lwdWxH4avXnlwx3l+1be/ciAncs1sB3JD7siCrMjgGrgGroFr4Dq4Dq6D6+A6uA6ug+vgOrgOboAb4Aa4AW6AG+AGuAFugDt85cMtV337KzfkjizIimzIjhzIiXxxRx/qQL6445ypjiz4G0U2/I0jB/4mkS/ueQ1e9e3Xv1/17a88uVd9+ysr/saQHX8TyIm/mdt71bc/+9DAbR0Z3KbI4F6+emZwL189M7gd23v56upDB7cLMrjdkMHtgQzu5asrC7iC7b18dfVBwBXsZwFXsJ8FXMF+FnAvXz0zuIrtvXx19UHBVexnBVexnxVcxX42cK0hg2vY3stXVx8MXMN+NnAN+9nAdexnB9dxPju4ju29fHX1wcF17GcH17GfA9zAfg5wA+dzgBvY3stXVx8uXz3z4J7PhtKrvv2ZL189c0PuyIKsyIPrg3v56pkDOZFr5stXz9yQO7IgKzK4l6/OZ1LpVd/+yok8uGMcddW3P2w/ckPuyIKsyIM7aiSu+vaH+UcO5ESumS9fPXND7siCPLijvuKqb3/lwU0beXBz9Ofy1TPXzJevnrkhd2RBVmRDduTBHbUcV337K9fMl6+euSF3ZEFWZEN2ZHAFXAFXwVVwFVwFV8FVcBVcBVfBVXANXAPXwDVwDVwD18A1cA1cA9fBdXAdXAfXwXVwHVwH18F1cAPcADfADXAD3MtX5SOf3Bhj/qu+/TEqGDmRa+bhq1duyB1ZkBXZkB0Z3AQ3wS1wC9wCt8AtcAvcArfALXBrcq/69lduyIPbZGRBVmRDduRATuSaefjqlRsyuA3cBm4Dt4HbwG3gNnA7uB3cDm4Ht4Pbwe3gdnA7uB1cAVfAFXAFXAFXwBVwBVwBV8BVcBVcBVfBVXAVXAVXwVVwFVwD18A1cA1cA9fANXANXAPXwHVwHVwH18F1cB1cB9fBdXAd3AA3wA1wA9wAN8ANcAPcADfATXAT3AQ3wU1wE9wEN8FNcBPcArfALXAL3AK3wC1wC9wCt26uXfXtr9yQO7IgK7IhO3IgJzK4DdwGbgO3gdvAbeA2cBu4DdwGbge3g9vB7eB2cDu4HdwObge3gyvgCrgCroAr4Aq4Aq6AK+AKuAqugqvgKrgKroKr4Cq4Cq6Ca+AauAaugWvgGrgGroFr4Bq4Dq6D6+A6uA6ug+vgOrgOroMb4Aa4AW6AG+AGuAFugBvgBrgJboKb4Ca4CW6Cm+AmuAluglvgFrgFboFb4Ba4BW6BW+DCVw2+avBVg68afNXgqwZfNfiqwVcNvmrwVYOvGnzV4KsGXzX4qsFXDb5q8FWDrxp81eCrBl81+KrBVw2+avBVg68afNXgqwZfNfiqwVcNvmrwVYOvGnzV4KsGXzX4qsFXDb5q8FWDrxp81eCrBl81+KrBVw2+avBVg68afNXgqwZfNfiqwVcNvmrwVYOvGnzV4KsGXzX4qsFXDb5q8FWDrxp81eCrBl81+KrBVw2+avBVg68afNXgqwZfNfiqwVcNvmrwVYOvGnzV4KsGXzX4qsFXDb5q8NVV3x7nmpFd9e2PGeCRB/dcG7Krvv2VFXlwz99u2FXfHuez4u2qb3/lwdUrD+65RmlXffsrD+65/mhXffsrC/LgxvX3huzIgZzIgxt+5stX59yUXfXtrzy457sG7Kpvf2VFHtxzzsqu+vZXDuTBzYs1uDXaH77KY/z78NUrd2QZ+fp7RTbkk5vn2p9d9e3ZxzYOX73yyU0ZfR6+ynPtz6769pSxP4evXhnbK9je4auU0bfhq1cO5ESumYevcpwbV337K3dkQVZkQ3bkQE7kmtnANXANXLu4Yx+aIhuyIwdyItfMfiA35I4MroPr4Dq4Dq6D6+AGuAFugBvgBrgBboAb4Aa4AW6Cm+AmuAlugpvgJrgJboI7fJVnTYVd9e2v3JAH9/LJ8FXaOLeHr155cH1cC8NXj1nKkQfXx7kxfPXKdeervv2VG/LgnvUJdtW3v7IiG7IjB3Ii18zDV6/ckMFt4DZwh6+yruzIJ/cxCzdyjmwj18hju4avXrmNXCN35JNbbbQ5fPXKhuwj68iBPLjDS1d9+zMPX73y4I7vmqu+/ZUHt48+DF89ZrRGNmRHDuTBHd676tufefjqlRvy4I7vsqu+/ZUHd5x7V337K1/c0c/hq9LBHb565ZrZcF4ZzqvLV898cY+RFdmQB1dHny2QB9cu1uDaaHP46pUbckcWZEUe3Ktvw1evHMiJPLg+9tvw1Ss35I48uDG2a/jqlQc3rzy413k+fPXKg5tj24evnnn46pUbckce3PE9ftW3v7IhO3IgJ3LNXAdyQ+7I4Ba4BW6BW+AWuDW5V337KzfkjizIimzIjhzIiQxuA7eB28Bt4DZwG7gN3AZuA7eB28Ht4HZwO7gd3A5uB7eD28Ht4Aq4Aq6AK+AKuAKugCvgCrgCroKr4Cq4Cq6Cq+AquAqugqvgGrgGroFr4Bq4Bq6Ba+AauAaug+vgOrgOroPr4Dq4Dq6D6+AGuAFugBvgBrgBboAb4Aa4AW6Cm+AmuPCVwlcKXyl8pfCVPn3lI9fM1/hqfPdd9e2vfHFjZEFWZEN25EBO5LqzPX115YbckQVZkQ3ZkQM5kcFt4DZwG7gN3AZuA7eB28Bt4DZwO7gd3A5uB7eD28Ht4HZwO7gdXJnjdhNwBVwBV8AVcAVcAVfAFXAV26vgKrgKroKr4Cq4Cq6Cq+AauAaugWvgGrgGroFr4Bq4Bq6D6+A6uA6ug+vgOrgOroPr4Aa4AW6AG+AGuAFugBvgBrgBboKb4Ca4CW6Cm+AmuAlugpvgFrgFLnxl8JXBVwZfGXxl8JXBVwZfOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDV/70lY885q+ijzzmc8a9sD/nr65/H/NX4x7qqm+/xvNXffsrD25df1MzX7565sEd81pXffsrP7jn265H1pF1ZBt5tH/66s6BnMg18+mrOzfkjizIigyugCvgCrgCroKr4Cq4Cq6Cq+AquAqugqvgGrgGroFr4Bq4Bq6Ba+AauAYu5q9Gffv5hvGRr+M7zrHn/NU4ptf8lV3/PrhtnBuXr67zwQd3zEmO+vY718xxIDfkjizIimzIjgxugBvg5sUd10WCm+AmuAluGv6/4Ca4CW6CW+BWQ+7IgqzI4JYjB3Ii151HffudG/LFlZEHd8wnjPr2OxuyIwdyItfM7UBuyB0Z3AZuA7eB28Bt4DZwO7gd3A5uB7eD28Ht4HZwO7gdXAFXwBVwBVwBV8AVcC9fyThel6+euWa+fDXmuOLy1TN3ZEFWZEM7jgzu5avn39fMBq6Ba+AauAaugWvgGriG7TVsr4Pr4Dq4Dq6De/nqmR05kLG9Du7lq2duyB1ZkMENcAPcADfADeznxPYmtjexvQnu5atnxn5O7OfEfk5wE9wCt8AtcAv7ubC9he0tbG+BWzi+NfdzHgdyQ57cPARZkQ3ZkQM5kef2ZjuQwW0dWZAV2ZDBbeA2cBu4HdzekLG9Hdvbsb0d3O7IgZzI2M8CroAr4Aq4Aq5gPwu2V7C9gu2Fr1JxfBX7WbGfFfsZvkoFV8FVcOGrhK8Svkr4KuGrNHANxxe+Svgq4as0cA1c+Crhq4SvEr5K+Crhq4Sv0sF1HF/4KuGrhK8ywA1w4auErxK+Svgq4auErxK+ygQ3cXzhq4SvEr7KBDfBha8Svkr4KuGrhK8Svkr4KgvcwvGFrxK+SviqjsmtoyF3ZEFWZEN25EBOZHDbgdyQO7Igg9vAha8Kvir4quCrgq8Kvir4qjq4XZEN2ZEDGdwOLnxV8FXBVwVfFXxV8FXBV4XxVWF8VfBVwVcFXxXGV4XxVcFXBV8VfFXwVcFXBV8VfFUGruH4wlcFXxV8VQaugQtfFXxV8FXBVwVfFXxV8FU5uI7jC18VfFXwVQW4AS58VfBVwVcFXxV8VfBVwVcV4CaOL3xV8FXBV5XgJrjwVcFXBV8VfFXwVcFXBV9VgVs4vvBVwVcFX1WBWzfXj+krP6av/Ji+8mP6yo/pKz+mr/yYvvLjuLl+HIlcM09f+TF95UcDt4HbwG3gNnCnr/yYvvKjYXs7treD2zuyICuyIYPbwe3gdnAFXMF+FmyvYHsF2yvgiiNjPwv2s2A/K7gKroKr4Cq4iv2s2F7F9iq2V8E1HF/DfjbsZ8N+NnANXAPXwDVwDfvZsb2O7XVsr4PrOL6O/ezYz4797OA6uAFugBvgBvZzYHsD2xvY3gA3cHwD+zmxnxP7OcFNcBPcBDfBTeznxPYmtrewvQVu4fgW9nNhPxf2c4Fb4Ba48FWDrxp81eCrBl81+Kodk9sORw7kRJ77uTVwG7jwVYOvGnzV4KsGXzX4qsFXrYHbD+SG3JEFGdwOLnzV4KsGXzX4qsFXDb5q8FUTcEWRsZ/hqwZfNQEXvmqK7VVsL3zVFFwFV8GFrxp81eCrptjep69s5Hu+zpt1ZEFWZEN25EBO5JrZD2RwHVwH18F1cB1cB9fBdXAD3AA3wA1wA9wAN8ANcAPcADfBTXAT3AQ3wU0c38R5lTiv4KsGXzX4qhXO58J5BV81+KrBVw2+avBVg68afNXhqw5fdfiqH5PbD0U2ZEcO5EQ74MJXHb7q8FWHrzp81eGrDl/1Bm5L5Hn9dviqw1e9g9vBha86fNXhqw5fdfiqw1cdvuoCrnRk7Gf4qsNXXcAVcOGrLuBifNUxvurwVcf4qmN81eGrrji+iv2s2M8YX3UD18A1cA1cjK86xlcd46uO8VXH+KobuI7j69jPjv2M8VV3cB1cB9fBxfiqY3zVMb7qGF91jK96gBs4voH9HNjPGF/1ADfATXATXIyvOsZXHeOrjvFVx/iqw1c9cXwT+7mwnzG+6vBVL3AL3AIXvurwVYevOnwl8JXM+XaXoyMLsiIbsqOdQE5kcOErga8EvhL4SuAraeA2Rw7kRJ77WXA/KB1c+ErgK4GvBL4S+ErgK4GvpIMrBzL2M3wl8JXgflAEXPhK4CuBrwS+EvhK4CuBrwTjK8H4SuArga8EvhKMrwTjK4GvBL4S+ErgK4GvBL4S+EoMXMPxha8EvhL4SnA/KA4ufCXwlcBXAl8JfCXwlcBXEuAGji98JfCVwFeC+0EJcOErga8EvhL4SuArga8EvhKMrwTjK4GvBL4S+EowvhKMrwS+EvhK4CuBrwS+EvhK4CuZ8+2uc33QFb5S+ErhK8X9oGL+SuErha8UvlL4SuErha8UvtIG7lwfdIWvFL5S+EpxP6iYv1L4SuErha8UvlL4SuErha+0gzvXB13hK4WvFL5S3A8q5q8UvlL4SuErha8UvlL4SuErxf2gKo4vfKXwlcJXivtBxf2gwlcKXyl8pfCVwlcKXyl8pQau4fjCVwpfKXylmL9SzF8pfKXwlcJXCl8pfKXwlcJX6uAGji98pfCVwleK+SvF/JXCVwpfKXyl8JXCVwpfKXylCW7i+MJXCl8pfKW4H1TcDyp8pfCVwlcKXyl8pfCVwlda4BaOL3xl8JXBV4b7QcP8lcFXBl8ZfGXwlcFXBl8ZfGWYb7e5PugGXxl8ZfCV4X7QMH9l8JXBVwZfGXxl8JXBVwZfGebbba4PusFXBl8ZfGW4HzTMXxl8ZfCVwVcGXxl8ZfCVwVeG+SvD/JXBVwZfGXxluB80zLcbfGXwlcFXBl8ZfGXwlcFXhvl2Mxxf+MrgK4OvDPeDhvl2g68MvjL4yuArg68MvjL4yjDfbo7jC18ZfGXwleF+0DDfbvCVwVcGXxl8ZfCVwVcGXxnm2y1xfOErg68MvjLcDxp8ZRhfGcZXBl8Z7gcN8+2G+SuDrwy+MvjKML6yp69s5Dlf58eB3JA7siArsiE7ciAnMrgN3AZuA7eB28Bt4DZwG7gN3AZuB7eD28Ht4HZwO7gd3A5uB7eDK+AKuAIu7gcd81eO+SuHrxy+cvjKMb5yjK8cvnL4yuErh68cvnL4yuErh68cvnL4yrE+6FgfdPjK4SuHrxz3g475K4evHL5y+MrhK4evHL5y+MqxPuhYH3T4yuErh68c94OO+SuHrxy+cvjK4SuHrxy+cvjKsT7oWB90+MrhK4evHPeDjvkrh68c64OO8ZVjfOXwlWN85RhfOXzlmG93zLd7YT9jfOW4H3TMXwXmrwLz7YHxVWB8FRhfBcZXgfFVYL49sD4YWB8M1DMExleB+8HA/FVg/iow3x4YXwXGV4HxVWB8FRhfBebbA+uDgfXBQD1DYHwVuB8MzF8F5q8C8+2B8VVgfBUYXwXGV4HxVcBXgfVB1Lc76tsd9e2O+nZHfbujvt1R3+6ob/eArwK+CvgK9e0emG8P1DMEfBXwVcBXqG/3wPxVwFcBXwV8FfAV6tsd9e2O+nYPzLcH6hkCvgr4KuAr1Ld7YP4q4KuArwK+CvgK9e2O+nZHfbsH5tsD9QwBXwV8FfAV6ts9MH8V8FXAVwFfBXyF+nZHfbujvt0D46vA+Crgq4CvAr5CfbsHxlcBXwV8lfBVwleob3fUtzvq2z0x355YH0z4KuGrhK9Q3+6J+auErxK+Svgq4SvUtzvq2x317Z6Yb0+sDyZ8lfBVwleob/fE/FXCVwlfJXyV8BXq2x317Y76dk+MrxLjq4SvEr5K+Ar17Z4YXyV8lfBVwlcJX6G+3VHf7qhv98R8e2J9MOGrhK8SvkJ9uyfmrxK+Svgq4auEr1Df7qhvd9S3e2K+PbE+mPBVwlcJX6G+3RPzVwlfJXyV8FXCV6hvd9S3O+rbPTHfnlgfTPgq4auEr1Df7on5q4SvEr5K+CrhK9S3O+rbHfXtnrgfTKwPJnyV8FXCV6hv98T9YMJXCV8lfJXwFerbHfXtjvp2L8y3F9YHC74q+KrgK9S3e2H+quCrgq8Kvir4CvXtjvp2R327F+bbC+uDBV8VfFXwFerbvTB/VfBVwVcFXxV8hfp2R327o77dC/PthfXBgq8Kvir4CvXtXrgfLPiq4KuCrwq+Qn27o77dUd/uhfn2wvpgwVcFXxV8hfp2L8xfFXxV8FXBVwVfob7dUd/uqG/3wnx7YX2w4KuCrwq+Qn27F+avCr4q+Krgq4KvUN/uqG931Ld7Yb69sD5Y8FXBVwVfob7dC/NXBV8VfFXwVcFXqG931Lc76tu9MH9VmL8q+Krgq4KvUN/uhfn2gq8Kvir4quAr1Lc76tsD9e1xzPn2OOb6YBzTV3FMX8UxfRWob49jzrfHMX0VxwFuA3f6KlDfHqhvD9S3x9HAneuDcUxfxTF9Fcf0VaC+PY4Obge3g9vBnb4K1LcH6tsD9e1xdHDn+mAcgv0s2M+C/SzgCrZXsL2C7RVwBVwFV8FVbK9iexVcxfY+fWUj3/N18apvv3LNbAdyQ+7IgqzIhuzI4Bq4Bq6D6+A6uA6ug+vgOrgOroPr4Aa4AW6AG+AGuAFugBvgBrgBboKbOL6J8ypxXiWOb+L4Js7nxPmcOK8S51XhvCpwC+dV4bwqcAvcArfALXDn+mC0uT4YDb5q8FWDr1DfHm3OX0WDrxp81eCrBl+hvj1Q3x6ob4/WwJ3rg9HgqwZfNfgK9e3RGrjwVYOvGnzV4CvUtwfq2wP17dE6uHN9MBp81eCrBl+hvj2agAtfNQFXwBXsZ/iqCbZXsb3wVVMcX8V+VuxnxX5WcBVcBVfBNXAN+9mwvYbtNWyvgWs4vob9bNjPhv3s4Dq4Dq6D6+A69rNjex3b69heBzdwfAP7ObCfA/s5wA1wA9wAN8AN7OfE9ia2N7G98FVLHN/Efk7s58R+hq9Q3x6obw/Utwfq26PBVw2+avAV6tujFbiF4wtfdfiqw1eob48+56+iw1cdvurwVYevUN8eqG8P1LdHb+DOeobo8FWHrzp8hfr26A1c+KrDVx2+6vAV6tsD9e2B+vboHdxZzxAdvurwVYevUN8eXcCFrzp81eGrDl+hvj1Q3x6ob4+O8VXH+KrDVx2+6vAV6tujY3zV4asOX3X4qsNXqG8P1LcH6tujG7iG4wtfdfiqw1eob49u4MJXHb7q8FWHr1DfHqhvD9S3R3dwHccXvurwVYevUN8ePcCFrzp81eGrDl+hvj1Q3x6ob4+O8VXH+KrDVx2+6vAV6tujY3zV4asOX3X4qsNXqG8P1LcH6tujF7iF4wtfdfiqw1eobw+Z81ch8JXAVwJfCXyF+vZAfXugvj3kAHeuD4bAVwJfCXyF+vaQBi58JfCVwFcCX6G+PVDfHqhvD+ngzvXBEPhK4CuBr1DfHtLBha8EvhL4SuAr1LcH6tsD9e0huB+UuT4YAl8JfCXwFerbQ3A/KPCVwFcCXwl8hfr2QH17oL49xMA1HF/4SuArga9Q3x5i4MJXAl8JfCXwFerbA/Xtgfr2EAfXcXzhK4GvBL5CfXtIgAtfCXwl8JXAV6hvD9S3B+rbQwLcxPGFrwS+EvgK9e0huB8U+ErgK4GvBL5CfXugvj1Q3x5S4BaOL3wl8JXAV6hvD8H8lcJXCl8pfKXwFerbA/Xtgfr20DnfHjrXB0PhK4WvFL5CfXso5q8UvlL4SuErha9Q3x6obw/Ut4d2cOf6YCh8pfCVwleobw/F/JXCVwpfKXyl8BXq2wP17YH69lDMXynmrxS+UvhK4SvUt4cquPCVwlcKXyl8hfr2QH17oL49VME1HF/4SuErha9Q3x5q4MJXCl8pfKXwFerbA/Xtgfr2UAfXcXzhK4WvFL5CfXuogwtfKXyl8JXCV6hvD9S3B+rbQwPcwPGFrxS+UvgK9e2B+vZAfXugvj0UvkJ9e2iCi/kr1LcH6tsD9e2B+vZ41bfbyBc3Rx5cbSMPrl5/P7h6/f3g6vn3z/p2O0ZuyINrNbIgD663kQ15cN1GHty4/j2Ra+bLV+dzj+NZ3/7Mg3u+8yue9e3PPLgx+nz56pkHNwf38tX5jOV41rc/c818+SrHtly+eubBrdGHy1fPrMiDWzqyI5/cxyzfyIlcMw9ftWP0c/jqlfvIo2/DV698ch+zcyMbsiMPbhv7YfjqlQe3j/08fNX66MPw1St35MHtoz/DV688uH20OXz1yoE8uGO+96pvf+bhqyZj3w5fvXJHHtxxrl717a88uDr27fDVKw+ujm0fvnrlwbWxLcNXrzy4Po7d8NUrC/Lg+mh/+OqVBzeudgY3Rp+Hr1pe/9+aefjqlRtyRxZkRTZkRw5kcAPcBDfBTXAT3AQ3wU1wE9wEN8EtcAvcArfALXAL3AK3wC1wa3Kv+vZXbsgd+eLqyIpsyBfXRg7kRK6Z24HcZjutI4PbFH9vyOA2cBu4DdwObge3g9vB7djeju3t4HZwO7gdXAH38tUzd2RBxvYKuJevnjmQE7lmVnAVXAVXwVVwFftZsb2K7VVsr4J7+eqZsZ8N+9mwnw1cA9fANXANXMN+dmyvY3sd2+vgOo6vYz879rNjPzu4Dm6AG+AGuIH9HNjewPYGtjfADRzfwH5O7OfEfk5wE9wEN8FNcBP7ObG9ie0tbG+BWzi+hf1c2M+F/VzgFrgFbk1uHAdyQ+7IgqzIkxuHIwdyIs/9HPBVNHAbuA1c+Crgq4CvAr4K+CoauP1AbsgdWZDB7eDCVwFfBXwV8FXAVwFfBXwVAq4oMvYzfBXwVQi4Ai58FfBVwFcBXwV8FfBVwFeh4CqOL3wV8FXAV2HgGrjwVcBXAV8FfBXwVcBXAV+Fg+s4vvBVwFcBX4WD6+DCVwFfBXwV8FXAVwFfBXwVAW7g+MJXAV8FfBUJboILXwV8FfBVwFcBXwV8FfBVJLiF4wtfBXwV8FUUuAUufBXwVcBXAV8lfJXwVcJXifFVYnyV8FXCVwlfJcZXifFVwlcJXyV8lfBVwlcJXyV8lQ3clshzPyd8lfBVdnA7uPBVwlcJXyV8lfBVwlcJX6WAKx0Z+xm+SvgqBVwBF75K+Crhq4SvEr5K+Crhq1RwFccXvkr4KuGrNHANXPgq4auErxK+Svgq4auEr9LAdRxf+Crhq4Sv0sF1cOGrhK8Svkr4KuGrhK8SvsoAN3B84auErxK+ygA3wIWvEr5K+Crhq4SvEr5K+CoT3MTxha8Svkr4KgvcAhe+Svgq4auErxK+Sviq4Ks6JreOjizIimzIjnYCOZHBha8Kvir4quCrgq+qgdscOZATee7nwv1gdXDhq4KvCr4q+Krgq4KvCr6qDq4cyNjP8FXBV4X7wRJw4auCrwq+Kviq4KuCrwq+KgVXcXzhq4KvCr4q3A+WggtfFXxV8FXBVwVfFXxV8FUZuIbjC18VfFXwVeF+sBxc+Krgq4KvCr4q+Krgq4KvKsANHF/4quCrgq8K94MV4MJXBV8VfFXwVcFXBV8VfFUJbuL4wlcFXxV8VbgfrAIXvir4quCrgq8Kvir4quCrqpubx3EgN+SOLMg3N4/pqzzm+CqPOb7KY/oqjwPcBm4Dd/oqj+mrPBq4c3yVx9NXMfLgnnPjedW3v3LNfPmqZOSGPLg12rl89cyDe76HLq/69lc+uf3wkWPkHDmRa+bhq96OkRtyH3n0YfjqlRXZRh7bO3z1yoPbx34bvnrlmnn4qvfRz+GrVx7cPvo2fPXKgytj24evXtmRB1fGfhi+euXB1bGfh6+6jj4MX71yRx5cHf0ZvnrlwdXR5vDVKwfy4J7vpsyrvv2Zh6+6j307fPXKHXlwffRz+OqVB9fHvh2+euXB9bHtw1evPLgxtmX46pUHN8exG756ZUEe3OscHr565cHNsR+Gr155cK/zfPjqmYevXrkhd2RBVmRDduRABjfBLXAL3AK3wC1wC9wCt8AtcGtyr/r2V27IHVmQFdmQHTmQExncBm4Dd/iqVxtZkBXZkB05kBO5Zh6+euWGfHF9ZEG+uDayITv+JpATf1MzX766/uby1TNf3BwZ3MtXzwzu5atnBvfy1TODe/nqmcFVbO/lq6sPCu7lq2cG9/LVM4N7+erKBu7lq2cG17C9l6+uPhi4hv1s4Br2s4Hr2M8O7uWrZwbXsb2Xr64+OLiO/ezgOvZzgBvYzwHu5atnBjewvZevrj4EuIH9HOAm9nOCm9jPCW7ifE5wE9t7+erqQ4Kb2M8FbmE/F7iF/VzgFs7nArewvZevrj7U5F717a88uVd9+ysL/kaRDX/jyIG/SeS6+3DVt7/yyZWjj9yRBVmRDdmRAzlHHtzhq2cevnrlhtyRBVmRDdmRAxnc4Stppw+v+vZXbsiD20afh69kjJ2u+vZXNmRHDuTBbWN/Dl89BnZnHr565YbckQVZkQ3ZkQd3jN+u+vZXvrhj2+3ijv4MX8lZh5NXffsrC7IiG7IjB3Ii18zDV68MroPr4Dq4Dq6D6+A6uA5ugBvgBrgBboAb4Aa4AW6AG+AmuAlugpvgJrgJboKb4Ca4CW6BW+AWuAVugVvgFrgFboFbF/ccz1z17TLG51d9u5w1WnnVt7+yICuyITtyICdyzdwOZHAbuA3cBm4Dt4HbwG3gNnA7uB3cDm4Ht4Pbwb18ddb55FXf/sqJXDNfvnrmhtyRBVmRDRlcAVfAFXAVXAVXwVVwFVwFV8FVcBVcBdfANXANXAPXwDVwDVwD18A1cB1cB9fBdXAdXAfXwXVwHVwHN8ANcAPcADfADXAD3AA3wA1wE9wEN8FNcBPcBDfBTXAT3AS3wC1wC9wCt8AtcAvcArfArcm96ttfuSF3ZEFWZEN25EBOZHAbuA3cBm4Dt4HbwG3gNnAbuA3cDm4Ht4Pbwe3gdnDhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvFL5S+ErhK4WvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvDL4y+MrgK4OvHL5y+MrhK4evHL5y+MrhK4evHL5y+MrhK4evHL5y+Oqqb5exvnPVt8tY07nq22Ws41z17a+cyIMbI1++On9bkVd9+ysP7ph7v+rbZawbXvXtr3xy9biyj3y1GcgnV8c80lXf/szDV9rH3wxfvXJHPrkqYxuHr3Tcv1/17a88uHK1GciJPLhjze6qb3+MakYeXLv+vSML8uBe+3b46pUdeXBj7KvhKx3rYld9+zMPX+lYC7vq2/X8XVVe9e061lau+vZXHtwcfRi+emVHDuRErpmHrx7f/iM35I4syIpsyI4cyIlcMwe4AW6AG+AGuAFugBvgBrgBboKb4Ca4CW6Cm+AmuAlugpvgFrgFboFb4Ba4BW6BW+AWuDW5V337KzfkjizIinxx28iOHMiJXDO3A7khd2RBVmRwG7gN3AZuA7eD28Ht4HZwO7gd3A5uB7eD28EVcAVcAVfAFXAFXAFXwBVwBdzLV2Md5Kpvf+WOfHIfI+eRdeQY2ZBPrp2/W8yrvv0xWh755NqYh7/q2595+OqVG3JHHlwZfRi+emVDduRATuSaefjqlRtyRwbXwXVwh69MrxzIg2tjXw1fPUZ6Zx6+svF9etW3v/LgDs9f9e2vPLjj+/Sqb39lRx7cUTtx1be/8uAO/1/17a/ckAc3Rt+Gr155cHP0YfjqlQc3r/9vICdyzTx8ZeO75qpvf+WOLMiDO2qKrvr2Vx7c6zwcvnrlizv6PHxlY83uqm9/5YY8z6urvv2VFfnaXhnZkQN5cEct01Xf/szDVz7W0a76dh/1SFd9+ysLsiIbsiOfXL/6Nnz1yjXz8NUrD27vI3dkQVbkwe1ju4avXnlw5cqDO875q779mYevfKxxXPXtr9yRBVmRDdmRL26OnMg1sx7IDbkjC7IiG7Ijg6vgKrgGroFr4Bq4Bq6Ba+AauAaugevgOrgOroPr4Dq4Dq6D6+A6uAFugBvgBrgBboAb4Aa4AW6Am+AmuAlugpvgJrgJboKb4Ca4BW6BW+AWuAVugVvgFrgFbk3uVd/+yg25IwuyIhuyIwdyIoPbwG3gNnAbuA3cBm4Dt4HbwG3gdnA7uB3cDm4Ht4Pbwe3gdnA7uAKugCvgCrgCroAr4MJXBV8VfFXwVcFXBV8VfFVPX9XIhuzI131ZjJzIg6vnd8FV3/7KDbkjC7IiG7IjB3Iig+vgOrgOroPr4Dq4Dq6D6+A6uAFugBvgBrgBboAb4Aa4AW6Am+AmuAlugpvgJrgJboKb4Ca4BW6BW+AWuAVugVvgFrgFbt3cuurbX7khd2RBVmRDduRATmRwG7gN3AZuA7eB28Bt4DZwG7gN3A5uB7eD28Ht4HZwO7gd3A5uB1fAFXAFXAFXwBVwBVwBV8AVcBVcBVfBVXAVXAVXwVVwFVwF18A1cA1cA9fANXANXAPXwDVwHVwH18F1cB1cB9fBdXAdXAc3wA1wA9wAN8ANcAPcADfADXAT3AQ3wU1wE9wEN8FNcBPcBLfALXAL3Gv+6qzHq6u+fczx1lXfrnLle/65rvr2ca9UV337K1/cx/dptaevrtyQB/ecp62rvv2Vx/ae9+911bc/ZkFHHtt73rPXVd/+yolcM1++euaG3JEFWZENGdwGbgO3gdvB7eB2cDu4HdwObge3g9vB7eAKuAKugCvgCrgCroAr4Aq4Aq6C+/RVjXzPe1d7zl9d/35xr3+3edwvX53Pg6qrvv2VE7lmvnz1zA25IwuyIhsyuAbu5asY56GB6+A6uA6ug3v56mrHwXVwHVzH9l6+uv6/AW6AG+AGuAHu5atnduRAxvYGuJevnrkhd2RBBvfy1bkOVVd9u+c41pevnjmRa+bLV8/ckDuyICuyIYNb4Ba4NblXffsrN+SOLMiKbMiOHMiJDG4Dt4HbwG3gNnAbuA3cBm4Dt4F7+er8rWJd9e2v3JEvro2syIbsyIGcaKdmFnAvX11/f/nqmcEVcAVcAVfAFXAFXAVXsb2K7VVwFVwFV8FVcC9fPXPNfPnqmbG9Bu7lq2dWZEN2ZHANXAPXwXVwHfvZsb2O7XVsr4N7+eqZsZ8d+zmwnwPcADfADXAD3MB+DmxvYHsD25vgJo5vYj8n9nNiPye4CW6Cm+AmuIX9XNjewvYWtrfALRzfwn4u7OfCfq7JleNAbsgdWZAV2ZAdOZAnV455fKUdyA25I4PbwG3gNnAbuC2Rsb0d29uxvfCVdEFWZEN2ZHA7uB1cARe+EvhK4CuBrwS+EgFXAhn7Gb4S+EoUXAUXvhL4SuArga8EvhL4SuArMXANxxe+EvhK4CsxcA1c+ErgK4GvBL4S+ErgK4GvxMF1HF/4SuArga/EwQ1w4SuBrwS+EvhK4CuBrwS+kgA3cHzhK4GvBL6SBDfBha8EvhL4SuArga8EvhL4SgrcwvGFrwS+EvhKCtwCF75S+ErhK4WvFL5S+ErhKz0mV49ATuS5nxW+0gZuAxe+UvhK4SuFrxS+UvhK4SvF+EoxvlL4SuErha8U4yvF+ErhK4WvFL5S+ErhK4WvFL5SAVcMGfsZvlL4SgVcBRe+UvhK4SuFrxS+UvhK4StVcBXHF75S+ErhKzVwDVz4SuErha8UvlL4SuErha/UwXUcX/hK4SuFr9TBdXDhK4WvFL5S+ErhK4WvFL7SADdwfOErha8UvtIEN8GFrxS+UvhK4SuFrxS+UvhKC9zC8YWvFL5S+EoL3AIXvlL4SuErg68MvjL4yuArOybXDkN25EBOZHAbuPCVwVcGXxl8ZfCVwVcGX1kDt83ja/CVwVcGXxnuBw33gwZfGXxl8JXBVwZfGXxl8JUJuCLI2M/wlcFXhvtBE3DhK4OvDL4y+MrgK4OvDL4yBVdxfOErg68MvjLcD5qBC18ZfGXwlcFXBl8ZfGXwlTm4juMLXxl8ZfCV4X7QHFz4yuArg68MvjL4yuArg68swA0cX/jK4CuDrwz3g5bgwlcGXxl8ZfCVwVcGXxl8ZQlu4vjCVwZfGXxluB+0Ahe+MvjK4CuDrwy+cvjK4Ss/JtcPQVZkQ3bkQDuJDC585fCVw1cOXzl85fCVN3BbICfy3M8OXznuBx2+coyvHOMrh68c94PewcX8lcNXDl85fOUYX/nTVzHynK9zMWRHDuREnvN1rgdyQ+7IggyugqvgKrgKroJr4Bq4Bq6Ba+AauAaugWvgGrgOroPr4Dq4Dq6D6+A6uLgfdMxfOeavHL5y+MrhK8f4yjG+cvjK4SuHrxy+cvjK4SuHrxy+cvjK4StPcBNc+MrhK4evHPeDjvkrh68cvnL4yuErh68cvnL4Ko7JjaMhd2RBVmRDO44cyIkMLnwV8FXAVwFfRQO3GbIjB3Iig4v5q4CvooOL8VVgfBXwVWB8FRhfBXwVmG8PzLeHYD9jfBW4HwzMXwXmrwLz7YHxVWB8FRhfBcZXgfFVYL49FMdXsZ8V+xnjq8D9YGD+KjB/FZhvD4yvAuOrwPgqML4KjK8C8+1hOL6G/WzYzxhfBe4HA/NXgfmrwHx7YHwVGF8FxleB8VVgfBXwVQSOb2A/B/YzxlcBXwXmrwLzV4H59oCvAr4K+Crgq4CvAvPtkTi+8FXAVwFfBe4HA/NXAV8FfBXwVcBXAV8FfBXwVWC+PWoe34SvEr5K+CpxP5iYv0r4KuGrhK8Svkr4KuGrhK8S8+3P+vZnVmRDdmRwMX+V8FXCVwlfJXyV8FXCVwlfJcZXifFVwlcJXyV8lRhfJcZXCV8lfJXwVcJXCV8lfJXwVWK+PbE+mPBVwlcJXyXuBxPzVwlfJXyV8FXCVwlfJXyV8FVivj2xPpjwVcJXCV8l7gcT81cJXyV8lfBVwlcJXyV8lfBVYnyVGF8lfJXwVcJXifFVYnyV8FXCVwlfJXyV8FXCVwlfJebbE+uDCV8lfJXwVeJ+MDF/lfBVwlcJXyV8lfBVwlcJXyXm2xPrgwlfJXxV8FXhfrAwf1XwVcFXBV8VfFXwVcFXBV8V5tsL64MFXxV8VfBV4X6wMH9V8FXBVwVfFXxV8FXBVwVfFe4HC+uDBV8VfFXwVeF+sHA/WPBVwVcFXxV8VfBVwVcFXxXm2wvrgwVfFXxV8FVh/qowf1XwVcFXBV8VfFXwVcFXBV8V5tsL64MFXxV8VfBVYf6qMH9V8FXBVwVfFXxV8FXBVwVfFebbC+uDBV8VfFXwVeF+sHA/WPBVwVcFXxV8VfBVwVcFXxXm2wvrgwVfFXxV8FXhfrAwf1XwVcFXBV8VfFXwVcFXBV8V5tsL64MFXxV8VfBVzfvBdhxzAuv80Pih84Pwg/KD8YPzQ/DD3YHzQ+HDVNf5ofFD5wf2oLEHjT1o7EFjD6bCzg/cB537oHMfdPZgzmudH5QfjB+cH9iDzh509kDYA2EPhEdBuA+E+0C4D4Q9mKuI5wceBeFRUB4FZQ+UPVD2QNkDZQ+UR0G5D5T7QLkPjD0wngfGo2A8CsajYOyBsQfGHhh7YOyB8yg494FzHzj3gbMHzvPAeRScR8F5FJw9CO6D4D4I7oNgD4I9CPYg2IPgPgjug2APkvvgacC4PtxTgOcH4QflB+MH54fgh+SHwodZinp+aPzAHhR7UOxBsQfFHhR7UOxBoQftOPih8UPnB+EH5QfjB+eH4IfkB/agsQeNPWjsQWMPGnvQ2IOG86C14IfkB5wHjU5sdGLrnR+EH3AmNjqx0YmNTmx0YqMTG53Y6MRGJzY6sQl7IOwBndjoxEYnNmEPlD2gExud2OjERic2OrHRiY1ObMoeKKzc6MRGJzY6sRl7YOwBndjoxEYnNjqx0YmNTmx0YnP2wIUfeBToxEYnNmcPnD2gE1uwB8EeBI8CndiC+yC4D+jEFjwPgkcheBSSRyHZg2QPkj1I9iDZg+RRSO6D5D5I7oNiD4rnQfEoFI9C8SgUe1DsQbEHxR5wnNg5TuwcJ3aOEzvHif1AD/ph/OD8EPyQ/MAeNPagsQeNPeA4sXOc2DlO7Bwndo4TO53YG84DFO+fHxo/dH5gDzp70NmDzh7QiZ1O7HRipxM7ndiFPRDhBx4FOrHTiajmPz+wB3RipxM7ndjpxE4ndjqx04ld2QPleUAndjqx04mo7T8/sAd0YqcTO53Y6cROJ3Y6sdOJ3dkD53lAJ3Y6sdOJqPQ/P7AHdGKnEzud2OnETid2OrHTiZ3jxM5xYqcTO53Y6cTOcWLnOLHTiZ1O7HRipxM7ndjpxE4n9mQPkucBndjpxE4n4lcA5wf2gE7sdGKnEzud2OlEoROFTpQDPZBD+EH5wfjB+SHYWvIDe0AnCp0odKLQiUInCp0oHCcKx4lCJwqdKHSicJwoHCcKnSh0otCJQicKnSh0otCJIuyBNH7gUaAThU4U3juLsAd0otCJQicKnSh0otCJQieKsgfK84BOFDpR6EThvbMYe0AnCp0odKLQiUInCp0odKIYe2A8D+hEoROFThTeO4uzB3Si0IlCJwqdKHSi0IlCJwrvnSV4HtCJQicKnSi8dxbeOwudKHSi0IlCJwqdKHSi0ImS7EHyPKAThU4UOhG/Mzg/sAd0otCJQicKnSh0otCJQifqgR7o0fih84Pwg/KDsTXnh+CH5Af2gE5UOlHpRKUTtbEHzfjB+SH4IfmBPeC9s9KJSicqnah0otKJSicqnaidPeg4D5ROVDpR6UTlvbNyPlHpRKUTlU5UOlHpRKUTlU5UZQ+U5wGdqHSi0onKe2flfKLSiUonKp2odKLSiUonKp2oxh4YzwM6UelEpROV987K+USlE5VOVDpR6USlE5VOVDpROZ+onE9UOlHpRKUTlffOGuwBnah0otKJSicqnah0otKJmuxB8jygE5VOVDpRee+sxR7QiUonKp2odKLSiUonKp2oxR4UzgOjE41ONDrReO9sXGMxOtHoRKMTjU40OtHoRKMTjWss1oQflB+MH5wf2AM60ThONI4TjU403jsb11iM84lGJxqdaHSicZz4+sXDmL9+/eShXx8aP3R+EH5QfjB+cH4Ifkh+wKyuKXug7IGyB8oeKHug7IGyB8oeKHug7IGxB8YeGHtg7IGxB8YeGHtg7IGxB8YeOHvg7IGzB84e8N7ZOJ9onE80OtHoRKMTjeNE4zjR6ESjE41ONDrR6ESjE41ONDrR6ESjEy3Zg2QP6ESjE41ONN47G+cTjU40OtHoRKMTjU40OtHoRCv2oIIf6AM60elE572zcz7R6USnE51OdDrR6USnE51OdK47O9ednU50OtHpROe9s3M+0elE57qzc5zoHCc6negcJzrHiU4nOtdYnGss+E3F+SH5gT3gfKJzPtG5xuIcJzrHic5xonOc6BwnOtdYnOvOznVnVx4FjhOd987O+UTnfKJzjcU5TnSOE53jROc40TlOdK6xONednevObjwKHCc6752d84nO+UTnGotznOgcJzrHic5xonOc6HSic93Zue6MX188PnCc6HSicz7ROZ/oXGNxOtHpRKcTnU50OtG5xuLJ84BOdDrR6UTnvbNzPtHpRKcTnU50OtHpRKcTnU50rrF48TygE51OdDrRee8cnE8MOjHoxKATg04MOjHoxKATg2sswVqcoBODTgw6MXjvHJxPDDox6MSgE4NODDox6MSgE4PjxOA4MejEoBODTgyOE4PjxKATg04MOjHoxKATg04MOjG4xhJcdw46MejEoBOD987B+cSgE4NODDox6MSgE4NODDoxuMYSXHcOOjHoxKATg/fOwfnEoBODTgw6MejEoBODTgw6MThODI4Tg04MOjHoxOA4MThODDox6MSgE4NODDox6MSgE4NrLMF156ATg04MOjF47xycTww6MejEoBODTgw6MejEoBODayzBdeegE4NODDoxeO8cnE8MOjHpxKQTk05MOjHpxKQTk2ssyXXnpBOTTkw6MXnvnJxPTDox6cSkE5NOTDox6cSkE5P3zsl156QTk05MOjF575y8d046MenEpBOTTkw6MenEpBOTayzJdeekE5NOTDoxOZ+YnE9MOjHpxKQTk05MOjHpxKQTk2ssyXXnpBOTTkw6MTmfmJxPTDox6cSkE5NO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sH/AfY7lBzQhhBS6MIQpLKEEDZoGTYOmQdOgadCOQR2YwhJK2EC8hCaEkEIXNAgNQoPQIDRIDVKD1CA1SA1Sg9QgNUgNUoOuQdega9A16Bp0DboGXYOuQddgaDA0GBoMDYYGQ4OhwdBgaDA0mBpMDaYGU4OpwdRgajA1mBpMDZYGS4OlwdJgabA0WBosDZYGS4PSoDQoDUqD0qA0KA1Kg9KgNNgabA22BluDrcHWYGuwNdgabAzq9RKaEEIKXRjCFJZQggZNg6ZB06Bp0DSwiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJtYNrFsYtnEsollE8smlk0sm1g2sWxi2cSyiWUTyyaWTSybWDaxbGLZxLKJZRPLJpZNLJu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpu4beK2idsmbpqYL5qYL5qYL5qYr9PE+3PAfJ0m3h/95es08f60L1+niQ8s4TbI99U2cJp4H1zM12nifSQrX6eJD9wGff729bv/+sOvP//hj7/8+T9/9y//c+G//+Mvf/r7z3/9yxv//t9/ex75468///LLz//x+7/9+tc//fnf/vHrn3//y1//9P3Y717vP/712vTG17W/zZ+u73Lx1ZD8unLRLs7vx9t+fV07ydf3498vuD5pnF/XJ4zfT/i2/ddr51Jf147l9dNv9yXOda/Pe7+ujzjfV7k+s/66PjX+XKNdD0Y8V7jufL+ue9zv18f36+/n7PnVXu37a/n5WvSv2N9f6j++tL4yvr80fnxpfOUtMz9favsr+veX1veXvo2ivrI+Pv2r39etH6+4XnJ9HvcotusX0+0apOs5+7nENWVnFL6ff31KN+6foL3+73dt/+ywtB/jcn1kHfewtB/jci3SuN1a/3+eN55vHnmN3xjvbz7ra31GIL6fHp85jWsMI863np+XXyvj6vj75ddHzfOzKK6rfsXB++XXaMUZrbael7frc+828v3y1i46P+v94DUS13blM9xxjX4e/fpnL7B//ADXD7nX85LrN3vtlR/nC6935r0ImcJ1jcP9tfZM+2XRP9/2+lh9zPvxHzMU3z/8T7/99ttPv/0v",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8ACaXZLcJyg1INjy6L\n8rjBDsfX5AxOKmEaK9Ag3fg/L+MegUDLcrfdN4WeoIPZidp8eMcQsZi5gQ+8n5roj4zu2i3pyFgM\n8iUMjFa6y6gVq2RX3wxZjt8mDnhQflswTiiXJ9rgPTBsAZG6LOI8hTz6ayoKMhZBoKK/FSBm096a\nlN0uNKyHlUDdxWlkuOUR+fPtcIqWT2RkrOktxmFhfHOldwy/YKx1/OG/VvSi/3RcBio0QvUsAW4p\nwUnjn2iaZnb7IphgPfrfRYAC0DW/UNDmqmzMm0L2Sw/RJQcAcNwCKrgQWMWqNCWJ0fZ6m9rwdxWB\nTDr7GALFRHI4TgkFNxWTyRHhEChFBSk/rWKJvT+o7dOJfkb+POc+KUvFrSrWWQ8eFFqR+q8WIsoc\nzwYN2hu/EZEfQPiCdmdrJmT64/qMh6sCmECEtF+ZFW5enta3OKXo/vifpBoIgHMx9Nngmws0chI5\ncnZWSTGkGSPe4mEOzy6/lyobhOqhbE9Qso/lVVlNJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7\nBxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTB1qo9Iyqs2JiB+UaGg7snTPdTyy\nMjJapvVuAlVQxWnwL2XbkYyloUnDv8fRqPx2W/55motm+r3k50Wvx4Mo680v4uOJ6Enyg8pXnNbe\nBJb9fRCSJFz2VuLTByhMsh9j9gbTbKgwA86UPfhEMBSR4UKieoqDJB81Al2u6zwZKIJJB0SgFdGc\naGxPsBh0MPV0H5ffWVe1Lk2kwmpwMnSCw+UcDKo67GvODEseI4hB6UiZ5joMVP82Ei0BQ56JInuA\noQCxV2zDg4wwrUAI63CW+Rpfe1FdBPnjeAiWu91sfy5KGXQOYU/1UrP67IhWajTFJO7mVDF6IbxM\nNcWAlVcUEskfMA90GhY2cOtaZsx1mMHL7bQghD3vEJcELTZz/OAcLgn0NtpnKuxo8iqX6DX+sXUn\n/wZ4OIyVRLUkDBHMNMwfHUJIsWY0BxbFCTXFwmk4zdIje+twtYIyutLCHZ7GfaQIOEy3ZmxVHAZu\n23RT8bGYXXRTy/j5H/6QRJ1NtZi/hQGBVwngwPmFfBHuGdylAGBbI5g+VZYPlCkgxrUaacYOBioP\nXq/UOUL/QcaxGPJ1U8CvI+oVz2YdG7+OQVNI6JEooCemPLi/TNEq2EliXkHp8tRvpeHtRBhxsRvh\nh7GkHCcQQKfsp7eTHG0gC3Ngk7t0NKp2SAyjpnRgO1KpM1/SC+2fSHZlCWoz6+CsLDPXyHLuH4By\nwfhJZXpv1+yr1YILFQxhhkGUHHWzNVSooEEIeylpXSX8z35LZX2j0S8WBiKT/S0ba7Sg9EVMvQm5\n/jZHTgPWSO8mkU/jwWgBp6qILALcUt+jLRJ6jioUpmx99fUqLFUJrblXxlr9g4glQWYBlr7sYmOj\ncb/8SyEcDBEy2VLRAP4A5n/u3FWjBaxsiAhBORSjpcajDAPBqLMwP8+oqrXqGvF4z0uF/X2bZPfI\nJG/ANeS6FXUSE+FRAl2HQutkvSXK4v8+L23ZR7nLTDEOezJJ9iKTuqO1JtOhmi22gGqiqsZVZZFZ\nWeTLz9D/9iCoERdUJyKJdsQePE+lHvPz0o09BRcWV7fxJWaSZ037CjbRIXSK2fgKE3vlBSiJLegT\n6i0T9cGb1CXmDRP3fxEZPXX+Wog9WLqIekvdM0VjYlV9cqcJfRur/7K4niHrOA6zVBRpXfXtAiTr\n8h6twPnN2itzPSBHXZsX1Xwm6QCpEdifS4SHPVDQ7ktbJuOmbBLQ5wP5TfPoPeOAv3TEWsURA93p\namtjKMAi2kvAwp5tHYdyUN5Lw0uUgRwd3JH71gtaDT7C5fKzBDrVkn917iJOe4uwdsAdnRXmldtJ\nYoR5L0k+SqJepx+Q/5V+KqqeomSYTxXLfqssT2ml2Ailb00MDfwyFqfkTkJc7/GGGfQrfw/rg2SO\nEbH+DYvGtgxvIQt+Bww1reRIgasMq+ppQb4/zeTE4IFhvnl5SCKu+7P2F0xNqsxv6+gtiDGpBETv\nEX32GkvxinRGtU2OzdDlJyENPQ9wXJw7Qm4veGR5CujPFMTyBusHozGX/1z2u6wLrwcDm+cLVXtv\nDU1Z+xKAoZlYPQqQ5tVT5L1kSbWO9QehChGFSw0wrqddreiukl/tbL8F77PitlsEvecaM00v6zMA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACI1Iqxhm96mHxGR1YWsdjjVEV4r6vTvbaQa74mI5ZObsv3yWkQ4YhQTYY06BO93FOqvLm\n+HmvUWepqDHVitGwuwDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0T/DBF7F3IrJuupLmeobqEaLN+EOCE3rvz8G891XJ5kBMevpRD\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6778094227820479499": {
            "error_kind": "string",
            "string": "You are not the challenger for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACDScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHABAnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjYtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI2LQIAAC0LBgELIgABgEQAByQCAAcAAAGeJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2QtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB7yUAAAR3LwoAAwABHgIAAgEKKgECAyQCAAMAAAIMJQAABIkmKACABAR4AA0AAACABIADJACAAwAAAjUqAQABBfeh86+lrdTKPAQCASYlAAACDS0LBAYLIgAGgEQAByQCAAcAAAJYJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAvAjAAACcS0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAApslAAAEmy4CAAeAAygAgAQEAAQlAAAErS4IgAUACgAiCgILACoLBgwtDgUMASIABoBGAAUOKgYFByQCAAcAAALbJQAABTstDgoBLQ4IAi0OBQMtDgkEIwAAA2MnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAADZC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABK0uCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARgADLQ4IBCMAAANjJiUAAAINLgiARQAFIwAAA3QNIgAFgEMABiQCAAYAAAPkIwAAA4ktCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAAA/ojAAAEZi0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABK0uCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAEZgEiAAWARgAGLQoGBSMAAAN0KgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVeEKDJz12ECzwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAEyCMAAATTLgCAA4AFIwAABTouAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFJi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAE9SgBgAUEAAEDAIAGAAKABiMAAAU6JioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "tZjRais5DIbfJde9sGRLts6rHEpJ2/QQCGnJaReW0ndfyZacZmEGzix70/+zx/5HtjWaaT53z4fHj18Px/PL6+/dj5+fu8fL8XQ6/no4vT7t34+vZ+393CX7AynvftQ71TYU0LUORW+jt7O3Mw8tyZVcZSgVV/VtqlWGtuzq/eJtGW1M2bUOBXDloZhcyXX4Yi6u6sOqBV3rUAJXGsrJtbj6vJpdZWjzdvProuPFVLrmVFzbUNu/rjzU4u3q49DH5ezq7eLzLF5Ti7crufr92Oexj6s+rvr9mrebzgMw0ImAClIHlEQOkAI0OMgG4oA5oDpkCKCAGFxieokeiulk04sCU4CN0cwotTg0dJAUoINRA6OkN0Uy0OWh7j9ZPgwQB9sBrAY2S3OA7Mw6CATwAE4pQO+OulFsiZSTgTjY0QyoDgUCYoyldwfGABusG86WQR1aCiAHi2cAD6gJAmyMLrlCDmgOyA52BANisB1BhxKzyOLJBtWBIYACxKGH2iEGt5jeokdiusR08enNntVcDMTBsr4DQkB1sMLRwSrGAN/DVpoDYUD0NBujCSB9f9hAHPpGdWgOVqssE8Ru2iFDADuU6CnRQ9FD0cPRw+ETOSY9xzqIQ0+2DjFYYnA/ZbLiammXe5ntwXayaC1spRqUZ58FPKjvV+tEQTT7eiJKJwmyGuE0nWsO6mk5iIL6IQ+K+0KCSTRJgmL3ob8pBvVE5a+vu128aB7eL4eDvWe+vXn0ffS2vxzO77sf54/T6W731/700Qf9ftufu77vL3pVz/9wflZVw5fj6WD0dXednZantgLNZzetU9OAbh1g2UFfcMUdQOvjdACiGwtcsSB2B0w4DTK0G4O8bFBrEXeoVXhaYLtdRlm2yITuUOCbQbo1oGUDBIFYBSZZtOBlC8JYBeW0yUCqGzDQpkVgixAwfzuLP7GoME+zriwD0v/rAczxXADXts1DC394VMFtHlqIw0ML77LHikWZp6Kfi7z4iMHKsbC+QeMRQc7TQ24fMljJLn1Bzofsup/AZVOxobxYbNrKVuj3c2wF1LQYBcjKOlqOzKiNYHrwbRiY1rZiPqqVuS1awOpKZCYXEPKSydqGEsWRNOLF6o0rpZP0NRdFJ7XllZS1KIBmFN+e1j9ZR67TocLSOtaesoRRv/Vlvlz71ixgpoWeTdtmwTMKaNuiyLOGK26LgjBdy0XdZsHXitNk20KudU//mdtmUeanRaZNC6klDqQW3mIgs94IbVqEpDhPwW0RzJzSj+r/uIR/G9xrc/90vNz84PFlVpfj/vF08ObLx/np29X3v9/iSvxg8nZ5fTo8f1wO5nT91UT//ET9skfie/to1qZ+nd/p57E1wa5S1aty/2XB/AM=",
      "brillig_names": [
        "slash"
      ]
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8ABBpAD7ypgcQbkpH0\n0WBWRiMLXpUFxdMzVR+ZKPnqyuAuvxE/jgPuniTPFSkutltNEXeAxkLaWZ98fvJfdsEfhBv3vUe3\nRRF93ibGbjS8/2nAV9ed7JrToirW763iDO/KDYL8IjfFksYDgICh5Q8T7tIOH2/58GKB1c+EHHlN\nFhgkLCKravv/xfH6uQnoQfpam8z5fnMMyCNDZLTz16HPUBvHMIdZ4OZN2fTPr7as8eivF+dnHP1A\nna6quJW5qQ31L6XKq/6BfC3AajggDN4VgE5thvuQbZlKZhLaXZDUO2gLQa5mRcIbrtPqLC/amR03\niDBM57UnORdvtPBQ+BSsxCKTAO9OKaxj7JQI9i2291uMESEK7IUm59zGZWLGr/dHIBOWaQifMUDO\n9VouylQxiRgwVaN/Vh6efdx1hKmd0XkSYdiwRWPQ2nximh+GW0c1gdb0auNgkEAgiUG9lL8SVgPM\nkU+QmLJ1YgJPSjPq2Vk6BLsy4H45tFO0dhnYAnjQJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7\nBxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTCmMMxH8kXD5LelAsEKquZDVPGo7\nJjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsYF7TqXs0TxJzu7jzY\nT4Jm+6PhJki5DKlrQUkvTuP28xgTzqYUKJR7pi+L0FXTqU3r+3UNevnsJkOg2ZrPuBEdHd6dnuIY\nmWuU0nmnrISdXoYULoIx3j1wBzrMykGB7kYkBO8d4M4BO9nG4WOEUkyRXcKfVbzHEOfRbaAA6Fj5\nLhmz7hM37OYMZEaDHOA0ls4ypkWhz4tfCGNY/9jEfYwFJnnwhPJ7oSVWC6jwqzoIu2mEI4Ktt7Eb\naGmvMSBwJ7ARRPkkuRVzu5l42nf5CMf6LO0T/Y1+n3qNoK6J5qowYwFm5l0Nm/6f69sf3AZjYN/o\nQO8ynvkdG6P6slyKuop0L/VXX59/X1/Zq9kT//zY9PEK0GzzvLkV6xmLFqG1EckXICgf8H86I1l/\nVQizwyr3eDibj1r5/RJY0d0hygTjugLnDplDwjYkBVuvIgwpBXkFVEUF9s9d1NMMdjBUquFiKCgt\nyVNqK7nunfDM6tlmjQL7TPFVKWuUYZd8NK2Vdy4lzWg7tjd5VJGwaDAjkSXho0mxuHsDI790KeF+\nWNQx8wopA8Ir2cvK21fbPQS2ZpXi6WNMbi8tfj71cclwnHzwIruwLJOWy00mOXDZOQEMx/uezoEE\nleoA6gf3ALcAHZ4C66JamtX0qWjwojpNvT4s7opqFRoENOZb1vS9conHYh1A+dln78VgcS8qfUgF\nwPiJU4x9VDkDsVmt4WCgiNSXEfxjyvR/hAJQW4fqukoRTgA7yX6DhH7SNHog64XXUe4LTCEVuQPT\nqBBki+g8xK5+eHzW8SONBZvQUzSPU4d22xKXHGqOiXDTK6loLIbiBw4Vg0R+X2CJKRv7o2Th7YbT\nI1Ii9Il43ZAonf1pQRHE9b5LgDE6yC3FMPEQPxkuHdIpWTGaO3w2BKBbJL0FmIp4PHtpWagv0dep\nIFFcC52LlSk7+HN0RFVb8KN+T+hejgDb6LfZ6/P/NNCj/g/EpeuiIzJ36HTeCHrmXNIWzAuho/Fu\nMNjHKRHkMEALFfYbHDAMyALEJ98Ewoh5zsbMoG/1SQzTWeHCmZYve5o2+25PAx4djoZi3PH6XGW0\n3BFGpAOJa/3HI7iGhCshdGxU1/kaDI1v7kogmuwjiXzU3Q3rE529WuIBuh2E0m84yjXezdMcsc7Q\nH156Ys20mEbhiDQX09dMaV7fRTK/3u5DglQ70QrcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rd\nIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSX\nm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJS\nNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdj\np07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACAdh5VwHa7u2oNvuxIpWNkPsnOZ3XHrKJpzQKH7TQjiULmKg4IG3vyvUzaUiDc9k58cfC\nI0/2tOBuJ1z5mjj93QDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAXLQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjRbtswDEX/xc95EClKovIrQ1GkbToECNIiSwYMRf59pC3KyQAJmbO9VMeMdS3Kl5Lqr+Ft+3L+/rw7vH/8GNbfvoaX426/331/3n+8bk67j4NEvwanfzgPa1gN2U8Njw04X9o0rElawGEdtE1Ti+Ua5Rr0Ro8GquAFyBtYJGhE1RIIsEIUyAIMBhbJEkHtlcME6JyBRcAiUCO5AHoDLqAjnCAVIDCw7sEEk3aXoWImgaAgOt6tBu9iAX36BKEAWgSpgD50Au0l8+PJGYQCwSLBItEikQy4gA5sglSA0UAfIYP32RkEA5kWL+mQIwMuoG92Aovo1E1gEW/3jFkojFmMEAz0ETJRFMiAC0Q0iAXUABNYhJ2BdhdvUEYDuYckwaCDn0CUCQXAG1hEB0+kwAV80Qn63kcgi5BFgkWC+lmGEXSoIyRJkBR0hBQVNKI3q0UpKYTJJNGBARfQEU6QCyAZWMTbPaMzBZJanbICFxgzVUAwkBEGsVbyZJALkEU0rwm0bmXqUgwFkjPgAiyPCKjABbJFsnYXI7EmOEEsABYBi6BFUJ/lL5fVYMvO8+m43eqqc7UOyer0uTluD6dhfTjv96vh52Z/Hm/68bk5jO1pc5RfJY/t4U1aEXzf7bdKl9Xc27W7RnFu6R0pxCoQ/kKBq0JwTQXsKHit0klBir8qxFsF31bgxKbA7LClcG8WEJbMQ9CiKgrRtRRiW8FHtfioIMsaVwWI/kYitSVk28lFAjDnWSLfSnBbQtxufkocoDWXuaMgBWwKMXJLATqTCUDZWyIQMLZEuongnEhsKgD2hpFDnU6Y50I2rfttgTzbAhcZa7ZmBG4p6Jrcdhb46ix/7azbPCA+XKWQHi7TuzOh1M6kqxFS1Ui5qYGdl0IRzOMUidoa8HClYcegiXItteDcIgmpriqBaZFEBKgFD20JeLhYsbd8YjYJsSo1ixV766dLddlxPFvDhz80OusOV2ewp7ZCZwGN4GqlxbZCN48INY/k2hpdi9e5IDluNS3u8f9qyPaHlksMV+9Etun7NdhKXv7H4mUaKdS9NTG1NToeRQc2DnQ0r4AoO8ONRu/dxlqwMjWhrdHNJdthBaTy2rnkx3Mh959zmZdRYIrNXO7eEnJs+pQ6h1DIruaS6eqwAP4vVtI6Djk6LVyMCR+WuOsAR+kfHOB65pAzQn2x10Ub/CIJzIskcphfa4wLJXCWSMskyM/m+iORJ7ncvO6ONx+xLip23G1e9tty+X4+vF79evr1ab/YR7DP48fr9u183KrS/CVM/nyT8lxJeT3ppy+9lIoEn/QS9JJ5Jf5/uuhgfgM=",
      "brillig_names": [
        "winner"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "join_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "is_init",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "num_players",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "game_over",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "first_capture",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "join_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slash_fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        join_fee: PublicImmutable<Field, Context>,\n        challenge_fee: PublicImmutable<Field, Context>,\n        slash_fee: PublicImmutable<Field, Context>,\n        deposit_size: PublicImmutable<Field, Context>,\n        is_init: PublicMutable<bool, Context>,\n        num_players: PublicMutable<u32, Context>,\n        deposits: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        game_over: SharedMutable<bool, 1, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        first_capture: SharedMutable<bool, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    // #[initializer]\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        join_fee: Field,\n        challenge_fee: Field,\n        slash_fee: Field,\n        deposit_size: Field,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.join_fee.initialize(join_fee);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.slash_fee.initialize(slash_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.num_players.write(0);\n        \n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n        let current_block = context.block_number() as u32;\n        // You can now use current_block for your logic\n        if current_block > storage.end.read() {\n            storage.game_over.schedule_value_change(true);\n        }\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[private]\n    fn submit_score() {\n        let score: TallyNote = storage.tally_note.at(context.msg_sender()).get_note().note;\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score.tally)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        let (gameOver, _) = storage.game_over.get_scheduled_value();\n\n        if(gameOver) {\n            storage.final_score.at(sender).schedule_value_change(score);\n            let (winner_score, _) = storage.winner_score.get_scheduled_value();\n            if(winner_score < score) {\n                storage.winner_score.schedule_value_change(score);\n                storage.winner.schedule_value_change(sender);\n            }\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        // Ensure the game is initialized\n        if !storage.is_init.read() {}\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[public]\n    fn slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == context.msg_sender(), \"You are not the challenger for this address\");\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let mut new_capture_note = capture_note;\n        let randomness: Field = unsafe { random() };\n        let mut challenger_capture_note = CaptureNote {\n            owner: challenger,\n            capture_block: 0,\n            randomness\n        };\n\n        // If they have captured before and its a succesful capture by the challenger, update the tally\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            new_capture_note = CaptureNote::new(context.msg_sender(), 0);\n            challenger_capture_note = CaptureNote {\n                owner: challenger,\n                capture_block: challenge_block,\n                randomness\n            };\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
